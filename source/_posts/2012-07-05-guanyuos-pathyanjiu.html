---
layout: post
title: 关于os.path研究
categories:
- python模块研究
tags:
- os.path
published: true
comments: true
indexer: true
---
<p>前言：os.path子库主要更容易地在跨平台上对文件名和路径进行解析, 创建, 测试和其他操作.</p>

<p><pre class="sh_python">
import os.path</p>

<p>for path in [ '/one/two/three','/one/two/three/','/',',']:
    print '"%s" : "%s"' % (path, os.path.split(path)) #<tt>split()</tt> 函数将路径切分成两个两部分并返回一个元组, 它的第二个元素是路径的最后一部份, 第一个元素是路径的前面部分.
    print '"%s" : "%s"' % (path, os.path.basename(path)) #basename() 返回的值和 <tt>split()</tt> 返回的第二个值相同.
    print '"%s" : "%s"' % (path, os.path.dirname(path)) #dirname() 返回的值是和 <tt>split()</tt> 返回的第一个值相同.
    print '"%s" :' % path, os.path.splitext(path) #splitext() 和 <tt>split()</tt> 类似但是分隔路径的扩展名, 而不是目录名.
paths = ['/one/two/three/four','/one/two/threefold','/one/two/three/',] # 取一个路径列表作为参数, 返回一个单一的字符串表示这些路径公共的前缀. 这个值可能是一个实际上不存在的路径. 路径分割符是被忽略的
print os.path.commonprefix(paths)
</pre></p>

<p><pre class="sh_python">
import os.path
import os
for parts in [ ('one', 'two', 'three'),('/', 'one', 'two', 'three'),('/one', '/two', '/three'),]:
    print parts, ':', os.path.join(*parts)  #可以使用 <tt>join()</tt> 将多个路径部分组合成一个单个值
for user in [ '', 'dongwm', 'postgres' ]:
    lookup = '~' + user
    print lookup, ':', os.path.expanduser(lookup)  # <tt>expanduser()</tt> 可以将波浪线(~)扩展成用户的主目录.
os.environ['MYVAR'] = 'VALUE'
print os.path.expandvars('/path/to/$MYVAR')  #获取出现在路径中的环境变量.
for path in [ '.', '..', './one/two/three', '../one/two/three']:
    print '"%s" : "%s"' % (path, os.path.abspath(path))  #使用 abspath() 将一个相对路径转换成绝对路径.
</pre>
<pre class="sh_python">
import os.path
import time</p>

<p>print 'File :', __file__
print 'Access time :', time.ctime(os.path.getatime(__file__)) #最后一次访问文件或目录的时间
print 'Modified time:', time.ctime(os.path.getmtime(__file__)) #最后一次修改文件或目录的时间
print 'Change time :', time.ctime(os.path.getctime(__file__)) #最后一次改变文件或目录(改变的是原数据即:属性)的时间
print 'Size :', os.path.getsize(__file__)
</pre>
<pre class="sh_python">
for file in [ __file__, os.path.dirname(__file__), '/', './broken_link']:
    print 'File :', file
    print 'Absolute :', os.path.isabs(file)  #判断是否是绝对路径，返回布尔值
    print 'Is File? :', os.path.isfile(file)#判断是否是文件，返回布尔值
    print 'Is Dir? :', os.path.isdir(file)  #判断是否是目录，返回布尔值
    print 'Is Link? :', os.path.islink(file) #判断是否是链接文件，返回布尔值
    print 'Mountpoint? :', os.path.ismount(file)#判断是否是挂载文件，返回布尔值
    print 'Exists? :', os.path.exists(file) #判断是否存在，返回布尔值
    print 'Link Exists?:', os.path.lexists(file) #判断是否符号链接存在，返回布尔值
    print
def visit(arg, dirname, names):
    print dirname, arg
    for name in names:
        subname = os.path.join(dirname, name)
        if os.path.isdir(subname):
            print ' %s/' % name
        else:
            print ' %s' % name
    if '.svn' in names:
        names.remove('.svn')  #假如是.svn 去掉
    print</p>

<p>os.path.walk('..', visit, '(User data)') #遍历树中的所有目录, 并调用一个你提供的函数, 同时将目录名和目录中包含内容的名字传递给这个函数

</pre></p>
