---
layout: post
title: 关于xml.etree.ElementTree研究(创建篇)
categories:
- python模块研究
tags:
- xml.etree.ElementTree
published: true
comments: true
indexer: true
---
<p><pre class="sh_python">
from xml.etree.ElementTree import Element, SubElement, Comment, tostring, ElementTree

from xml.dom import minidom
import sys
import csv
import datetime
top = Element('top')  #创建一个root节点</p>

<p>comment = Comment('Generated for dongwm')  #设置一个注释信息
top.append(comment)  #添加到节点中</p>

<p>child = SubElement(top, 'child')  #船舰一个子节点名字叫'child'  父节点是'top'
child.text = 'This child contains text.'  #设置子节点的值</p>

<p>child_with_tail = SubElement(top, 'child_with_tail')
child_with_tail.text = 'This child has regular text.'  #设置借点标签间的值
child_with_tail.tail = 'And "tail" text.' #设置节点标签结束后的值</p>

<p>child_with_entity_ref = SubElement(top, 'child_with_entity_ref')
child_with_entity_ref.text = 'This &amp; that'  #这个值会在显示的时候转化成合适的内容
print tostring(top)
ElementTree(top).write(sys.stdout)  #将xml数据导入流（这里是sys.stdout）
def prettify(elem):
    rough_string = tostring(elem, 'utf-8') #要转化的xml文件
    reparsed = minidom.parseString(rough_string) 
    return reparsed.toprettyxml(indent="  ") #美化显示xml
print prettify(top)
generated_on = str(datetime.datetime.now())
root = Element('opml')  #设置root节点opml
root.set('version', '1.0')  #设置xml的版本</p>

<p>root.append(Comment('Generated by ElementTree_csv_to_xml.py for dongwm')) #增加注释</p>

<p>head = SubElement(root, 'head') #根节点的head子节点
title = SubElement(head, 'title')
title.text = 'My Podcasts' #tittle子节点的值
dc = SubElement(head, 'dateCreated')  #head的子节点
dc.text = generated_on  #上面抓取的时间
dm = SubElement(head, 'dateModified')
dm.text = generated_on
body = SubElement(root, 'body')
with open('podcasts.csv', 'rt') as f:  #这是在解析篇生成的csv文件 
    current_group = None
    reader = csv.reader(f) #读取csv文件
    for row in reader:
        group_name, podcast_name, xml_url, html_url = row
        if current_group is None or group_name != current_group.text:
            current_group = SubElement(body, 'outline', {'text':group_name})
        podcast = SubElement(current_group, 'outline',
                             {'text':podcast_name,
                              'xmlUrl':xml_url,
                              'htmlUrl':html_url,
                              })</p>

<p>print prettify(root)
print
top = Element('top') #重新设置根节点
children = [
    Element('child', num=str(i))
    for i in xrange(3)
    ]
top.extend(children)  #设置延长，加上上面的迭代列表的三个子节点
top = Element('top')
parent = SubElement(top, 'parent') #设置根节点的子节点
children = XML('''&lt;root&gt;&lt;child num="0" /&gt;&lt;child num="1" /&gt;&lt;child num="2" /&gt;&lt;/root&gt; ''')  #直接使用xml内容添加
parent.extend(children)
print prettify(top)
top = Element('top')
parent_a = SubElement(top, 'parent', id='A') #设置id不同的2个子节点
parent_b = SubElement(top, 'parent', id='B')
children = XML('''&lt;root&gt;&lt;child num="0" /&gt;&lt;child num="1" /&gt;&lt;child num="2" /&gt;&lt;/root&gt; ''') 
for c in children:
    c.set('id', str(id(c)))  #准备要添加的子节点
parent_a.extend(children)  #增加字节点
print 'A:'
print prettify(top)  #含有id为A的子节点
print
parent_b.extend(children)  #继续添加ID为B的字节点 但是A的字节点还在
print 'B:'
print prettify(top)
print
top = Element('top')
child = SubElement(top, 'child')
child.text = 'This child contains text.'
empty_child = SubElement(top, 'empty_child')
for method in [ 'xml', 'html', 'text' ]:
    print method
    ElementTree(top).write(sys.stdout, method=method) #xml是默认的method，只有<tt>&lt;empty_child /&gt;</tt>，text包含的text内容，html包含<tt>&lt;empty_child&gt;&lt;/empty_child&gt;</tt>
    print '\n'
</pre></p>

<p>&nbsp;</p>
