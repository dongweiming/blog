---
layout: post
title: 关于imaplib研究
categories:
- python模块研究
tags:
- imaplib
published: true
comments: true
indexer: true
---
<p>前言：imaplib是IMAP4的客户端库，用来接收imap协议服务器的邮件模块</p>

<p><pre class="sh_python">
import imaplib
import re
from pprint import pprint
list_response_pattern = re.compile(r'\((?P&lt;flags&gt;.*?)\) "(?P&lt;delimiter&gt;.*)" (?P&lt;name&gt;.*)')
#imaplib.Debug = 4 #设置debug模式
 def parse_list_response(line):
    flags, delimiter, mailbox_name = list_response_pattern.match(line).groups()
    mailbox_name = mailbox_name.strip('"')
    return (flags, delimiter, mailbox_name)</p>

<p>hostname='imap.qq.com' #设置收取腾讯邮件
connection = imaplib.IMAP4_SSL(hostname)  #要求使用SSL加密方式登录  不强制的话可以用imaplib.IMAP4</p>

<p>username = 'XXX' #用户名
password = 'YYYY' #密码
print 'Logging in as', username
connection.login(username, password)  #连接  注意我这个程序没有异常处理
typ,data =  connection.list()  #检索Mailbox
pprint(data)</p>

<p>for line in data:
    flags, delimiter, mailbox_name = parse_list_response(line)
    print 'Parsed response:', (flags, delimiter, mailbox_name)
    print connection.status(mailbox_name, '(MESSAGES RECENT UIDNEXT UIDVALIDITY UNSEEN)') #邮箱状态,MESSAGES:消息数量，RECENT：最近查看的邮件数量，
                                                在#UIDNEXT：邮箱的下一个唯一标识符值,UIDVALIDITY:邮箱的有效性的唯一标识符值,UNSEEN:还没有查看的邮件数量
    connection.select(mailbox_name, readonly=True)  
    typ, msg_ids = connection.search(None, 'ALL')#寻找邮件包含'ALL'数量
    typ, msg_ids = connection.search(None, '( FROM "Doug" SUBJECT "test message 2")')  #寻找邮件主题包含’test message 2‘，发件人是'Doug'的邮件数量
    typ, msg_data = c.fetch('1', '(BODY.PEEK[HEADER] FLAGS)') #
    print mailbox_name, typ, msg_ids    </p>

<p>try:
    connection.select('INBOX', readonly=True)</p>

<p>    print 'HEADER:'
    typ, msg_data = connection.fetch('1', '(BODY.PEEK[HEADER])')
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            print response_part[1]  #打印邮件头内容</p>

<p>    print 'BODY TEXT:'
    typ, msg_data = connection.fetch('1', '(BODY.PEEK[TEXT])')
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            print response_part[1] #打印内容</p>

<p>    print '\nFLAGS:'
    typ, msg_data = connection.fetch('1', '(FLAGS)')
    for response_part in msg_data:
        print response_part
        print imaplib.ParseFlags(response_part)
finally:
    try:
        c.close()
    except:
        pass
connection.logout()
</pre></p>

<p><pre class="sh_python">
import imaplib
import email
import time
import email.message
import re</p>

<p>hostname='imap.qq.com'
connection = imaplib.IMAP4_SSL(hostname)</p>

<p>username = 'XXX' 
password = 'YYY'
print 'Logging in as', username
connection.login(username, password)</p>

<p>new_message = email.message.Message()
new_message.set_unixfrom('pymotw')
new_message['Subject'] = 'subject goes here'
new_message['From'] = 'pymotw@example.com'
new_message['To'] = 'example@example.com'
new_message.set_payload('This is the body of the message.\n')</p>

<p>print new_message #想增加一封邮件
try:
    connection.append('INBOX', '', imaplib.Time2Internaldate(time.time()), str(new_message)) #给收件箱添加一封邮件
    connection.select('INBOX', readonly=True) #选定收件箱
    typ, msg_data = connection.fetch('1', '(RFC822)')  #获取RFC822邮件
    for response_part in msg_data:
        if isinstance(response_part, tuple):
            msg = email.message_from_string(response_part[1])
            for header in [ 'subject', 'to', 'from' ]:
                print '%-8s: %s' % (header.upper(), msg[header]) #打印主题，发件人和收件人
    typ, [response] = connection.search(None, 'SEEN')  #搜索查看过得邮件
    if typ != 'OK':
        raise RuntimeError(response)</p>

<p>    msg_ids = ','.join(response.split(' '))
    typ, create_response = connection.create('Archive.Today')  #创建一个邮箱
    print 'CREATED Archive.Today:', create_response </p>

<p>    print 'COPYING:', msg_ids
    connection.copy(msg_ids, 'Archive.Today') #拷贝那些邮件到这里</p>

<p>    connection.select('Archive.Today')
    typ, [response] = connection.search(None, 'ALL')
    print 'COPIED:', response
    typ, response = connection.store(msg_ids, '+FLAGS', r'(\Deleted)')  #设置删除的标识
    typ, response = connection.fetch(msg_ids, '(FLAGS)') 
    print 'Flags after:', response</p>

<p>    typ, response = connection.expunge() #删除邮件 
    print 'Expunged:', response
finally:
    try:
        connection.close()
    except:
        pass
    connection.logout()
</pre></p>
