---
layout: post
title: 关于inspect研究
categories:
- python模块研究
tags:
- inspect
published: true
comments: true
indexer: true
---
<p>前言：inspect是一个检查活动对象的模块</p>

<p>这里有个例子文件example.py：</p>

<p><pre class="sh_python">
"""Sample file to serve as the basis for inspect examples.
"""</p>

<p>def module_level_function(arg1, arg2='default', *args, **kwargs):
    """This function is declared in the module."""
    local_variable = arg1
    return</p>

<p>class A(object):
    """The A class."""
    def __init__(self, name):
        self.name = name</p>

<p>    def get_name(self):
        "Returns the name of the instance."
        return self.name</p>

<p>instance_of_a = A('sample_instance')</p>

<p>class B(A):
    """This is the B class.
    It is derived from A.
    """</p>

<p>    # This method is not part of A.
    def do_something(self):
        """Does some work"""
        pass</p>

<p>    def get_name(self):
        "Overrides version from A"
        return 'B(' + self.name + ')'
</pre></p>

<p><pre class="sh_python">
import inspect
import pprint
import example</p>

<p>for name, data in inspect.getmembers(example):#过滤返回的对象,元组每个列表2个数据:成员名称，成员类型
    if name == '__builtins__':  #内置模块不属于实际模块，忽略
        continue
    print '%s :' % name, repr(data)
print
for name, data in inspect.getmembers(example, inspect.isclass): #这个谓语限定只要返回 类
    print '%s :' % name, repr(data)
pprint.pprint(inspect.getmembers(example.A)) #由于没有过滤，输出显示的属性，方法，slots，和其他类的成员
print 
pprint.pprint(inspect.getmembers(example.A, inspect.ismethod)) #过滤只返回类的方法</p>

<p>print inspect.getdoc(example.B) #返回文档字符串，也就是__doc__的内容</p>

<p>print inspect.getcomments(example.B.do_something) #返回评论，打印方法前面的注释
print inspect.getsource(example.A.get_name)  #如果<tt>py</tt>文件是用于一个模块，类或方法的原始源代码可以使用inspect.getsource或者下面的getsourcelines检索
pprint.pprint(inspect.getsourcelines(example.A.get_name))  
arg_spec = inspect.getargspec(example.module_level_function) #getargspec函数返回一个包含位置参数名称的列表
print 'NAMES   :', arg_spec[0]
print '*       :', arg_spec[1]
print '**      :', arg_spec[2]
print 'defaults:', arg_spec[3]</p>

<p>class C(example.B):
    pass</p>

<p>class D(C, example.A):
    pass</p>

<p>def print_class_tree(tree, indent=-1):
    if isinstance(tree, list):
        for node in tree:
            print_class_tree(node, indent+1)
    else:
        print '  ' * indent, tree[0].__name__
    return</p>

<p>print 'A, B, C, D:'
print_class_tree(inspect.getclasstree([example.A, example.B, C, D])) #显示类层次结构，创建一个类似树状的数据结构，使用基于它被赋予的类和基类的嵌套列表和元组。
                                                      # 在返回列表中的每个元素可以是一个类和它的基类，或另一个子类的列表，其中包含元组的元组
class C(object):
    pass</p>

<p>class C_First(C, example.B):
    pass</p>

<p>class B_First(example.B, C):
    pass</p>

<p>print 'B_First:'
for c in inspect.getmro(B_First):  #返回一个元组的顺序,显示类继承的顺序，从底层到最上层
    print '\t', c.__name__
print
print 'C_First:'
for c in inspect.getmro(C_First):
    print '\t', c.__name__
def recurse(limit):  
    local_variable = '.' * limit
    print limit, inspect.getargvalues(inspect.currentframe()) #堆栈的顶部（当前函数）的框架,返回一个参数名，可变参数的名称和本地变量字典的tuple
    if limit &lt;= 0:
        return
    recurse(limit - 1)
    return
recurse(3)
</pre></p>

<p>执行结果：</p>

<p>dongwm@linux-dongwm:~&gt; python test.py
A : &lt;class 'example.A'&gt;
B : &lt;class 'example.B'&gt;
__doc__ : 'Sample file to serve as the basis for inspect examples.\n'
__file__ : '/home/dongwm/example.pyc'
__name__ : 'example'
__package__ : None
instance_of_a : &lt;example.A object at 0xb7403cec&gt;
module_level_function : &lt;function module_level_function at 0xb740709c&gt;</p>

<p>A : &lt;class 'example.A'&gt;
B : &lt;class 'example.B'&gt;
[('__class__', &lt;type 'type'&gt;),
('__delattr__', &lt;slot wrapper '__delattr__' of 'object' objects&gt;),
('__dict__', &lt;dictproxy object at 0xb740a044&gt;),
('__doc__', 'The A class.'),
('__format__', &lt;method '__format__' of 'object' objects&gt;),
('__getattribute__', &lt;slot wrapper '__getattribute__' of 'object' objects&gt;),
('__hash__', &lt;slot wrapper '__hash__' of 'object' objects&gt;),
('__init__', &lt;unbound method A.__init__&gt;),
('__module__', 'example'),
('__new__', &lt;built-in method __new__ of type object at 0xb784cb80&gt;),
('__reduce__', &lt;method '__reduce__' of 'object' objects&gt;),
('__reduce_ex__', &lt;method '__reduce_ex__' of 'object' objects&gt;),
('__repr__', &lt;slot wrapper '__repr__' of 'object' objects&gt;),
('__setattr__', &lt;slot wrapper '__setattr__' of 'object' objects&gt;),
('__sizeof__', &lt;method '__sizeof__' of 'object' objects&gt;),
('__str__', &lt;slot wrapper '__str__' of 'object' objects&gt;),
('__subclasshook__',
&lt;built-in method __subclasshook__ of type object at 0x81078ac&gt;),
('__weakref__', &lt;attribute '__weakref__' of 'A' objects&gt;),
('get_name', &lt;unbound method A.get_name&gt;)]</p>

<p>[('__init__', &lt;unbound method A.__init__&gt;),
('get_name', &lt;unbound method A.get_name&gt;)]
This is the B class.
It is derived from A.
# This method is not part of A.</p>

<p>def get_name(self):
"Returns the name of the instance."
return self.name</p>

<p>(['    def get_name(self):\n',
'        "Returns the name of the instance."\n',
'        return self.name\n'],
14)
NAMES   : ['arg1', 'arg2']
*       : args
**      : kwargs
defaults: ('default',)
A, B, C, D:
object
A
D
B
C
D
B_First:
B_First
B
A
C
object</p>

<p>C_First:
C_First
C
B
A
object
3 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '...', 'limit': 3})
2 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '..', 'limit': 2})
1 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '.', 'limit': 1})
0 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '', 'limit': 0})</p>
